# 任务中断机制说明

## 概述

已为任务系统增加完整的**中断支持**，现在可以通过 `TaskSchedulerService.cancelTask(executionId)` 优雅地取消正在运行的任务。

## 架构改进

### 1. TaskExecutor 层 - 底层中断机制

**新增功能**：
- ✅ 维护任务映射表 `Map<executionId, TaskContext>`
- ✅ 记录任务的 `Future` 和执行线程 `Thread`
- ✅ 支持通过 `executionId` 取消任务
- ✅ 中断线程 + 取消 Future + 更新任务状态

**关键代码**：
```java
public boolean cancelTask(String executionId) {
    TaskContext context = runningTasks.get(executionId);
    if (context == null) {
        return false;
    }
    
    // 1. 中断执行线程
    if (context.executingThread != null) {
        context.executingThread.interrupt();
    }
    
    // 2. 取消Future
    if (context.future != null) {
        context.future.cancel(true);
    }
    
    // 3. 更新任务状态
    context.task.cancel();
    
    // 4. 通知监听器
    notifyListeners(listener -> listener.onTaskFailed(
        task.toNotification("任务已被取消")
    ));
    
    return true;
}
```

### 2. TaskSchedulerService 层 - 服务接口

**新增方法**：
```java
// 取消任务
boolean cancelTask(String executionId);

// 查询任务
Optional<Task> getTask(String executionId);

// 获取运行中的任务列表
List<Task> getRunningTasks();

// 获取运行中的任务数量
int getRunningTaskCount();
```

### 3. BossRecruitmentServiceImpl 层 - 业务层中断检查

**核心改进**：在所有长时间运行的循环中添加中断检查

#### 中断检查辅助方法
```java
/**
 * 检查线程是否被中断，如果被中断则抛出异常
 * 用于支持任务取消功能
 */
private void checkInterrupted() throws InterruptedException {
    if (Thread.currentThread().isInterrupted()) {
        log.info("检测到任务取消信号，准备停止执行");
        throw new InterruptedException("任务已被取消");
    }
}
```

#### 关键位置的中断检查

##### 1️⃣ collectJobs() - 岗位采集
```java
@Override
public List<JobDTO> collectJobs() {
    try {
        // 按城市和关键词搜索岗位
        for (String cityCode : config.getCityCodeCodes()) {
            checkInterrupted(); // ✅ 城市循环检查
            
            for (String keyword : config.getKeywordsList()) {
                checkInterrupted(); // ✅ 关键词循环检查
                collectJobsByCity(cityCode, keyword, config);
            }
        }
        
        // 可中断的等待
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw e; // ✅ 重新抛出
        }
        
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("Boss直聘岗位采集被取消");
        return allJobDTOS;
    }
}
```

##### 2️⃣ deliverJobs() - 岗位投递
```java
@Override
public int deliverJobs(List<JobDTO> jobDTOS) {
    try {
        for (JobDTO jobDTO : jobDTOS) {
            try {
                checkInterrupted(); // ✅ 每个岗位投递前检查
                
                boolean delivered = deliverSingleJob(jobDTO, config);
                
                // 可中断的投递间隔
                try {
                    TimeUnit.SECONDS.sleep(15);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw e; // ✅ 重新抛出
                }
                
            } catch (InterruptedException e) {
                throw e; // ✅ 向外传播
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("Boss直聘岗位投递被取消，已成功投递: {}", successCount);
    }
}
```

##### 3️⃣ loadJobsWithScroll() - 滚动加载
```java
private int loadJobsWithScroll(Page page, String jobType) throws InterruptedException {
    while (unchangedCount < 2) {
        try {
            checkInterrupted(); // ✅ 每次滚动前检查
            
            // 查询岗位卡片
            List<ElementHandle> jobCards = page.querySelectorAll(JOB_LIST_SELECTOR);
            
            if (unchangedCount < 2) {
                checkInterrupted(); // ✅ 重试前再次检查
                // 继续滚动...
            }
            
        } catch (InterruptedException e) {
            log.info("滚动加载被取消: {}", jobType);
            throw e; // ✅ 向外传播
        }
    }
}
```

##### 4️⃣ updateBlacklistFromChat() - 黑名单更新
```java
private void updateBlacklistFromChat() {
    try {
        TimeUnit.SECONDS.sleep(3);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.info("黑名单更新被取消");
        return; // ✅ 提前返回
    }
    
    while (!shouldBreak) {
        // 检查中断
        if (Thread.currentThread().isInterrupted()) {
            log.info("检测到任务取消信号，停止黑名单更新");
            break; // ✅ 跳出循环
        }
        
        for (int i = 0; i < itemCount; i++) {
            // 内层循环也检查
            if (Thread.currentThread().isInterrupted()) {
                log.info("检测到任务取消信号，停止黑名单更新");
                shouldBreak = true;
                break; // ✅ 跳出循环
            }
            
            // 处理聊天记录...
        }
    }
}
```

## 使用示例

### 示例 1：在 Controller 中提供任务管理 API

```java
@RestController
@RequestMapping("/api/tasks")
public class TaskManagementController {

    @Autowired
    private TaskSchedulerService taskSchedulerService;

    @Autowired
    private JobDeliveryService jobDeliveryService;

    // 提交异步任务
    @PostMapping("/quick-delivery/{platform}")
    public ResponseEntity<Map<String, String>> startQuickDelivery(
            @PathVariable String platform) {
        
        // 创建任务
        ScheduledTask task = () -> {
            RecruitmentPlatformEnum platformEnum = 
                RecruitmentPlatformEnum.valueOf(platform.toUpperCase());
            return jobDeliveryService.executeQuickDelivery(platformEnum);
        };
        
        // 异步提交
        Future<Task> future = taskSchedulerService.submitTaskAsync(task);
        
        // 获取 executionId（非阻塞，很快返回）
        try {
            Task taskInfo = future.get(100, TimeUnit.MILLISECONDS);
            return ResponseEntity.ok(Map.of(
                "executionId", taskInfo.getExecutionId(),
                "status", "submitted",
                "message", "任务已提交，请保存executionId用于查询和取消"
            ));
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of(
                "error", "任务提交失败: " + e.getMessage()
            ));
        }
    }

    // 取消任务
    @DeleteMapping("/{executionId}/cancel")
    public ResponseEntity<Map<String, Object>> cancelTask(
            @PathVariable String executionId) {
        
        boolean cancelled = taskSchedulerService.cancelTask(executionId);
        
        return ResponseEntity.ok(Map.of(
            "executionId", executionId,
            "cancelled", cancelled,
            "message", cancelled ? 
                "任务已取消" : "任务未找到或已完成，无法取消"
        ));
    }

    // 查询任务状态
    @GetMapping("/{executionId}")
    public ResponseEntity<?> getTaskStatus(
            @PathVariable String executionId) {
        
        Optional<Task> task = taskSchedulerService.getTask(executionId);
        
        if (task.isPresent()) {
            Task t = task.get();
            return ResponseEntity.ok(Map.of(
                "executionId", t.getExecutionId(),
                "taskName", t.getConfig().getTaskName(),
                "status", t.getStatus().toString(),
                "startTime", t.getStartTime().toString(),
                "isRunning", t.isRunning(),
                "isCompleted", t.isCompleted()
            ));
        } else {
            return ResponseEntity.status(404).body(Map.of(
                "error", "任务未找到: " + executionId
            ));
        }
    }

    // 获取所有运行中的任务
    @GetMapping("/running")
    public ResponseEntity<List<Map<String, Object>>> getRunningTasks() {
        List<Task> runningTasks = taskSchedulerService.getRunningTasks();
        
        List<Map<String, Object>> result = runningTasks.stream()
            .map(task -> Map.of(
                "executionId", (Object) task.getExecutionId(),
                "taskName", (Object) task.getConfig().getTaskName(),
                "status", (Object) task.getStatus().toString(),
                "startTime", (Object) task.getStartTime().toString(),
                "description", (Object) task.getConfig().getDescription()
            ))
            .collect(Collectors.toList());
        
        return ResponseEntity.ok(result);
    }
}
```

### 示例 2：前端调用流程

```javascript
// 1. 启动任务
async function startTask(platform) {
    const response = await fetch(`/api/tasks/quick-delivery/${platform}`, {
        method: 'POST'
    });
    const data = await response.json();
    
    // 保存 executionId
    const executionId = data.executionId;
    localStorage.setItem('currentTaskId', executionId);
    
    console.log('任务已启动:', executionId);
    
    // 开始轮询任务状态
    startPollingTaskStatus(executionId);
}

// 2. 轮询任务状态
function startPollingTaskStatus(executionId) {
    const intervalId = setInterval(async () => {
        const response = await fetch(`/api/tasks/${executionId}`);
        
        if (response.status === 404) {
            console.log('任务已完成或不存在');
            clearInterval(intervalId);
            return;
        }
        
        const task = await response.json();
        console.log('任务状态:', task.status);
        
        if (task.isCompleted) {
            console.log('任务完成:', task);
            clearInterval(intervalId);
        }
    }, 2000); // 每2秒查询一次
    
    // 保存 intervalId 用于后续清理
    window.taskPollingInterval = intervalId;
}

// 3. 取消任务
async function cancelTask() {
    const executionId = localStorage.getItem('currentTaskId');
    if (!executionId) {
        alert('没有正在运行的任务');
        return;
    }
    
    const response = await fetch(`/api/tasks/${executionId}/cancel`, {
        method: 'DELETE'
    });
    const data = await response.json();
    
    if (data.cancelled) {
        alert('任务已取消');
        // 停止轮询
        if (window.taskPollingInterval) {
            clearInterval(window.taskPollingInterval);
        }
    } else {
        alert(data.message);
    }
}

// 4. 查看所有运行中的任务
async function viewRunningTasks() {
    const response = await fetch('/api/tasks/running');
    const tasks = await response.json();
    
    console.log('运行中的任务:', tasks);
    tasks.forEach(task => {
        console.log(`- ${task.taskName} (${task.executionId}): ${task.status}`);
    });
}
```

## 中断机制说明

### 工作原理

```
用户请求取消
    ↓
TaskSchedulerService.cancelTask(executionId)
    ↓
TaskExecutor.cancelTask(executionId)
    ↓
┌─────────────────────────────────────┐
│ 1. Thread.interrupt()  中断执行线程 │
│ 2. Future.cancel(true) 取消Future   │
│ 3. Task.cancel()       更新状态     │
│ 4. 通知监听器          发送通知     │
│ 5. 从映射中移除        清理资源     │
└─────────────────────────────────────┘
    ↓
业务代码检查中断状态
    ↓
┌─────────────────────────────────────┐
│ - checkInterrupted() 抛出异常       │
│ - Thread.interrupted() 返回true     │
│ - sleep() 抛出 InterruptedException │
└─────────────────────────────────────┘
    ↓
任务优雅退出
```

### 最佳实践

#### ✅ DO - 应该这样做

1. **在循环开始时检查中断**
```java
for (String item : items) {
    checkInterrupted(); // ✅ 循环开始检查
    processItem(item);
}
```

2. **正确处理 InterruptedException**
```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // ✅ 恢复中断状态
    throw e; // ✅ 向上传播
}
```

3. **在长时间操作前检查**
```java
checkInterrupted(); // ✅ 执行前检查
performLongRunningOperation();
```

4. **多层循环都要检查**
```java
for (String city : cities) {
    checkInterrupted(); // ✅ 外层检查
    for (String keyword : keywords) {
        checkInterrupted(); // ✅ 内层也检查
        search(city, keyword);
    }
}
```

#### ❌ DON'T - 不应该这样做

1. **吞掉 InterruptedException**
```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    // ❌ 什么都不做，任务无法取消
}
```

2. **只记录日志，不传播**
```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    log.error("中断异常", e); // ❌ 只记录不传播
}
```

3. **循环中不检查中断**
```java
// ❌ 长时间运行的循环，无中断检查
for (int i = 0; i < 10000; i++) {
    doWork();
}
```

## 任务状态流转

```
PENDING (待执行)
    ↓
RUNNING (运行中) ←──── 这个阶段可以取消
    ↓
SUCCESS (成功) / FAILED (失败) / CANCELLED (已取消)
```

## 注意事项

### ⚠️ 重要提醒

1. **任务需要配合实现**
   - 业务代码必须检查 `Thread.interrupted()` 或响应 `InterruptedException`
   - 不检查中断的任务无法被取消

2. **中断不是立即停止**
   - 中断是**协作机制**，不是强制终止
   - 任务需要主动检查中断状态才能停止
   - 正在执行的方法调用不会被打断（除非该方法支持中断）

3. **资源清理**
   - 使用 `try-finally` 确保资源释放
   - 任务取消后应清理临时数据

4. **线程安全**
   - `ConcurrentHashMap` 保证线程安全
   - 任务状态更新是原子操作

## 总结

现在系统具备完整的任务取消能力：

| 层级 | 功能 | 状态 |
|------|------|------|
| TaskExecutor | 中断线程 + 取消Future | ✅ |
| TaskSchedulerService | 暴露取消API | ✅ |
| BossRecruitmentServiceImpl | 响应中断信号 | ✅ |
| 其他平台服务 | 待实现 | ⏳ |

**下一步建议**：
- 为其他招聘平台服务（智联、51Job、猎聘）添加中断检查
- 添加任务执行进度报告功能
- 实现任务执行历史记录查询

