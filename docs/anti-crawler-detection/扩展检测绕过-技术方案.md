# Playwright 扩展检测绕过 - 技术方案

## 问题
网站通过检测 `chrome-extension://` 请求来识别自动化浏览器，导致页面跳转到 `about:blank` 或加载失败。

---

## 核心解决方案：三层反检测脚本

### 第一层：AJAX 拦截器 - 绕过反爬虫验证

#### 原理分析

**Boss 直聘的反爬虫机制：**
```javascript
// 网站 main.js 中的检测逻辑
var c = Sign.encryptPs;  // 获取加密值
var l = "X";             // 初始标记

// 发送验证请求
$.ajax({
  url: '/wapi/zpCommon/toggle/all',
  data: { key: '9E2145704D3D49648DD85D6DDAC1CF0D' },
  success: function(response) {
    // 验证：response.zpData.nd_result_13912_number_1.result === c
    if (response.zpData.nd_result_13912_number_1.result === c) {
      l = c;  // 验证通过
    } else {
      // 验证失败 → 触发内存炸弹 → 页面崩溃
      while(true) { var arr = new Array(999999999); }
    }
  }
});
```

**问题本质：**
- 网站动态生成一个加密值 `Sign.encryptPs`
- 发送请求到服务器验证这个值
- 如果服务器返回的值与本地不匹配 → 触发反爬虫机制

#### 解决方案

**核心思路：拦截验证请求，动态读取 `Sign.encryptPs` 并返回匹配的响应**

```javascript
// 1. 动态获取加密值
function getEncryptPsValue() {
  try {
    if (window.Sign && window.Sign.encryptPs) {
      return window.Sign.encryptPs;  // 读取网站生成的加密值
    }
  } catch(e) {}
  return 'FALLBACK_VALUE';
}

// 2. Hook XMLHttpRequest
const OriginalXHR = window.XMLHttpRequest;
window.XMLHttpRequest = function() {
  const xhr = new OriginalXHR();
  const originalOpen = xhr.open;
  const originalSend = xhr.send;
  
  let requestUrl = '';
  let requestMethod = '';
  
  // 拦截 open 方法，记录请求信息
  xhr.open = function(method, url, ...args) {
    requestUrl = url;
    requestMethod = method;
    return originalOpen.call(this, method, url, ...args);
  };
  
  // 拦截 send 方法，判断是否需要拦截
  xhr.send = function(data) {
    // 检查是否是反爬虫验证接口
    const urlMatch = requestUrl.indexOf('/wapi/zpCommon/toggle/all') !== -1;
    const dataMatch = data && data.toString().indexOf('9E2145704D3D49648DD85D6DDAC1CF0D') !== -1;
    const shouldIntercept = urlMatch && dataMatch && requestMethod.toUpperCase() === 'POST';
    
    if (shouldIntercept) {
      // 动态读取 Sign.encryptPs
      const encryptPsValue = getEncryptPsValue();
      console.warn('[AJAX_INTERCEPTOR] 拦截验证请求，Sign.encryptPs =', encryptPsValue);
      
      // 构造正确的响应，让验证逻辑通过
      const fakeResponse = {
        code: 0,
        message: 'success',
        zpData: {
          nd_result_13912_number_1: {
            result: encryptPsValue  // 关键：返回与本地相同的值
          }
        }
      };
      
      // 异步伪造响应
      setTimeout(() => {
        // 设置 XHR 对象的状态
        Object.defineProperty(xhr, 'readyState', { value: 4, writable: false, configurable: true });
        Object.defineProperty(xhr, 'status', { value: 200, writable: false, configurable: true });
        Object.defineProperty(xhr, 'statusText', { value: 'OK', writable: false, configurable: true });
        Object.defineProperty(xhr, 'responseText', { 
          value: JSON.stringify(fakeResponse),
          writable: false,
          configurable: true
        });
        Object.defineProperty(xhr, 'response', { 
          value: JSON.stringify(fakeResponse),
          writable: false,
          configurable: true
        });
        
        // 触发回调
        if (typeof xhr.onreadystatechange === 'function') {
          xhr.onreadystatechange();
        }
        if (typeof xhr.onload === 'function') {
          xhr.onload();
        }
        
        console.log('[AJAX_INTERCEPTOR] ✅ 验证通过，已阻止内存炸弹');
      }, 50);
      
      return; // 不发送真实请求
    }
    
    // 其他请求正常发送
    return originalSend.call(this, data);
  };
  
  return xhr;
};

// 3. Hook fetch API（防御性编程，虽然网站用的是 $.ajax）
const originalFetch = window.fetch;
window.fetch = function(url, options) {
  const urlStr = typeof url === 'string' ? url : url.url || '';
  const urlMatch = urlStr.indexOf('/wapi/zpCommon/toggle/all') !== -1;
  const bodyMatch = options && options.body && 
                   options.body.toString().indexOf('9E2145704D3D49648DD85D6DDAC1CF0D') !== -1;
  const methodMatch = options && options.method && options.method.toUpperCase() === 'POST';
  
  if (urlMatch && bodyMatch && methodMatch) {
    const encryptPsValue = getEncryptPsValue();
    console.warn('[AJAX_INTERCEPTOR] 拦截 fetch 验证请求，Sign.encryptPs =', encryptPsValue);
    
    const fakeResponse = {
      code: 0,
      message: 'success',
      zpData: {
        nd_result_13912_number_1: {
          result: encryptPsValue
        }
      }
    };
    
    console.log('[AJAX_INTERCEPTOR] ✅ 验证通过，已阻止内存炸弹');
    return Promise.resolve(new Response(JSON.stringify(fakeResponse), {
      status: 200,
      statusText: 'OK',
      headers: { 'Content-Type': 'application/json' }
    }));
  }
  
  return originalFetch.call(this, url, options);
};
```

**关键点：**
1. **动态读取**：不是硬编码加密值，而是动态读取 `window.Sign.encryptPs`
2. **精确匹配**：只拦截特定的验证接口（URL + 特征字符串 + POST 方法）
3. **伪造响应**：返回与本地加密值相同的响应，让验证逻辑通过
4. **阻止请求**：不发送真实请求，避免服务器返回错误值

---

### 第二层：扩展检测绕过 - 拦截 chrome-extension:// 请求

#### 原理分析

**网站的扩展检测逻辑：**
```javascript
// 网站检测代码
fetch('chrome-extension://invalid/')
  .then(() => {
    // 请求成功 → 浏览器有扩展 → 可能是真实用户
  })
  .catch(() => {
    // 请求失败 → 浏览器没有扩展 → 可能是自动化工具
    // 触发反爬虫机制：跳转到 about:blank
    window.location.href = 'about:blank';
  });
```

**问题本质：**
- 真实用户的浏览器通常安装了扩展（广告拦截器、翻译工具等）
- 自动化浏览器通常没有扩展，显得"过于干净"
- 网站通过请求 `chrome-extension://` 协议来检测扩展是否存在

**为什么会失败：**
```
网站发起请求：chrome-extension://invalid/
    ↓
浏览器没有扩展
    ↓
请求失败：net::ERR_BLOCKED_BY_CLIENT 或 net::ERR_FAILED
    ↓
网站检测到自动化工具
    ↓
触发反爬虫：页面跳转到 about:blank
```

#### 解决方案

**核心思路：拦截所有 `chrome-extension://` 请求，返回成功响应**

**关键：fetch 和 XHR 必须使用相同的拦截条件**

```javascript
// 1. 拦截 fetch
const originalFetch = window.fetch;
window.fetch = function(url, options) {
  // 转换 URL 为字符串，处理各种可能的 URL 类型
  let urlStr;
  if (typeof url === 'string') {
    urlStr = url;
  } else if (url && typeof url === 'object') {
    // URL 对象或 Request 对象
    urlStr = url.url || url.href || String(url);
  } else {
    urlStr = String(url);
  }
  
  // 拦截所有 chrome-extension:// 请求
  if (urlStr.startsWith('chrome-extension://')) {
    console.warn('[EXTENSION_BYPASS] 拦截 fetch:', urlStr);
    // 返回成功响应，让网站认为扩展存在
    return Promise.resolve(new Response('{}', {
      status: 200,
      statusText: 'OK',
      headers: { 'Content-Type': 'application/json' }
    }));
  }
  
  return originalFetch.call(this, url, options);
};

// 2. 拦截 XMLHttpRequest
const OriginalXHR = window.XMLHttpRequest;
const originalXHROpen = OriginalXHR.prototype.open;
const originalXHRSend = OriginalXHR.prototype.send;

OriginalXHR.prototype.open = function(method, url, ...args) {
  this._extensionBypassUrl = url;  // 保存 URL
  return originalXHROpen.call(this, method, url, ...args);
};

OriginalXHR.prototype.send = function(data) {
  const url = this._extensionBypassUrl || '';
  
  // 拦截所有 chrome-extension:// 请求
  if (url.startsWith('chrome-extension://')) {
    console.warn('[EXTENSION_BYPASS] 拦截 XHR:', url);
    
    // 模拟成功响应
    setTimeout(() => {
      Object.defineProperty(this, 'readyState', { value: 4, configurable: true });
      Object.defineProperty(this, 'status', { value: 200, configurable: true });
      Object.defineProperty(this, 'statusText', { value: 'OK', configurable: true });
      Object.defineProperty(this, 'responseText', { value: '{}', configurable: true });
      Object.defineProperty(this, 'response', { value: '{}', configurable: true });
      
      if (typeof this.onreadystatechange === 'function') this.onreadystatechange();
      if (typeof this.onload === 'function') this.onload();
      
      console.log('[EXTENSION_BYPASS] ✅ XHR 模拟响应已触发');
    }, 10);
    return;
  }
  
  return originalXHRSend.call(this, data);
};
```

**关键点：**
1. **拦截所有请求**：不要只拦截 `chrome-extension://invalid/`，要拦截所有 `chrome-extension://` 开头的请求
2. **规则一致性**：fetch 和 XHR 必须使用相同的拦截条件（都是 `startsWith('chrome-extension://')`）
3. **返回成功响应**：状态码 200，让网站认为扩展存在
4. **属性可配置**：`Object.defineProperty` 必须设置 `configurable: true`

**常见错误：**
```javascript
// ❌ 错误：只拦截特定 URL
if (url.startsWith('chrome-extension://') && 
    (url.includes('invalid') || url.includes('test'))) {
  // 只拦截包含 'invalid' 或 'test' 的请求
  // 问题：其他 chrome-extension:// 请求会漏网
}

// ✅ 正确：拦截所有 chrome-extension:// 请求
if (url.startsWith('chrome-extension://')) {
  // 拦截所有扩展检测请求
}
```

---

### 第三层：Stealth 脚本 - 隐藏 Playwright 特征

#### 原理分析

**网站的自动化检测手段：**
```javascript
// 1. 检测 webdriver 属性
if (navigator.webdriver === true) {
  // 这是自动化浏览器
  triggerAntiBot();
}

// 2. 检测 chrome 对象
if (!window.chrome || !window.chrome.runtime) {
  // 没有 chrome 对象，可能是自动化工具
  triggerAntiBot();
}

// 3. 检测 plugins
if (navigator.plugins.length === 0) {
  // 没有插件，可能是自动化工具
  triggerAntiBot();
}

// 4. 检测 Playwright 特有属性
if (window.__playwright || window.__pw_manual) {
  // 检测到 Playwright
  triggerAntiBot();
}
```

#### 解决方案

**核心思路：伪装成真实的 Chrome 浏览器**

```javascript
// 1. 隐藏 webdriver 属性（最重要！）
Object.defineProperty(navigator, 'webdriver', {
  get: () => undefined,  // 返回 undefined 而不是 true
  configurable: true
});

// 删除 Playwright 在原型链上设置的 webdriver
delete navigator.__proto__.webdriver;

// 2. 模拟 chrome 对象（让网站认为这是真实的 Chrome）
if (!window.chrome) {
  window.chrome = {};
}

// 模拟 chrome.runtime（让网站认为有扩展存在）
window.chrome.runtime = window.chrome.runtime || {
  id: 'cjpalhdlnbpafiamejdnhcphjbkeiagm', // uBlock Origin 的扩展 ID
  connect: function() { 
    return { 
      onMessage: { addListener: function() {} }, 
      postMessage: function() {} 
    }; 
  },
  sendMessage: function(extId, msg, callback) { 
    if (callback) setTimeout(callback, 10); 
  },
  onMessage: { addListener: function() {}, removeListener: function() {} },
  onConnect: { addListener: function() {} },
  getManifest: function() { 
    return { version: '1.57.2', name: 'uBlock Origin' }; 
  },
  getURL: function(path) { 
    return 'chrome-extension://cjpalhdlnbpafiamejdnhcphjbkeiagm/' + path; 
  },
  lastError: null
};

// 模拟 chrome.loadTimes（Chrome 特有的 API）
window.chrome.loadTimes = window.chrome.loadTimes || function() {
  return {
    commitLoadTime: Date.now() / 1000 - Math.random() * 10,
    connectionInfo: 'h2',
    finishDocumentLoadTime: Date.now() / 1000 - Math.random() * 5,
    finishLoadTime: Date.now() / 1000 - Math.random() * 2,
    firstPaintAfterLoadTime: 0,
    firstPaintTime: Date.now() / 1000 - Math.random() * 8,
    navigationType: 'Other',
    npnNegotiatedProtocol: 'h2',
    requestTime: Date.now() / 1000 - Math.random() * 15,
    startLoadTime: Date.now() / 1000 - Math.random() * 12,
    wasAlternateProtocolAvailable: false,
    wasFetchedViaSpdy: true,
    wasNpnNegotiated: true
  };
};

// 3. 修改 permissions 查询结果
const originalQuery = navigator.permissions.query;
navigator.permissions.query = function(parameters) {
  if (parameters.name === 'notifications') {
    return Promise.resolve({ state: Notification.permission, onchange: null });
  }
  return originalQuery.call(this, parameters);
};

// 4. 创建真实的 PluginArray（模拟浏览器插件）
const plugins = [
  { name: 'Chrome PDF Plugin', description: 'Portable Document Format', filename: 'internal-pdf-viewer' },
  { name: 'Chrome PDF Viewer', description: '', filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai' },
  { name: 'Native Client', description: '', filename: 'internal-nacl-plugin' }
];
Object.defineProperty(navigator, 'plugins', {
  get: () => {
    const arr = plugins.map(p => ({
      ...p,
      length: 1,
      item: () => null,
      namedItem: () => null,
      [Symbol.iterator]: function* () { yield this; }
    }));
    arr.item = (i) => arr[i];
    arr.namedItem = (name) => arr.find(p => p.name === name);
    arr.refresh = () => {};
    return arr;
  },
  configurable: true
});

// 5. 修改 languages（模拟真实用户的语言设置）
Object.defineProperty(navigator, 'languages', {
  get: () => ['zh-CN', 'zh', 'en-US', 'en'],
  configurable: true
});

// 6. 修改 hardwareConcurrency（CPU 核心数）
Object.defineProperty(navigator, 'hardwareConcurrency', {
  get: () => 8,
  configurable: true
});

// 7. 修改 deviceMemory（设备内存）
Object.defineProperty(navigator, 'deviceMemory', {
  get: () => 8,
  configurable: true
});

// 8. 修改 platform（操作系统平台）
Object.defineProperty(navigator, 'platform', {
  get: () => 'MacIntel',
  configurable: true
});

// 9. 隐藏 Playwright 特有的函数和属性
const playwrightProps = [
  '__playwright',
  '__pw_manual',
  '__PW_inspect',
  'playwright',
  '__webdriverFunc',
  '__driver_evaluate',
  '__webdriver_evaluate',
  '__selenium_evaluate',
  '__fxdriver_evaluate',
  '__driver_unwrapped',
  '__webdriver_unwrapped',
  '__selenium_unwrapped',
  '__fxdriver_unwrapped'
];

playwrightProps.forEach(prop => {
  try {
    delete window[prop];
    Object.defineProperty(window, prop, {
      get: () => undefined,
      configurable: true
    });
  } catch(e) {}
});

// 10. 修复 Function.prototype.toString 检测
const originalToString = Function.prototype.toString;
Function.prototype.toString = function() {
  if (this === navigator.permissions.query) {
    return 'function query() { [native code] }';
  }
  return originalToString.call(this);
};
```

**关键点：**
1. **隐藏 webdriver**：最重要的特征，必须设置为 `undefined`
2. **模拟 chrome 对象**：让网站认为这是真实的 Chrome 浏览器
3. **模拟插件**：真实浏览器通常有 PDF 插件等
4. **删除 Playwright 属性**：删除所有 Playwright 特有的属性
5. **修复 toString**：让 Hook 的函数看起来像原生代码

---

## 完整实现

### Java 代码

```java
private void addStealthScripts(BrowserContext context) {
    // 第一层：AJAX 拦截器
    context.addInitScript("(() => { /* AJAX 拦截代码 */ })();");
    
    // 第二层：扩展检测绕过
    context.addInitScript("(() => { /* 扩展检测绕过代码 */ })();");
    
    // 第三层：Stealth 脚本
    context.addInitScript("(() => { /* Stealth 代码 */ })();");
    
    log.info("✓ 已添加反检测脚本到BrowserContext");
}
```

### 启动配置

```java
context = playwright.chromium().launchPersistentContext(
    userDataDir,
    new BrowserType.LaunchPersistentContextOptions()
        .setHeadless(false)
        .setIgnoreDefaultArgs(List.of("--enable-automation"))  // 关键：移除自动化标记
        .setArgs(List.of(
            "--disable-blink-features=AutomationControlled",
            "--disable-infobars",
            "--no-first-run",
            "--no-default-browser-check",
            // 加载真实扩展
            "--disable-extensions-except=" + extensionPath.toAbsolutePath(),
            "--load-extension=" + extensionPath.toAbsolutePath()
        ))
);
```

---

## 关键点总结

### 1. AJAX 拦截器
- **目的**：绕过反爬虫验证，阻止内存炸弹
- **原理**：动态读取加密值，返回匹配的响应
- **关键**：精确匹配验证接口，不影响其他请求

### 2. 扩展检测绕过
- **目的**：让网站认为浏览器安装了扩展
- **原理**：拦截所有 `chrome-extension://` 请求，返回成功响应
- **关键**：fetch 和 XHR 规则必须一致，拦截所有而不是部分

### 3. Stealth 脚本
- **目的**：隐藏 Playwright 特征，伪装成真实浏览器
- **原理**：修改 navigator 属性，模拟 chrome 对象，删除 Playwright 属性
- **关键**：隐藏 webdriver，模拟完整的 Chrome 环境

### 4. 真实扩展
- **目的**：让浏览器环境更真实
- **原理**：使用 `launchPersistentContext` 加载真实的 Chrome 扩展
- **关键**：必须忽略 `--enable-automation` 参数

---

## 验证方法

```javascript
// 浏览器控制台测试
console.log('webdriver:', navigator.webdriver);  // 应该是 undefined
console.log('chrome.runtime:', window.chrome.runtime);  // 应该有值
console.log('plugins:', navigator.plugins.length);  // 应该 > 0

// 测试扩展检测拦截
fetch('chrome-extension://invalid/test')
    .then(r => console.log('✅ 拦截成功', r.status))  // 应该返回 200
    .catch(e => console.log('❌ 拦截失败', e));
```

---

**文档版本**：v2.0  
**最后更新**：2026-01-23  
**状态**：✅ 已验证可用
