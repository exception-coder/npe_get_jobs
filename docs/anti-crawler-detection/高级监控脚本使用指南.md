# 🚀 高级监控脚本 - 快速使用指南

## 📋 目的

使用高级监控脚本来**找到混淆 JS 中触发 about:blank 跳转的具体代码**。

---

## ✅ 使用步骤

### 步骤 1：启用高级监控脚本

在 `PlaywrightService.java` 的 `createNewContext()` 方法中，**取消注释**以下行：

```java
// 找到这一行（大约在第 120 行）
// getjobs.common.util.AdvancedAntiCrawlerAnalyzer.attachAdvancedMonitor(context);

// 取消注释，改为：
getjobs.common.util.AdvancedAntiCrawlerAnalyzer.attachAdvancedMonitor(context);
```

### 步骤 2：重启应用

```bash
# 停止应用
# 启动应用
```

### 步骤 3：查看浏览器控制台

打开浏览器控制台（F12），你会看到类似这样的输出：

```log
[ADVANCED_MONITOR] 高级监控脚本已启动
[ADVANCED_MONITOR] ✓ 所有 Hook 已安装完成
[ADVANCED_MONITOR] 现在会记录所有可疑的 API 调用

[HOOK] location.href = about:blank
  参数: ["about:blank"]
  调用栈:
    at checkBrowser (https://www.zhipin.com/static/main.js:1234:56)
    at init (https://www.zhipin.com/static/main.js:789:12)
    at <anonymous> (https://www.zhipin.com/static/main.js:1:1)

[BLOCKED] 阻止跳转到 about:blank
调用栈: ...
```

### 步骤 4：分析调用栈

从调用栈中，你可以看到：
1. **触发跳转的函数名**：`checkBrowser`
2. **具体的文件和行号**：`main.js:1234:56`
3. **完整的调用链**：`checkBrowser` → `init` → `(anonymous)`

### 步骤 5：在 Chrome DevTools 中定位代码

1. 打开 Chrome DevTools（F12）
2. 切换到 **Sources** 标签
3. 按 `Ctrl+P`，输入 `main.js`
4. 点击左下角的 `{}` 按钮（Pretty print）格式化代码
5. 按 `Ctrl+G`，输入行号 `1234`，跳转到对应位置
6. 查看代码，找到检测逻辑

### 步骤 6：分析检测逻辑

假设你在 `main.js:1234` 找到了这样的代码：

```javascript
function checkBrowser() {
  // 检测 webdriver
  if (navigator.webdriver) {
    location.href = 'about:blank';
    return;
  }
  
  // 检测 chrome 对象
  if (!window.chrome || !window.chrome.runtime) {
    location.href = 'about:blank';
    return;
  }
  
  // 检测 plugins
  if (navigator.plugins.length === 0) {
    location.href = 'about:blank';
    return;
  }
}
```

### 步骤 7：针对性隐藏特征

根据找到的检测逻辑，确认我们的 Stealth 脚本是否已经隐藏了这些特征：

```java
// 在 PlaywrightService.createNewContext() 中
context.addInitScript(
    "// 1. 隐藏 webdriver ✅\n" +
    "Object.defineProperty(navigator, 'webdriver', { get: () => undefined });\n" +
    "\n" +
    "// 2. 伪造 window.chrome ✅\n" +
    "window.chrome = { runtime: {}, ... };\n" +
    "\n" +
    "// 3. 伪造 navigator.plugins ✅\n" +
    "Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });\n"
);
```

如果发现新的检测逻辑，添加对应的隐藏代码。

---

## 📊 监控的 API

高级监控脚本会 Hook 以下 API：

| API | 说明 | 用途 |
|-----|------|------|
| `location.href` | 设置 URL | 检测跳转 |
| `location.replace()` | 替换 URL | 检测跳转 |
| `location.assign()` | 分配 URL | 检测跳转 |
| `window.open()` | 打开新窗口 | 检测弹窗 |
| `eval()` | 执行代码 | 检测动态代码 |
| `Function()` | 创建函数 | 检测动态代码 |
| `setTimeout()` | 延迟执行 | 检测定时器 |
| `setInterval()` | 定期执行 | 检测定时器 |
| `Object.defineProperty()` | 定义属性 | 检测属性修改 |
| `document.write()` | 写入文档 | 检测 DOM 操作 |

---

## 🎯 实战案例

### 案例 1：找到检测 webdriver 的代码

**控制台输出**：
```log
[HOOK] location.href = about:blank
  参数: ["about:blank"]
  调用栈:
    at checkWebdriver (main.js:1234:56)
    at init (main.js:789:12)
```

**分析**：
- 触发函数：`checkWebdriver`
- 位置：`main.js:1234:56`

**解决**：
- 在 DevTools 中定位到 `main.js:1234`
- 查看 `checkWebdriver` 函数的逻辑
- 确认是否检测了 `navigator.webdriver`
- 确认 Stealth 脚本已经隐藏了这个特征

### 案例 2：找到检测 chrome 对象的代码

**控制台输出**：
```log
[HOOK] Object.defineProperty
  对象: window
  属性: chrome
  描述符: {get: ƒ, set: undefined, enumerable: true, configurable: true}
  调用栈:
    at checkChrome (main.js:5678:90)
```

**分析**：
- 对方在检测 `window.chrome` 对象
- 位置：`main.js:5678:90`

**解决**：
- 确认 Stealth 脚本已经伪造了 `window.chrome`
- 如果还是被检测，可能需要伪造更多属性

---

## ⚠️ 注意事项

### 1. 日志量很大

高级监控脚本会产生**大量日志**，建议：
- ✅ 仅在调试时启用
- ✅ 找到问题后立即禁用
- ✅ 不要在生产环境启用

### 2. 性能影响

Hook 所有 API 会有**性能影响**，建议：
- ✅ 仅在需要时启用
- ✅ 找到问题后立即禁用

### 3. 禁用方法

找到问题后，**注释掉**以下行：

```java
// 禁用高级监控脚本
// getjobs.common.util.AdvancedAntiCrawlerAnalyzer.attachAdvancedMonitor(context);
```

---

## 🔍 高级技巧

### 技巧 1：只监控特定 API

如果日志太多，可以修改 `AdvancedAntiCrawlerAnalyzer.java`，只 Hook 特定的 API。

例如，只监控 `location.href`：

```java
// 只保留 location.href 的 Hook
context.addInitScript(
    "const originalHrefDescriptor = Object.getOwnPropertyDescriptor(Location.prototype, 'href');\n" +
    "Object.defineProperty(Location.prototype, 'href', {\n" +
    "  get: originalHrefDescriptor.get,\n" +
    "  set: function(value) {\n" +
    "    console.log('[HOOK] location.href =', value);\n" +
    "    console.trace();\n" +
    "    if (value && value.includes('about:blank')) {\n" +
    "      console.error('[BLOCKED] 阻止跳转');\n" +
    "      return;\n" +
    "    }\n" +
    "    return originalHrefDescriptor.set.call(this, value);\n" +
    "  }\n" +
    "});"
);
```

### 技巧 2：使用条件断点

在 Chrome DevTools 中，右键点击行号，选择 "Add conditional breakpoint"，输入条件：

```javascript
// 只在包含 about:blank 时触发断点
url.includes('about:blank')
```

### 技巧 3：使用 Fiddler/Charles 替换 JS

1. 使用 Fiddler 或 Charles 拦截 `main.js`
2. 替换为反混淆后的版本
3. 在反混淆的代码中添加 `console.log` 或 `debugger`
4. 更容易调试

---

## 📚 相关文档

- [混淆 JS 破解指南](./混淆JS破解指南.md) - 完整的破解方法
- [快速参考](./快速参考.md) - 快速查看关键信息
- [测试指南](./测试指南.md) - 测试和验证方法

---

## ✨ 总结

### 核心流程

```
1. 启用高级监控脚本
   ↓
2. 重启应用，查看浏览器控制台
   ↓
3. 找到触发 about:blank 的调用栈
   ↓
4. 在 Chrome DevTools 中定位代码
   ↓
5. 分析检测逻辑
   ↓
6. 针对性隐藏特征
   ↓
7. 禁用高级监控脚本
```

### 核心思想

> **不要盲目地隐藏特征，而是要先找到对方检测了哪些特征，然后针对性地隐藏。**

高级监控脚本就是帮你**找到对方检测了哪些特征**的工具！

---

**祝调试顺利！🔍**

