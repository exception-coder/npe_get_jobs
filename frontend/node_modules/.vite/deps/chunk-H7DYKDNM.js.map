{
  "version": 3,
  "sources": ["../../@univerjs/engine-formula/lib/es/facade.js"],
  "sourcesContent": ["import { FBase as f, FUniver as d } from \"@univerjs/core/facade\";\nimport { Inject as c, ICommandService as p, Injector as _, IConfigService as C } from \"@univerjs/core\";\nimport { LexerTreeBuilder as v, SetFormulaCalculationStartMutation as l, SetFormulaCalculationStopMutation as S, SetFormulaCalculationNotificationMutation as m, GlobalComputingStatusService as x, ENGINE_FORMULA_CYCLE_REFERENCE_COUNT as h } from \"@univerjs/engine-formula\";\nimport { firstValueFrom as g, race as E, filter as F, timer as B, map as I } from \"rxjs\";\nvar T = Object.getOwnPropertyDescriptor, N = (e, t, r, i) => {\n  for (var o = i > 1 ? void 0 : i ? T(t, r) : t, a = e.length - 1, u; a >= 0; a--)\n    (u = e[a]) && (o = u(o) || o);\n  return o;\n}, n = (e, t) => (r, i) => t(r, i, e);\nlet s = class extends f {\n  constructor(e, t, r, i) {\n    super(), this._commandService = e, this._injector = t, this._lexerTreeBuilder = r, this._configService = i, this._initialize();\n  }\n  /**\n   * @ignore\n   */\n  _initialize() {\n  }\n  /**\n   * The tree builder for formula string.\n   * @type {LexerTreeBuilder}\n   */\n  get lexerTreeBuilder() {\n    return this._lexerTreeBuilder;\n  }\n  /**\n   * Offsets the formula\n   * @param {string} formulaString - The formula string to offset\n   * @param {number} refOffsetX - The offset column\n   * @param {number} refOffsetY - The offset row\n   * @param {boolean} [ignoreAbsolute] - Whether to ignore the absolute reference\n   * @returns {string} The offset formula string\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * const result = formulaEngine.moveFormulaRefOffset('=SUM(A1,B2)', 1, 1);\n   * console.log(result);\n   * ```\n   */\n  moveFormulaRefOffset(e, t, r, i) {\n    return this._lexerTreeBuilder.moveFormulaRefOffset(e, t, r, i);\n  }\n  /**\n   * Resolves the formula string to a 'node' node\n   * @param {string} formulaString - The formula string to resolve\n   * @returns {Array<ISequenceNode | string>} The nodes of the formula string\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * const nodes = formulaEngine.sequenceNodesBuilder('=SUM(A1,B2)');\n   * console.log(nodes);\n   * ```\n   */\n  sequenceNodesBuilder(e) {\n    return this._lexerTreeBuilder.sequenceNodesBuilder(e) || [];\n  }\n  /**\n   * Start the calculation of the formula.\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.executeCalculation();\n   * ```\n   */\n  executeCalculation() {\n    this._commandService.executeCommand(l.id, { commands: [], forceCalculation: !0 }, { onlyLocal: !0 });\n  }\n  /**\n   * Stop the calculation of the formula.\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.stopCalculation();\n   * ```\n   */\n  stopCalculation() {\n    this._commandService.executeCommand(S.id, {});\n  }\n  /**\n   * Listening calculation starts.\n   * @param {Function} callback - The callback function to be called when the formula calculation starts.\n   * @returns {IDisposable} The disposable instance.\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.calculationStart((forceCalculation) => {\n   *   console.log('Calculation start', forceCalculation);\n   * });\n   * ```\n   */\n  calculationStart(e) {\n    return this._commandService.onCommandExecuted((t) => {\n      if (t.id === l.id) {\n        const r = t.params;\n        e(r.forceCalculation);\n      }\n    });\n  }\n  /**\n   * Listening calculation ends.\n   * @param {Function} callback - The callback function to be called when the formula calculation ends.\n   * @returns {IDisposable} The disposable instance.\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.calculationEnd((functionsExecutedState) => {\n   *   console.log('Calculation end', functionsExecutedState);\n   * });\n   * ```\n   */\n  calculationEnd(e) {\n    return this._commandService.onCommandExecuted((t) => {\n      if (t.id !== m.id)\n        return;\n      const r = t.params;\n      r.functionsExecutedState !== void 0 && e(r.functionsExecutedState);\n    });\n  }\n  /**\n   * Wait for computing in the Univer instance to complete. Please note that this does not only include formula calculation,\n   * but also other computing tasks, e.g. pivot table calculation.\n   * @param {number} [timeout] The maximum time to wait for the computing to complete, in milliseconds. The default\n   * value is 30,000 milliseconds.\n   * @returns {Promise<boolean>} This method returns `true` if the computing is complete. If the timeout is reached, this\n   * method returns `false`.\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.whenComputingCompleteAsync(3000).then((isComplete) => {\n   *   console.log('Computing complete:', isComplete);\n   * });\n   * ```\n   */\n  whenComputingCompleteAsync(e) {\n    const t = this._injector.get(x);\n    return t.computingStatus ? Promise.resolve(!0) : g(E(\n      t.computingStatus$.pipe(F((r) => r)),\n      B(e != null ? e : 3e4).pipe(I(() => !1))\n    ));\n  }\n  /**\n   * @deprecated Use `whenComputingCompleteAsync` instead.\n   * @returns {Promise<void>} This method returns a promise that resolves when the calculation is complete.\n   */\n  onCalculationEnd() {\n    return new Promise((e, t) => {\n      const r = setTimeout(() => {\n        t(new Error(\"Calculation end timeout\"));\n      }, 3e4), i = this.calculationEnd(() => {\n        clearTimeout(r), i.dispose(), e();\n      });\n    });\n  }\n  /**\n   * Listening calculation processing.\n   * @param {Function} callback - The callback function to be called when the formula calculation is in progress.\n   * @returns {IDisposable} The disposable instance.\n   *\n   * @example\n   * ```ts\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.calculationProcessing((stageInfo) => {\n   *   console.log('Calculation processing', stageInfo);\n   * });\n   * ```\n   */\n  calculationProcessing(e) {\n    return this._commandService.onCommandExecuted((t) => {\n      if (t.id !== m.id)\n        return;\n      const r = t.params;\n      r.stageInfo !== void 0 && e(r.stageInfo);\n    });\n  }\n  /**\n   * When a formula contains a circular reference, set the maximum number of iterations for the formula calculation.\n   * @param {number} maxIteration The maximum number of iterations. The default value is 1.\n   *\n   * @example\n   * ```ts\n   * // Set the maximum number of iterations for the formula calculation to 5.\n   * // The default value is 1.\n   * const formulaEngine = univerAPI.getFormula();\n   * formulaEngine.setMaxIteration(5);\n   * ```\n   */\n  setMaxIteration(e) {\n    this._configService.setConfig(h, e);\n  }\n};\ns = N([\n  n(0, c(p)),\n  n(1, c(_)),\n  n(2, c(v)),\n  n(3, C)\n], s);\nclass O extends d {\n  getFormula() {\n    return this._injector.createInstance(s);\n  }\n}\nd.extend(O);\nexport {\n  s as FFormula\n};\n"],
  "mappings": "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",
  "names": []
}
