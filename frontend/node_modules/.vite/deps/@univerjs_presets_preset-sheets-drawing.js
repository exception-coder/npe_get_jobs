import {
  $,
  Ar,
  Bt,
  Cr,
  D,
  Ie,
  Le,
  Pe,
  Pt,
  Ue,
  Wt,
  Xt,
  Y as Y2,
  Ze,
  _r,
  d,
  et as et2,
  fr,
  ge,
  gr,
  h as h2,
  hr,
  it,
  kt,
  l,
  lr,
  mr,
  nt,
  oe,
  rt,
  tt,
  ut,
  w,
  wr,
  z,
  ze
} from "./chunk-ZTXDQJG2.js";
import {
  E,
  R,
  Y,
  f,
  g,
  h
} from "./chunk-MO6OUX3Q.js";
import {
  q
} from "./chunk-WEJEHBT6.js";
import {
  S,
  k
} from "./chunk-FOCXVU2X.js";
import {
  S1,
  e2,
  gt,
  t2,
  ue
} from "./chunk-DZMX4FYO.js";
import {
  At2 as At,
  IE,
  ME,
  Mt3 as Mt,
  On3 as On,
  Qt3 as Qt,
  Yt3 as Yt,
  Zt2 as Zt,
  _n2 as _n,
  cn2 as cn,
  ln2 as ln,
  mn2 as mn,
  un3 as un,
  vn2 as vn,
  wn2 as wn
} from "./chunk-I7I3GTAS.js";
import {
  $ as $2,
  I,
  O,
  j
} from "./chunk-YFGUMDM2.js";
import {
  El,
  Inject,
  Injector,
  KC,
  Ls,
  We,
  et,
  ng,
  oc,
  pE,
  tg,
  vr,
  we
} from "./chunk-RGZYGL3P.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@univerjs/sheets-drawing-ui/lib/es/facade.js
var q2 = Object.defineProperty;
var J = (o, r, t) => r in o ? q2(o, r, { enumerable: true, configurable: true, writable: true, value: t }) : o[r] = t;
var P = (o, r, t) => J(o, typeof r != "symbol" ? r + "" : r, t);
var de = Object.getOwnPropertyDescriptor;
var V = (o, r, t, e) => {
  for (var i = e > 1 ? void 0 : e ? de(r, t) : r, n = o.length - 1, s; n >= 0; n--)
    (s = o[n]) && (i = s(i) || i);
  return i;
};
var x = (o, r) => (t, e) => r(t, e, o);
function ce(o, r) {
  const { from: t, to: e, flipY: i = false, flipX: n = false, angle: s = 0, skewX: a = 0, skewY: d2 = 0 } = o.sheetTransform, { column: g2, columnOffset: c, row: m, rowOffset: l2 } = t, _ = e2(
    o.unitId,
    o.subUnitId,
    { from: t, to: e },
    r
  ), { width: h3, height: u } = _;
  return {
    ...o,
    column: g2,
    columnOffset: c,
    row: m,
    rowOffset: l2,
    width: h3,
    height: u,
    flipY: i,
    flipX: n,
    angle: s,
    skewX: a,
    skewY: d2
  };
}
function ge2(o, r, t) {
  const { column: e, columnOffset: i, row: n, rowOffset: s, flipY: a = false, flipX: d2 = false, angle: g2 = 0, skewX: c = 0, skewY: m = 0, width: l2, height: _ } = o, h3 = t2(
    o.unitId,
    o.subUnitId,
    { column: e, columnOffset: i, row: n, rowOffset: s },
    l2,
    _,
    r,
    t
  ), { sheetTransform: u, transform: B } = h3;
  return {
    ...o,
    sheetTransform: {
      ...u,
      flipY: a,
      flipX: d2,
      angle: g2,
      skewX: c,
      skewY: m
    },
    transform: {
      ...B,
      flipY: a,
      flipX: d2,
      angle: g2,
      skewX: c,
      skewY: m
    }
  };
}
var F = class {
  constructor(o, r, t) {
    P(this, "_image");
    this._injector = t, this._image = {
      drawingId: et(6),
      drawingType: ng.DRAWING_IMAGE,
      imageSourceType: oc.BASE64,
      source: "",
      unitId: o,
      subUnitId: r,
      column: 0,
      columnOffset: 0,
      row: 0,
      rowOffset: 0,
      width: 0,
      height: 0
    };
  }
  /**
   * Set the initial image configuration for the image builder.
   * @param {ISheetImage} image - The image configuration
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set initial image configuration.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setImage({
   *     drawingId: '123456',
   *     drawingType: univerAPI.Enum.DrawingType.DRAWING_IMAGE,
   *     imageSourceType: univerAPI.Enum.ImageSourceType.BASE64,
   *     source: 'https://avatars.githubusercontent.com/u/61444807?s=48&v=4',
   *     unitId: fWorkbook.getId(),
   *     subUnitId: fWorksheet.getSheetId(),
   *   })
   *   .setColumn(5)
   *   .setRow(5)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setImage(o) {
    const t = this._injector.get(ME).getRenderById(o.unitId);
    if (!t)
      throw new Error(`Render Unit with unitId ${o.unitId} not found`);
    const e = t.with(ue);
    return o.sheetTransform == null && (o.sheetTransform = {
      from: {
        column: 0,
        columnOffset: 0,
        row: 0,
        rowOffset: 0
      },
      to: {
        column: 0,
        columnOffset: 0,
        row: 0,
        rowOffset: 0
      }
    }), this._image = ce(o, e), this;
  }
  setSource(o, r) {
    const t = r != null ? r : oc.URL;
    return this._image.source = o, this._image.imageSourceType = t, this;
  }
  /**
   * Get the source of the image
   * @returns {string} The source of the image
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const images = fWorksheet.getImages();
   * images.forEach((image) => {
   *   console.log(image, image.toBuilder().getSource());
   * });
   * ```
   */
  getSource() {
    return this._image.source;
  }
  /**
   * Get the source type of the image
   * @returns {ImageSourceType} The source type of the image
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const images = fWorksheet.getImages();
   * images.forEach((image) => {
   *   console.log(image, image.toBuilder().getSourceType());
   * });
   * ```
   */
  getSourceType() {
    return this._image.imageSourceType;
  }
  /**
   * Set the horizontal position of the image
   * @param {number} column - The column index of the image start position, start at 0
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setColumn(o) {
    return this._image.column = o, this;
  }
  /**
   * Set the vertical position of the image
   * @param {number} row - The row index of the image start position, start at 0
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setRow(o) {
    return this._image.row = o, this;
  }
  /**
   * Set the horizontal offset of the image
   * @param {number} offset - The column offset of the image start position, pixel unit
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell and horizontal offset is 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setColumnOffset(10)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setColumnOffset(o) {
    return this._image.columnOffset = o, this;
  }
  /**
   * Set the vertical offset of the image
   * @param {number} offset - The row offset of the image start position, pixel unit
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell and vertical offset is 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setRowOffset(10)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setRowOffset(o) {
    return this._image.rowOffset = o, this;
  }
  /**
   * Set the width of the image
   * @param {number} width - The width of the image, pixel unit
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, width is 120px and height is 50px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setWidth(120)
   *   .setHeight(50)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setWidth(o) {
    return this._image.width = o, this;
  }
  /**
   * Set the height of the image
   * @param {number} height - The height of the image, pixel unit
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, width is 120px and height is 50px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setWidth(120)
   *   .setHeight(50)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setHeight(o) {
    return this._image.height = o, this;
  }
  /**
   * Set the anchor type of the image, whether the position and size change with the cell
   * @param {SheetDrawingAnchorType} anchorType - The anchor type of the image
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // image1 position is start from A6 cell, anchor type is Position.
   * // Only the position of the drawing follows the cell changes. When rows or columns are inserted or deleted, the position of the drawing changes, but the size remains the same.
   * const image1 = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(0)
   *   .setRow(5)
   *   .setAnchorType(univerAPI.Enum.SheetDrawingAnchorType.Position)
   *   .buildAsync();
   *
   * // image2 position is start from C6 cell, anchor type is Both.
   * // The size and position of the drawing follow the cell changes. When rows or columns are inserted or deleted, the size and position of the drawing change accordingly.
   * const image2 = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(2)
   *   .setRow(5)
   *   .setAnchorType(univerAPI.Enum.SheetDrawingAnchorType.Both)
   *   .buildAsync();
   *
   * // image3 position is start from E6 cell, anchor type is None.
   * // The size and position of the drawing do not follow the cell changes. When rows or columns are inserted or deleted, the position and size of the drawing remain unchanged.
   * const image3 = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(4)
   *   .setRow(5)
   *   .setAnchorType(univerAPI.Enum.SheetDrawingAnchorType.None)
   *   .buildAsync();
   *
   * // insert images into the sheet
   * fWorksheet.insertImages([image1, image2, image3]);
   *
   * // after 2 seconds, set the row height of the 5th row to 100px and insert a row before the 5th row.
   * // then observe the position and size changes of the images.
   * setTimeout(() => {
   *   fWorksheet.setRowHeight(5, 100).insertRowBefore(5);
   * }, 2000);
   * ```
   */
  setAnchorType(o) {
    return this._image.anchorType = o, this;
  }
  /**
   * Set the cropping region of the image by defining the top edges, thereby displaying the specific part of the image you want.
   * @param {number} top - The number of pixels to crop from the top of the image
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, top crop is 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setCropTop(10)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setCropTop(o) {
    return this._initializeSrcRect(), this._image.srcRect.top = o, this;
  }
  /**
   * Set the cropping region of the image by defining the left edges, thereby displaying the specific part of the image you want.
   * @param {number} left - The number of pixels to crop from the left side of the image
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, left crop is 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setCropLeft(10)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setCropLeft(o) {
    return this._initializeSrcRect(), this._image.srcRect.left = o, this;
  }
  /**
   * Set the cropping region of the image by defining the bottom edges, thereby displaying the specific part of the image you want.
   * @param {number} bottom - The number of pixels to crop from the bottom of the image
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, bottom crop is 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setCropBottom(10)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setCropBottom(o) {
    return this._initializeSrcRect(), this._image.srcRect.bottom = o, this;
  }
  /**
   * Set the cropping region of the image by defining the right edges, thereby displaying the specific part of the image you want.
   * @param {number} right - The number of pixels to crop from the right side of the image
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, right crop is 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setCropRight(10)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setCropRight(o) {
    return this._initializeSrcRect(), this._image.srcRect.right = o, this;
  }
  _initializeSrcRect() {
    this._image.srcRect == null && (this._image.srcRect = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    });
  }
  /**
   * Set the rotation angle of the image
   * @param {number} angle - Degree of rotation of the image, for example, 90, 180, 270, etc.
   * @returns {FOverGridImageBuilder} The `FOverGridImageBuilder` for chaining
   * @example
   * ```ts
   * // create a new image builder and set image source.
   * // then build `ISheetImage` and insert it into the sheet, position is start from F6 cell, rotate 90 degrees.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = await fWorksheet.newOverGridImage()
   *   .setSource('https://avatars.githubusercontent.com/u/61444807?s=48&v=4', univerAPI.Enum.ImageSourceType.URL)
   *   .setColumn(5)
   *   .setRow(5)
   *   .setRotate(90)
   *   .buildAsync();
   * fWorksheet.insertImages([image]);
   * ```
   */
  setRotate(o) {
    return this._image.angle = o, this;
  }
  setUnitId(o) {
    return this._image.unitId = o, this;
  }
  setSubUnitId(o) {
    return this._image.subUnitId = o, this;
  }
  async buildAsync() {
    const r = this._injector.get(ME).getRenderById(this._image.unitId);
    if (!r)
      throw new Error(`Render Unit with unitId ${this._image.unitId} not found`);
    const t = r.with(gt), e = r.with(ue);
    if (this._image.width === 0 || this._image.height === 0) {
      const i = await wn(this._image.source), n = i.width, s = i.height;
      this._image.width === 0 && (this._image.width = n), this._image.height === 0 && (this._image.height = s);
    }
    return ge2(this._image, t, e);
  }
};
F = V([
  x(2, Inject(Injector))
], F);
var v = class extends $2 {
  constructor(o, r, t) {
    super(), this._image = o, this._commandService = r, this._injector = t;
  }
  /**
   * Get the id of the image
   * @returns {string} The id of the image
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const images = fWorksheet.getImages();
   * images.forEach((image) => {
   *   console.log(image, image.getId());
   * });
   * ```
   */
  getId() {
    return this._image.drawingId;
  }
  /**
   * Get the drawing type of the image
   * @returns {DrawingTypeEnum} The drawing type of the image
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const images = fWorksheet.getImages();
   * images.forEach((image) => {
   *   console.log(image, image.getType());
   * });
   * ```
   */
  getType() {
    return this._image.drawingType;
  }
  /**
   * Remove the image from the sheet
   * @returns {boolean} true if the image is removed successfully, otherwise false
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.remove();
   * console.log(result);
   * ```
   */
  remove() {
    return this._commandService.syncExecuteCommand(rt.id, { unitId: this._image.unitId, drawings: [this._image] });
  }
  /**
   * Convert the image to a FOverGridImageBuilder
   * @returns {FOverGridImageBuilder} The builder FOverGridImageBuilder
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const images = fWorksheet.getImages();
   * images.forEach((image) => {
   *   console.log(image, image.toBuilder().getSource());
   * });
   * ```
   */
  toBuilder() {
    const o = this._injector.createInstance(F);
    return o.setImage(this._image), o;
  }
  setSource(o, r) {
    const t = r != null ? r : oc.URL;
    return this._image.source = o, this._image.imageSourceType = t, this._commandService.syncExecuteCommand(Wt.id, { unitId: this._image.unitId, drawings: [this._image] });
  }
  async setPositionAsync(o, r, t, e) {
    const i = this.toBuilder();
    i.setColumn(r), i.setRow(o), t != null && i.setRowOffset(t), e != null && i.setColumnOffset(e);
    const n = await i.buildAsync();
    return this._commandService.syncExecuteCommand(Wt.id, { unitId: this._image.unitId, drawings: [n] });
  }
  /**
   * Set the size of the image
   * @param {number} width - The width of the image, pixel unit
   * @param {number} height - The height of the image, pixel unit
   * @returns {boolean} true if the size is set successfully, otherwise false
   * @example
   * ```ts
   * // set the image width 120px and height 50px
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setSizeAsync(120, 50);
   * console.log(result);
   * ```
   */
  async setSizeAsync(o, r) {
    const t = this.toBuilder();
    t.setWidth(o), t.setHeight(r);
    const e = await t.buildAsync();
    return this._commandService.syncExecuteCommand(Wt.id, { unitId: this._image.unitId, drawings: [e] });
  }
  /**
   * Set the cropping region of the image by defining the top, bottom, left, and right edges, thereby displaying the specific part of the image you want.
   * @param {number} top - The number of pixels to crop from the top of the image
   * @param {number} left - The number of pixels to crop from the left side of the image
   * @param {number} bottom - The number of pixels to crop from the bottom of the image
   * @param {number} right - The number of pixels to crop from the right side of the image
   * @returns {boolean} true if the crop is set successfully, otherwise false
   * @example
   * ```ts
   * // set the crop of the image, top 10px, left 10px, bottom 10px, right 10px.
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setCrop(10, 10, 10, 10);
   * console.log(result);
   * ```
   */
  setCrop(o, r, t, e) {
    return this._image.srcRect == null && (this._image.srcRect = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    }), o != null && (this._image.srcRect.top = o), r != null && (this._image.srcRect.left = r), t != null && (this._image.srcRect.bottom = t), e != null && (this._image.srcRect.right = e), this._commandService.syncExecuteCommand(Wt.id, { unitId: this._image.unitId, drawings: [this._image] });
  }
  /**
   * Set the rotation angle of the image
   * @param {number} angle - Degree of rotation of the image, for example, 90, 180, 270, etc.
   * @returns {boolean} true if the rotation is set successfully, otherwise false
   * @example
   * ```ts
   * // set 90 degrees rotation of the image
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setRotate(90);
   * console.log(result);
   * ```
   */
  setRotate(o) {
    return this._image.sheetTransform.angle = o, this._image.transform && (this._image.transform.angle = o), this._commandService.syncExecuteCommand(Wt.id, { unitId: this._image.unitId, drawings: [this._image] });
  }
  /**
   * Move the image layer forward by one level
   * @returns {boolean} true if the image is moved forward successfully, otherwise false
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setForward();
   * console.log(result);
   * ```
   */
  setForward() {
    return this._commandService.syncExecuteCommand(fr.id, {
      unitId: this._image.unitId,
      subUnitId: this._image.subUnitId,
      drawingIds: [this._image.drawingId],
      arrangeType: tg.forward
    });
  }
  /**
   * Move the image layer backward by one level
   * @returns {boolean} true if the image is moved backward successfully, otherwise false
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setBackward();
   * console.log(result);
   * ```
   */
  setBackward() {
    return this._commandService.syncExecuteCommand(fr.id, {
      unitId: this._image.unitId,
      subUnitId: this._image.subUnitId,
      drawingIds: [this._image.drawingId],
      arrangeType: tg.backward
    });
  }
  /**
   * Move the image layer to the bottom layer
   * @returns {boolean} true if the image is moved to the bottom layer successfully, otherwise false
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setBack();
   * console.log(result);
   * ```
   */
  setBack() {
    return this._commandService.syncExecuteCommand(fr.id, {
      unitId: this._image.unitId,
      subUnitId: this._image.subUnitId,
      drawingIds: [this._image.drawingId],
      arrangeType: tg.back
    });
  }
  /**
   * Move the image layer to the top layer
   * @returns {boolean} true if the image is moved to the top layer successfully, otherwise false
   * @example
   * ```ts
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const image = fWorksheet.getImages()[0];
   * const result = image?.setFront();
   * console.log(result);
   * ```
   */
  setFront() {
    return this._commandService.syncExecuteCommand(fr.id, {
      unitId: this._image.unitId,
      subUnitId: this._image.subUnitId,
      drawingIds: [this._image.drawingId],
      arrangeType: tg.front
    });
  }
};
v = V([
  x(1, Ls),
  x(2, Inject(Injector))
], v);
var me = class extends S {
  getFloatDomById(r) {
    const e = this._injector.get(tt).getFloatDomInfo(r);
    if (!e) return null;
    const { unitId: i, subUnitId: n } = e, { rect: s } = e, a = s.getState(), { left: d2 = 0, top: g2 = 0, width: c = 0, height: m = 0, flipX: l2 = false, flipY: _ = false, angle: h3 = 0, skewX: u = 0, skewY: B = 0 } = a, O2 = this._injector.get(E).getDrawingByParam({
      drawingId: e.id,
      unitId: i,
      subUnitId: n
    });
    return O2 ? {
      position: {
        left: d2,
        top: g2,
        width: c,
        height: m,
        flipX: l2,
        flipY: _,
        angle: h3,
        skewX: u,
        skewY: B
      },
      componentKey: O2.componentKey,
      allowTransform: O2.allowTransform,
      data: O2.data,
      id: e.id
    } : null;
  }
  getAllFloatDoms() {
    const r = this._injector.get(tt), t = this._workbook.getUnitId(), e = this._worksheet.getSheetId();
    return Array.from(r.getFloatDomsBySubUnitId(t, e).values()).map((i) => {
      const { rect: n } = i, s = this._injector.get(E).getDrawingByParam({
        drawingId: i.id,
        unitId: t,
        subUnitId: e
      }), { left: a, top: d2, width: g2, height: c, flipX: m, flipY: l2, angle: _, skewX: h3, skewY: u } = n.getState();
      return {
        position: {
          left: a,
          top: d2,
          width: g2,
          height: c,
          flipX: m,
          flipY: l2,
          angle: _,
          skewX: h3,
          skewY: u
        },
        componentKey: s.componentKey,
        allowTransform: s.allowTransform,
        data: s.data,
        id: i.id
      };
    });
  }
  updateFloatDom(r, t) {
    var h3, u;
    const i = this._injector.get(tt).getFloatDomInfo(r);
    if (!i) return this;
    const { unitId: n, subUnitId: s } = i, a = this._injector.get(E).getDrawingByParam({
      unitId: n,
      subUnitId: s,
      drawingId: r
    }), d2 = this._injector.get(ME);
    if (!d2.getRenderById(n)) return this;
    if (!this.getSkeleton()) return this;
    const m = (h3 = d2.getRenderById(this.getWorkbook().getUnitId())) == null ? void 0 : h3.with(gt);
    if (!m) return this;
    const l2 = {
      ...a,
      componentKey: t.componentKey || a.componentKey,
      allowTransform: t.allowTransform !== void 0 ? t.allowTransform : a.allowTransform,
      data: t.data || a.data,
      sheetTransform: t.position && (u = $(
        t.position,
        m
      )) != null ? u : a.sheetTransform,
      transform: {
        ...a.transform,
        ...t.position
        // Merge with existing transform
      }
    };
    if (!this._commandService.syncExecuteCommand(Wt.id, { unitId: n, subUnitId: s, drawings: [l2] }))
      throw new Error("updateFloatDom failed");
    return this;
  }
  batchUpdateFloatDoms(r) {
    var s;
    const t = this._injector.get(tt), e = this._injector.get(E), i = this._injector.get(ME), n = [];
    for (const a of r) {
      const d2 = t.getFloatDomInfo(a.id);
      if (!d2) continue;
      const { unitId: g2, subUnitId: c } = d2, m = e.getDrawingByParam({
        unitId: g2,
        subUnitId: c,
        drawingId: a.id
      });
      if (!m) continue;
      const l2 = i.getRenderById(g2);
      if (!l2 || !this.getSkeleton()) continue;
      const h3 = l2.with(gt);
      if (!h3) return this;
      const u = {
        ...m,
        componentKey: a.config.componentKey || m.componentKey,
        allowTransform: a.config.allowTransform !== void 0 ? a.config.allowTransform : m.allowTransform,
        data: a.config.data || m.data,
        sheetTransform: a.config.position && (s = $(
          a.config.position,
          h3
        )) != null ? s : m.sheetTransform,
        transform: {
          ...m.transform,
          ...a.config.position
          // Merge with existing transform
        }
      };
      n.push(u);
    }
    if (n.length > 0) {
      const a = this._workbook.getUnitId(), d2 = this._worksheet.getSheetId();
      if (!this._commandService.syncExecuteCommand(Wt.id, { unitId: a, subUnitId: d2, drawings: n }))
        throw new Error("batchUpdateFloatDoms failed");
    }
    return this;
  }
  removeFloatDom(r) {
    const e = this._injector.get(tt).getFloatDomInfo(r);
    if (!e) return this;
    const { unitId: i, subUnitId: n } = e, a = this._injector.get(E).getDrawingByParam({
      unitId: i,
      subUnitId: n,
      drawingId: r
    });
    if (!a) return this;
    if (!this._commandService.syncExecuteCommand(rt.id, {
      unitId: i,
      drawings: [a]
    }))
      throw new Error("removeFloatDom failed");
    return this;
  }
  addFloatDomToPosition(r, t) {
    const e = this._workbook.getUnitId(), i = this._worksheet.getSheetId(), { key: n, disposableCollection: s } = q(r, this._injector.get(S1)), d2 = this._injector.get(tt).addFloatDomToPosition({ ...r, componentKey: n, unitId: e, subUnitId: i }, t);
    return d2 ? (s.add(d2.dispose), {
      id: d2.id,
      dispose: () => {
        s.dispose(), d2.dispose();
      }
    }) : (s.dispose(), null);
  }
  addFloatDomToRange(r, t, e, i) {
    const n = this._workbook.getUnitId(), s = this._worksheet.getSheetId(), { key: a, disposableCollection: d2 } = q(t, this._injector.get(S1)), c = this._injector.get(tt).addFloatDomToRange(r.getRange(), { ...t, componentKey: a, unitId: n, subUnitId: s }, e, i);
    return c ? (d2.add(c.dispose), {
      id: c.id,
      dispose: () => {
        d2.dispose(), c.dispose();
      }
    }) : (d2.dispose(), null);
  }
  addFloatDomToColumnHeader(r, t, e, i) {
    const n = this._workbook.getUnitId(), s = this._worksheet.getSheetId(), { key: a, disposableCollection: d2 } = q(t, this._injector.get(S1)), c = this._injector.get(tt).addFloatDomToColumnHeader(r, { ...t, componentKey: a, unitId: n, subUnitId: s }, e, i);
    return c ? (d2.add(c.dispose), {
      id: c.id,
      dispose: () => {
        d2.dispose(), c.dispose();
      }
    }) : (d2.dispose(), null);
  }
  async insertImage(r, t, e, i, n) {
    const s = this.newOverGridImage();
    if (typeof r == "string")
      s.setSource(r);
    else {
      const g2 = await r.getBlob().getDataAsString();
      s.setSource(g2, oc.BASE64);
    }
    t !== void 0 ? s.setColumn(t) : s.setColumn(0), e !== void 0 ? s.setRow(e) : s.setRow(0), i !== void 0 ? s.setColumnOffset(i) : s.setColumnOffset(0), n !== void 0 ? s.setRowOffset(n) : s.setRowOffset(0);
    const a = await s.buildAsync();
    return this._commandService.syncExecuteCommand(kt.id, { unitId: this._fWorkbook.getId(), drawings: [a] });
  }
  insertImages(r) {
    const t = r.map((e) => (e.unitId = this._fWorkbook.getId(), e.subUnitId = this.getSheetId(), e));
    return this._commandService.syncExecuteCommand(kt.id, { unitId: this._fWorkbook.getId(), drawings: t }), this;
  }
  deleteImages(r) {
    const t = r.map((e) => ({
      unitId: this._fWorkbook.getId(),
      drawingId: e.getId(),
      subUnitId: this.getSheetId(),
      drawingType: e.getType()
    }));
    return this._commandService.syncExecuteCommand(rt.id, { unitId: this._fWorkbook.getId(), drawings: t }), this;
  }
  getImages() {
    const t = this._injector.get(E).getDrawingData(this._fWorkbook.getId(), this.getSheetId()), e = [];
    for (const i in t) {
      const n = t[i];
      n.drawingType === ng.DRAWING_IMAGE && e.push(this._injector.createInstance(v, n));
    }
    return e;
  }
  getImageById(r) {
    const e = this._injector.get(E).getDrawingByParam({ unitId: this._fWorkbook.getId(), subUnitId: this.getSheetId(), drawingId: r });
    return e && e.drawingType === ng.DRAWING_IMAGE ? this._injector.createInstance(v, e) : null;
  }
  getActiveImages() {
    const t = this._injector.get(E).getFocusDrawings(), e = [];
    for (const i in t) {
      const n = t[i];
      e.push(this._injector.createInstance(v, n));
    }
    return e;
  }
  updateImages(r) {
    return this._commandService.syncExecuteCommand(Wt.id, { unitId: this._fWorkbook.getId(), drawings: r }), this;
  }
  onImageInserted(r) {
    const t = this._injector.get(E);
    return We(t.add$.subscribe((e) => {
      const i = e.map(
        (n) => this._injector.createInstance(v, t.getDrawingByParam(n))
      );
      r(i);
    }));
  }
  onImageDeleted(r) {
    const t = this._injector.get(E);
    return We(t.remove$.subscribe((e) => {
      const i = e.map(
        (n) => this._injector.createInstance(v, t.getDrawingByParam(n))
      );
      r(i);
    }));
  }
  onImageChanged(r) {
    const t = this._injector.get(E);
    return We(t.update$.subscribe((e) => {
      const i = e.map(
        (n) => this._injector.createInstance(v, t.getDrawingByParam(n))
      );
      r(i);
    }));
  }
  newOverGridImage() {
    const r = this._fWorkbook.getId(), t = this.getSheetId();
    return this._injector.createInstance(F, r, t);
  }
};
S.extend(me);
var he = class extends O {
  get DrawingType() {
    return ng;
  }
  get ImageSourceType() {
    return oc;
  }
  get SheetDrawingAnchorType() {
    return Y;
  }
};
O.extend(he);
var le = class extends j {
  get BeforeFloatDomAdd() {
    return "BeforeFloatDomAdd";
  }
  get FloatDomAdded() {
    return "FloatDomAdded";
  }
  get BeforeFloatDomUpdate() {
    return "BeforeFloatDomUpdate";
  }
  get FloatDomUpdated() {
    return "FloatDomUpdated";
  }
  get BeforeFloatDomDelete() {
    return "BeforeFloatDomDelete";
  }
  get FloatDomDeleted() {
    return "FloatDomDeleted";
  }
  get BeforeOverGridImageChange() {
    return "BeforeOverGridImageChange";
  }
  get OverGridImageChanged() {
    return "OverGridImageChanged";
  }
  get BeforeOverGridImageInsert() {
    return "BeforeOverGridImageInsert";
  }
  get OverGridImageInserted() {
    return "OverGridImageInserted";
  }
  get BeforeOverGridImageRemove() {
    return "BeforeOverGridImageRemove";
  }
  get OverGridImageRemoved() {
    return "OverGridImageRemoved";
  }
  get BeforeOverGridImageSelect() {
    return "BeforeOverGridImageSelect";
  }
  get OverGridImageSelected() {
    return "OverGridImageSelected";
  }
};
j.extend(le);
var ue2 = class extends I {
  /**
   * @ignore
   */
  // eslint-disable-next-line max-lines-per-function
  _initialize(r) {
    const t = r.get(Ls);
    this.registerEventHandler(
      this.Event.BeforeFloatDomAdd,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== kt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = s.filter(
          (g2) => g2.drawingType === ng.DRAWING_DOM
        );
        if (a.length === 0)
          return;
        const d2 = {
          workbook: n,
          drawings: a
        };
        if (this.fireEvent(this.Event.BeforeFloatDomAdd, d2), d2.cancel)
          throw new KC();
      })
    ), this.registerEventHandler(
      this.Event.FloatDomAdded,
      () => t.onCommandExecuted((e) => {
        if (e.id !== kt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = s.filter(
          (d2) => d2.drawingType === ng.DRAWING_DOM
        );
        a.length !== 0 && this.fireEvent(this.Event.FloatDomAdded, {
          workbook: n,
          drawings: a
        });
      })
    ), this.registerEventHandler(
      this.Event.BeforeOverGridImageInsert,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== kt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = {
          workbook: n,
          insertImageParams: s
        };
        if (this.fireEvent(this.Event.BeforeOverGridImageInsert, a), a.cancel)
          throw new KC();
      })
    ), this.registerEventHandler(
      this.Event.BeforeOverGridImageRemove,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== rt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const s = r.get(Mt), { drawings: a } = i, d2 = a.map((c) => s.getDrawingByParam(c)), g2 = {
          workbook: n,
          images: this._createFOverGridImage(d2)
        };
        if (this.fireEvent(this.Event.BeforeOverGridImageRemove, g2), g2.cancel)
          throw new KC();
      })
    ), this.registerEventHandler(
      this.Event.BeforeOverGridImageChange,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== Wt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = r.get(Mt), d2 = [];
        s.forEach((c) => {
          const m = a.getDrawingByParam(c);
          m != null && d2.push({
            changeParam: c,
            image: this._injector.createInstance(v, m)
          });
        });
        const g2 = {
          workbook: n,
          images: d2
        };
        if (this.fireEvent(this.Event.BeforeOverGridImageChange, g2), g2.cancel)
          throw a.updateNotification(s), new KC();
      })
    ), this.registerEventHandler(
      this.Event.BeforeFloatDomUpdate,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== Wt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = r.get(Mt), d2 = [];
        if (s.forEach((c) => {
          const m = a.getDrawingByParam(c);
          (m == null ? void 0 : m.drawingType) === ng.DRAWING_DOM && d2.push(m);
        }), d2.length === 0)
          return;
        const g2 = {
          workbook: n,
          drawings: d2
        };
        if (this.fireEvent(this.Event.BeforeFloatDomUpdate, g2), g2.cancel)
          throw a.updateNotification(s), new KC();
      })
    ), this.registerEventHandler(
      this.Event.FloatDomUpdated,
      () => t.onCommandExecuted((e) => {
        if (e.id !== Wt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = r.get(Mt), d2 = [];
        s.forEach((g2) => {
          const c = a.getDrawingByParam(g2);
          (c == null ? void 0 : c.drawingType) === ng.DRAWING_DOM && d2.push(c);
        }), d2.length !== 0 && this.fireEvent(this.Event.FloatDomUpdated, {
          workbook: n,
          drawings: d2
        });
      })
    ), this.registerEventHandler(
      this.Event.BeforeFloatDomDelete,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== rt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const s = r.get(Mt), { drawings: a } = i, d2 = a.map((c) => s.getDrawingByParam(c)).filter(
          (c) => (c == null ? void 0 : c.drawingType) === ng.DRAWING_DOM
        );
        if (d2.length === 0)
          return;
        const g2 = {
          workbook: n,
          drawings: d2
        };
        if (this.fireEvent(this.Event.BeforeFloatDomDelete, g2), g2.cancel)
          throw new KC();
      })
    ), this.registerEventHandler(
      this.Event.FloatDomDeleted,
      () => t.onCommandExecuted((e) => {
        if (e.id !== rt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i;
        this.fireEvent(this.Event.FloatDomDeleted, {
          workbook: n,
          drawings: s.filter((a) => a.drawingType === ng.DRAWING_DOM).map((a) => a.drawingId)
        });
      })
    ), this.registerEventHandler(
      this.Event.BeforeOverGridImageSelect,
      () => t.beforeCommandExecuted((e) => {
        if (e.id !== Qt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null)
          return;
        const s = r.get(Mt), a = s.getFocusDrawings(), d2 = i.map((c) => s.getDrawingByParam(c)), g2 = {
          workbook: n,
          selectedImages: this._createFOverGridImage(d2),
          oldSelectedImages: this._createFOverGridImage(a)
        };
        if (this.fireEvent(this.Event.BeforeOverGridImageSelect, g2), g2.cancel)
          throw new KC();
      })
    ), this.registerEventHandler(
      this.Event.OverGridImageInserted,
      () => t.onCommandExecuted((e) => {
        if (e.id !== kt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i;
        this.fireEvent(this.Event.OverGridImageInserted, {
          workbook: n,
          images: this._createFOverGridImage(s)
        });
      })
    ), this.registerEventHandler(
      this.Event.OverGridImageRemoved,
      () => t.onCommandExecuted((e) => {
        if (e.id !== rt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i;
        this.fireEvent(this.Event.OverGridImageRemoved, {
          workbook: n,
          removeImageParams: s
        });
      })
    ), this.registerEventHandler(
      this.Event.OverGridImageChanged,
      () => t.onCommandExecuted((e) => {
        if (e.id !== Wt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null || i == null)
          return;
        const { drawings: s } = i, a = r.get(Mt), d2 = s.map((g2) => this._injector.createInstance(v, a.getDrawingByParam(g2)));
        this.fireEvent(this.Event.OverGridImageChanged, {
          workbook: n,
          images: d2
        });
      })
    ), this.registerEventHandler(
      this.Event.OverGridImageSelected,
      () => t.onCommandExecuted((e) => {
        if (e.id !== Qt.id) return;
        const i = e.params, n = this.getActiveWorkbook();
        if (n == null)
          return;
        const s = r.get(Mt), a = i.map((d2) => s.getDrawingByParam(d2));
        this.fireEvent(this.Event.OverGridImageSelected, {
          workbook: n,
          selectedImages: this._createFOverGridImage(a)
        });
      })
    );
  }
  _createFOverGridImage(r) {
    return r.map((t) => this._injector.createInstance(v, t));
  }
};
I.extend(ue2);
var fe = class extends k {
  async insertCellImageAsync(r) {
    var n;
    const t = this._injector.get(ME), e = (n = IE(we.UNIVER_SHEET, this._injector.get(vr), t)) == null ? void 0 : n.with(et2);
    if (!e)
      return false;
    const i = {
      unitId: this._workbook.getUnitId(),
      subUnitId: this._worksheet.getSheetId(),
      row: this.getRow(),
      col: this.getColumn()
    };
    return typeof r == "string" ? e.insertCellImageByUrl(r, i) : e.insertCellImageByFile(r, i);
  }
};
k.extend(fe);

// node_modules/@univerjs/preset-sheets-drawing/lib/es/index.js
function U(r = {}) {
  const { collaboration: o = false } = r;
  return {
    plugins: [
      [At, { override: o ? [[El, null]] : [] }],
      h2,
      nt,
      f,
      Pt
    ].filter((i) => !!i)
  };
}
export {
  Pe as AutoImageCropOperation,
  Xt as COMPONENT_IMAGE_POPUP_MENU,
  Y2 as ClearSheetDrawingTransformerOperation,
  oe as CloseImageCropOperation,
  w as DOCS_DRAWING_PLUGIN,
  Zt as DRAWING_IMAGE_ALLOW_IMAGE_LIST,
  Yt as DRAWING_IMAGE_ALLOW_SIZE,
  mn as DRAWING_IMAGE_COUNT_LIMIT,
  vn as DRAWING_IMAGE_HEIGHT_LIMIT,
  _n as DRAWING_IMAGE_WIDTH_LIMIT,
  hr as DeleteDrawingsCommand,
  D as DocDrawingController,
  d as DocDrawingService,
  h as DrawingApplyType,
  Ar as DrawingCommonPanel,
  un as DrawingManagerService,
  Ue as DrawingRenderService,
  _r as EditSheetDrawingOperation,
  gr as GroupSheetDrawingCommand,
  l as IDocDrawingService,
  Mt as IDrawingManagerService,
  El as IImageIoService,
  E as ISheetDrawingService,
  Ie as ImageCropperObject,
  cn as ImageIoService,
  lr as ImagePopupMenu,
  ut as ImageResetSizeOperation,
  oc as ImageSourceType,
  pE as ImageUploadStatusType,
  Bt as InsertFloatImageCommand,
  kt as InsertSheetDrawingCommand,
  it as MoveDrawingsCommand,
  Ze as OpenImageCropOperation,
  rt as RemoveSheetDrawingCommand,
  Cr as SHEETS_IMAGE_MENU_ID,
  R as SHEET_DRAWING_PLUGIN,
  ze as SetDrawingAlignOperation,
  g as SetDrawingApplyMutation,
  fr as SetDrawingArrangeCommand,
  Qt as SetDrawingSelectedOperation,
  Wt as SetSheetDrawingCommand,
  tt as SheetCanvasFloatDomManagerService,
  Y as SheetDrawingAnchorType,
  et2 as SheetDrawingUpdateController,
  wr as SidebarSheetDrawingOperation,
  mr as UngroupSheetDrawingCommand,
  ln as UnitDrawingService,
  h2 as UniverDocsDrawingPlugin,
  At as UniverDrawingPlugin,
  nt as UniverDrawingUIPlugin,
  f as UniverSheetsDrawingPlugin,
  U as UniverSheetsDrawingPreset,
  Pt as UniverSheetsDrawingUIPlugin,
  ge as calcSheetFloatDomPosition,
  z as drawingPositionToTransform,
  On as getDrawingShapeKeyByDrawingSearch,
  wn as getImageSize,
  Le as getUpdateParams,
  $ as transformToDrawingPosition
};
//# sourceMappingURL=@univerjs_presets_preset-sheets-drawing.js.map
