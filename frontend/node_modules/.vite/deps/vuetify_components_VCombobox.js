import "./chunk-4MMPKXON.js";
import {
  highlightResult,
  makeFilterProps,
  useFilter
} from "./chunk-JXHJYB55.js";
import {
  VVirtualScroll,
  makeSelectProps,
  useMenuActivator,
  useScrolling
} from "./chunk-FA4IE6UW.js";
import {
  VMenu
} from "./chunk-Y5TLA7LN.js";
import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-O7QG2S7O.js";
import "./chunk-VLRVMSDS.js";
import "./chunk-4XKTRSD7.js";
import {
  VCheckboxBtn
} from "./chunk-2M45YEXH.js";
import "./chunk-N5UHBXZ6.js";
import "./chunk-DYPZJBFB.js";
import "./chunk-HVB34AZK.js";
import "./chunk-YDOBNVWP.js";
import "./chunk-YN4CGNQ5.js";
import "./chunk-URPVGWNG.js";
import {
  useForm
} from "./chunk-7IL725KB.js";
import {
  forwardRefs
} from "./chunk-BKGZARYA.js";
import {
  VChip
} from "./chunk-TUA53F2O.js";
import "./chunk-4E7MMBTK.js";
import "./chunk-5AIYZ25Z.js";
import {
  VList,
  VListItem,
  VListSubheader,
  transformItem,
  useItems
} from "./chunk-3S3VE6NV.js";
import {
  VDivider
} from "./chunk-6L5XLM4V.js";
import {
  VAvatar
} from "./chunk-Y2TSEWX6.js";
import "./chunk-Y6FFL6LN.js";
import "./chunk-PV4ZLWPG.js";
import "./chunk-6TKGL5IO.js";
import "./chunk-BGINYFWM.js";
import "./chunk-KPABAAM5.js";
import "./chunk-PEPVDRUN.js";
import "./chunk-7AXLJKI7.js";
import "./chunk-HQK4BL6Y.js";
import "./chunk-ZQ4J3RFK.js";
import "./chunk-WB2LNXEG.js";
import "./chunk-ZKLQZVB7.js";
import "./chunk-PXGSME6P.js";
import "./chunk-RVCRK5AG.js";
import "./chunk-KGGQ65FV.js";
import {
  VIcon
} from "./chunk-7Q4PSEDZ.js";
import "./chunk-RPM4DENV.js";
import "./chunk-GSWLJLRT.js";
import {
  VDefaultsProvider
} from "./chunk-HYXYAQDT.js";
import "./chunk-KLG2CH6W.js";
import {
  useLocale
} from "./chunk-Y3T46EWX.js";
import "./chunk-XP2TMJTT.js";
import {
  useProxiedModel
} from "./chunk-3YSEF5IH.js";
import "./chunk-4NA2HYHA.js";
import "./chunk-ERLWZXKH.js";
import "./chunk-H4MDRP7U.js";
import "./chunk-XCTWR5SS.js";
import "./chunk-BMDM27ON.js";
import "./chunk-PJCOVXSO.js";
import {
  useTextColor
} from "./chunk-ISKBOFKL.js";
import "./chunk-3KASG3Y6.js";
import "./chunk-N3JVBOMY.js";
import {
  IN_BROWSER,
  checkPrintable,
  deepEqual,
  ensureValidVNode,
  escapeForRegex,
  genericComponent,
  isComposingIgnoreKey,
  noop,
  omit,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-C5YFB3CC.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createTextVNode,
  createVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  ref,
  shallowRef,
  watch
} from "./chunk-3AID4HRN.js";
import "./chunk-DC5AMYBS.js";

// node_modules/vuetify/lib/components/VCombobox/VCombobox.js
import "/Users/zhangkai/IdeaProjects/npe_get_jobs/frontend/node_modules/vuetify/lib/components/VCombobox/VCombobox.css";
var makeVComboboxProps = propsFactory({
  alwaysFilter: Boolean,
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: true
  },
  delimiters: Array,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeSelectProps({
    hideNoData: true,
    returnObject: true
  }),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])
}, "VCombobox");
var VCombobox = genericComponent()({
  name: "VCombobox",
  props: makeVComboboxProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (value) => true,
    "update:search": (value) => true,
    "update:menu": (value) => true
  },
  setup(props, _ref) {
    var _a;
    let {
      emit,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = shallowRef(false);
    const isPristine = shallowRef(true);
    const listHasFocus = shallowRef(false);
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const selectionIndex = shallowRef(-1);
    let cleared = false;
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(() => {
      var _a2;
      return (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.color;
    });
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm(props);
    const hasChips = computed(() => !!(props.chips || slots.chip));
    const hasSelectionSlot = computed(() => hasChips.value || !!slots.selection);
    const _search = shallowRef(!props.multiple && !hasSelectionSlot.value ? ((_a = model.value[0]) == null ? void 0 : _a.title) ?? "" : "");
    const _searchLock = shallowRef(null);
    const search = computed({
      get: () => {
        return _search.value;
      },
      set: async (val) => {
        var _a2;
        _search.value = val ?? "";
        if (val === null || val === "" && !props.multiple && !hasSelectionSlot.value) {
          model.value = [];
        } else if (!props.multiple && !hasSelectionSlot.value) {
          model.value = [transformItem(props, val)];
          nextTick(() => {
            var _a3;
            return (_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(0);
          });
        }
        if (val && props.multiple && ((_a2 = props.delimiters) == null ? void 0 : _a2.length)) {
          const signsToMatch = props.delimiters.map(escapeForRegex).join("|");
          const values = val.split(new RegExp(`(?:${signsToMatch})+`));
          if (values.length > 1) {
            for (let v of values) {
              v = v.trim();
              if (v) {
                select(transformItem(props, v));
                await nextTick();
              }
            }
            _search.value = "";
          }
        }
        if (!val) selectionIndex.value = -1;
        isPristine.value = !val;
      }
    });
    const counterValue = computed(() => {
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : props.multiple ? model.value.length : search.value.length;
    });
    const {
      filteredItems,
      getMatches
    } = useFilter(props, items, () => _searchLock.value ?? (props.alwaysFilter || !isPristine.value ? search.value : ""));
    const displayItems = computed(() => {
      if (props.hideSelected && _searchLock.value === null) {
        return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || form.isReadonly.value || form.isDisabled.value);
    const _menu = useProxiedModel(props, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        var _a2;
        if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.Î¨openChildren.size)) return;
        if (v && menuDisabled.value) return;
        _menu.value = v;
      }
    });
    const {
      menuId,
      ariaExpanded,
      ariaControls,
      ariaLabel
    } = useMenuActivator(props, menu);
    watch(_search, (value) => {
      if (cleared) {
        nextTick(() => cleared = false);
      } else if (isFocused.value && !menu.value) {
        menu.value = true;
      }
      emit("update:search", value);
    });
    watch(model, (value) => {
      var _a2;
      if (!props.multiple && !hasSelectionSlot.value) {
        _search.value = ((_a2 = value[0]) == null ? void 0 : _a2.title) ?? "";
      }
    });
    const selectedValues = computed(() => model.value.map((selection) => selection.value));
    const highlightFirst = computed(() => {
      var _a2;
      const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a2 = displayItems.value[0]) == null ? void 0 : _a2.title);
      return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
    });
    const listRef = ref();
    const listEvents = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      cleared = true;
      nextTick(() => cleared = false);
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (menuDisabled.value) return;
      menu.value = true;
    }
    function onMousedownMenuIcon(e) {
      if (menuDisabled.value) return;
      if (isFocused.value) {
        e.preventDefault();
        e.stopPropagation();
      }
      menu.value = !menu.value;
    }
    function onListKeydown(e) {
      var _a2;
      if (checkPrintable(e) || e.key === "Backspace") {
        (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
      }
    }
    function onKeydown(e) {
      var _a2, _b, _c, _d;
      if (isComposingIgnoreKey(e) || form.isReadonly.value) return;
      const selectionStart = (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.selectionStart;
      const length = model.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some((_ref2) => {
        let {
          value
        } = _ref2;
        return value === displayItems.value[0].value;
      })) {
        select(filteredItems.value[0]);
      }
      if (e.key === "ArrowDown" && highlightFirst.value) {
        (_b = listRef.value) == null ? void 0 : _b.focus("next");
      }
      if (e.key === "Enter" && search.value) {
        select(transformItem(props, search.value), true, true);
        if (hasSelectionSlot.value) _search.value = "";
      }
      if (["Backspace", "Delete"].includes(e.key)) {
        if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value) return select(model.value[0], false);
        if (~selectionIndex.value) {
          e.preventDefault();
          const originalSelectionIndex = selectionIndex.value;
          select(model.value[selectionIndex.value], false);
          selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
        } else if (e.key === "Backspace" && !search.value) {
          selectionIndex.value = length - 1;
        }
        return;
      }
      if (!props.multiple) return;
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart && selectionStart > 0) return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (model.value[prev]) {
          selectionIndex.value = prev;
        } else {
          selectionIndex.value = -1;
          (_c = vTextFieldRef.value) == null ? void 0 : _c.setSelectionRange(search.value.length, search.value.length);
        }
      } else if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0) return;
        const next = selectionIndex.value + 1;
        if (model.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          (_d = vTextFieldRef.value) == null ? void 0 : _d.setSelectionRange(0, 0);
        }
      } else if (~selectionIndex.value && checkPrintable(e)) {
        selectionIndex.value = -1;
      }
    }
    function onAfterEnter() {
      var _a2;
      if (props.eager) {
        (_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.calculateVisibleItems();
      }
    }
    function onAfterLeave() {
      var _a2;
      if (isFocused.value) {
        (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
      }
      isPristine.value = true;
      _searchLock.value = null;
    }
    function select(item) {
      let set = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      let keepMenu = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (!item || item.props.disabled) return;
      if (props.multiple) {
        const index = model.value.findIndex((selection) => (props.valueComparator || deepEqual)(selection.value, item.value));
        const add = set == null ? !~index : set;
        if (~index) {
          const value = add ? [...model.value, item] : [...model.value];
          value.splice(index, 1);
          model.value = value;
        } else if (add) {
          model.value = [...model.value, item];
        }
        if (props.clearOnSelect) {
          search.value = "";
        }
      } else {
        const add = set !== false;
        model.value = add ? [item] : [];
        if ((!isPristine.value || props.alwaysFilter) && _search.value) {
          _searchLock.value = _search.value;
        }
        _search.value = add && !hasSelectionSlot.value ? item.title : "";
        nextTick(() => {
          menu.value = keepMenu;
          isPristine.value = true;
        });
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
      setTimeout(() => {
        listHasFocus.value = true;
      });
    }
    function onFocusout(e) {
      listHasFocus.value = false;
    }
    watch(isFocused, (val, oldVal) => {
      if (val || val === oldVal) return;
      selectionIndex.value = -1;
      menu.value = false;
      if (search.value) {
        if (props.multiple) {
          select(transformItem(props, search.value));
          return;
        }
        if (!hasSelectionSlot.value) return;
        if (model.value.some((_ref3) => {
          let {
            title
          } = _ref3;
          return title === search.value;
        })) {
          _search.value = "";
        } else {
          select(transformItem(props, search.value));
        }
      }
    });
    watch(menu, (val) => {
      if (!props.hideSelected && val && model.value.length && isPristine.value) {
        const index = displayItems.value.findIndex((item) => model.value.some((s) => (props.valueComparator || deepEqual)(s.value, item.value)));
        IN_BROWSER && window.requestAnimationFrame(() => {
          var _a2;
          index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
        });
      }
      if (val) _searchLock.value = null;
    });
    watch(items, (newVal, oldVal) => {
      if (menu.value) return;
      if (isFocused.value && !oldVal.length && newVal.length) {
        menu.value = true;
      }
    });
    useRender(() => {
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const textFieldProps = VTextField.filterProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": ($event) => search.value = $event,
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": counterValue.value,
        "dirty": isDirty,
        "class": ["v-combobox", {
          "v-combobox--active-menu": menu.value,
          "v-combobox--chips": !!props.chips,
          "v-combobox--selection-slot": !!hasSelectionSlot.value,
          "v-combobox--selecting-index": selectionIndex.value > -1,
          [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
        }, props.class],
        "style": props.style,
        "readonly": form.isReadonly.value,
        "placeholder": isDirty ? void 0 : props.placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onKeydown": onKeydown,
        "aria-expanded": ariaExpanded.value,
        "aria-controls": ariaControls.value
      }), {
        ...slots,
        default: () => createBaseVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "id": menuId.value,
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-combobox__content",
          "disabled": menuDisabled.value,
          "eager": props.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "onAfterEnter": onAfterEnter,
          "onAfterLeave": onAfterLeave
        }, props.menuProps), {
          default: () => [hasList && createVNode(VList, mergeProps({
            "ref": listRef,
            "filterable": true,
            "selected": selectedValues.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "selectable": true,
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "tabindex": "-1",
            "aria-live": "polite",
            "color": props.itemColor ?? props.color
          }, listEvents, props.listProps), {
            default: () => {
              var _a2, _b, _c;
              return [(_a2 = slots["prepend-item"]) == null ? void 0 : _a2.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                "key": "no-data",
                "title": t(props.noDataText)
              }, null)), createVNode(VVirtualScroll, {
                "ref": vVirtualScrollRef,
                "renderless": true,
                "items": displayItems.value,
                "itemKey": "value"
              }, {
                default: (_ref4) => {
                  var _a3, _b2, _c2;
                  let {
                    item,
                    index,
                    itemRef
                  } = _ref4;
                  const itemProps = mergeProps(item.props, {
                    ref: itemRef,
                    key: item.value,
                    active: highlightFirst.value && index === 0 ? true : void 0,
                    onClick: () => select(item, null)
                  });
                  if (item.type === "divider") {
                    return ((_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
                      props: item.raw,
                      index
                    })) ?? createVNode(VDivider, mergeProps(item.props, {
                      "key": `divider-${index}`
                    }), null);
                  }
                  if (item.type === "subheader") {
                    return ((_b2 = slots.subheader) == null ? void 0 : _b2.call(slots, {
                      props: item.raw,
                      index
                    })) ?? createVNode(VListSubheader, mergeProps(item.props, {
                      "key": `subheader-${index}`
                    }), null);
                  }
                  return ((_c2 = slots.item) == null ? void 0 : _c2.call(slots, {
                    item,
                    index,
                    props: itemProps
                  })) ?? createVNode(VListItem, mergeProps(itemProps, {
                    "role": "option"
                  }), {
                    prepend: (_ref5) => {
                      let {
                        isSelected
                      } = _ref5;
                      return createBaseVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                        "key": item.value,
                        "modelValue": isSelected,
                        "ripple": false,
                        "tabindex": "-1",
                        "onClick": (event) => event.preventDefault()
                      }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                        "image": item.props.prependAvatar
                      }, null), item.props.prependIcon && createVNode(VIcon, {
                        "icon": item.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var _a4;
                      return isPristine.value ? item.title : highlightResult("v-combobox", item.title, (_a4 = getMatches(item)) == null ? void 0 : _a4.title);
                    }
                  });
                }
              }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
            }
          })]
        }), model.value.map((item, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item, false);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onKeydown(e) {
              if (e.key !== "Enter" && e.key !== " ") return;
              e.preventDefault();
              e.stopPropagation();
              onChipClose(e);
            },
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
          const slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
            item,
            index,
            props: slotProps
          }) : slots.selection({
            item,
            index
          })) : void 0;
          if (hasSlot && !slotContent) return void 0;
          return createBaseVNode("div", {
            "key": item.value,
            "class": normalizeClass(["v-combobox__selection", index === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]]),
            "style": normalizeStyle(index === selectionIndex.value ? textColorStyles.value : {})
          }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => [slotContent]
          }) : slotContent ?? createBaseVNode("span", {
            "class": "v-combobox__selection-text"
          }, [item.title, props.multiple && index < model.value.length - 1 && createBaseVNode("span", {
            "class": "v-combobox__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          var _a2, _b;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createBaseVNode(Fragment, null, [(_a2 = slots["append-inner"]) == null ? void 0 : _a2.call(slots, ...args), (!props.hideNoData || props.items.length) && props.menuIcon ? createVNode(VIcon, {
            "class": "v-combobox__menu-icon",
            "color": (_b = vTextFieldRef.value) == null ? void 0 : _b.fieldIconColor,
            "icon": props.menuIcon,
            "onMousedown": onMousedownMenuIcon,
            "onClick": noop,
            "aria-label": ariaLabel.value,
            "title": ariaLabel.value,
            "tabindex": "-1"
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      selectionIndex,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});
export {
  VCombobox
};
//# sourceMappingURL=vuetify_components_VCombobox.js.map
