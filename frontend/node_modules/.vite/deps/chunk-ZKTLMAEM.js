import {
  C,
  F,
  G as G2,
  N,
  Q,
  S,
  Ue,
  h,
  j,
  p,
  v
} from "./chunk-VAEXAE3K.js";
import {
  je,
  xt as xt2
} from "./chunk-RWMUFXJB.js";
import {
  $e,
  Ae,
  Co,
  Cr,
  Dr,
  G,
  Ht2 as Ht,
  P,
  Ws2 as Ws,
  X3 as X,
  Xs2 as Xs,
  ee2 as ee,
  ga2 as ga,
  ls,
  or,
  qr,
  so,
  xt,
  z
} from "./chunk-I7I3GTAS.js";
import {
  $R,
  AC,
  Bn,
  C1,
  Di,
  En,
  GR,
  Gg,
  Inject,
  Injector,
  J,
  Ls,
  Ms,
  NC,
  Ol,
  Or,
  Qo,
  Subject,
  TC,
  Ve,
  We,
  Wn,
  Wp,
  bufferWhen,
  eC,
  eR,
  et,
  filter,
  fn,
  fo,
  h1,
  ic,
  ke,
  n1,
  oo,
  pt,
  qR,
  tn,
  vr,
  we,
  yC
} from "./chunk-RGZYGL3P.js";

// node_modules/@univerjs/sheets-data-validation/lib/es/index.js
var St = Object.defineProperty;
var Et = (o, a, e) => a in o ? St(o, a, { enumerable: true, configurable: true, writable: true, value: e }) : o[a] = e;
var m = (o, a, e) => Et(o, typeof a != "symbol" ? a + "" : a, e);
var Kt = Object.getOwnPropertyDescriptor;
var zt = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Kt(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var He = (o, a) => (e, t) => a(e, t, o);
var Q2 = class extends Ve {
  constructor(a, e, t) {
    super();
    m(this, "_cacheMatrix", /* @__PURE__ */ new Map());
    m(this, "_dirtyRanges$", new Subject());
    m(this, "dirtyRanges$", this._dirtyRanges$.asObservable());
    this._commandService = a, this._univerInstanceService = e, this._sheetDataValidationModel = t, this._initDirtyRanges(), this._initSheetRemove();
  }
  _initDirtyRanges() {
    this.disposeWithMe(this._commandService.onCommandExecuted((a) => {
      if (a.id === ee.id) {
        const { cellValue: e, unitId: t, subUnitId: r } = a.params;
        if (e) {
          const i = new pt(e).getDataRange();
          if (i.endRow === -1) return;
          const l = this._sheetDataValidationModel.getRules(t, r).map((u) => u.ranges).flat().map((u) => Wp(u, i)).filter(Boolean);
          l.length && this.markRangeDirty(t, r, l, true);
        }
      }
    }));
  }
  _initSheetRemove() {
    this.disposeWithMe(this._commandService.onCommandExecuted((a) => {
      var e;
      if (a.id === Ht.id) {
        const { unitId: t, subUnitId: r } = a.params;
        (e = this._cacheMatrix.get(t)) == null || e.delete(r);
      }
    })), this.disposeWithMe(this._univerInstanceService.unitDisposed$.subscribe((a) => {
      a.type === we.UNIVER_SHEET && this._cacheMatrix.delete(a.getUnitId());
    }));
  }
  _ensureCache(a, e) {
    let t = this._cacheMatrix.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._cacheMatrix.set(a, t));
    let r = t.get(e);
    return r || (r = new pt(), t.set(e, r)), r;
  }
  ensureCache(a, e) {
    return this._ensureCache(a, e);
  }
  addRule(a, e, t) {
    this.markRangeDirty(a, e, t.ranges);
  }
  removeRule(a, e, t) {
    this._deleteRange(a, e, t.ranges);
  }
  markRangeDirty(a, e, t, r) {
    const i = this._ensureCache(a, e);
    t.forEach((s) => {
      Or.foreach(s, (n, l) => {
        i.getValue(n, l) !== void 0 && i.setValue(n, l, void 0);
      });
    }), this._dirtyRanges$.next({ unitId: a, subUnitId: e, ranges: t, isSetRange: r });
  }
  _deleteRange(a, e, t) {
    const r = this._ensureCache(a, e);
    t.forEach((i) => {
      Or.foreach(i, (s, n) => {
        r.realDeleteValue(s, n);
      });
    }), this._dirtyRanges$.next({ unitId: a, subUnitId: e, ranges: t });
  }
  getValue(a, e, t, r) {
    return this._ensureCache(a, e).getValue(t, r);
  }
};
Q2 = zt([
  He(0, Inject(Ls)),
  He(1, Inject(vr)),
  He(2, Inject(h))
], Q2);
function oe(o) {
  var a, e;
  return (e = (a = o == null ? void 0 : o[0]) == null ? void 0 : a[0]) == null ? void 0 : e.v;
}
function pe(o) {
  var a;
  return (a = o == null ? void 0 : o[0]) == null ? void 0 : a[0];
}
function C2(o) {
  return !or.has(o);
}
function de(o, a) {
  var t;
  const e = a.getValidatorItem(o);
  return (t = e == null ? void 0 : e.offsetFormulaByRange) != null ? t : false;
}
var Zt = Object.getOwnPropertyDescriptor;
var Jt = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Zt(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var re = (o, a) => (e, t) => a(e, t, o);
var H = class extends Ve {
  constructor(a, e, t, r, i) {
    super();
    m(this, "_ruleFormulaMap", /* @__PURE__ */ new Map());
    m(this, "_ruleFormulaMap2", /* @__PURE__ */ new Map());
    this._instanceSrv = a, this._registerOtherFormulaService = e, this._dataValidationModel = t, this._dataValidationCacheService = r, this._validatorRegistryService = i, this._initFormulaResultHandler(), this._initDirtyRanges();
  }
  dispose() {
    super.dispose(), this._ruleFormulaMap.clear(), this._ruleFormulaMap2.clear();
  }
  _initFormulaResultHandler() {
    this.disposeWithMe(this._registerOtherFormulaService.formulaResult$.subscribe((a) => {
      for (const e in a) {
        const t = a[e];
        if (this._instanceSrv.getUnitType(e) === we.UNIVER_SHEET)
          for (const i in t) {
            const s = t[i], { ruleFormulaMap: n } = this._ensureMaps(e, i);
            s.forEach((l) => {
              var c, g;
              const u = n.get((c = l.extra) == null ? void 0 : c.ruleId), d = this._dataValidationModel.getRuleById(e, i, (g = l.extra) == null ? void 0 : g.ruleId);
              d && u && this._dataValidationCacheService.markRangeDirty(e, i, d.ranges);
            });
          }
      }
    }));
  }
  _ensureMaps(a, e) {
    let t = this._ruleFormulaMap.get(a), r = this._ruleFormulaMap2.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._ruleFormulaMap.set(a, t)), r || (r = /* @__PURE__ */ new Map(), this._ruleFormulaMap2.set(a, r));
    let i = t.get(e);
    i || (i = /* @__PURE__ */ new Map(), t.set(e, i));
    let s = r.get(e);
    return s || (s = /* @__PURE__ */ new Map(), r.set(e, s)), { ruleFormulaMap: i, ruleFormulaMap2: s };
  }
  _registerFormula(a, e, t, r, i) {
    return this._registerOtherFormulaService.registerFormulaWithRange(a, e, r, i, { ruleId: t });
  }
  _handleDirtyRanges(a, e, t) {
    this._dataValidationModel.getRules(a, e).forEach((i) => {
      const s = i.ranges;
      En.doAnyRangesIntersect(s, t) && this.makeRuleDirty(a, e, i.uid);
    });
  }
  _initDirtyRanges() {
    this.disposeWithMe(this._dataValidationCacheService.dirtyRanges$.subscribe((a) => {
      a.isSetRange && this._handleDirtyRanges(a.unitId, a.subUnitId, a.ranges);
    }));
  }
  deleteByRuleId(a, e, t) {
    const { ruleFormulaMap: r, ruleFormulaMap2: i } = this._ensureMaps(a, e), s = this._dataValidationModel.getRuleById(a, e, t), n = r.get(t);
    if (!s || !n)
      return;
    const l = r.get(t);
    l && (r.delete(t), this._registerOtherFormulaService.deleteFormula(a, e, [l.formulaId]));
    const u = i.get(t);
    u && (i.delete(t), this._registerOtherFormulaService.deleteFormula(a, e, [u.formulaId]));
  }
  _addFormulaByRange(a, e, t, r, i, s) {
    const { ruleFormulaMap: n, ruleFormulaMap2: l } = this._ensureMaps(a, e), u = s[0].startRow, d = s[0].startColumn;
    if (r && Gg(r)) {
      const c = this._registerFormula(a, e, t, r, s);
      n.set(t, {
        formula: r,
        originCol: d,
        originRow: u,
        formulaId: c
      });
    }
    if (i && Gg(i)) {
      const c = this._registerFormula(a, e, t, i, s);
      l.set(t, {
        formula: i,
        originCol: d,
        originRow: u,
        formulaId: c
      });
    }
  }
  addRule(a, e, t) {
    if (de(t.type, this._validatorRegistryService)) {
      const { ranges: r, formula1: i, formula2: s, uid: n } = t;
      this._addFormulaByRange(a, e, n, i, s, r);
    }
  }
  async getCellFormulaValue(a, e, t, r, i) {
    var f, p2;
    const { ruleFormulaMap: s } = this._ensureMaps(a, e), n = s.get(t);
    if (!n)
      return Promise.resolve(void 0);
    const l = await this._registerOtherFormulaService.getFormulaValue(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return pe((p2 = (f = l == null ? void 0 : l.result) == null ? void 0 : f[c]) == null ? void 0 : p2[g]);
  }
  async getCellFormula2Value(a, e, t, r, i) {
    var f, p2;
    const { ruleFormulaMap2: s } = this._ensureMaps(a, e), n = s.get(t);
    if (!n)
      return Promise.resolve(void 0);
    const l = await this._registerOtherFormulaService.getFormulaValue(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return pe((p2 = (f = l == null ? void 0 : l.result) == null ? void 0 : f[c]) == null ? void 0 : p2[g]);
  }
  getCellFormulaValueSync(a, e, t, r, i) {
    var f, p2;
    const { ruleFormulaMap: s } = this._ensureMaps(a, e), n = s.get(t);
    if (!n)
      return;
    const l = this._registerOtherFormulaService.getFormulaValueSync(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return pe((p2 = (f = l == null ? void 0 : l.result) == null ? void 0 : f[c]) == null ? void 0 : p2[g]);
  }
  getCellFormula2ValueSync(a, e, t, r, i) {
    var f, p2;
    const { ruleFormulaMap2: s } = this._ensureMaps(a, e), n = s.get(t);
    if (!n)
      return;
    const l = this._registerOtherFormulaService.getFormulaValueSync(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return pe((p2 = (f = l == null ? void 0 : l.result) == null ? void 0 : f[c]) == null ? void 0 : p2[g]);
  }
  getRuleFormulaInfo(a, e, t) {
    const { ruleFormulaMap: r } = this._ensureMaps(a, e);
    return r.get(t);
  }
  makeRuleDirty(a, e, t) {
    var s, n, l, u;
    const r = (n = (s = this._ruleFormulaMap.get(a)) == null ? void 0 : s.get(e)) == null ? void 0 : n.get(t), i = (u = (l = this._ruleFormulaMap2.get(a)) == null ? void 0 : l.get(e)) == null ? void 0 : u.get(t);
    r && this._registerOtherFormulaService.markFormulaDirty(a, e, r.formulaId), i && this._registerOtherFormulaService.markFormulaDirty(a, e, i.formulaId);
  }
};
H = Jt([
  re(0, vr),
  re(1, Inject(je)),
  re(2, Inject(h)),
  re(3, Inject(Q2)),
  re(4, Inject(F))
], H);
var ea = Object.getOwnPropertyDescriptor;
var ta = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ea(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var ie = (o, a) => (e, t) => a(e, t, o);
var K = class extends Ve {
  constructor(a, e, t, r, i) {
    super();
    m(this, "_formulaRuleMap", /* @__PURE__ */ new Map());
    this._instanceService = a, this._registerOtherFormulaService = e, this._dataValidationCacheService = t, this._dataValidationModel = r, this._validatorRegistryService = i, this._initFormulaResultHandler();
  }
  _initFormulaResultHandler() {
    this.disposeWithMe(this._registerOtherFormulaService.formulaResult$.subscribe((a) => {
      for (const e in a) {
        const t = a[e];
        if (this._instanceService.getUnitType(e) === we.UNIVER_SHEET)
          for (const i in t) {
            const s = t[i], n = this._ensureRuleFormulaMap(e, i);
            s.forEach((l) => {
              var u, d;
              if (n.get((u = l.extra) == null ? void 0 : u.ruleId)) {
                const c = this._dataValidationModel.getRuleById(e, i, (d = l.extra) == null ? void 0 : d.ruleId);
                c && this._dataValidationCacheService.markRangeDirty(e, i, c.ranges);
              }
            });
          }
      }
    }));
  }
  _ensureRuleFormulaMap(a, e) {
    let t = this._formulaRuleMap.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._formulaRuleMap.set(a, t));
    let r = t.get(e);
    return r || (r = /* @__PURE__ */ new Map(), t.set(e, r)), r;
  }
  _registerSingleFormula(a, e, t, r) {
    const i = [{ startColumn: 0, endColumn: 0, startRow: 0, endRow: 0 }];
    return this._registerOtherFormulaService.registerFormulaWithRange(a, e, t, i, { ruleId: r });
  }
  addRule(a, e, t) {
    if (!de(t.type, this._validatorRegistryService) && t.type !== TC.CHECKBOX) {
      const { formula1: r, formula2: i, uid: s } = t, n = Gg(r), l = Gg(i);
      if (!n && !l)
        return;
      const u = this._ensureRuleFormulaMap(a, e), d = [void 0, void 0];
      if (n) {
        const c = this._registerSingleFormula(a, e, r, s);
        d[0] = { id: c, text: r };
      }
      if (l) {
        const c = this._registerSingleFormula(a, e, i, s);
        d[1] = { id: c, text: i };
      }
      u.set(s, d);
    }
  }
  removeRule(a, e, t) {
    const i = this._ensureRuleFormulaMap(a, e).get(t);
    if (!i)
      return;
    const [s, n] = i, l = [s == null ? void 0 : s.id, n == null ? void 0 : n.id].filter(Boolean);
    l.length && this._registerOtherFormulaService.deleteFormula(a, e, l);
  }
  getRuleFormulaResult(a, e, t) {
    const i = this._ensureRuleFormulaMap(a, e).get(t);
    if (!i)
      return Promise.resolve(null);
    const s = async (n) => n && this._registerOtherFormulaService.getFormulaValue(a, e, n.id);
    return Promise.all([
      s(i[0]),
      s(i[1])
    ]);
  }
  getRuleFormulaResultSync(a, e, t) {
    const i = this._ensureRuleFormulaMap(a, e).get(t);
    if (i)
      return i.map((s) => {
        if (s)
          return this._registerOtherFormulaService.getFormulaValueSync(a, e, s.id);
      });
  }
  getRuleFormulaInfo(a, e, t) {
    return this._ensureRuleFormulaMap(a, e).get(t);
  }
};
K = ta([
  ie(0, vr),
  ie(1, Inject(je)),
  ie(2, Inject(Q2)),
  ie(3, Inject(h)),
  ie(4, Inject(F))
], K);
function ne(o) {
  return GR(o);
}
function pt2(o) {
  var a;
  return String((a = ne(o)) != null ? a : "");
}
var Ze = class _Ze {
  constructor(a, e, t, r, i = false) {
    m(this, "_map");
    m(this, "_tree", new Di());
    m(this, "_dirty", true);
    m(this, "_buildTree", () => {
      if (!this._dirty || this._disableTree)
        return;
      this._tree.clear();
      const a2 = [];
      this._map.forEach((e2, t2) => {
        e2.forEach((r2) => {
          a2.push({
            minX: r2.startRow,
            maxX: r2.endRow,
            minY: r2.startColumn,
            maxY: r2.endColumn,
            ruleId: t2
          });
        });
      }), this._tree.load(a2), this._dirty = false;
    });
    m(this, "_debonceBuildTree", n1(this._buildTree, 0));
    this._unitId = e, this._subUnitId = t, this._univerInstanceService = r, this._disableTree = i, this._map = a, this._buildTree();
  }
  get _worksheet() {
    var a;
    return (a = this._univerInstanceService.getUnit(this._unitId, we.UNIVER_SHEET)) == null ? void 0 : a.getSheetBySheetId(this._subUnitId);
  }
  _addRule(a, e) {
    if (!this._worksheet)
      return;
    const t = En.mergeRanges(e.map((r) => Or.transformRange(r, this._worksheet)));
    this._map.forEach((r, i) => {
      const s = En.subtractMulti(r, t);
      s.length === 0 ? this._map.delete(i) : this._map.set(i, s);
    }), this._dirty = true, this._map.set(a, t), this._debonceBuildTree();
  }
  addRule(a) {
    this._addRule(a.uid, a.ranges);
  }
  removeRange(a) {
    if (!this._worksheet)
      return;
    const e = a.map((t) => Or.transformRange(t, this._worksheet));
    this._map.forEach((t, r) => {
      const i = En.subtractMulti(t, e);
      i.length === 0 ? this._map.delete(r) : this._map.set(r, i);
    }), this._dirty = true, this._debonceBuildTree();
  }
  _removeRule(a) {
    this._map.delete(a), this._dirty = true, this._debonceBuildTree();
  }
  removeRule(a) {
    this._removeRule(a.uid);
  }
  updateRange(a, e) {
    this._removeRule(a), this._addRule(a, e);
  }
  addRangeRules(a) {
    a.forEach(({ id: e, ranges: t }) => {
      if (!t.length)
        return;
      let r = this._map.get(e);
      r ? (this._map.set(e, En.mergeRanges([...r, ...t])), r = this._map.get(e)) : (r = t, this._map.set(e, r)), this._map.forEach((i, s) => {
        if (s === e)
          return;
        const n = En.subtractMulti(i, t);
        n.length === 0 ? this._map.delete(s) : this._map.set(s, n);
      });
    }), this._dirty = true, this._debonceBuildTree();
  }
  diff(a) {
    const e = [];
    let t = 0;
    return a.forEach((r, i) => {
      var l;
      const s = (l = this._map.get(r.uid)) != null ? l : [], n = r.ranges;
      s.length !== 0 && (s.length !== n.length || s.some((u, d) => !En.equals(u, n[d]))) && e.push({
        type: "update",
        ruleId: r.uid,
        oldRanges: n,
        newRanges: En.sort(s),
        rule: r
      }), s.length === 0 && (e.push({
        type: "delete",
        rule: r,
        index: i - t
      }), t++);
    }), e;
  }
  diffWithAddition(a, e) {
    const t = [];
    let r = 0;
    return a.forEach((i, s) => {
      var u;
      const n = (u = this._map.get(i.uid)) != null ? u : [], l = i.ranges;
      n.length !== 0 && (n.length !== l.length || n.some((d, c) => !En.equals(d, l[c]))) && t.push({
        type: "update",
        ruleId: i.uid,
        oldRanges: l,
        newRanges: En.sort(n),
        rule: i
      }), n.length === 0 && (t.push({
        type: "delete",
        rule: i,
        index: s - r
      }), r++);
    }), Array.from(e).forEach((i) => {
      var n;
      const s = (n = this._map.get(i.uid)) != null ? n : [];
      t.push({
        type: "add",
        rule: {
          ...i,
          ranges: En.sort(s)
        }
      });
    }), t;
  }
  clone() {
    return new _Ze(
      new Map(J.deepClone(Array.from(this._map.entries()))),
      this._unitId,
      this._subUnitId,
      this._univerInstanceService,
      // disable tree on cloned matrix, cause there is no need to search
      true
    );
  }
  getValue(a, e) {
    this._dirty && this._buildTree();
    const t = this._tree.search({
      minX: a,
      maxX: a,
      minY: e,
      maxY: e
    });
    return t.length > 0 ? t[0].ruleId : void 0;
  }
};
var aa = Object.getOwnPropertyDescriptor;
var ra = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? aa(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var X2 = (o, a) => (e, t) => a(e, t, o);
var F2 = class extends Ve {
  constructor(a, e, t, r, i, s, n) {
    super();
    m(this, "_ruleMatrixMap", /* @__PURE__ */ new Map());
    m(this, "_validStatusChange$", new Subject());
    m(this, "_ruleChange$", new Subject());
    m(this, "ruleChange$", this._ruleChange$.asObservable());
    m(this, "validStatusChange$", this._validStatusChange$.asObservable());
    this._dataValidationModel = a, this._univerInstanceService = e, this._dataValidatorRegistryService = t, this._dataValidationCacheService = r, this._dataValidationFormulaService = i, this._dataValidationCustomFormulaService = s, this._commandService = n, this._initRuleUpdateListener(), this.disposeWithMe(() => {
      this._ruleChange$.complete(), this._validStatusChange$.complete();
    }), this._initUniverInstanceListener();
  }
  _initUniverInstanceListener() {
    this.disposeWithMe(
      this._univerInstanceService.unitDisposed$.subscribe((a) => {
        this._ruleMatrixMap.delete(a.getUnitId());
      })
    ), this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === Ht.id) {
          const { unitId: e, subUnitId: t } = a.params, r = this._ruleMatrixMap.get(e);
          r && r.delete(t);
        }
      })
    );
  }
  _initRuleUpdateListener() {
    const a = this._dataValidationModel.getAll();
    for (const [e, t] of a)
      for (const [r, i] of t)
        for (const s of i)
          this._addRule(e, r, s), this._ruleChange$.next({
            type: "add",
            unitId: e,
            subUnitId: r,
            rule: s,
            source: "patched"
          });
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((e) => {
        switch (e.type) {
          case "add":
            this._addRule(e.unitId, e.subUnitId, e.rule);
            break;
          case "update":
            this._updateRule(e.unitId, e.subUnitId, e.rule.uid, e.oldRule, e.updatePayload);
            break;
          case "remove":
            this._removeRule(e.unitId, e.subUnitId, e.rule);
            break;
        }
        this._ruleChange$.next(e);
      })
    );
  }
  _ensureRuleMatrix(a, e) {
    let t = this._ruleMatrixMap.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._ruleMatrixMap.set(a, t));
    let r = t.get(e);
    return r || (r = new Ze(/* @__PURE__ */ new Map(), a, e, this._univerInstanceService), t.set(e, r)), r;
  }
  _addRuleSideEffect(a, e, t) {
    this._ensureRuleMatrix(a, e).addRule(t), this._dataValidationCacheService.addRule(a, e, t), this._dataValidationFormulaService.addRule(a, e, t), this._dataValidationCustomFormulaService.addRule(a, e, t);
  }
  _addRule(a, e, t) {
    (Array.isArray(t) ? t : [t]).forEach((i) => {
      this._addRuleSideEffect(a, e, i);
    });
  }
  _updateRule(a, e, t, r, i) {
    const s = this._ensureRuleMatrix(a, e), n = {
      ...r,
      ...i.payload
    };
    i.type === p.RANGE ? s.updateRange(t, i.payload) : i.type === p.ALL && s.updateRange(t, i.payload.ranges), this._dataValidationCacheService.removeRule(a, e, r), this._dataValidationCacheService.addRule(a, e, n), this._dataValidationFormulaService.removeRule(a, e, r.uid), this._dataValidationFormulaService.addRule(a, e, n), this._dataValidationCustomFormulaService.deleteByRuleId(a, e, t), this._dataValidationCustomFormulaService.addRule(a, e, n);
  }
  _removeRule(a, e, t) {
    this._ensureRuleMatrix(a, e).removeRule(t), this._dataValidationCacheService.removeRule(a, e, t), this._dataValidationCustomFormulaService.deleteByRuleId(a, e, t.uid);
  }
  getValidator(a) {
    return this._dataValidatorRegistryService.getValidatorItem(a);
  }
  getRuleIdByLocation(a, e, t, r) {
    return this._ensureRuleMatrix(a, e).getValue(t, r);
  }
  getRuleByLocation(a, e, t, r) {
    const i = this.getRuleIdByLocation(a, e, t, r);
    if (i)
      return this._dataValidationModel.getRuleById(a, e, i);
  }
  validator(a, e, t) {
    const { col: r, row: i, unitId: s, subUnitId: n, worksheet: l } = e, u = (p2, R) => {
      t && t(p2, R), R && this._validStatusChange$.next({
        unitId: s,
        subUnitId: n,
        ruleId: a.uid,
        status: p2,
        row: i,
        col: r
      });
    }, d = l.getCellValueOnly(i, r), c = this.getValidator(a.type), g = l.getCellRaw(i, r), f = ne(g);
    if (c) {
      const p2 = this._dataValidationCacheService.ensureCache(s, n), R = p2.getValue(i, r);
      return R == null ? (p2.setValue(i, r, NC.VALIDATING), c.validator(
        {
          value: f,
          unitId: s,
          subUnitId: n,
          row: i,
          column: r,
          worksheet: e.worksheet,
          workbook: e.workbook,
          interceptValue: ne(d),
          t: g == null ? void 0 : g.t
        },
        a
      ).then((V) => {
        const _ = V ? NC.VALID : NC.INVALID, w = p2.getValue(i, r);
        _ === NC.VALID ? p2.realDeleteValue(i, r) : p2.setValue(i, r, _), u(_, R !== w);
      }), NC.VALIDATING) : (u(R != null ? R : NC.VALID, false), R != null ? R : NC.VALID);
    } else
      return u(NC.VALID, false), NC.VALID;
  }
  getRuleObjectMatrix(a, e) {
    return this._ensureRuleMatrix(a, e);
  }
  getRuleById(a, e, t) {
    return this._dataValidationModel.getRuleById(a, e, t);
  }
  getRuleIndex(a, e, t) {
    return this._dataValidationModel.getRuleIndex(a, e, t);
  }
  getRules(a, e) {
    return [...this._dataValidationModel.getRules(a, e)];
  }
  getUnitRules(a) {
    return this._dataValidationModel.getUnitRules(a);
  }
  deleteUnitRules(a) {
    return this._dataValidationModel.deleteUnitRules(a);
  }
  getSubUnitIds(a) {
    return this._dataValidationModel.getSubUnitIds(a);
  }
  getAll() {
    return this._dataValidationModel.getAll();
  }
};
F2 = ra([
  X2(0, Inject(h)),
  X2(1, vr),
  X2(2, Inject(F)),
  X2(3, Inject(Q2)),
  X2(4, Inject(K)),
  X2(5, Inject(H)),
  X2(6, Ls)
], F2);
var Ee = 1;
var Ve2 = 0;
function at(o, a) {
  return J.isBlank(o) ? a.t("dataValidation.validFail.value") : Gg(o) ? a.t("dataValidation.validFail.primitive") : "";
}
var fe = (o) => J.isDefine(o) && String(o).toLowerCase() === "true" ? "1" : String(o).toLowerCase() === "false" ? "0" : o;
var ia = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "id", TC.CHECKBOX);
    m(this, "title", "dataValidation.checkbox.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "order", 41);
    m(this, "offsetFormulaByRange", false);
    m(this, "_formulaService", this.injector.get(K));
    m(this, "skipDefaultFontRender", (e, t, r) => {
      const { unitId: i, subUnitId: s } = r, { formula1: n, formula2: l } = this.parseFormulaSync(e, i, s), u = `${t != null ? t : ""}`;
      return !u || u === `${n}` || u === `${l}`;
    });
  }
  validatorFormula(e, t, r) {
    const { formula1: i, formula2: s } = e, n = i === s;
    if (J.isBlank(i) && J.isBlank(s))
      return {
        success: true
      };
    if (n)
      return {
        success: false,
        formula1: this.localeService.t("dataValidation.validFail.checkboxEqual"),
        formula2: this.localeService.t("dataValidation.validFail.checkboxEqual")
      };
    const l = at(i, this.localeService), u = at(s, this.localeService);
    return {
      success: !l && !u,
      formula1: l,
      formula2: u
    };
  }
  async parseFormula(e, t, r) {
    var c, g, f, p2;
    const { formula1: i = Ee, formula2: s = Ve2 } = e, n = await this._formulaService.getRuleFormulaResult(t, r, e.uid), l = Gg(i) ? oe((g = (c = n == null ? void 0 : n[0]) == null ? void 0 : c.result) == null ? void 0 : g[0][0]) : i, u = Gg(s) ? oe((p2 = (f = n == null ? void 0 : n[1]) == null ? void 0 : f.result) == null ? void 0 : p2[0][0]) : s, d = C2(String(l)) && C2(String(u));
    return {
      formula1: fe(l),
      formula2: fe(u),
      originFormula1: l,
      originFormula2: u,
      isFormulaValid: d
    };
  }
  getExtraStyle(e, t) {
    return {
      tb: Bn.CLIP
    };
  }
  parseFormulaSync(e, t, r) {
    var c, g, f, p2;
    const { formula1: i = Ee, formula2: s = Ve2 } = e, n = this._formulaService.getRuleFormulaResultSync(t, r, e.uid), l = Gg(i) ? oe((g = (c = n == null ? void 0 : n[0]) == null ? void 0 : c.result) == null ? void 0 : g[0][0]) : i, u = Gg(s) ? oe((p2 = (f = n == null ? void 0 : n[1]) == null ? void 0 : f.result) == null ? void 0 : p2[0][0]) : s, d = C2(String(l)) && C2(String(u));
    return {
      formula1: fe(l),
      formula2: fe(u),
      originFormula1: l,
      originFormula2: u,
      isFormulaValid: d
    };
  }
  async isValidType(e, t, r) {
    const { value: i, unitId: s, subUnitId: n } = e, { formula1: l, formula2: u, originFormula1: d, originFormula2: c } = await this.parseFormula(r, s, n);
    return !J.isDefine(l) || !J.isDefine(u) ? true : J.isDefine(i) && (String(i) === String(l) || String(i) === String(u) || String(i) === String(d != null ? d : "") || String(i) === String(c != null ? c : ""));
  }
  generateRuleErrorMessage(e) {
    return this.localeService.t("dataValidation.checkbox.error");
  }
  generateRuleName(e) {
    return this.titleStr;
  }
};
var oa = {
  [AC.BETWEEN]: "dataValidation.date.operators.between",
  [AC.EQUAL]: "dataValidation.date.operators.equal",
  [AC.GREATER_THAN]: "dataValidation.date.operators.greaterThan",
  [AC.GREATER_THAN_OR_EQUAL]: "dataValidation.date.operators.greaterThanOrEqual",
  [AC.LESS_THAN]: "dataValidation.date.operators.lessThan",
  [AC.LESS_THAN_OR_EQUAL]: "dataValidation.date.operators.lessThanOrEqual",
  [AC.NOT_BETWEEN]: "dataValidation.date.operators.notBetween",
  [AC.NOT_EQUAL]: "dataValidation.date.operators.notEqual"
};
AC.BETWEEN + "", AC.EQUAL + "", AC.GREATER_THAN + "", AC.GREATER_THAN_OR_EQUAL + "", AC.LESS_THAN + "", AC.LESS_THAN_OR_EQUAL + "", AC.NOT_BETWEEN + "", AC.NOT_EQUAL + "";
var rt = {
  [AC.BETWEEN]: "dataValidation.date.ruleName.between",
  [AC.EQUAL]: "dataValidation.date.ruleName.equal",
  [AC.GREATER_THAN]: "dataValidation.date.ruleName.greaterThan",
  [AC.GREATER_THAN_OR_EQUAL]: "dataValidation.date.ruleName.greaterThanOrEqual",
  [AC.LESS_THAN]: "dataValidation.date.ruleName.lessThan",
  [AC.LESS_THAN_OR_EQUAL]: "dataValidation.date.ruleName.lessThanOrEqual",
  [AC.NOT_BETWEEN]: "dataValidation.date.ruleName.notBetween",
  [AC.NOT_EQUAL]: "dataValidation.date.ruleName.notEqual",
  NONE: "dataValidation.date.ruleName.legal"
};
var sa = {
  [AC.BETWEEN]: "dataValidation.date.errorMsg.between",
  [AC.EQUAL]: "dataValidation.date.errorMsg.equal",
  [AC.GREATER_THAN]: "dataValidation.date.errorMsg.greaterThan",
  [AC.GREATER_THAN_OR_EQUAL]: "dataValidation.date.errorMsg.greaterThanOrEqual",
  [AC.LESS_THAN]: "dataValidation.date.errorMsg.lessThan",
  [AC.LESS_THAN_OR_EQUAL]: "dataValidation.date.errorMsg.lessThanOrEqual",
  [AC.NOT_BETWEEN]: "dataValidation.date.errorMsg.notBetween",
  [AC.NOT_EQUAL]: "dataValidation.date.errorMsg.notEqual",
  NONE: "dataValidation.date.errorMsg.legal"
};
var be = [
  AC.BETWEEN,
  AC.NOT_BETWEEN
];
var le = "{FORMULA1}";
var ue = "{FORMULA2}";
function Ka(o) {
  return o.filter(Boolean).join(",");
}
function _e(o) {
  return o.split(",").filter(Boolean);
}
function za(o) {
  const a = ne(o);
  return a == null ? "" : a.toString();
}
function Le(o, a, e) {
  const { formula1: t, formula2: r } = a, i = a.ranges[0].startRow, s = a.ranges[0].startColumn, n = e.row - i, l = e.col - s, u = Gg(t) ? o.moveFormulaRefOffset(t, l, n, true) : t, d = Gg(r) ? o.moveFormulaRefOffset(r, l, n, true) : r;
  return {
    transformedFormula1: u,
    transformedFormula2: d
  };
}
var We2 = (o) => {
  var e, t;
  if (o == null || typeof o == "boolean")
    return;
  if (typeof o == "number" || !Number.isNaN(+o))
    return +o;
  const a = (e = eR.parseDate(o)) == null ? void 0 : e.v;
  return J.isDefine(a) ? a : (t = eR.parseDate(tn(o).format("YYYY-MM-DD HH:mm:ss"))) == null ? void 0 : t.v;
};
var na = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "id", TC.DATE);
    m(this, "title", "dataValidation.date.title");
    m(this, "order", 40);
    m(this, "operators", [
      AC.BETWEEN,
      AC.EQUAL,
      AC.GREATER_THAN,
      AC.GREATER_THAN_OR_EQUAL,
      AC.LESS_THAN,
      AC.LESS_THAN_OR_EQUAL,
      AC.NOT_BETWEEN,
      AC.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
    m(this, "_customFormulaService", this.injector.get(H));
    m(this, "_lexerTreeBuilder", this.injector.get(ga));
  }
  async parseFormula(e, t, r, i, s) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, s), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, s), { formula1: u, formula2: d } = e, c = C2(String(n == null ? void 0 : n.v)) && C2(String(l == null ? void 0 : l.v));
    return {
      formula1: We2(Gg(u) ? n == null ? void 0 : n.v : u),
      formula2: We2(Gg(d) ? l == null ? void 0 : l.v : d),
      isFormulaValid: c
    };
  }
  async isValidType(e) {
    const { interceptValue: t, value: r } = e;
    return typeof r == "number" && typeof t == "string" ? !!eR.parseDate(t) : typeof t == "string" ? !!eR.parseDate(t) : false;
  }
  _validatorSingleFormula(e) {
    return !J.isBlank(e) && (Gg(e) || !Number.isNaN(+e) || !!(e && eR.parseDate(e)));
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: true
      };
    const s = this._validatorSingleFormula(e.formula1), n = this.localeService.t("dataValidation.validFail.date");
    if (be.includes(i)) {
      const u = this._validatorSingleFormula(e.formula2);
      return {
        success: s && u,
        formula1: s ? void 0 : n,
        formula2: u ? void 0 : n
      };
    }
    return {
      success: s,
      formula1: s ? void 0 : n
    };
  }
  normalizeFormula(e, t, r) {
    const { formula1: i, formula2: s, bizInfo: n } = e, l = (u) => {
      var c;
      if (!u)
        return u;
      let d;
      if (!Number.isNaN(+u))
        d = eR.dateFromSerial(+u);
      else {
        const g = (c = eR.parseDate(u)) == null ? void 0 : c.v;
        if (g == null)
          return "";
        d = eR.dateFromSerial(g);
      }
      return tn(`${d[0]}/${d[1]}/${d[2]} ${d[3]}:${d[4]}:${d[5]}`).format(n != null && n.showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD");
    };
    return {
      formula1: Gg(i) ? i : l(`${i}`),
      formula2: Gg(s) ? s : l(`${s}`)
    };
  }
  transform(e, t, r) {
    const { value: i } = e;
    return {
      ...e,
      value: We2(i)
    };
  }
  get operatorNames() {
    return this.operators.map((e) => this.localeService.t(oa[e]));
  }
  generateRuleName(e) {
    var r, i;
    if (!e.operator)
      return this.localeService.t(rt.NONE);
    const t = this.localeService.t(rt[e.operator]).replace(le, (r = e.formula1) != null ? r : "").replace(ue, (i = e.formula2) != null ? i : "");
    return `${this.titleStr} ${t}`;
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.titleStr;
    const { transformedFormula1: r, transformedFormula2: i } = Le(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(sa[e.operator]).replace(le, r != null ? r : "").replace(ue, i != null ? i : "")}`;
  }
};
AC.BETWEEN + "", AC.EQUAL + "", AC.GREATER_THAN + "", AC.GREATER_THAN_OR_EQUAL + "", AC.LESS_THAN + "", AC.LESS_THAN_OR_EQUAL + "", AC.NOT_BETWEEN + "", AC.NOT_EQUAL + "";
AC.BETWEEN + "", AC.EQUAL + "", AC.GREATER_THAN + "", AC.GREATER_THAN_OR_EQUAL + "", AC.LESS_THAN + "", AC.LESS_THAN_OR_EQUAL + "", AC.NOT_BETWEEN + "", AC.NOT_EQUAL + "";
var Me = {
  [AC.BETWEEN]: "dataValidation.errorMsg.between",
  [AC.EQUAL]: "dataValidation.errorMsg.equal",
  [AC.GREATER_THAN]: "dataValidation.errorMsg.greaterThan",
  [AC.GREATER_THAN_OR_EQUAL]: "dataValidation.errorMsg.greaterThanOrEqual",
  [AC.LESS_THAN]: "dataValidation.errorMsg.lessThan",
  [AC.LESS_THAN_OR_EQUAL]: "dataValidation.errorMsg.lessThanOrEqual",
  [AC.NOT_BETWEEN]: "dataValidation.errorMsg.notBetween",
  [AC.NOT_EQUAL]: "dataValidation.errorMsg.notEqual",
  NONE: "dataValidation.errorMsg.legal"
};
function ye(o) {
  return +o;
}
var la = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "_customFormulaService", this.injector.get(H));
    m(this, "id", TC.DECIMAL);
    m(this, "_lexerTreeBuilder", this.injector.get(ga));
    m(this, "title", "dataValidation.decimal.title");
    m(this, "order", 20);
    m(this, "operators", [
      AC.BETWEEN,
      AC.EQUAL,
      AC.GREATER_THAN,
      AC.GREATER_THAN_OR_EQUAL,
      AC.LESS_THAN,
      AC.LESS_THAN_OR_EQUAL,
      AC.NOT_BETWEEN,
      AC.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
  }
  _isFormulaOrNumber(e) {
    return !J.isBlank(e) && (Gg(e) || !Number.isNaN(+e));
  }
  async isValidType(e, t, r) {
    const { value: i } = e;
    return !Number.isNaN(ye(i));
  }
  transform(e, t, r) {
    const { value: i } = e;
    return {
      ...e,
      value: ye(i)
    };
  }
  _parseNumber(e) {
    return e == null ? Number.NaN : +e;
  }
  async parseFormula(e, t, r, i, s) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, s), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, s), { formula1: u, formula2: d } = e, c = C2(String(n == null ? void 0 : n.v)) && C2(String(l == null ? void 0 : l.v));
    return {
      formula1: this._parseNumber(Gg(u) ? n == null ? void 0 : n.v : u),
      formula2: this._parseNumber(Gg(d) ? l == null ? void 0 : l.v : d),
      isFormulaValid: c
    };
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: true
      };
    const s = J.isDefine(e.formula1) && this._isFormulaOrNumber(e.formula1), n = J.isDefine(e.formula2) && this._isFormulaOrNumber(e.formula2), l = be.includes(i), u = this.localeService.t("dataValidation.validFail.number");
    return l ? {
      success: s && n,
      formula1: s ? void 0 : u,
      formula2: n ? void 0 : u
    } : {
      success: s,
      formula1: s ? "" : u
    };
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.localeService.t(Me.NONE).replace("{TYPE}", this.titleStr);
    const { transformedFormula1: r, transformedFormula2: i } = Le(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(Me[e.operator]).replace(le, r != null ? r : "").replace(ue, i != null ? i : "")}`;
  }
};
function $e2(o) {
  if (!o)
    return [];
  const a = /* @__PURE__ */ new Set();
  return o.forEach(
    (e) => {
      e.forEach((t) => {
        var i, s;
        const r = ne(t);
        if (r != null) {
          if (typeof r != "string" && typeof (t == null ? void 0 : t.s) == "object" && ((s = (i = t.s) == null ? void 0 : i.n) != null && s.pattern)) {
            a.add(eR.format(t.s.n.pattern, r, { throws: false }));
            return;
          }
          C2(r.toString()) && a.add(r.toString());
        }
      });
    }
  ), [...a];
}
var ua = [
  "if",
  "indirect",
  "choose",
  "offset"
];
function da(o, a) {
  if (!Gg(o) || so(o.slice(1)))
    return true;
  const t = a.sequenceNodesBuilder(o);
  return t && t.some((r) => typeof r == "object" && r.nodeType === $e.FUNCTION && ua.indexOf(r.token.toLowerCase()) > -1);
}
function ca(o, a) {
  const { formula1: e = "", ranges: t } = o;
  if (so(e.slice(1))) {
    const i = Dr(e.slice(1));
    if ((!i.sheetName || i.sheetName === a) && t.some((s) => En.intersects(s, i.range)))
      return true;
  }
  return false;
}
var ft = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "formulaService", this.injector.get(K));
    m(this, "_lexer", this.injector.get(ga));
    m(this, "_univerInstanceService", this.injector.get(vr));
    m(this, "order", 50);
    m(this, "offsetFormulaByRange", false);
    m(this, "id", TC.LIST);
    m(this, "title", "dataValidation.list.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "skipDefaultFontRender", (e) => e.renderMode !== yC.TEXT);
  }
  validatorFormula(e, t, r) {
    var u, d, c;
    const i = !J.isBlank(e.formula1), s = da((u = e.formula1) != null ? u : "", this._lexer), n = (c = (d = this._univerInstanceService.getUnit(t, we.UNIVER_SHEET)) == null ? void 0 : d.getSheetBySheetId(r)) == null ? void 0 : c.getName(), l = ca(e, n != null ? n : "");
    return {
      success: !!(i && s && !l),
      formula1: i ? s ? l ? this.localeService.t("dataValidation.validFail.listIntersects") : void 0 : this.localeService.t("dataValidation.validFail.listInvalid") : this.localeService.t("dataValidation.validFail.list")
    };
  }
  getExtraStyle(e, t, { style: r }) {
    var s;
    const i = (s = r.tb !== Bn.OVERFLOW ? r.tb : Bn.CLIP) != null ? s : Bn.WRAP;
    if (e.type === TC.LIST && (e.renderMode === yC.ARROW || e.renderMode === yC.TEXT)) {
      const n = this.getListWithColorMap(e), l = `${t != null ? t : ""}`, u = n[l];
      if (u)
        return {
          bg: {
            rgb: u
          },
          tb: i
        };
    }
    return {
      tb: i
    };
  }
  parseCellValue(e) {
    const t = e.toString();
    return _e(t);
  }
  async parseFormula(e, t, r) {
    var l, u;
    const i = await this.formulaService.getRuleFormulaResult(t, r, e.uid), s = oe((u = (l = i == null ? void 0 : i[0]) == null ? void 0 : l.result) == null ? void 0 : u[0][0]);
    return {
      formula1: void 0,
      formula2: void 0,
      isFormulaValid: C2(String(s))
    };
  }
  async isValidType(e, t, r) {
    var g, f;
    const { value: i, unitId: s, subUnitId: n } = e, { formula1: l = "" } = r, u = await this.formulaService.getRuleFormulaResult(s, n, r.uid), d = Gg(l) ? $e2((f = (g = u == null ? void 0 : u[0]) == null ? void 0 : g.result) == null ? void 0 : f[0][0]) : _e(l);
    return this.parseCellValue(i).every((p2) => d.includes(p2));
  }
  generateRuleName() {
    return this.localeService.t("dataValidation.list.name");
  }
  generateRuleErrorMessage() {
    return this.localeService.t("dataValidation.list.error");
  }
  getList(e, t, r) {
    var g, f, p2, R;
    const { formula1: i = "" } = e, s = this.injector.get(vr), n = (g = t ? s.getUniverSheetInstance(t) : void 0) != null ? g : s.getCurrentUnitForType(we.UNIVER_SHEET);
    if (!n) return [];
    const l = (f = r ? n.getSheetBySheetId(r) : void 0) != null ? f : n.getActiveSheet();
    if (!l) return [];
    const u = n.getUnitId(), d = l.getSheetId(), c = this.formulaService.getRuleFormulaResultSync(u, d, e.uid);
    return Gg(i) ? $e2((R = (p2 = c == null ? void 0 : c[0]) == null ? void 0 : p2.result) == null ? void 0 : R[0][0]) : _e(i);
  }
  async getListAsync(e, t, r) {
    var g, f, p2, R;
    const { formula1: i = "" } = e, s = this.injector.get(vr), n = (g = t ? s.getUniverSheetInstance(t) : void 0) != null ? g : s.getCurrentUnitForType(we.UNIVER_SHEET);
    if (!n) return [];
    const l = (f = r ? n.getSheetBySheetId(r) : void 0) != null ? f : n.getActiveSheet();
    if (!l) return [];
    const u = n.getUnitId(), d = l.getSheetId(), c = await this.formulaService.getRuleFormulaResult(u, d, e.uid);
    return Gg(i) ? $e2((R = (p2 = c == null ? void 0 : c[0]) == null ? void 0 : p2.result) == null ? void 0 : R[0][0]) : _e(i);
  }
  getListWithColor(e, t, r) {
    const i = this.getList(e, t, r), s = (e.formula2 || "").split(",");
    return i.map((n, l) => ({ label: n, color: s[l] }));
  }
  getListWithColorMap(e, t, r) {
    const i = this.getListWithColor(e, t, r), s = {};
    return i.forEach((n) => {
      n.color && (s[n.label] = n.color);
    }), s;
  }
};
var ha = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "id", TC.TEXT_LENGTH);
    m(this, "title", "dataValidation.textLength.title");
    m(this, "_lexerTreeBuilder", this.injector.get(ga));
    m(this, "order", 30);
    m(this, "operators", [
      AC.BETWEEN,
      AC.EQUAL,
      AC.GREATER_THAN,
      AC.GREATER_THAN_OR_EQUAL,
      AC.LESS_THAN,
      AC.LESS_THAN_OR_EQUAL,
      AC.NOT_BETWEEN,
      AC.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
    m(this, "_customFormulaService", this.injector.get(H));
  }
  _isFormulaOrInt(e) {
    return !J.isBlank(e) && (Gg(e) || !Number.isNaN(+e) && Number.isInteger(+e));
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: false
      };
    const s = J.isDefine(e.formula1) && this._isFormulaOrInt(e.formula1), n = J.isDefine(e.formula2) && this._isFormulaOrInt(e.formula2), l = be.includes(i), u = this.localeService.t("dataValidation.validFail.number");
    return l ? {
      success: s && n,
      formula1: s ? void 0 : u,
      formula2: n ? void 0 : u
    } : {
      success: s,
      formula1: u
    };
  }
  _parseNumber(e) {
    return e == null ? Number.NaN : +e;
  }
  async parseFormula(e, t, r, i, s) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, s), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, s), { formula1: u, formula2: d } = e, c = C2(String(n == null ? void 0 : n.v)) && C2(String(l == null ? void 0 : l.v));
    return {
      formula1: this._parseNumber(Gg(u) ? n == null ? void 0 : n.v : u),
      formula2: this._parseNumber(Gg(d) ? l == null ? void 0 : l.v : d),
      isFormulaValid: c
    };
  }
  transform(e, t, r) {
    return {
      ...e,
      value: e.value.toString().length
    };
  }
  async isValidType(e, t, r) {
    const { value: i } = e;
    return typeof i == "string" || typeof i == "number";
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.titleStr;
    const { transformedFormula1: r, transformedFormula2: i } = Le(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(Ue[e.operator]).replace(le, r != null ? r : "").replace(ue, i != null ? i : "")}`;
  }
};
function _t(o) {
  var e, t;
  return o ? o.p ? !((t = (e = o.p.body) == null ? void 0 : e.dataStream) != null ? t : "").slice(0, -2).trim() : J.isBlank(o.v) : true;
}
function Ue2(o, a, e, t, r = "command", i = true) {
  const s = t.get(ga), n = t.get(F), l = [], u = [], d = t.get(F2), c = t.get(vr), g = P(c, { unitId: o, subUnitId: a });
  if (!g)
    return {
      redoMutations: l,
      undoMutations: u
    };
  const { worksheet: f } = g, p2 = new pt();
  let R = false;
  function V(_, w) {
    i && _.forEach(($) => {
      Or.foreach($, (B, k) => {
        const x = f.getCellRaw(B, k), J2 = pt2(x);
        (_t(x) || J2 === w) && !(x != null && x.p) && (R = true, p2.setValue(B, k, {
          v: w,
          p: null
        }));
      });
    });
  }
  if (e.forEach((_) => {
    switch (_.type) {
      case "delete":
        l.push({
          id: N.id,
          params: {
            unitId: o,
            subUnitId: a,
            ruleId: _.rule.uid,
            source: r
          }
        }), u.unshift({
          id: S.id,
          params: {
            unitId: o,
            subUnitId: a,
            rule: _.rule,
            index: _.index,
            source: r
          }
        });
        break;
      case "update": {
        if (de(_.rule.type, n)) {
          const $ = _.oldRanges[0].startRow, B = _.oldRanges[0].startColumn, k = _.newRanges[0].startRow, x = _.newRanges[0].startColumn, J2 = k - $, ce = x - B, he = Gg(_.rule.formula1) ? s.moveFormulaRefOffset(_.rule.formula1, ce, J2) : _.rule.formula1, me = Gg(_.rule.formula2) ? s.moveFormulaRefOffset(_.rule.formula2, ce, J2) : _.rule.formula2;
          he !== _.rule.formula1 || me !== _.rule.formula2 || !$R(_.newRanges, _.oldRanges) ? (l.push({
            id: v.id,
            params: {
              unitId: o,
              subUnitId: a,
              ruleId: _.ruleId,
              payload: {
                type: p.ALL,
                payload: {
                  formula1: he,
                  formula2: me,
                  ranges: _.newRanges
                }
              }
            }
          }), u.unshift({
            id: v.id,
            params: {
              unitId: o,
              subUnitId: a,
              ruleId: _.ruleId,
              payload: {
                type: p.ALL,
                payload: {
                  formula1: _.rule.formula1,
                  formula2: _.rule.formula2,
                  ranges: _.oldRanges
                }
              }
            }
          })) : (l.push({
            id: v.id,
            params: {
              unitId: o,
              subUnitId: a,
              ruleId: _.ruleId,
              payload: {
                type: p.RANGE,
                payload: _.newRanges
              },
              source: r
            }
          }), u.unshift({
            id: v.id,
            params: {
              unitId: o,
              subUnitId: a,
              ruleId: _.ruleId,
              payload: {
                type: p.RANGE,
                payload: _.oldRanges
              },
              source: r
            }
          }));
        } else
          l.push({
            id: v.id,
            params: {
              unitId: o,
              subUnitId: a,
              ruleId: _.ruleId,
              payload: {
                type: p.RANGE,
                payload: _.newRanges
              },
              source: r
            }
          }), u.unshift({
            id: v.id,
            params: {
              unitId: o,
              subUnitId: a,
              ruleId: _.ruleId,
              payload: {
                type: p.RANGE,
                payload: _.oldRanges
              },
              source: r
            }
          });
        const w = d.getRuleById(o, a, _.ruleId);
        if (w && w.type === TC.CHECKBOX) {
          const B = d.getValidator(TC.CHECKBOX).parseFormulaSync(w, o, a);
          V(_.newRanges, B.formula2);
        }
        break;
      }
      case "add": {
        if (l.push({
          id: S.id,
          params: {
            unitId: o,
            subUnitId: a,
            rule: _.rule,
            source: r
          }
        }), u.unshift({
          id: N.id,
          params: {
            unitId: o,
            subUnitId: a,
            ruleId: _.rule.uid,
            source: r
          }
        }), _.rule.type === TC.CHECKBOX) {
          const $ = d.getValidator(TC.CHECKBOX).parseFormulaSync(_.rule, o, a);
          V(_.rule.ranges, $.originFormula2);
        }
        break;
      }
    }
  }), R) {
    const _ = {
      id: ee.id,
      params: {
        unitId: o,
        subUnitId: a,
        cellValue: p2.getData()
      }
    }, w = {
      id: ee.id,
      params: Ae(t, _.params)
    };
    l.push(_), u.push(w);
  }
  return {
    redoMutations: l,
    undoMutations: u
  };
}
var ma = {
  type: Ms.COMMAND,
  id: "sheet.command.updateDataValidationRuleRange",
  handler(o, a) {
    if (!a)
      return false;
    const { unitId: e, subUnitId: t, ranges: r, ruleId: i } = a, s = o.get(F2), n = o.get(Ls), l = o.get(Qo);
    if (!s.getRuleById(e, t, i))
      return false;
    const d = s.getRuleObjectMatrix(e, t).clone();
    d.updateRange(i, r);
    const c = d.diff(s.getRules(e, t)), { redoMutations: g, undoMutations: f } = Ue2(e, t, c, o);
    return l.pushUndoRedo({
      undoMutations: f,
      redoMutations: g,
      unitID: e
    }), fo(g, n), true;
  }
};
var ga2 = {
  type: Ms.COMMAND,
  id: "sheet.command.addDataValidation",
  handler(o, a) {
    if (!a)
      return false;
    const { unitId: e, subUnitId: t, rule: r } = a, i = o.get(F2), s = o.get(Ls), n = o.get(Qo), l = i.getRuleObjectMatrix(e, t).clone();
    l.addRule(r);
    const u = l.diff(i.getRules(e, t)), d = i.getValidator(r.type), c = {
      unitId: e,
      subUnitId: t,
      rule: {
        ...r,
        ...d == null ? void 0 : d.normalizeFormula(r, e, t)
      }
    }, { redoMutations: g, undoMutations: f } = Ue2(e, t, u, o);
    return g.push({
      id: S.id,
      params: c
    }), f.unshift({
      id: N.id,
      params: {
        unitId: e,
        subUnitId: t,
        ruleId: r.uid
      }
    }), n.pushUndoRedo({
      unitID: e,
      redoMutations: g,
      undoMutations: f
    }), fo(g, s), true;
  }
};
var pa = {
  type: Ms.COMMAND,
  id: "sheets.command.update-data-validation-setting",
  // eslint-disable-next-line max-lines-per-function
  handler(o, a) {
    if (!a)
      return false;
    const e = o.get(Ls), t = o.get(Qo), r = o.get(F2), i = o.get(F), { unitId: s, subUnitId: n, ruleId: l, setting: u } = a, d = i.getValidatorItem(u.type);
    if (!d)
      return false;
    const c = r.getRuleById(s, n, l);
    if (!c)
      return false;
    const g = { ...c, ...u };
    if (!d.validatorFormula(g, s, n).success)
      return false;
    const f = {
      unitId: s,
      subUnitId: n,
      ruleId: l,
      payload: {
        type: p.SETTING,
        payload: {
          ...u,
          ...d.normalizeFormula(g, s, n)
        }
      }
    }, p2 = [{
      id: v.id,
      params: f
    }], R = {
      unitId: s,
      subUnitId: n,
      ruleId: l,
      payload: {
        type: p.SETTING,
        payload: Q(c)
      }
    }, V = [{
      id: v.id,
      params: R
    }];
    if (u.type === TC.CHECKBOX) {
      const w = c.ranges, $ = o.get(vr), B = P($, { unitId: s, subUnitId: n });
      if (B) {
        const k = new pt(), { worksheet: x } = B, { formula2: J2 = Ve2, formula1: ce = Ee } = c, { formula2: he = Ve2, formula1: me = Ee } = u;
        let Be = false;
        if (w.forEach((ge) => {
          Or.foreach(ge, (ae, xe) => {
            const j2 = x.getCellRaw(ae, xe), Je = pt2(j2);
            (_t(j2) || Je === String(J2)) && !(j2 != null && j2.p) ? (k.setValue(ae, xe, {
              v: he,
              p: null
            }), Be = true) : Je === String(ce) && !(j2 != null && j2.p) && (k.setValue(ae, xe, {
              v: me,
              p: null
            }), Be = true);
          });
        }), Be) {
          const ge = {
            id: ee.id,
            params: {
              unitId: s,
              subUnitId: n,
              cellValue: k.getData()
            }
          }, ae = {
            id: ee.id,
            params: Ae(o, ge.params)
          };
          p2.push(ge), V.push(ae);
        }
      }
    }
    return fo(p2, e).result ? (t.pushUndoRedo({
      unitID: s,
      redoMutations: p2,
      undoMutations: V
    }), true) : false;
  }
};
var fa = {
  type: Ms.COMMAND,
  id: "sheets.command.update-data-validation-options",
  handler(o, a) {
    if (!a)
      return false;
    const e = o.get(Ls), t = o.get(Qo), r = o.get(F2), { unitId: i, subUnitId: s, ruleId: n, options: l } = a, u = r.getRuleById(i, s, n);
    if (!u)
      return false;
    const d = {
      unitId: i,
      subUnitId: s,
      ruleId: n,
      payload: {
        type: p.OPTIONS,
        payload: l
      }
    }, c = [{
      id: v.id,
      params: d
    }], g = {
      unitId: i,
      subUnitId: s,
      ruleId: n,
      payload: {
        type: p.OPTIONS,
        payload: j(u)
      }
    }, f = [{
      id: v.id,
      params: g
    }];
    return t.pushUndoRedo({
      unitID: i,
      redoMutations: c,
      undoMutations: f
    }), e.executeCommand(v.id, d), true;
  }
};
var _a = {
  type: Ms.COMMAND,
  id: "sheets.command.clear-range-data-validation",
  handler(o, a) {
    if (!a)
      return false;
    const { unitId: e, subUnitId: t, ranges: r } = a, i = o.get(Ls), s = o.get(vr), n = P(s, { unitId: e, subUnitId: t }), l = o.get(F2);
    if (!n) return false;
    const u = o.get(Qo), d = l.getRuleObjectMatrix(e, t).clone();
    d.removeRange(r);
    const c = d.diff(l.getRules(e, t)), { redoMutations: g, undoMutations: f } = Ue2(e, t, c, o);
    return u.pushUndoRedo({
      unitID: e,
      redoMutations: g,
      undoMutations: f
    }), fo(g, i).result;
  }
};
var Ra = {
  type: Ms.COMMAND,
  id: "sheet.command.remove-all-data-validation",
  handler(o, a) {
    if (!a)
      return false;
    const { unitId: e, subUnitId: t } = a, r = o.get(Ls), i = o.get(F2), s = o.get(Qo), n = [...i.getRules(e, t)], l = {
      unitId: e,
      subUnitId: t,
      ruleId: n.map((c) => c.uid)
    }, u = [{
      id: N.id,
      params: l
    }], d = [{
      id: S.id,
      params: {
        unitId: e,
        subUnitId: t,
        rule: n
      }
    }];
    return s.pushUndoRedo({
      redoMutations: u,
      undoMutations: d,
      unitID: e
    }), r.executeCommand(N.id, l), true;
  }
};
var va = (o, a) => {
  const e = o.get(F2), { unitId: t, subUnitId: r, ruleId: i, source: s } = a;
  if (Array.isArray(i)) {
    const l = i.map((u) => e.getRuleById(t, r, u)).filter(Boolean);
    return [{
      id: S.id,
      params: {
        unitId: t,
        subUnitId: r,
        rule: l,
        source: s
      }
    }];
  }
  return [{
    id: S.id,
    params: {
      unitId: t,
      subUnitId: r,
      rule: {
        ...e.getRuleById(t, r, i)
      },
      index: e.getRuleIndex(t, r, i)
    }
  }];
};
var Sa = {
  type: Ms.COMMAND,
  id: "sheet.command.remove-data-validation-rule",
  handler(o, a) {
    if (!a)
      return false;
    const { unitId: e, subUnitId: t, ruleId: r } = a, i = o.get(Ls), s = o.get(Qo), n = o.get(F2), l = [{
      id: N.id,
      params: a
    }], u = [{
      id: S.id,
      params: {
        unitId: e,
        subUnitId: t,
        rule: {
          ...n.getRuleById(e, t, r)
        },
        index: n.getRuleIndex(e, t, r)
      }
    }];
    return s.pushUndoRedo({
      undoMutations: u,
      redoMutations: l,
      unitID: a.unitId
    }), i.executeCommand(N.id, a), true;
  }
};
var Ea = "SHEET_DATA_VALIDATION_PLUGIN";
var Rt = ((o) => (o[o.View = 0] = "View", o[o.Edit = 1] = "Edit", o[o.ManageCollaborator = 2] = "ManageCollaborator", o[o.Print = 3] = "Print", o[o.Duplicate = 4] = "Duplicate", o[o.Comment = 5] = "Comment", o[o.Copy = 6] = "Copy", o[o.Share = 7] = "Share", o[o.Export = 8] = "Export", o[o.MoveWorksheet = 9] = "MoveWorksheet", o[o.DeleteWorksheet = 10] = "DeleteWorksheet", o[o.HideWorksheet = 11] = "HideWorksheet", o[o.RenameWorksheet = 12] = "RenameWorksheet", o[o.CreateWorksheet = 13] = "CreateWorksheet", o[o.SetWorksheetStyle = 14] = "SetWorksheetStyle", o[o.EditWorksheetCell = 15] = "EditWorksheetCell", o[o.InsertHyperlink = 16] = "InsertHyperlink", o[o.Sort = 17] = "Sort", o[o.Filter = 18] = "Filter", o[o.PivotTable = 19] = "PivotTable", o[o.FloatImg = 20] = "FloatImg", o[o.History = 21] = "History", o[o.RwHgtClWdt = 22] = "RwHgtClWdt", o[o.ViemRwHgtClWdt = 23] = "ViemRwHgtClWdt", o[o.ViewFilter = 24] = "ViewFilter", o[o.MoveSheet = 25] = "MoveSheet", o[o.DeleteSheet = 26] = "DeleteSheet", o[o.HideSheet = 27] = "HideSheet", o[o.CopySheet = 28] = "CopySheet", o[o.RenameSheet = 29] = "RenameSheet", o[o.CreateSheet = 30] = "CreateSheet", o[o.SelectProtectedCells = 31] = "SelectProtectedCells", o[o.SelectUnProtectedCells = 32] = "SelectUnProtectedCells", o[o.SetCellStyle = 33] = "SetCellStyle", o[o.SetCellValue = 34] = "SetCellValue", o[o.SetRowStyle = 35] = "SetRowStyle", o[o.SetColumnStyle = 36] = "SetColumnStyle", o[o.InsertRow = 37] = "InsertRow", o[o.InsertColumn = 38] = "InsertColumn", o[o.DeleteRow = 39] = "DeleteRow", o[o.DeleteColumn = 40] = "DeleteColumn", o[o.EditExtraObject = 41] = "EditExtraObject", o[o.Delete = 42] = "Delete", o[o.RecoverHistory = 43] = "RecoverHistory", o[o.ViewHistory = 44] = "ViewHistory", o[o.CreatePermissionObject = 45] = "CreatePermissionObject", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED", o))(Rt || {});
var Va = Object.getOwnPropertyDescriptor;
var Ma = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Va(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var ke2 = (o, a) => (e, t) => a(e, t, o);
var Te = class extends Ve {
  constructor(o, a, e) {
    super(), this._univerInstanceService = o, this._permissionService = a, this._lexerTreeBuilder = e;
  }
  getFormulaRefCheck(o) {
    var e, t;
    const a = this._lexerTreeBuilder.sequenceNodesBuilder(o);
    if (!a)
      return true;
    for (let r = 0; r < a.length; r++) {
      const i = a[r];
      if (typeof i == "string")
        continue;
      const { token: s } = i, n = Cr(s), l = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET);
      let u = l.getActiveSheet();
      const d = l.getUnitId();
      if (n.sheetName) {
        if (u = l.getSheetBySheetName(n.sheetName), !u)
          return false;
        const R = u == null ? void 0 : u.getSheetId();
        if (!this._permissionService.getPermissionPoint(new ls(d, R).id)) return false;
      }
      if (!u)
        return false;
      const { startRow: c, endRow: g, startColumn: f, endColumn: p2 } = n.range;
      for (let R = c; R <= g; R++)
        for (let V = f; V <= p2; V++) {
          const _ = (t = (e = u.getCell(R, V)) == null ? void 0 : e.selectionProtection) == null ? void 0 : t[0];
          if ((_ == null ? void 0 : _[Rt.View]) === false)
            return false;
        }
    }
    return true;
  }
};
Te = Ma([
  ke2(0, vr),
  ke2(1, eC),
  ke2(2, Inject(ga))
], Te);
var ya = "sheets-data-validation.config";
var it = {};
var Ta = Object.getOwnPropertyDescriptor;
var Fa = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Ta(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var je2 = (o, a) => (e, t) => a(e, t, o);
var Fe = class extends Ve {
  constructor(a, e, t) {
    super();
    m(this, "_disposableMap", /* @__PURE__ */ new Map());
    m(this, "registerRule", (a2, e2, t2) => {
      de(t2.type, this._validatorRegistryService) && this.register(a2, e2, t2);
    });
    this._dataValidationModel = a, this._formulaRefRangeService = e, this._validatorRegistryService = t, this._initRefRange();
  }
  _getIdWithUnitId(a, e, t) {
    return `${a}_${e}_${t}`;
  }
  // eslint-disable-next-line max-lines-per-function
  register(a, e, t) {
    const r = t.ranges, i = t.formula1, s = t.formula2, n = this._formulaRefRangeService.registerRangeFormula(a, e, r, [i != null ? i : "", s != null ? s : ""], (u) => {
      if (u.length === 0)
        return {
          undos: [{
            id: S.id,
            params: {
              unitId: a,
              subUnitId: e,
              rule: t,
              source: "patched"
            }
          }],
          redos: [{
            id: N.id,
            params: {
              unitId: a,
              subUnitId: e,
              ruleId: t.uid,
              source: "patched"
            }
          }]
        };
      const d = [], c = [], g = u[0];
      d.push({
        id: v.id,
        params: {
          unitId: a,
          subUnitId: e,
          ruleId: t.uid,
          payload: {
            type: p.ALL,
            payload: {
              ranges: g.ranges,
              formula1: g.formulas[0],
              formula2: g.formulas[1]
            }
          },
          source: "patched"
        }
      }), c.push({
        id: v.id,
        params: {
          unitId: a,
          subUnitId: e,
          ruleId: t.uid,
          payload: {
            type: p.ALL,
            payload: {
              ranges: r,
              formula1: i,
              formula2: s
            }
          },
          source: "patched"
        }
      });
      for (let f = 1; f < u.length; f++) {
        const p2 = u[f], R = et();
        d.push({
          id: S.id,
          params: {
            unitId: a,
            subUnitId: e,
            rule: {
              ...t,
              uid: R,
              formula1: p2.formulas[0],
              formula2: p2.formulas[1],
              ranges: p2.ranges
            },
            source: "patched"
          }
        }), c.push({
          id: N.id,
          params: {
            unitId: a,
            subUnitId: e,
            ruleId: R,
            source: "patched"
          }
        });
      }
      return {
        undos: c,
        redos: d
      };
    }), l = this._getIdWithUnitId(a, e, t.uid);
    this._disposableMap.set(l, n);
  }
  _initRefRange() {
    const a = this._dataValidationModel.getAll();
    for (const [e, t] of a)
      for (const [r, i] of t)
        for (const s of i)
          this.registerRule(e, r, s);
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((e) => {
        const { unitId: t, subUnitId: r, rule: i } = e;
        switch (e.type) {
          case "add": {
            const s = e.rule;
            this.registerRule(e.unitId, e.subUnitId, s);
            break;
          }
          case "remove": {
            const s = this._disposableMap.get(this._getIdWithUnitId(t, r, i.uid));
            s && s.dispose();
            break;
          }
          case "update": {
            const s = e.rule, n = this._disposableMap.get(this._getIdWithUnitId(t, r, s.uid));
            n && n.dispose(), this.registerRule(e.unitId, e.subUnitId, s);
            break;
          }
        }
      })
    ), this.disposeWithMe(We(() => {
      this._disposableMap.forEach((e) => {
        e.dispose();
      }), this._disposableMap.clear();
    }));
  }
};
Fe = Fa([
  je2(0, Inject(F2)),
  je2(1, Inject(xt2)),
  je2(2, Inject(F))
], Fe);
var Na = Object.getOwnPropertyDescriptor;
var Ca = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Na(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var ee2 = (o, a) => (e, t) => a(e, t, o);
var Ne = class extends Ve {
  constructor(a, e, t, r, i, s) {
    super();
    m(this, "_disposableMap", /* @__PURE__ */ new Map());
    m(this, "registerRule", (a2, e2, t2) => {
      de(t2.type, this._validatorRegistryService) || (this.register(a2, e2, t2), this.registerFormula(a2, e2, t2));
    });
    this._dataValidationModel = a, this._injector = e, this._refRangeService = t, this._dataValidationFormulaService = r, this._formulaRefRangeService = i, this._validatorRegistryService = s, this._initRefRange();
  }
  _getIdWithUnitId(a, e, t) {
    return `${a}_${e}_${t}`;
  }
  // eslint-disable-next-line max-lines-per-function
  registerFormula(a, e, t) {
    var u;
    const r = t.uid, i = this._getIdWithUnitId(a, e, r), s = (u = this._disposableMap.get(i)) != null ? u : /* @__PURE__ */ new Set(), n = (d, c) => {
      const g = this._dataValidationModel.getRuleById(a, e, r);
      if (!g)
        return { redos: [], undos: [] };
      const f = g[d];
      if (!f || f === c)
        return { redos: [], undos: [] };
      const p2 = {
        unitId: a,
        subUnitId: e,
        ruleId: t.uid,
        payload: {
          type: p.SETTING,
          payload: {
            type: g.type,
            formula1: g.formula1,
            formula2: g.formula2,
            [d]: c
          }
        },
        source: "patched"
      }, R = {
        unitId: a,
        subUnitId: e,
        ruleId: t.uid,
        payload: {
          type: p.SETTING,
          payload: {
            type: g.type,
            formula1: g.formula1,
            formula2: g.formula2
          }
        },
        source: "patched"
      }, V = [
        {
          id: v.id,
          params: p2
        }
      ], _ = [
        {
          id: v.id,
          params: R
        }
      ];
      return { redos: V, undos: _ };
    }, l = this._dataValidationFormulaService.getRuleFormulaInfo(a, e, r);
    if (l) {
      const [d, c] = l;
      if (d) {
        const g = this._formulaRefRangeService.registerFormula(
          a,
          e,
          d.text,
          (f) => n("formula1", f)
        );
        s.add(() => g.dispose());
      }
      if (c) {
        const g = this._formulaRefRangeService.registerFormula(
          a,
          e,
          c.text,
          (f) => n("formula2", f)
        );
        s.add(() => g.dispose());
      }
    }
  }
  register(a, e, t) {
    var l;
    const r = (u) => {
      const d = [...t.ranges], g = d.map((p2) => Co(p2, u)).filter((p2) => !!p2).flat();
      if ($R(g, d))
        return { redos: [], undos: [] };
      if (g.length) {
        const p2 = {
          unitId: a,
          subUnitId: e,
          ruleId: t.uid,
          payload: {
            type: p.RANGE,
            payload: g
          },
          source: "patched"
        }, R = [{ id: v.id, params: p2 }], V = [{
          id: v.id,
          params: {
            unitId: a,
            subUnitId: e,
            ruleId: t.uid,
            payload: {
              type: p.RANGE,
              payload: d
            },
            source: "patched"
          }
        }];
        return { redos: R, undos: V };
      } else {
        const p2 = { unitId: a, subUnitId: e, ruleId: t.uid }, R = [{ id: N.id, params: p2 }], V = va(this._injector, p2);
        return { redos: R, undos: V };
      }
    }, i = [];
    t.ranges.forEach((u) => {
      const d = this._refRangeService.registerRefRange(u, r, a, e);
      i.push(() => d.dispose());
    });
    const s = this._getIdWithUnitId(a, e, t.uid), n = (l = this._disposableMap.get(s)) != null ? l : /* @__PURE__ */ new Set();
    n.add(() => i.forEach((u) => u())), this._disposableMap.set(s, n);
  }
  _initRefRange() {
    const a = this._dataValidationModel.getAll();
    for (const [e, t] of a)
      for (const [r, i] of t)
        for (const s of i)
          this.registerRule(e, r, s);
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((e) => {
        const { unitId: t, subUnitId: r, rule: i } = e;
        switch (e.type) {
          case "add": {
            const s = e.rule;
            this.registerRule(e.unitId, e.subUnitId, s);
            break;
          }
          case "remove": {
            const s = this._disposableMap.get(this._getIdWithUnitId(t, r, i.uid));
            s && s.forEach((n) => n());
            break;
          }
          case "update": {
            const s = e.rule, n = this._disposableMap.get(this._getIdWithUnitId(t, r, s.uid));
            n && n.forEach((l) => l()), this.registerRule(e.unitId, e.subUnitId, s);
            break;
          }
        }
      })
    ), this.disposeWithMe(We(() => {
      this._disposableMap.forEach((e) => {
        e.forEach((t) => t());
      }), this._disposableMap.clear();
    }));
  }
};
Ne = Ca([
  ee2(0, Inject(F2)),
  ee2(1, Inject(Injector)),
  ee2(2, Inject(xt)),
  ee2(3, Inject(K)),
  ee2(4, Inject(xt2)),
  ee2(5, Inject(F))
], Ne);
var Oa = Object.getOwnPropertyDescriptor;
var wa = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Oa(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var Qe = (o, a) => (e, t) => a(e, t, o);
var Ce = class extends Ve {
  constructor(o, a, e) {
    super(), this._sheetInterceptorService = o, this._univerInstanceService = a, this._sheetDataValidationModel = e, this._initSheetChange();
  }
  // eslint-disable-next-line max-lines-per-function
  _initSheetChange() {
    this.disposeWithMe(
      this._sheetInterceptorService.interceptCommand({
        // eslint-disable-next-line max-lines-per-function
        getMutations: (o) => {
          var a;
          if (o.id === Xs.id) {
            const e = o.params, t = e.unitId || this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET).getUnitId(), r = this._univerInstanceService.getUniverSheetInstance(t);
            if (!r)
              return { redos: [], undos: [] };
            const i = e.subUnitId || ((a = r.getActiveSheet()) == null ? void 0 : a.getSheetId());
            if (!i)
              return { redos: [], undos: [] };
            const s = this._sheetDataValidationModel.getRules(t, i);
            if (s.length === 0)
              return { redos: [], undos: [] };
            const n = s.map((d) => d.uid), l = {
              unitId: t,
              subUnitId: i,
              ruleId: n,
              source: "patched"
            }, u = {
              unitId: t,
              subUnitId: i,
              rule: [...s],
              source: "patched"
            };
            return {
              redos: [{
                id: N.id,
                params: l
              }],
              undos: [{
                id: S.id,
                params: u
              }]
            };
          } else if (o.id === qr.id) {
            const e = o.params, { unitId: t, subUnitId: r, targetSubUnitId: i } = e;
            if (!t || !r || !i)
              return { redos: [], undos: [] };
            const s = this._sheetDataValidationModel.getRules(t, r);
            if (s.length === 0)
              return { redos: [], undos: [] };
            const n = s.map((l) => ({ ...l, uid: et(6) }));
            return {
              redos: [
                {
                  id: S.id,
                  params: {
                    unitId: t,
                    subUnitId: i,
                    rule: n,
                    source: "patched"
                  }
                }
              ],
              undos: [
                {
                  id: N.id,
                  params: {
                    unitId: t,
                    subUnitId: i,
                    ruleId: n.map((l) => l.uid),
                    source: "patched"
                  }
                }
              ]
            };
          }
          return { redos: [], undos: [] };
        }
      })
    );
  }
};
Ce = wa([
  Qe(0, Inject(G)),
  Qe(1, Inject(vr)),
  Qe(2, Inject(F2))
], Ce);
var Ia = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "id", TC.ANY);
    m(this, "title", "dataValidation.any.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "order", 0);
    m(this, "offsetFormulaByRange", false);
  }
  async parseFormula(e, t, r) {
    return {
      formula1: e.formula1,
      formula2: e.formula2,
      isFormulaValid: true
    };
  }
  validatorFormula(e, t, r) {
    return {
      success: true
    };
  }
  async isValidType(e, t, r) {
    return true;
  }
  generateRuleErrorMessage(e) {
    return this.localeService.t("dataValidation.any.error");
  }
};
var Aa = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "id", TC.CUSTOM);
    m(this, "title", "dataValidation.custom.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "order", 60);
    m(this, "_customFormulaService", this.injector.get(H));
    m(this, "_lexerTreeBuilder", this.injector.get(ga));
  }
  validatorFormula(e, t, r) {
    var u;
    const i = Gg(e.formula1), s = (u = e.formula1) != null ? u : "", l = this._lexerTreeBuilder.checkIfAddBracket(s) === 0 && s.startsWith(X.EQUALS);
    return {
      success: i && l,
      formula1: i && l ? "" : this.localeService.t("dataValidation.validFail.formula")
    };
  }
  async parseFormula(e, t, r) {
    return {
      formula1: void 0,
      formula2: void 0,
      isFormulaValid: true
    };
  }
  async isValidType(e, t, r) {
    const { column: i, row: s, unitId: n, subUnitId: l } = e, u = await this._customFormulaService.getCellFormulaValue(n, l, r.uid, s, i), d = u == null ? void 0 : u.v;
    return C2(String(d)) && J.isDefine(d) && d !== "" ? u.t === fn.BOOLEAN ? !!d : typeof d == "boolean" ? d : typeof d == "number" ? !!d : typeof d == "string" ? C2(d) : !!d : false;
  }
  generateRuleErrorMessage(e) {
    return this.localeService.t("dataValidation.custom.error");
  }
  generateRuleName(e) {
    var t;
    return this.localeService.t("dataValidation.custom.ruleName").replace("{FORMULA1}", (t = e.formula1) != null ? t : "");
  }
};
var Da = class extends ft {
  constructor() {
    super(...arguments);
    m(this, "id", TC.LIST_MULTIPLE);
    m(this, "title", "dataValidation.listMultiple.title");
    m(this, "offsetFormulaByRange", false);
    m(this, "skipDefaultFontRender", () => true);
  }
};
var ba = class extends G2 {
  constructor() {
    super(...arguments);
    m(this, "_customFormulaService", this.injector.get(H));
    m(this, "_lexerTreeBuilder", this.injector.get(ga));
    m(this, "id", TC.WHOLE);
    m(this, "title", "dataValidation.whole.title");
    m(this, "order", 10);
    m(this, "operators", [
      AC.BETWEEN,
      AC.EQUAL,
      AC.GREATER_THAN,
      AC.GREATER_THAN_OR_EQUAL,
      AC.LESS_THAN,
      AC.LESS_THAN_OR_EQUAL,
      AC.NOT_BETWEEN,
      AC.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
  }
  _isFormulaOrInt(e) {
    return !J.isBlank(e) && (Gg(e) || !Number.isNaN(+e) && Number.isInteger(+e));
  }
  async isValidType(e, t, r) {
    const { value: i } = e, s = ye(i);
    return !Number.isNaN(s) && Number.isInteger(s);
  }
  transform(e, t, r) {
    const { value: i } = e;
    return {
      ...e,
      value: ye(i)
    };
  }
  _parseNumber(e) {
    return e == null ? Number.NaN : +e;
  }
  async parseFormula(e, t, r, i, s) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, s), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, s), { formula1: u, formula2: d } = e, c = Gg(u) ? n == null ? void 0 : n.v : u, g = Gg(d) ? l == null ? void 0 : l.v : d, f = C2(`${c}`) && C2(`${g}`);
    return {
      formula1: this._parseNumber(c),
      formula2: this._parseNumber(g),
      isFormulaValid: f
    };
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: true
      };
    const s = J.isDefine(e.formula1) && this._isFormulaOrInt(e.formula1), n = J.isDefine(e.formula2) && this._isFormulaOrInt(e.formula2), l = be.includes(i), u = this.localeService.t("dataValidation.validFail.number");
    return l ? {
      success: s && n,
      formula1: s ? void 0 : u,
      formula2: n ? void 0 : u
    } : {
      success: s,
      formula1: u
    };
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.localeService.t(Me.NONE).replace("{TYPE}", this.titleStr);
    const { transformedFormula1: r, transformedFormula2: i } = Le(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(Me[e.operator]).replace(le, r != null ? r : "").replace(ue, i != null ? i : "")}`;
  }
};
var La = Object.getOwnPropertyDescriptor;
var Ua = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? La(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var te = (o, a) => (e, t) => a(e, t, o);
var Oe = class extends h1 {
  constructor(o, a, e, t, r, i) {
    super(), this._univerInstanceService = o, this._dataValidatorRegistryService = a, this._injector = e, this._selectionManagerService = t, this._sheetInterceptorService = r, this._sheetDataValidationModel = i, this._init();
  }
  _init() {
    this._registerValidators(), this._initCommandInterceptor();
  }
  _registerValidators() {
    [
      Ia,
      la,
      ba,
      ha,
      na,
      ia,
      ft,
      Da,
      Aa
    ].forEach((o) => {
      const a = this._injector.createInstance(o);
      this.disposeWithMe(this._dataValidatorRegistryService.register(a)), this.disposeWithMe(We(() => this._injector.delete(o)));
    });
  }
  _initCommandInterceptor() {
    this._sheetInterceptorService.interceptCommand({
      getMutations: (o) => {
        var a;
        if (o.id === Ws.id) {
          const e = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET), t = e.getUnitId(), r = e.getActiveSheet();
          if (!r)
            throw new Error("No active sheet found");
          const i = r.getSheetId(), s = (a = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : a.map((c) => c.range), n = this._sheetDataValidationModel.getRuleObjectMatrix(t, i).clone();
          s && n.removeRange(s);
          const l = n.diff(this._sheetDataValidationModel.getRules(t, i)), { redoMutations: u, undoMutations: d } = Ue2(t, i, l, this._injector, "patched");
          return {
            undos: d,
            redos: u
          };
        }
        return {
          undos: [],
          redos: []
        };
      }
    });
  }
};
Oe = Ua([
  te(0, vr),
  te(1, Inject(F)),
  te(2, Inject(Injector)),
  te(3, Inject(z)),
  te(4, Inject(G)),
  te(5, Inject(F2))
], Oe);
var Ba = Object.getOwnPropertyDescriptor;
var xa = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Ba(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var Re = (o, a) => (e, t) => a(e, t, o);
var we2 = class extends Ve {
  constructor(o, a, e, t) {
    super(), this._univerInstanceService = o, this._sheetDataValidationModel = a, this._dataValidationCacheService = e, this._lifecycleService = t, this._initRecalculate();
  }
  _initRecalculate() {
    const o = (a) => {
      if (a.length === 0)
        return;
      const e = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET), t = e == null ? void 0 : e.getActiveSheet(), r = {};
      a.flat().forEach((i) => {
        r[i.unitId] || (r[i.unitId] = {}), r[i.unitId][i.subUnitId] || (r[i.unitId][i.subUnitId] = []);
        const s = this._univerInstanceService.getUnit(i.unitId, we.UNIVER_SHEET), n = s == null ? void 0 : s.getSheetBySheetId(i.subUnitId);
        n && r[i.unitId][i.subUnitId].push(...i.ranges.map((l) => Or.transformRange(l, n)));
      }), Object.entries(r).forEach(([i, s]) => {
        Object.entries(s).forEach(([n, l]) => {
          (e == null ? void 0 : e.getUnitId()) === i && (t == null ? void 0 : t.getSheetId()) === n ? this.validatorRanges(i, n, l) : requestIdleCallback(() => {
            this.validatorRanges(i, n, l);
          });
        });
      });
    };
    this.disposeWithMe(this._dataValidationCacheService.dirtyRanges$.pipe(bufferWhen(() => this._lifecycleService.lifecycle$.pipe(filter((a) => a === ke.Rendered)))).subscribe(o)), this.disposeWithMe(this._dataValidationCacheService.dirtyRanges$.pipe(filter(() => this._lifecycleService.stage >= ke.Rendered), C1(20)).subscribe(o));
  }
  async _validatorByCell(o, a, e, t) {
    const r = o.getUnitId(), i = a.getSheetId();
    if (!J.isDefine(e) || !J.isDefine(t))
      throw new Error(`row or col is not defined, row: ${e}, col: ${t}`);
    const s = this._sheetDataValidationModel.getRuleByLocation(r, i, e, t);
    return s ? new Promise((n) => {
      this._sheetDataValidationModel.validator(s, { unitId: r, subUnitId: i, row: e, col: t, worksheet: a, workbook: o }, (l) => {
        n(l);
      });
    }) : NC.VALID;
  }
  async validatorCell(o, a, e, t) {
    const r = this._univerInstanceService.getUnit(o, we.UNIVER_SHEET);
    if (!r)
      throw new Error(`cannot find current workbook, unitId: ${o}`);
    const i = r.getSheetBySheetId(a);
    if (!i)
      throw new Error(`cannot find current worksheet, sheetId: ${a}`);
    return this._validatorByCell(r, i, e, t);
  }
  validatorRanges(o, a, e) {
    if (!e.length)
      return Promise.resolve([]);
    const t = this._univerInstanceService.getUnit(o, we.UNIVER_SHEET);
    if (!t)
      throw new Error(`cannot find current workbook, unitId: ${o}`);
    const r = t.getSheetBySheetId(a);
    if (!r)
      throw new Error(`cannot find current worksheet, sheetId: ${a}`);
    const s = this._sheetDataValidationModel.getRules(o, a).map((l) => l.ranges).flat(), n = e.map((l) => s.map((u) => Wp(l, u))).flat().filter(Boolean);
    return Promise.all(n.map((l) => {
      const u = [];
      return Or.foreach(l, (d, c) => {
        u.push(this._validatorByCell(t, r, d, c));
      }), Promise.all(u);
    }));
  }
  async validatorWorksheet(o, a) {
    const e = this._univerInstanceService.getUnit(o, we.UNIVER_SHEET);
    if (!e)
      throw new Error(`cannot find current workbook, unitId: ${o}`);
    const t = e.getSheetBySheetId(a);
    if (!t)
      throw new Error(`cannot find current worksheet, sheetId: ${a}`);
    const r = this._sheetDataValidationModel.getRules(o, a);
    return await Promise.all(
      r.map((i) => Promise.all(
        i.ranges.map((s) => {
          const n = [];
          return Or.foreach(s, (l, u) => {
            n.push(this._validatorByCell(e, t, l, u));
          }), Promise.all(n);
        })
      ))
    ), this._dataValidationCacheService.ensureCache(o, a);
  }
  async validatorWorkbook(o) {
    const a = this._sheetDataValidationModel.getSubUnitIds(o), e = await Promise.all(a.map((r) => this.validatorWorksheet(o, r))), t = {};
    return e.forEach((r, i) => {
      t[a[i]] = r;
    }), t;
  }
  getDataValidations(o, a, e) {
    const t = this._sheetDataValidationModel.getRuleObjectMatrix(o, a), r = /* @__PURE__ */ new Set();
    return e.forEach((s) => {
      Or.foreach(s, (n, l) => {
        const u = t.getValue(n, l);
        u && r.add(u);
      });
    }), Array.from(r).map((s) => this._sheetDataValidationModel.getRuleById(o, a, s)).filter(Boolean);
  }
  getDataValidation(o, a, e) {
    return this.getDataValidations(o, a, e)[0];
  }
};
we2 = xa([
  Re(0, vr),
  Re(1, Inject(F2)),
  Re(2, Inject(Q2)),
  Re(3, Inject(Wn))
], we2);
var Pa = Object.defineProperty;
var Ha = Object.getOwnPropertyDescriptor;
var Wa = (o, a, e) => a in o ? Pa(o, a, { enumerable: true, configurable: true, writable: true, value: e }) : o[a] = e;
var $a = (o, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Ha(a, e) : a, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (r = s(r) || r);
  return r;
};
var qe = (o, a) => (e, t) => a(e, t, o);
var vt = (o, a, e) => Wa(o, typeof a != "symbol" ? a + "" : a, e);
var Ie = class extends Ol {
  constructor(o = it, a, e, t) {
    super(), this._config = o, this._injector = a, this._commandService = e, this._configService = t;
    const { ...r } = oo(
      {},
      it,
      this._config
    );
    this._configService.setConfig(ya, r);
  }
  onStarting() {
    [
      [Q2],
      [K],
      [H],
      [we2],
      [F2],
      [Oe],
      [Te],
      [Ce],
      [Ne],
      [Fe]
    ].forEach((o) => {
      this._injector.add(o);
    }), [
      ga2,
      ma,
      pa,
      fa,
      Sa,
      Ra,
      _a
    ].forEach((o) => {
      this._commandService.registerCommand(o);
    }), this._injector.get(Q2), this._injector.get(we2), this._injector.get(Oe), this._injector.get(Fe), this._injector.get(Ne);
  }
  onReady() {
    this._injector.get(Ce);
  }
  onRendered() {
    this._injector.get(Te);
  }
};
vt(Ie, "pluginName", Ea);
vt(Ie, "type", we.UNIVER_SHEET);
Ie = $a([
  qR(C),
  qe(1, Inject(Injector)),
  qe(2, Ls),
  qe(3, ic)
], Ie);
function Za(o) {
  const e = o.get(z).getCurrentSelections().map((i) => i.range);
  return {
    uid: et(6),
    type: TC.DECIMAL,
    operator: AC.EQUAL,
    formula1: "100",
    ranges: e != null ? e : [{ startColumn: 0, endColumn: 0, startRow: 0, endRow: 0 }]
  };
}
var Ja = "data-validation.custom-formula-input";
var er = "data-validation.formula-input";
var tr = "data-validation.list-formula-input";
var ar = "data-validation.checkbox-formula-input";

export {
  Q2 as Q,
  oe,
  pe,
  C2 as C,
  H,
  K,
  ne,
  F2 as F,
  Ee,
  Ve2 as Ve,
  fe,
  ia,
  Ka,
  _e,
  za,
  Le,
  na,
  ye,
  ft,
  Ue2 as Ue,
  ma,
  ga2 as ga,
  pa,
  fa,
  _a,
  Ra,
  Sa,
  Ea,
  Te,
  Da,
  we2 as we,
  Ie,
  Za,
  Ja,
  er,
  tr,
  ar
};
//# sourceMappingURL=chunk-ZKTLMAEM.js.map
