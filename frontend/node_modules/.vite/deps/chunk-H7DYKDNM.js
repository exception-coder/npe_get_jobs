import {
  _n,
  co,
  ey,
  ga2 as ga,
  qu,
  uo
} from "./chunk-I7I3GTAS.js";
import {
  $,
  I
} from "./chunk-YFGUMDM2.js";
import {
  Inject,
  Injector,
  Ls,
  filter,
  firstValueFrom,
  ic,
  map,
  race,
  timer
} from "./chunk-RGZYGL3P.js";

// node_modules/@univerjs/engine-formula/lib/es/facade.js
var T = Object.getOwnPropertyDescriptor;
var N = (e, t, r, i) => {
  for (var o = i > 1 ? void 0 : i ? T(t, r) : t, a = e.length - 1, u; a >= 0; a--)
    (u = e[a]) && (o = u(o) || o);
  return o;
};
var n = (e, t) => (r, i) => t(r, i, e);
var s = class extends $ {
  constructor(e, t, r, i) {
    super(), this._commandService = e, this._injector = t, this._lexerTreeBuilder = r, this._configService = i, this._initialize();
  }
  /**
   * @ignore
   */
  _initialize() {
  }
  /**
   * The tree builder for formula string.
   * @type {LexerTreeBuilder}
   */
  get lexerTreeBuilder() {
    return this._lexerTreeBuilder;
  }
  /**
   * Offsets the formula
   * @param {string} formulaString - The formula string to offset
   * @param {number} refOffsetX - The offset column
   * @param {number} refOffsetY - The offset row
   * @param {boolean} [ignoreAbsolute] - Whether to ignore the absolute reference
   * @returns {string} The offset formula string
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * const result = formulaEngine.moveFormulaRefOffset('=SUM(A1,B2)', 1, 1);
   * console.log(result);
   * ```
   */
  moveFormulaRefOffset(e, t, r, i) {
    return this._lexerTreeBuilder.moveFormulaRefOffset(e, t, r, i);
  }
  /**
   * Resolves the formula string to a 'node' node
   * @param {string} formulaString - The formula string to resolve
   * @returns {Array<ISequenceNode | string>} The nodes of the formula string
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * const nodes = formulaEngine.sequenceNodesBuilder('=SUM(A1,B2)');
   * console.log(nodes);
   * ```
   */
  sequenceNodesBuilder(e) {
    return this._lexerTreeBuilder.sequenceNodesBuilder(e) || [];
  }
  /**
   * Start the calculation of the formula.
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.executeCalculation();
   * ```
   */
  executeCalculation() {
    this._commandService.executeCommand(uo.id, { commands: [], forceCalculation: true }, { onlyLocal: true });
  }
  /**
   * Stop the calculation of the formula.
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.stopCalculation();
   * ```
   */
  stopCalculation() {
    this._commandService.executeCommand(co.id, {});
  }
  /**
   * Listening calculation starts.
   * @param {Function} callback - The callback function to be called when the formula calculation starts.
   * @returns {IDisposable} The disposable instance.
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.calculationStart((forceCalculation) => {
   *   console.log('Calculation start', forceCalculation);
   * });
   * ```
   */
  calculationStart(e) {
    return this._commandService.onCommandExecuted((t) => {
      if (t.id === uo.id) {
        const r = t.params;
        e(r.forceCalculation);
      }
    });
  }
  /**
   * Listening calculation ends.
   * @param {Function} callback - The callback function to be called when the formula calculation ends.
   * @returns {IDisposable} The disposable instance.
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.calculationEnd((functionsExecutedState) => {
   *   console.log('Calculation end', functionsExecutedState);
   * });
   * ```
   */
  calculationEnd(e) {
    return this._commandService.onCommandExecuted((t) => {
      if (t.id !== _n.id)
        return;
      const r = t.params;
      r.functionsExecutedState !== void 0 && e(r.functionsExecutedState);
    });
  }
  /**
   * Wait for computing in the Univer instance to complete. Please note that this does not only include formula calculation,
   * but also other computing tasks, e.g. pivot table calculation.
   * @param {number} [timeout] The maximum time to wait for the computing to complete, in milliseconds. The default
   * value is 30,000 milliseconds.
   * @returns {Promise<boolean>} This method returns `true` if the computing is complete. If the timeout is reached, this
   * method returns `false`.
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.whenComputingCompleteAsync(3000).then((isComplete) => {
   *   console.log('Computing complete:', isComplete);
   * });
   * ```
   */
  whenComputingCompleteAsync(e) {
    const t = this._injector.get(qu);
    return t.computingStatus ? Promise.resolve(true) : firstValueFrom(race(
      t.computingStatus$.pipe(filter((r) => r)),
      timer(e != null ? e : 3e4).pipe(map(() => false))
    ));
  }
  /**
   * @deprecated Use `whenComputingCompleteAsync` instead.
   * @returns {Promise<void>} This method returns a promise that resolves when the calculation is complete.
   */
  onCalculationEnd() {
    return new Promise((e, t) => {
      const r = setTimeout(() => {
        t(new Error("Calculation end timeout"));
      }, 3e4), i = this.calculationEnd(() => {
        clearTimeout(r), i.dispose(), e();
      });
    });
  }
  /**
   * Listening calculation processing.
   * @param {Function} callback - The callback function to be called when the formula calculation is in progress.
   * @returns {IDisposable} The disposable instance.
   *
   * @example
   * ```ts
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.calculationProcessing((stageInfo) => {
   *   console.log('Calculation processing', stageInfo);
   * });
   * ```
   */
  calculationProcessing(e) {
    return this._commandService.onCommandExecuted((t) => {
      if (t.id !== _n.id)
        return;
      const r = t.params;
      r.stageInfo !== void 0 && e(r.stageInfo);
    });
  }
  /**
   * When a formula contains a circular reference, set the maximum number of iterations for the formula calculation.
   * @param {number} maxIteration The maximum number of iterations. The default value is 1.
   *
   * @example
   * ```ts
   * // Set the maximum number of iterations for the formula calculation to 5.
   * // The default value is 1.
   * const formulaEngine = univerAPI.getFormula();
   * formulaEngine.setMaxIteration(5);
   * ```
   */
  setMaxIteration(e) {
    this._configService.setConfig(ey, e);
  }
};
s = N([
  n(0, Inject(Ls)),
  n(1, Inject(Injector)),
  n(2, Inject(ga)),
  n(3, ic)
], s);
var O = class extends I {
  getFormula() {
    return this._injector.createInstance(s);
  }
};
I.extend(O);

export {
  s
};
//# sourceMappingURL=chunk-H7DYKDNM.js.map
