import {
  C,
  He,
  S,
  Y,
  k
} from "./chunk-FOCXVU2X.js";
import {
  Ci,
  Do2 as Do,
  Et2 as Et,
  Fn,
  Kt,
  Mr,
  Oo2 as Oo,
  Op,
  Qt,
  S1,
  So,
  Wi2 as Wi,
  Xc,
  Ye2 as Ye,
  ct,
  gt,
  is2 as is,
  jn,
  kn,
  lr,
  nn,
  oa,
  q1,
  qe2 as qe,
  rd2 as rd,
  sa,
  ss,
  tt3 as tt,
  ue,
  we as we2,
  yi2 as yi
} from "./chunk-DZMX4FYO.js";
import {
  Ch,
  G,
  Kv,
  M4 as M,
  ME,
  eo,
  ha3 as ha,
  ht,
  ib,
  k2,
  mh,
  z
} from "./chunk-I7I3GTAS.js";
import {
  I,
  j
} from "./chunk-YFGUMDM2.js";
import {
  Dl,
  KC,
  Ls,
  We,
  Wn,
  ao,
  combineLatest,
  dn,
  eI,
  et,
  filter,
  ke,
  sr,
  vr,
  we,
  yt
} from "./chunk-RGZYGL3P.js";

// node_modules/@univerjs/sheets-ui/lib/es/facade.js
var xe = class extends I {
  // eslint-disable-next-line max-lines-per-function
  _initSheetUIEvent(e) {
    const r = e.get(Ls);
    this.registerEventHandler(
      this.Event.BeforeSheetEditStart,
      () => r.beforeCommandExecuted((t) => {
        if (t.id !== tt.id) return;
        const i = this.getActiveSheet();
        if (!i) return;
        const { workbook: o, worksheet: s } = i, d = e.get(qe), h = t.params, { visible: g, keycode: l, eventType: a } = h, n = d.getEditLocation();
        if (g) {
          const c = {
            row: n.row,
            column: n.column,
            eventType: a,
            keycode: l,
            workbook: o,
            worksheet: s,
            isZenEditor: false
          };
          if (this.fireEvent(this.Event.BeforeSheetEditStart, c), c.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetEditEnd,
      () => r.beforeCommandExecuted((t) => {
        if (t.id !== tt.id) return;
        const i = this.getActiveSheet();
        if (!i) return;
        const { workbook: o, worksheet: s } = i, d = e.get(qe), h = e.get(vr), g = t.params, { visible: l, keycode: a, eventType: n } = g, c = d.getEditLocation();
        if (!l) {
          const R = {
            row: c.row,
            column: c.column,
            eventType: n,
            keycode: a,
            workbook: o,
            worksheet: s,
            isZenEditor: false,
            value: dn.create(h.getUnit(Dl).getSnapshot()),
            isConfirm: a !== q1.ESC
          };
          if (this.fireEvent(this.Event.BeforeSheetEditEnd, R), R.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.SheetEditStarted,
      () => r.onCommandExecuted((t) => {
        if (t.id !== tt.id) return;
        const i = this.getCommandSheetTarget(t);
        if (!i) return;
        const { workbook: o, worksheet: s } = i, d = e.get(qe), h = t.params, { visible: g, keycode: l, eventType: a } = h, n = d.getEditLocation();
        if (g) {
          const c = {
            row: n.row,
            column: n.column,
            eventType: a,
            keycode: l,
            workbook: o,
            worksheet: s,
            isZenEditor: false
          };
          this.fireEvent(this.Event.SheetEditStarted, c);
        }
      })
    ), this.registerEventHandler(
      this.Event.SheetEditEnded,
      () => r.onCommandExecuted((t) => {
        if (t.id !== tt.id) return;
        const i = this.getCommandSheetTarget(t);
        if (!i) return;
        const { workbook: o, worksheet: s } = i, d = e.get(qe), h = t.params, { visible: g, keycode: l, eventType: a } = h, n = d.getEditLocation();
        if (!g) {
          const c = {
            row: n.row,
            column: n.column,
            eventType: a,
            keycode: l,
            workbook: o,
            worksheet: s,
            isZenEditor: false,
            isConfirm: l !== q1.ESC
          };
          this.fireEvent(this.Event.SheetEditEnded, c);
        }
      })
    ), this.registerEventHandler(
      this.Event.SheetEditChanging,
      () => r.onCommandExecuted((t) => {
        if (t.id !== M.id) return;
        const i = this.getActiveSheet();
        if (!i) return;
        const { workbook: o, worksheet: s } = i, d = e.get(qe), h = e.get(vr), g = t.params;
        if (!d.isVisible().visible) return;
        const { unitId: l } = g;
        if (l === Dl) {
          const { row: a, column: n } = d.getEditLocation(), c = {
            workbook: o,
            worksheet: s,
            row: a,
            column: n,
            value: dn.create(h.getUnit(Dl).getSnapshot()),
            isZenEditor: false
          };
          this.fireEvent(this.Event.SheetEditChanging, c);
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetZoomChange,
      () => r.beforeCommandExecuted((t) => {
        if (t.id !== ss.id) return;
        const i = this.getCommandSheetTarget(t);
        if (!i) return;
        const { workbook: o, worksheet: s } = i, d = {
          zoom: t.params.zoomRatio,
          workbook: o,
          worksheet: s
        };
        if (this.fireEvent(this.Event.BeforeSheetZoomChange, d), d.cancel)
          throw new KC();
      })
    ), this.registerEventHandler(
      this.Event.SheetZoomChanged,
      () => r.onCommandExecuted((t) => {
        if (t.id !== ss.id) return;
        const i = this.getCommandSheetTarget(t);
        if (!i) return;
        const { workbook: o, worksheet: s } = i;
        this.fireEvent(this.Event.SheetZoomChanged, {
          zoom: s.getZoom(),
          workbook: o,
          worksheet: s
        });
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function
  _initObserverListener(e) {
    const r = e.get(ME), t = e.get(Wn), i = new ao();
    this.disposeWithMe(t.lifecycle$.subscribe((h) => {
      if (h !== ke.Rendered) return;
      i.dispose();
      const g = e.get(Mr), l = e.get(Oo);
      g && (this.registerEventHandler(
        this.Event.CellClicked,
        () => {
          var a;
          return (a = g.currentClickedCell$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.location.unitId, n.location.subUnitId);
            c && this.fireEvent(this.Event.CellClicked, {
              ...c,
              ...n,
              row: n.location.row,
              column: n.location.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.CellHover,
        () => {
          var a;
          return (a = g.currentRichText$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.CellHover, {
              ...c,
              ...n,
              row: n.row,
              column: n.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.CellPointerDown,
        () => {
          var a;
          return (a = g.currentPointerDownCell$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.CellPointerDown, {
              ...c,
              ...n,
              row: n.row,
              column: n.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.CellPointerUp,
        () => {
          var a;
          return (a = g.currentPointerUpCell$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.CellPointerUp, {
              ...c,
              ...n,
              row: n.row,
              column: n.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.CellPointerMove,
        () => {
          var a;
          return (a = g.currentCellPosWithEvent$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.CellPointerMove, {
              ...c,
              ...n,
              row: n.row,
              column: n.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.DragOver,
        () => {
          var a;
          return (a = l.currentCell$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.location.unitId, n.location.subUnitId);
            c && this.fireEvent(this.Event.DragOver, {
              ...c,
              ...n,
              row: n.location.row,
              column: n.location.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.Drop,
        () => {
          var a;
          return (a = l.endCell$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.location.unitId, n.location.subUnitId);
            c && this.fireEvent(this.Event.Drop, {
              ...c,
              ...n,
              row: n.location.row,
              column: n.location.col
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.RowHeaderClick,
        () => {
          var a;
          return (a = g.currentRowHeaderClick$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.RowHeaderClick, {
              ...c,
              row: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.RowHeaderPointerDown,
        () => {
          var a;
          return (a = g.currentRowHeaderPointerDown$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.RowHeaderPointerDown, {
              ...c,
              row: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.RowHeaderPointerUp,
        () => {
          var a;
          return (a = g.currentRowHeaderPointerUp$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.RowHeaderPointerUp, {
              ...c,
              row: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.RowHeaderHover,
        () => {
          var a;
          return (a = g.currentHoveredRowHeader$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.RowHeaderHover, {
              ...c,
              row: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.ColumnHeaderClick,
        () => {
          var a;
          return (a = g.currentColHeaderClick$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.ColumnHeaderClick, {
              ...c,
              column: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.ColumnHeaderPointerDown,
        () => {
          var a;
          return (a = g.currentColHeaderPointerDown$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.ColumnHeaderPointerDown, {
              ...c,
              column: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.ColumnHeaderPointerUp,
        () => {
          var a;
          return (a = g.currentColHeaderPointerUp$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.ColumnHeaderPointerUp, {
              ...c,
              column: n.index
            });
          });
        }
      ), this.registerEventHandler(
        this.Event.ColumnHeaderHover,
        () => {
          var a;
          return (a = g.currentHoveredColHeader$) == null ? void 0 : a.pipe(filter((n) => !!n)).subscribe((n) => {
            const c = this.getSheetTarget(n.unitId, n.subUnitId);
            c && this.fireEvent(this.Event.ColumnHeaderHover, {
              ...c,
              column: n.index
            });
          });
        }
      ));
    })), this.disposeWithMe(i);
    const o = /* @__PURE__ */ new Map();
    let s;
    const d = combineLatest([
      r.created$,
      t.lifecycle$
    ]);
    this.disposeWithMe(d.subscribe(([h, g]) => {
      var R;
      if (h.type === we.UNIVER_SHEET && (s = h), g <= ke.Rendered || !s) return;
      const l = new ao(), a = this.getWorkbook(s.unitId);
      if (!a) return;
      o.get(s.unitId) && ((R = o.get(s.unitId)) == null || R.dispose()), o.set(s.unitId, l);
      const n = s.with(Et), c = s.with(z);
      l.add(this.registerEventHandler(
        this.Event.Scroll,
        () => n.validViewportScrollInfo$.subscribe((S2) => {
          S2 && this.fireEvent(this.Event.Scroll, {
            workbook: a,
            worksheet: a.getActiveSheet(),
            ...S2
          });
        })
      )), l.add(this.registerEventHandler(
        this.Event.SelectionMoveStart,
        () => c.selectionMoveStart$.subscribe((S2) => {
          var C2;
          this.fireEvent(this.Event.SelectionMoveStart, {
            workbook: a,
            worksheet: a.getActiveSheet(),
            selections: (C2 = S2 == null ? void 0 : S2.map((I2) => I2.range)) != null ? C2 : []
          });
        })
      )), l.add(this.registerEventHandler(
        this.Event.SelectionMoving,
        () => c.selectionMoving$.subscribe((S2) => {
          var C2;
          this.fireEvent(this.Event.SelectionMoving, {
            workbook: a,
            worksheet: a.getActiveSheet(),
            selections: (C2 = S2 == null ? void 0 : S2.map((I2) => I2.range)) != null ? C2 : []
          });
        })
      )), l.add(this.registerEventHandler(
        this.Event.SelectionMoveEnd,
        () => c.selectionMoveEnd$.subscribe((S2) => {
          var C2;
          this.fireEvent(this.Event.SelectionMoveEnd, {
            workbook: a,
            worksheet: a.getActiveSheet(),
            selections: (C2 = S2 == null ? void 0 : S2.map((I2) => I2.range)) != null ? C2 : []
          });
        })
      )), l.add(this.registerEventHandler(
        this.Event.SelectionChanged,
        () => c.selectionChanged$.subscribe((S2) => {
          var C2;
          this.fireEvent(this.Event.SelectionChanged, {
            workbook: a,
            worksheet: a.getActiveSheet(),
            selections: (C2 = S2 == null ? void 0 : S2.map((I2) => I2.range)) != null ? C2 : []
          });
        })
      )), s = null, this.disposeWithMe(l);
    })), this.disposeWithMe(r.disposed$.subscribe((h) => {
      var g;
      (g = o.get(h)) == null || g.dispose(), o.delete(h);
    })), this.disposeWithMe(() => {
      o.forEach((h) => {
        h.dispose();
      });
    });
  }
  /**
   * @ignore
   */
  _initialize(e) {
    this._initSheetUIEvent(e), this._initObserverListener(e);
    const r = e.get(Ls);
    this.registerEventHandler(
      this.Event.BeforeClipboardChange,
      () => r.beforeCommandExecuted((t) => {
        switch (t.id) {
          case Fn.id:
          case kn.id:
            this._beforeClipboardChange();
            break;
        }
      })
    ), this.registerEventHandler(
      this.Event.ClipboardChanged,
      () => r.onCommandExecuted((t) => {
        switch (t.id) {
          case Fn.id:
          case kn.id:
            this._clipboardChanged();
            break;
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeClipboardPaste,
      () => r.beforeCommandExecuted((t) => {
        switch (t.id) {
          case Xc.id:
            this._beforeClipboardPaste(t.params);
            break;
          case jn.id:
            this._beforeClipboardPasteAsync();
            break;
        }
      })
    ), this.registerEventHandler(
      this.Event.ClipboardPasted,
      () => r.onCommandExecuted((t) => {
        switch (t.id) {
          case Xc.id:
            this._clipboardPaste(t.params);
            break;
          case jn.id:
            this._clipboardPasteAsync();
            break;
        }
      })
    ), this.registerEventHandler(
      this.Event.SheetSkeletonChanged,
      () => r.onCommandExecuted((t) => {
        if (mh.indexOf(t.id) > -1) {
          const i = this.getActiveSheet();
          if (!i) return;
          const o = Ch(t, i.worksheet.getMaxColumns()).map((s) => {
            var d, h;
            return (h = (d = this.getWorkbook(s.unitId)) == null ? void 0 : d.getSheetBySheetId(s.subUnitId)) == null ? void 0 : h.getRange(s.range);
          }).filter(Boolean);
          if (!o.length) return;
          this.fireEvent(this.Event.SheetSkeletonChanged, {
            workbook: i.workbook,
            worksheet: i.worksheet,
            payload: t,
            skeleton: i.worksheet.getSkeleton(),
            effectedRanges: o
          });
        }
      })
    );
  }
  _generateClipboardCopyParam() {
    const e = this.getActiveWorkbook(), r = e == null ? void 0 : e.getActiveSheet(), t = e == null ? void 0 : e.getActiveRange();
    if (!e || !r || !t)
      return;
    const o = this._injector.get(nn).generateCopyContent(e.getId(), r.getSheetId(), t.getRange());
    if (!o)
      return;
    const { html: s, plain: d } = o;
    return {
      workbook: e,
      worksheet: r,
      text: d,
      html: s,
      fromSheet: r,
      fromRange: t
    };
  }
  _beforeClipboardChange() {
    const e = this._generateClipboardCopyParam();
    if (e && (this.fireEvent(this.Event.BeforeClipboardChange, e), e.cancel))
      throw new KC();
  }
  _clipboardChanged() {
    const e = this._generateClipboardCopyParam();
    e && this.fireEvent(this.Event.ClipboardChanged, e);
  }
  _generateClipboardPasteParam(e) {
    if (!e)
      return;
    const { htmlContent: r, textContent: t } = e, i = this.getActiveWorkbook(), o = i == null ? void 0 : i.getActiveSheet();
    return !i || !o ? void 0 : {
      workbook: i,
      worksheet: o,
      text: t,
      html: r
    };
  }
  async _generateClipboardPasteParamAsync() {
    const e = this.getActiveWorkbook(), r = e == null ? void 0 : e.getActiveSheet();
    if (!e || !r)
      return;
    const o = (await this._injector.get(lr).read())[0];
    let s;
    if (o) {
      const d = o.types, h = d.indexOf(Qt) !== -1 ? await o.getType(Qt).then((l) => l && l.text()) : "", g = d.indexOf(Kt) !== -1 ? await o.getType(Kt).then((l) => l && l.text()) : "";
      s = {
        workbook: e,
        worksheet: r,
        text: h,
        html: g
      };
    }
    return s;
  }
  _beforeClipboardPaste(e) {
    const r = this._generateClipboardPasteParam(e);
    if (r && (this.fireEvent(this.Event.BeforeClipboardPaste, r), r.cancel))
      throw new KC();
  }
  _clipboardPaste(e) {
    const r = this._generateClipboardPasteParam(e);
    if (r && (this.fireEvent(this.Event.ClipboardPasted, r), r.cancel))
      throw new KC();
  }
  async _beforeClipboardPasteAsync() {
    if (!So()) {
      this._injector.get(yt).warn("[Facade]: The navigator object only supports the browser environment");
      return;
    }
    const e = await this._generateClipboardPasteParamAsync();
    if (e && (this.fireEvent(this.Event.BeforeClipboardPaste, e), e.cancel))
      throw new KC();
  }
  async _clipboardPasteAsync() {
    if (!So()) {
      this._injector.get(yt).warn("[Facade]: The navigator object only supports the browser environment");
      return;
    }
    const e = await this._generateClipboardPasteParamAsync();
    if (e && (this.fireEvent(this.Event.ClipboardPasted, e), e.cancel))
      throw new KC();
  }
  customizeColumnHeader(e) {
    var g, l;
    const r = this.getActiveWorkbook();
    if (!r) {
      console.error("WorkBook not exist");
      return;
    }
    const t = r == null ? void 0 : r.getId(), i = this._injector.get(ME), o = r.getActiveSheet(), s = o.getSheetId(), d = i.getRenderById(t);
    d && ((g = e.headerStyle) != null && g.size) && (d.with(ue).setColumnHeaderSize(d, s, (l = e.headerStyle) == null ? void 0 : l.size), o == null || o.refreshCanvas()), this._getSheetRenderComponent(t, Ye.COLUMN).setCustomHeader(e), o == null || o.refreshCanvas();
  }
  customizeRowHeader(e) {
    const r = this.getActiveWorkbook();
    if (!r) {
      console.error("WorkBook not exist");
      return;
    }
    const t = r == null ? void 0 : r.getId();
    this._getSheetRenderComponent(t, Ye.ROW).setCustomHeader(e);
  }
  registerSheetRowHeaderExtension(e, ...r) {
    const t = this._getSheetRenderComponent(e, Ye.ROW), i = t.register(...r);
    return We(() => {
      i.dispose(), t.makeDirty(true);
    });
  }
  registerSheetColumnHeaderExtension(e, ...r) {
    const t = this._getSheetRenderComponent(e, Ye.COLUMN), i = t.register(...r);
    return We(() => {
      i.dispose(), t.makeDirty(true);
    });
  }
  registerSheetMainExtension(e, ...r) {
    const t = this._getSheetRenderComponent(e, Ye.MAIN), i = t.register(...r);
    return We(() => {
      i.dispose(), t.makeDirty(true);
    });
  }
  /**
   * Get sheet render component from render by unitId and view key.
   * @private
   * @param {string} unitId The unit id of the spreadsheet.
   * @param {SHEET_VIEW_KEY} viewKey The view key of the spreadsheet.
   * @returns {Nullable<RenderComponentType>} The render component.
   */
  _getSheetRenderComponent(e, r) {
    const i = this._injector.get(ME).getRenderById(e);
    if (!i)
      throw new Error(`Render Unit with unitId ${e} not found`);
    const { components: o } = i, s = o.get(r);
    if (!s)
      throw new Error("Render component not found");
    return s;
  }
  /**
   * Get sheet hooks.
   * @returns {FSheetHooks} FSheetHooks instance
   */
  getSheetHooks() {
    return this._injector.createInstance(He);
  }
  pasteIntoSheet(e, r, t) {
    return this._commandService.executeCommand(Xc.id, { htmlContent: e, textContent: r, files: t });
  }
  setProtectedRangeShadowStrategy(e) {
    this._injector.get(rd).setProtectedRangeShadowStrategy(e);
  }
  getProtectedRangeShadowStrategy() {
    return this._injector.get(rd).getProtectedRangeShadowStrategy();
  }
  getProtectedRangeShadowStrategy$() {
    return this._injector.get(rd).getProtectedRangeShadowStrategy$();
  }
};
I.extend(xe);
var Be = class extends C {
  openSiderbar(e) {
    return this._logDeprecation("openSiderbar"), this._injector.get(we2).open(e);
  }
  openDialog(e) {
    this._logDeprecation("openDialog");
    const t = this._injector.get(ct).open({
      ...e,
      onClose: () => {
        t.dispose();
      }
    });
    return t;
  }
  customizeColumnHeader(e) {
    const r = this._workbook.getUnitId();
    this._getSheetRenderComponent(r, Ye.COLUMN).setCustomHeader(e);
  }
  customizeRowHeader(e) {
    const r = this._workbook.getUnitId();
    this._getSheetRenderComponent(r, Ye.ROW).setCustomHeader(e);
  }
  /**
   * Get sheet render component from render by unitId and view key.
   * @private
   * @param {string} unitId The unit id of the spreadsheet.
   * @param {SHEET_VIEW_KEY} viewKey The view key of the spreadsheet.
   * @returns {Nullable<RenderComponentType>} The render component.
   */
  _getSheetRenderComponent(e, r) {
    const i = this._injector.get(ME).getRenderById(e);
    if (!i)
      throw new Error(`Render Unit with unitId ${e} not found`);
    const { components: o } = i, s = o.get(r);
    if (!s)
      throw new Error("Render component not found");
    return s;
  }
  _logDeprecation(e) {
    this._injector.get(yt).warn("[FWorkbook]", `${e} is deprecated. Please use the function of the same name on "FUniver".`);
  }
  generateCellParams(e) {
    const r = this.getActiveSheet();
    return {
      row: e.row,
      column: e.col,
      workbook: this,
      worksheet: r
    };
  }
  onCellClick(e) {
    const r = this._injector.get(Mr);
    return We(
      r.currentClickedCell$.pipe(filter((t) => !!t)).subscribe((t) => {
        e(t);
      })
    );
  }
  onCellHover(e) {
    const r = this._injector.get(Mr);
    return We(
      r.currentRichText$.pipe(filter((t) => !!t)).subscribe(e)
    );
  }
  onCellPointerDown(e) {
    const r = this._injector.get(Mr);
    return We(
      r.currentPointerDownCell$.subscribe(e)
    );
  }
  onCellPointerUp(e) {
    const r = this._injector.get(Mr);
    return We(
      r.currentPointerUpCell$.subscribe(e)
    );
  }
  onCellPointerMove(e) {
    const r = this._injector.get(Mr);
    return We(
      r.currentCellPosWithEvent$.pipe(filter((t) => !!t)).subscribe((t) => {
        e(t, t.event);
      })
    );
  }
  onDragOver(e) {
    const r = this._injector.get(Oo);
    return We(
      r.currentCell$.pipe(filter((t) => !!t)).subscribe((t) => {
        e(t);
      })
    );
  }
  onDrop(e) {
    const r = this._injector.get(Oo);
    return We(
      r.endCell$.pipe(filter((t) => !!t)).subscribe((t) => {
        e(t);
      })
    );
  }
  startEditing() {
    const e = this._injector.get(Ls);
    return this._injector.get(qe).isVisible().visible ? true : e.syncExecuteCommand(tt.id, {
      eventType: Kv.Dblclick,
      unitId: this._workbook.getUnitId(),
      visible: true
    });
  }
  async endEditing(e) {
    const r = this._injector.get(Ls);
    return this._injector.get(qe).isVisible().visible && r.syncExecuteCommand(tt.id, {
      eventType: Kv.Keyboard,
      keycode: e ? q1.ENTER : q1.ESC,
      visible: false,
      unitId: this._workbook.getUnitId()
    }), await eI(0), true;
  }
  endEditingAsync(e = true) {
    return this.endEditing(e);
  }
  abortEditingAsync() {
    return this.endEditingAsync(false);
  }
  isCellEditing() {
    return this._injector.get(qe).isVisible().visible;
  }
  /**
   * Get scroll state of specified sheet.
   * @param {string} sheetId - sheet id
   * @returns {IScrollState} scroll state
   * @example
   * ``` ts
   * univerAPI.getActiveWorkbook().getScrollStateBySheetId($sheetId)
   * ```
   */
  getScrollStateBySheetId(e) {
    const r = this._workbook.getUnitId(), i = this._injector.get(ME).getRenderById(r);
    return i ? i.with(Et).getScrollStateByParam({ unitId: r, sheetId: e }) : null;
  }
  disableSelection() {
    const e = this._workbook.getUnitId(), t = this._injector.get(ME).getRenderById(e);
    return t && t.with(gt).disableSelection(), this;
  }
  enableSelection() {
    const e = this._workbook.getUnitId(), t = this._injector.get(ME).getRenderById(e);
    return t && t.with(gt).enableSelection(), this;
  }
  transparentSelection() {
    const e = this._workbook.getUnitId(), t = this._injector.get(ME).getRenderById(e);
    return t && t.with(gt).transparentSelection(), this;
  }
  showSelection() {
    const e = this._workbook.getUnitId(), t = this._injector.get(ME).getRenderById(e);
    return t && t.with(gt).showSelection(), this;
  }
};
C.extend(Be);
var De = class extends S {
  refreshCanvas() {
    const e = this._injector.get(ME), r = this._fWorkbook.id, t = e.getRenderById(r);
    if (!t)
      throw new Error(`Render Unit with unitId ${r} not found`);
    t.with(ue).reCalculate();
    const i = t.mainComponent;
    if (!i)
      throw new Error("Main component not found");
    return i.makeDirty(), this;
  }
  highlightRanges(e, r, t) {
    const i = this._injector.get(Wi), o = [];
    for (const s of e) {
      const d = s.getRange(), h = i.addShapeWithNoFresh({ range: d, style: r, primary: t });
      h && o.push(h);
    }
    if (i.refreshShapes(), o.length === 0)
      throw new Error("Failed to highlight current range");
    return We(() => {
      o.forEach((s) => {
        i.removeShape(s);
      });
    });
  }
  zoom(e) {
    const r = this._injector.get(Ls), t = Math.min(Math.max(e, 0.1), 4);
    return r.executeCommand(ss.id, {
      unitId: this._workbook.getUnitId(),
      subUnitId: this._worksheet.getSheetId(),
      zoomRatio: t
    }), this;
  }
  getZoom() {
    return this._worksheet.getZoomRatio();
  }
  getVisibleRange() {
    const e = this._workbook.getUnitId(), t = this._injector.get(ME).getRenderById(e);
    let i = {
      startColumn: 0,
      startRow: 0,
      endColumn: 0,
      endRow: 0
    };
    if (!t) return i;
    const s = t.with(ue).getCurrentSkeleton();
    if (!s) return i;
    const d = s == null ? void 0 : s.getVisibleRanges();
    if (!d) return i;
    i = s.getVisibleRangeByViewport(k2.VIEW_MAIN);
    for (const [h, g] of d)
      ib.indexOf(h) !== -1 && (i.startColumn = Math.min(i.startColumn, g.startColumn), i.startRow = Math.min(i.startRow, g.startRow), i.endColumn = Math.max(i.endColumn, g.endColumn), i.endRow = Math.max(i.endRow, g.endRow));
    return i;
  }
  scrollToCell(e, r, t) {
    const i = this._workbook.getUnitId(), s = this._injector.get(ME).getRenderById(i);
    return s && (s == null ? void 0 : s.with(Ci)).scrollToCell(e, r, t), this;
  }
  getScrollState() {
    const e = {
      offsetX: 0,
      offsetY: 0,
      sheetViewStartColumn: 0,
      sheetViewStartRow: 0
    }, r = this._workbook.getUnitId(), t = this._worksheet.getSheetId(), o = this._injector.get(ME).getRenderById(r);
    return o && o.with(Et).getScrollStateByParam({ unitId: r, sheetId: t }) || e;
  }
  onScroll(e) {
    var o;
    const r = this._workbook.getUnitId(), i = (o = this._injector.get(ME).getRenderById(r)) == null ? void 0 : o.with(Et);
    if (i) {
      const s = i.validViewportScrollInfo$.subscribe((d) => {
        e(d);
      });
      return We(s);
    }
    return We(() => {
    });
  }
  getSkeleton() {
    var r, t;
    const e = (r = this._injector.get(ME).getRenderById(this._workbook.getUnitId())) == null ? void 0 : r.with(ue);
    return (t = e == null ? void 0 : e.getWorksheetSkeleton(this._worksheet.getSheetId())) == null ? void 0 : t.skeleton;
  }
  autoResizeColumn(e) {
    return this.autoResizeColumns(e, 1);
  }
  autoResizeColumns(e, r) {
    const t = this._workbook.getUnitId(), i = this._worksheet.getSheetId(), o = [
      {
        startColumn: e,
        endColumn: e + r - 1,
        startRow: 0,
        endRow: this._worksheet.getRowCount() - 1
      }
    ];
    return this._commandService.syncExecuteCommand(is.id, {
      unitId: t,
      subUnitId: i,
      ranges: o
    }), this;
  }
  setColumnAutoWidth(e, r) {
    return this.autoResizeColumns(e, r);
  }
  autoResizeRows(e, r) {
    const t = this._workbook.getUnitId(), i = this._worksheet.getSheetId(), o = [
      {
        startRow: e,
        endRow: e + r - 1,
        startColumn: 0,
        endColumn: this._worksheet.getColumnCount() - 1
      }
    ];
    return this._commandService.syncExecuteCommand(eo.id, {
      unitId: t,
      subUnitId: i,
      ranges: o
    }), this;
  }
  customizeColumnHeader(e) {
    var d, h;
    const r = this._workbook.getUnitId(), t = this._worksheet.getSheetId(), o = this._injector.get(ME).getRenderById(r);
    o && ((d = e.headerStyle) != null && d.size) && o.with(ue).setColumnHeaderSize(o, t, (h = e.headerStyle) == null ? void 0 : h.size), this._getSheetRenderComponent(r, Ye.COLUMN).setCustomHeader(e, t);
  }
  customizeRowHeader(e) {
    var d, h;
    const r = this._workbook.getUnitId(), t = this._worksheet.getSheetId(), o = this._injector.get(ME).getRenderById(r);
    o && ((d = e.headerStyle) != null && d.size) && o.with(ue).setRowHeaderSize(o, t, (h = e.headerStyle) == null ? void 0 : h.size), this._getSheetRenderComponent(r, Ye.ROW).setCustomHeader(e, t);
  }
  setColumnHeaderHeight(e) {
    const r = this._workbook.getUnitId(), t = this._worksheet.getSheetId();
    return this._commandService.executeCommand(sa.id, {
      unitId: r,
      subUnitId: t,
      size: e
    }), this;
  }
  setRowHeaderWidth(e) {
    const r = this._workbook.getUnitId(), t = this._worksheet.getSheetId();
    return this._commandService.executeCommand(oa.id, {
      unitId: r,
      subUnitId: t,
      size: e
    }), this;
  }
  /**
   * Get sheet render component from render by unitId and view key.
   * @private
   * @param {string} unitId The unit id of the spreadsheet.
   * @param {SHEET_VIEW_KEY} viewKey The view key of the spreadsheet.
   * @returns {Nullable<RenderComponentType>} The render component.
   */
  _getSheetRenderComponent(e, r) {
    const i = this._injector.get(ME).getRenderById(e);
    if (!i)
      throw new Error(`Render Unit with unitId ${e} not found`);
    const { components: o } = i, s = o.get(r);
    if (!s)
      throw new Error("Render component not found");
    return s;
  }
};
S.extend(De);
var Te = class extends Y {
  setPermissionDialogVisible(e) {
    this._permissionService.setShowComponents(e);
  }
};
Y.extend(Te);
var Ae = class extends He {
  onCellPointerMove(e) {
    return We(this._injector.get(Mr).currentPosition$.subscribe(e));
  }
  onCellPointerOver(e) {
    return We(this._injector.get(Mr).currentCell$.subscribe(e));
  }
  onCellDragOver(e) {
    return We(this._injector.get(Oo).currentCell$.subscribe(e));
  }
  onCellDrop(e) {
    return We(this._injector.get(Oo).endCell$.subscribe(e));
  }
  onCellRender(e, r = sr.Style, t = ha.DATA_VALIDATION) {
    return this._injector.get(G).intercept(ht.CELL_CONTENT, {
      effect: r,
      handler: (i, o, s) => (i && !i.customRender && e && (i.customRender = [...e]), s(i)),
      priority: t
    });
  }
  onBeforeCellEdit(e) {
    return this._injector.get(Ls).beforeCommandExecuted((r) => {
      const t = r.params;
      r.id === tt.id && t.visible && e(t);
    });
  }
  onAfterCellEdit(e) {
    return this._injector.get(Ls).onCommandExecuted((r) => {
      const t = r.params;
      r.id === tt.id && !t.visible && e(t);
    });
  }
};
He.extend(Ae);
var H = {
  CellClicked: "CellClicked",
  CellPointerDown: "CellPointerDown",
  CellPointerUp: "CellPointerUp",
  CellPointerMove: "CellPointerMove",
  CellHover: "CellHover"
};
var je = class {
  get BeforeClipboardChange() {
    return "BeforeClipboardChange";
  }
  get ClipboardChanged() {
    return "ClipboardChanged";
  }
  get BeforeClipboardPaste() {
    return "BeforeClipboardPaste";
  }
  get ClipboardPasted() {
    return "ClipboardPasted";
  }
  get BeforeSheetEditStart() {
    return "BeforeSheetEditStart";
  }
  get SheetEditStarted() {
    return "SheetEditStarted";
  }
  get SheetEditChanging() {
    return "SheetEditChanging";
  }
  get BeforeSheetEditEnd() {
    return "BeforeSheetEditEnd";
  }
  get SheetEditEnded() {
    return "SheetEditEnded";
  }
  get CellClicked() {
    return H.CellClicked;
  }
  get CellHover() {
    return H.CellHover;
  }
  get CellPointerDown() {
    return H.CellPointerDown;
  }
  get CellPointerUp() {
    return H.CellPointerUp;
  }
  get CellPointerMove() {
    return H.CellPointerMove;
  }
  get DragOver() {
    return "DragOver";
  }
  get Drop() {
    return "Drop";
  }
  get Scroll() {
    return "Scroll";
  }
  get SelectionMoveStart() {
    return "SelectionMoveStart";
  }
  get SelectionChanged() {
    return "SelectionChanged";
  }
  get SelectionMoving() {
    return "SelectionMoving";
  }
  get SelectionMoveEnd() {
    return "SelectionMoveEnd";
  }
  get RowHeaderClick() {
    return "RowHeaderClick";
  }
  get RowHeaderPointerDown() {
    return "RowHeaderPointerDown";
  }
  get RowHeaderPointerUp() {
    return "RowHeaderPointerUp";
  }
  get RowHeaderHover() {
    return "RowHeaderHover";
  }
  get ColumnHeaderClick() {
    return "ColumnHeaderClick";
  }
  get ColumnHeaderPointerDown() {
    return "ColumnHeaderPointerDown";
  }
  get ColumnHeaderPointerUp() {
    return "ColumnHeaderPointerUp";
  }
  get ColumnHeaderHover() {
    return "ColumnHeaderHover";
  }
  get SheetSkeletonChanged() {
    return "SheetSkeletonChanged";
  }
  get BeforeSheetZoomChange() {
    return "BeforeSheetZoomChange";
  }
  get SheetZoomChanged() {
    return "SheetZoomChanged";
  }
};
j.extend(je);
var $e = class extends k {
  getCell() {
    var d;
    const e = this._injector.get(ME), r = this._injector.get(yt), t = this._workbook.getUnitId(), i = this._worksheet.getSheetId(), o = e.getRenderById(t), s = (d = o == null ? void 0 : o.with(ue).getSkeletonParam(i)) == null ? void 0 : d.skeleton;
    if (!s)
      throw r.error("[Facade]: `FRange.getCell` can only be called in current worksheet"), new Error("`FRange.getCell` can only be called in current worksheet");
    return s.getCellWithCoordByIndex(this._range.startRow, this._range.startColumn);
  }
  getCellRect() {
    const { startX: e, startY: r, endX: t, endY: i } = this.getCell(), o = { x: e, y: r, width: t - e, height: i - r, top: r, left: e, bottom: i, right: t };
    return { ...o, toJSON: () => JSON.stringify(o) };
  }
  generateHTML() {
    var t;
    const r = this._injector.get(nn).generateCopyContent(
      this._workbook.getUnitId(),
      this._worksheet.getSheetId(),
      this._range
    );
    return (t = r == null ? void 0 : r.html) != null ? t : "";
  }
  attachPopup(e) {
    var s, d, h;
    e.direction = (s = e.direction) != null ? s : "horizontal", e.extraProps = (d = e.extraProps) != null ? d : {}, e.offset = (h = e.offset) != null ? h : [0, 0];
    const { key: r, disposableCollection: t } = q(e, this._injector.get(S1)), o = this._injector.get(yi).attachPopupToCell(
      this._range.startRow,
      this._range.startColumn,
      { ...e, componentKey: r },
      this.getUnitId(),
      this._worksheet.getSheetId()
    );
    return o ? (t.add(o), t) : (t.dispose(), null);
  }
  attachAlertPopup(e) {
    const r = this._injector.get(Do), t = {
      workbook: this._workbook,
      worksheet: this._worksheet,
      row: this._range.startRow,
      col: this._range.startColumn,
      unitId: this.getUnitId(),
      subUnitId: this._worksheet.getSheetId()
    };
    return r.showAlert({
      ...e,
      location: t
    }), {
      dispose: () => {
        r.removeAlert(e.key);
      }
    };
  }
  /**
   * attachDOMPopup
   * @param popup
   * @returns {IDisposable} disposable
      let sheet = univerAPI.getActiveWorkbook().getActiveSheet();
      let range = sheet.getRange(2, 2, 3, 3);
      univerAPI.getActiveWorkbook().setActiveRange(range);
      let disposable = range.attachDOMPopup({
      componentKey: 'univer.sheet.single-dom-popup',
      extraProps: { alert: { type: 0, title: 'This is an Info', message: 'This is an info message' } },
      });
   */
  attachRangePopup(e) {
    var s, d, h;
    e.direction = (s = e.direction) != null ? s : "top-center", e.extraProps = (d = e.extraProps) != null ? d : {}, e.offset = (h = e.offset) != null ? h : [0, 0];
    const { key: r, disposableCollection: t } = q(e, this._injector.get(S1)), o = this._injector.get(yi).attachRangePopup(
      this._range,
      { ...e, componentKey: r },
      this.getUnitId(),
      this._worksheet.getSheetId()
    );
    return o ? (t.add(o), t) : (t.dispose(), null);
  }
  highlight(e, r) {
    const t = this._injector.get(Wi), i = t.addShape({ range: this._range, style: e, primary: r });
    if (!i)
      throw new Error("Failed to highlight current range");
    return We(() => {
      t.removeShape(i);
    });
  }
  showDropdown(e) {
    return this._injector.get(Op).showDropdown(e);
  }
};
k.extend($e);
function q(b, e) {
  const { componentKey: r, isVue3: t } = b;
  let i;
  const o = new ao();
  return typeof r == "string" ? i = r : (i = `External_${et(6)}`, o.add(e.register(i, r, { framework: t ? "vue3" : "react" }))), {
    key: i,
    disposableCollection: o
  };
}

export {
  q
};
//# sourceMappingURL=chunk-WEJEHBT6.js.map
