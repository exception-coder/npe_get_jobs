import {
  E,
  Y,
  f,
  g,
  h
} from "./chunk-MO6OUX3Q.js";
import {
  Ap,
  B1,
  Bi,
  Cr,
  De,
  H1,
  Hr,
  Jt2 as Jt,
  Mr,
  Ri,
  S1,
  Sa,
  Xf,
  Yn2 as Yn,
  _a,
  ar,
  bo,
  connectInjector,
  ct,
  e2,
  et as et2,
  et2 as et3,
  gn,
  gt,
  he,
  lr,
  nn,
  nt,
  q1,
  qe2 as qe,
  tt3 as tt,
  u7,
  ue,
  useDependency,
  ut,
  we as we2,
  wr2 as wr,
  ye as ye2,
  yi2 as yi
} from "./chunk-DZMX4FYO.js";
import {
  At2 as At,
  Bn,
  Es,
  Fn as Fn2,
  G,
  GB,
  Gn,
  HT,
  I1,
  IE,
  Le,
  ME,
  Mt2 as Mt,
  Mt3 as Mt2,
  Nt,
  On3 as On,
  P,
  Pe,
  Pt,
  Q1,
  Qt3 as Qt,
  Sn2 as Sn,
  Tt,
  U,
  V,
  Ve as Ve2,
  Vv,
  Xe2 as Xe,
  Xo,
  Xv,
  Ye,
  Yt3 as Yt,
  Zt2 as Zt,
  _n2 as _n,
  an2 as an,
  bs2 as bs,
  bt,
  cs,
  de,
  ds,
  fn,
  ha3 as ha,
  hr,
  ht,
  k2,
  ln,
  ln2,
  ls,
  mh,
  mn,
  mn2,
  mt,
  nt as nt2,
  on2 as on,
  pn2 as pn,
  rn,
  s7,
  st,
  un2 as un,
  v1 as v12,
  vn2 as vn,
  vt,
  w3,
  wn2 as wn,
  x3,
  ye,
  z,
  zn
} from "./chunk-I7I3GTAS.js";
import {
  $C,
  GE,
  LE,
  TE,
  UE,
  em,
  ep,
  ie as ie2,
  kE,
  kt,
  require_jsx_runtime,
  require_react,
  vr as vr2,
  xE
} from "./chunk-YFGUMDM2.js";
import {
  BehaviorSubject,
  Cm,
  Dl,
  EMPTY,
  El,
  En,
  Fm,
  Fn,
  GC,
  Hc,
  Inject,
  Injector,
  J,
  Je,
  Jo,
  Jr,
  Km,
  Ls,
  Ms,
  Nr,
  Ol,
  PR,
  Pm,
  Qo,
  Rs,
  Subject,
  TR,
  UR,
  Ul,
  Ve,
  We,
  Wn,
  Xm,
  ao,
  combineLatest,
  createIdentifier,
  dR,
  distinctUntilChanged,
  eC,
  et,
  filter,
  fo,
  gE,
  h1,
  ic,
  ie,
  ke,
  mE,
  map,
  n1,
  ng,
  oc,
  of,
  oo,
  pE,
  pt,
  qR,
  sr,
  switchMap,
  take,
  takeUntil,
  tap,
  tg,
  throttleTime,
  v1,
  vr,
  we,
  zc
} from "./chunk-RGZYGL3P.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@univerjs/docs-drawing/lib/es/index.js
var f2 = Object.defineProperty;
var p = (r, t, e) => t in r ? f2(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var _ = (r, t, e) => p(r, typeof t != "symbol" ? t + "" : t, e);
var d = class extends ln2 {
};
var l = createIdentifier("univer.doc.plugin.doc-drawing.service");
var E2 = Object.getOwnPropertyDescriptor;
var G2 = (r, t, e, n) => {
  for (var i = n > 1 ? void 0 : n ? E2(t, e) : t, a = r.length - 1, s; a >= 0; a--)
    (s = r[a]) && (i = s(i) || i);
  return i;
};
var o = (r, t) => (e, n) => t(e, n, r);
var w = "DOC_DRAWING_PLUGIN";
var D = class extends Ve {
  constructor(r, t, e, n) {
    super(), this._docDrawingService = r, this._drawingManagerService = t, this._resourceManagerService = e, this._univerInstanceService = n, this._init();
  }
  _init() {
    this._initSnapshot();
  }
  _initSnapshot() {
    const r = (e) => {
      const n = this._univerInstanceService.getUnit(e, we.UNIVER_DOC);
      if (n) {
        const i = n.getSnapshot().drawings, a = n.getSnapshot().drawingsOrder, s = {
          data: i != null ? i : {},
          order: a != null ? a : []
        };
        return JSON.stringify(s);
      }
      return "";
    }, t = (e) => {
      if (!e)
        return { data: {}, order: [] };
      try {
        return JSON.parse(e);
      } catch {
        return { data: {}, order: [] };
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        pluginName: w,
        businesses: [we.UNIVER_DOC],
        toJson: (e) => r(e),
        parseJson: (e) => t(e),
        onUnLoad: (e) => {
          this._setDrawingDataForUnit(e, { data: {}, order: [] });
        },
        onLoad: (e, n) => {
          var i, a;
          this._setDrawingDataForUnit(e, { data: (i = n.data) != null ? i : {}, order: (a = n.order) != null ? a : [] });
        }
      })
    );
  }
  _setDrawingDataForUnit(r, t) {
    const e = this._univerInstanceService.getUnit(r);
    e != null && (e.resetDrawing(t.data, t.order), this.loadDrawingDataForUnit(r));
  }
  loadDrawingDataForUnit(r) {
    const t = this._univerInstanceService.getUnit(r, we.UNIVER_DOC);
    if (!t)
      return false;
    const e = r, n = t.getDrawings(), i = t.getDrawingsOrder();
    if (!n || !i)
      return false;
    Object.keys(n).forEach((s) => {
      const S = n[s];
      n[s] = { ...S };
    });
    const a = {
      [e]: {
        unitId: r,
        subUnitId: e,
        data: n,
        order: i
      }
    };
    return this._docDrawingService.registerDrawingData(r, a), this._drawingManagerService.registerDrawingData(r, a), true;
  }
};
D = G2([
  o(0, l),
  o(1, Mt2),
  o(2, Jo),
  o(3, vr)
], D);
var F = "docs-drawing.config";
var v = {};
var J2 = Object.getOwnPropertyDescriptor;
var L = (r, t, e, n) => {
  for (var i = n > 1 ? void 0 : n ? J2(t, e) : t, a = r.length - 1, s; a >= 0; a--)
    (s = r[a]) && (i = s(i) || i);
  return i;
};
var u = (r, t) => (e, n) => t(e, n, r);
var c;
var h2 = (c = class extends Ol {
  constructor(r = v, t, e) {
    super(), this._config = r, this._injector = t, this._configService = e;
    const { ...n } = oo(
      {},
      v,
      this._config
    );
    this._configService.setConfig(F, n);
  }
  onStarting() {
    [
      [D],
      [d],
      [l, { useClass: d }]
    ].forEach((r) => this._injector.add(r)), zc(this._injector, [
      [D]
    ]);
  }
}, _(c, "pluginName", w), _(c, "type", we.UNIVER_DOC), c);
h2 = L([
  u(1, Inject(Injector)),
  u(2, ic)
], h2);

// node_modules/@univerjs/drawing-ui/lib/es/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var Ot = Object.defineProperty;
var Dt = (i, r, e) => r in i ? Ot(i, r, { enumerable: true, configurable: true, writable: true, value: e }) : i[r] = e;
var J3 = (i, r, e) => Dt(i, typeof r != "symbol" ? r + "" : r, e);
var D2 = ((i) => (i.default = "0", i.left = "1", i.center = "2", i.right = "3", i.top = "4", i.middle = "5", i.bottom = "6", i.horizon = "7", i.vertical = "8", i))(D2 || {});
var ze = {
  id: "sheet.operation.set-image-align",
  type: Ms.OPERATION,
  handler: (i, r) => true
};
var Ze = {
  id: "sheet.operation.open-image-crop",
  type: Ms.OPERATION,
  handler: (i, r) => true
};
var oe = {
  id: "sheet.operation.close-image-crop",
  type: Ms.OPERATION,
  handler: (i, r) => true
};
var x = ((i) => (i.FREE = "0", i.R1_1 = "1", i.R16_9 = "2", i.R9_16 = "3", i.R5_4 = "4", i.R4_5 = "5", i.R4_3 = "6", i.R3_4 = "7", i.R3_2 = "8", i.R2_3 = "9", i))(x || {});
var Pe2 = {
  id: "sheet.operation.Auto-image-crop",
  type: Ms.OPERATION,
  handler: (i, r) => true
};
var ut2 = {
  id: "sheet.operation.image-reset-size",
  type: Ms.OPERATION,
  handler: (i, r) => true
};
var Yt2 = "drawing-ui.config";
var Qe = {};
var Xt = "COMPONENT_IMAGE_POPUP_MENU";
function z2({ ref: i, ...r }) {
  const { icon: e, id: t, className: n, extend: s, ...a } = r, o2 = `univerjs-icon univerjs-icon-${t} ${n || ""}`.trim(), c2 = (0, import_react.useRef)(`_${Qt2()}`);
  return gt2(e, `${t}`, {
    defIds: e.defIds,
    idSuffix: c2.current
  }, {
    ref: i,
    className: o2,
    ...a
  }, s);
}
function gt2(i, r, e, t, n) {
  return (0, import_react.createElement)(i.tag, {
    key: r,
    ...Jt2(i, e, n),
    ...t
  }, (qt(i, e).children || []).map((s, a) => gt2(s, `${r}-${i.tag}-${a}`, e, void 0, n)));
}
function Jt2(i, r, e) {
  const t = { ...i.attrs };
  e != null && e.colorChannel1 && t.fill === "colorChannel1" && (t.fill = e.colorChannel1), i.tag === "mask" && t.id && (t.id = t.id + r.idSuffix), Object.entries(t).forEach(([s, a]) => {
    s === "mask" && typeof a == "string" && (t[s] = a.replace(/url\(#(.*)\)/, `url(#$1${r.idSuffix})`));
  });
  const { defIds: n } = r;
  return !n || n.length === 0 || (i.tag === "use" && t["xlink:href"] && (t["xlink:href"] = t["xlink:href"] + r.idSuffix), Object.entries(t).forEach(([s, a]) => {
    typeof a == "string" && (t[s] = a.replace(/url\(#(.*)\)/, `url(#$1${r.idSuffix})`));
  })), t;
}
function qt(i, r) {
  var t;
  const { defIds: e } = r;
  return !e || e.length === 0 ? i : i.tag === "defs" && ((t = i.children) != null && t.length) ? {
    ...i,
    children: i.children.map((n) => typeof n.attrs.id == "string" && e && e.includes(n.attrs.id) ? {
      ...n,
      attrs: {
        ...n.attrs,
        id: n.attrs.id + r.idSuffix
      }
    } : n)
  } : i;
}
function Qt2() {
  return Math.random().toString(36).substring(2, 8);
}
z2.displayName = "UniverIcon";
var er = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 17 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M14.0045 4.4334C14.8881 4.4334 15.6045 3.71705 15.6045 2.8334C15.6045 1.94974 14.8881 1.2334 14.0045 1.2334H3.70449C2.82084 1.2334 2.10449 1.94974 2.10449 2.8334C2.10449 3.71705 2.82084 4.4334 3.70449 4.4334H14.0045ZM14.4045 2.8334C14.4045 3.05431 14.2254 3.2334 14.0045 3.2334H3.70449C3.48358 3.2334 3.30449 3.05431 3.30449 2.8334C3.30449 2.61248 3.48358 2.4334 3.70449 2.4334H14.0045C14.2254 2.4334 14.4045 2.61249 14.4045 2.8334Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M14.1544 8.5999C15.038 8.5999 15.7544 7.88356 15.7544 6.9999C15.7544 6.11625 15.038 5.3999 14.1544 5.3999H3.85439C2.97074 5.3999 2.25439 6.11625 2.25439 6.9999C2.25439 7.88356 2.97074 8.5999 3.85439 8.5999H14.1544ZM14.5544 6.9999C14.5544 7.22082 14.3753 7.3999 14.1544 7.3999H3.85439C3.63348 7.3999 3.45439 7.22082 3.45439 6.9999C3.45439 6.77899 3.63348 6.5999 3.85439 6.5999H14.1544C14.3753 6.5999 14.5544 6.77899 14.5544 6.9999Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M8.57975 14.5902L6.58023 12.5907C6.34591 12.3564 6.34591 11.9765 6.58023 11.7421C6.81454 11.5078 7.19444 11.5078 7.42876 11.7421L8.40449 12.7179V10.1664C8.40449 9.83504 8.67312 9.56641 9.00449 9.56641C9.33586 9.56641 9.60449 9.83504 9.60449 10.1664V12.7179L10.5802 11.7421C10.8145 11.5078 11.1944 11.5078 11.4288 11.7421C11.6631 11.9765 11.6631 12.3564 11.4288 12.5907L9.42923 14.5902"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M8.57975 14.5902C8.58121 14.5917 8.58268 14.5931 8.58416 14.5946C8.64077 14.6502 8.70566 14.6923 8.77482 14.7209C8.84557 14.7502 8.92314 14.7664 9.00449 14.7664C9.08585 14.7664 9.16342 14.7502 9.23416 14.7209C9.30332 14.6923 9.36821 14.6502 9.42482 14.5946"
      }
    }
  ]
};
var dt = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "bottom-icon",
    ref: e,
    icon: er
  }));
});
dt.displayName = "BottomIcon";
var tr = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M5.97705 7.51296C5.97705 7.18159 6.24568 6.91296 6.57705 6.91296H8.48632C8.81769 6.91296 9.08632 7.18159 9.08632 7.51296C9.08632 7.84433 8.81769 8.11296 8.48632 8.11296H6.57705C6.24568 8.11296 5.97705 7.84433 5.97705 7.51296Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M6.57705 9.41028C6.24568 9.41028 5.97705 9.67891 5.97705 10.0103C5.97705 10.3416 6.24568 10.6103 6.57705 10.6103H10.8199C11.1512 10.6103 11.4199 10.3416 11.4199 10.0103C11.4199 9.67891 11.1512 9.41028 10.8199 9.41028H6.57705Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M3.51074 2.37063C3.51074 1.48697 4.22709 0.77063 5.11074 0.77063H9.80318L9.81294 0.770708C9.97168 0.768161 10.1311 0.82824 10.2511 0.95055L14.4317 5.21408C14.5165 5.30049 14.5697 5.406 14.5917 5.51645C14.6041 5.5644 14.6106 5.61467 14.6106 5.66648V11.6406C14.6106 12.5243 13.8943 13.2406 13.0106 13.2406H5.11074C4.22709 13.2406 3.51074 12.5243 3.51074 11.6406V2.37063ZM10.4032 4.66648V2.81964L12.6063 5.06648H10.8032C10.5823 5.06648 10.4032 4.88739 10.4032 4.66648ZM5.11074 1.97063C4.88983 1.97063 4.71074 2.14972 4.71074 2.37063V11.6406C4.71074 11.8615 4.88983 12.0406 5.11074 12.0406H13.0106C13.2316 12.0406 13.4106 11.8615 13.4106 11.6406V6.26648H10.8032C9.91953 6.26648 9.20318 5.55013 9.20318 4.66648V1.97063H5.11074Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M2.58916 6.6741C2.58916 6.34273 2.32053 6.0741 1.98916 6.0741C1.65779 6.0741 1.38916 6.34273 1.38916 6.6741V12.6294C1.38916 14.0653 2.55322 15.2294 3.98916 15.2294H9.41408C9.74545 15.2294 10.0141 14.9607 10.0141 14.6294C10.0141 14.298 9.74545 14.0294 9.41408 14.0294H3.98916C3.21596 14.0294 2.58916 13.4026 2.58916 12.6294V6.6741Z"
      }
    }
  ]
};
var ht2 = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "create-copy-icon",
    ref: e,
    icon: tr
  }));
});
ht2.displayName = "CreateCopyIcon";
var rr = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 17 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M7.38125 1.16211C6.49759 1.16211 5.78125 1.87845 5.78125 2.76211V5.6377H2.87783C1.99418 5.6377 1.27783 6.35404 1.27783 7.2377V13.2377C1.27783 14.1214 1.99418 14.8377 2.87783 14.8377H8.87783C9.76149 14.8377 10.4778 14.1214 10.4778 13.2377V10.3621H13.3813C14.2649 10.3621 14.9813 9.64577 14.9813 8.76211V2.76211C14.9813 1.87845 14.2649 1.16211 13.3813 1.16211H7.38125ZM10.4778 9.16211H13.3813C13.6022 9.16211 13.7812 8.98302 13.7812 8.76211V2.76211C13.7812 2.5412 13.6022 2.36211 13.3813 2.36211H7.38125C7.16034 2.36211 6.98125 2.5412 6.98125 2.76211V5.6377H8.87783C9.76149 5.6377 10.4778 6.35404 10.4778 7.2377V9.16211ZM6.98125 6.8377H8.87783C9.09875 6.8377 9.27783 7.01678 9.27783 7.2377V9.16211H7.38125C7.16034 9.16211 6.98125 8.98302 6.98125 8.76211V6.8377ZM5.78125 6.8377V8.76211C5.78125 9.64577 6.49759 10.3621 7.38125 10.3621H9.27783V13.2377C9.27783 13.4586 9.09875 13.6377 8.87783 13.6377H2.87783C2.65692 13.6377 2.47783 13.4586 2.47783 13.2377V7.2377C2.47783 7.01678 2.65692 6.8377 2.87783 6.8377H5.78125Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }]
};
var ft = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "group-icon",
    ref: e,
    icon: rr
  }));
});
ft.displayName = "GroupIcon";
var nr = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M11.3536 6.14645C11.5488 6.34171 11.5488 6.65829 11.3536 6.85355L8.35355 9.85355C8.15829 10.0488 7.84171 10.0488 7.64645 9.85355L4.64645 6.85355C4.45118 6.65829 4.45118 6.34171 4.64645 6.14645C4.84171 5.95118 5.15829 5.95118 5.35355 6.14645L8 8.79289L10.6464 6.14645C10.8417 5.95118 11.1583 5.95118 11.3536 6.14645Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }]
};
var pt2 = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "more-down-icon",
    ref: e,
    icon: nr
  }));
});
pt2.displayName = "MoreDownIcon";
var ir = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M1.25 2.96401C1.25 3.84767 1.96634 4.56401 2.85 4.56401H13.15C14.0337 4.56401 14.75 3.84767 14.75 2.96401C14.75 2.08036 14.0337 1.36401 13.15 1.36401H2.85C1.96635 1.36401 1.25 2.08036 1.25 2.96401ZM2.85 3.36401C2.62909 3.36401 2.45 3.18493 2.45 2.96401C2.45 2.7431 2.62909 2.56401 2.85 2.56401H13.15C13.3709 2.56401 13.55 2.7431 13.55 2.96401C13.55 3.18493 13.3709 3.36401 13.15 3.36401H2.85Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M5.57564 11.6118C5.80995 11.3774 6.18985 11.3774 6.42417 11.6118L7.3999 12.5875V6.36951C7.3999 6.03814 7.66853 5.76951 7.9999 5.76951C8.33127 5.76951 8.5999 6.03814 8.5999 6.36951V12.5875L9.57564 11.6118C9.80995 11.3774 10.1899 11.3774 10.4242 11.6118C10.6585 11.8461 10.6585 12.226 10.4242 12.4603L8.4324 14.452C8.32324 14.5655 8.16982 14.6362 7.9999 14.6362C7.82998 14.6362 7.67655 14.5655 7.56739 14.452L5.57564 12.4603C5.34132 12.226 5.34132 11.8461 5.57564 11.6118Z"
    }
  }]
};
var mt2 = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "move-down-icon",
    ref: e,
    icon: ir
  }));
});
mt2.displayName = "MoveDownIcon";
var ar2 = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M1.25 13.036C1.25 12.1523 1.96634 11.436 2.85 11.436H13.15C14.0337 11.436 14.75 12.1523 14.75 13.036C14.75 13.9196 14.0337 14.636 13.15 14.636H2.85C1.96635 14.636 1.25 13.9196 1.25 13.036ZM2.85 12.636C2.62909 12.636 2.45 12.8151 2.45 13.036C2.45 13.2569 2.62909 13.436 2.85 13.436H13.15C13.3709 13.436 13.55 13.2569 13.55 13.036C13.55 12.8151 13.3709 12.636 13.15 12.636H2.85Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M5.57564 4.38825C5.80995 4.62256 6.18985 4.62256 6.42417 4.38825L7.3999 3.41251V9.63049C7.3999 9.96186 7.66853 10.2305 7.9999 10.2305C8.33127 10.2305 8.5999 9.96186 8.5999 9.63049V3.41251L9.57564 4.38825C9.80995 4.62256 10.1899 4.62256 10.4242 4.38825C10.6585 4.15393 10.6585 3.77403 10.4242 3.53972L8.4324 1.54796C8.32324 1.43445 8.16982 1.36382 7.9999 1.36382C7.82998 1.36382 7.67655 1.43446 7.56739 1.54797L5.57564 3.53972C5.34132 3.77403 5.34132 4.15393 5.57564 4.38825Z"
    }
  }]
};
var wt = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "move-up-icon",
    ref: e,
    icon: ar2
  }));
});
wt.displayName = "MoveUpIcon";
var sr2 = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 17 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M7.82994 1.40913C7.88746 1.35161 7.95376 1.30821 8.02453 1.27893C8.09527 1.24959 8.17285 1.2334 8.2542 1.2334C8.33555 1.2334 8.41313 1.24959 8.48387 1.27893C8.55464 1.30821 8.62094 1.35161 8.67846 1.40913L10.6785 3.40913C10.9128 3.64345 10.9128 4.02335 10.6785 4.25766C10.4441 4.49198 10.0642 4.49198 9.82994 4.25766L8.8542 3.28193V5.8334C8.8542 6.16477 8.58557 6.4334 8.2542 6.4334C7.92283 6.4334 7.6542 6.16477 7.6542 5.8334V3.28193L6.67846 4.25766C6.44415 4.49198 6.06425 4.49198 5.82994 4.25766C5.59562 4.02335 5.59562 3.64345 5.82994 3.40913L7.82994 1.40913Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.50439 9C1.50439 8.11634 2.22074 7.4 3.10439 7.4H13.4044C14.288 7.4 15.0044 8.11634 15.0044 9C15.0044 9.88366 14.2881 10.6 13.4044 10.6H3.1044C2.22074 10.6 1.50439 9.88366 1.50439 9ZM3.10439 8.6C2.88348 8.6 2.70439 8.77909 2.70439 9C2.70439 9.22091 2.88348 9.4 3.1044 9.4H13.4044C13.6253 9.4 13.8044 9.22091 13.8044 9C13.8044 8.77909 13.6253 8.6 13.4044 8.6H3.10439Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.6543 13.1665C1.6543 12.2828 2.37064 11.5665 3.2543 11.5665H13.5543C14.438 11.5665 15.1543 12.2828 15.1543 13.1665C15.1543 14.0502 14.438 14.7665 13.5543 14.7665H3.2543C2.37064 14.7665 1.6543 14.0502 1.6543 13.1665ZM3.2543 12.7665C3.03338 12.7665 2.8543 12.9456 2.8543 13.1665C2.8543 13.3874 3.03338 13.5665 3.2543 13.5665H13.5543C13.7752 13.5665 13.9543 13.3874 13.9543 13.1665C13.9543 12.9456 13.7752 12.7665 13.5543 12.7665H3.2543Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    }
  ]
};
var vt2 = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "topmost-icon",
    ref: e,
    icon: sr2
  }));
});
vt2.displayName = "TopmostIcon";
var or = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 17 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M7.46855 2.83731C7.46855 2.61639 7.64764 2.4373 7.86855 2.4373H13.8603C14.0812 2.4373 14.2603 2.61639 14.2603 2.8373V9.5049C14.2603 9.72581 14.0812 9.90489 13.8603 9.90489H12.866C12.5346 9.90489 12.266 10.1735 12.266 10.5049C12.266 10.8363 12.5346 11.1049 12.866 11.1049H13.8603C14.7439 11.1049 15.4603 10.3886 15.4603 9.5049V2.8373C15.4603 1.95365 14.7439 1.2373 13.8603 1.2373H7.86855C6.9849 1.2373 6.26855 1.95365 6.26855 2.83731V3.48688C6.26855 3.81825 6.53718 4.08688 6.86855 4.08688C7.19993 4.08688 7.46855 3.81825 7.46855 3.48688V2.83731Z"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M3.19888 5.56299C2.31522 5.56299 1.59888 6.27933 1.59888 7.16299V13.163C1.59888 14.0466 2.31522 14.763 3.19888 14.763H9.19888C10.0825 14.763 10.7989 14.0466 10.7989 13.163V7.16299C10.7989 6.27933 10.0825 5.56299 9.19888 5.56299H3.19888ZM2.79888 7.16299C2.79888 6.94207 2.97796 6.76299 3.19888 6.76299H9.19888C9.41979 6.76299 9.59888 6.94207 9.59888 7.16299V13.163C9.59888 13.3839 9.41979 13.563 9.19888 13.563H3.19888C2.97796 13.563 2.79888 13.3839 2.79888 13.163V7.16299Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }]
};
var _t = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "ungroup-icon",
    ref: e,
    icon: or
  }));
});
_t.displayName = "UngroupIcon";
var cr = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "colorChannel1",
        d: "M11.0363 12.2367V14.0367C11.0363 14.3681 11.3049 14.6367 11.6363 14.6367C11.9676 14.6367 12.2363 14.3681 12.2363 14.0367V12.2367H14.0364C14.3677 12.2367 14.6364 11.9681 14.6364 11.6367C14.6364 11.3054 14.3677 11.0367 14.0364 11.0367H12.2363V9.23672C12.2363 8.90535 11.9676 8.63672 11.6363 8.63672C11.3049 8.63672 11.0363 8.90535 11.0363 9.23672V11.0367H9.23635C8.90498 11.0367 8.63635 11.3054 8.63635 11.6367C8.63635 11.9681 8.90498 12.2367 9.23635 12.2367H11.0363Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M2.56365 1.36377C1.90091 1.36377 1.36365 1.90103 1.36365 2.56377V6.16377C1.36365 6.82651 1.90091 7.36377 2.56365 7.36377H6.16365C6.82639 7.36377 7.36365 6.82651 7.36365 6.16377V2.56377C7.36365 1.90103 6.82639 1.36377 6.16365 1.36377H2.56365ZM6.16365 2.56377H2.56365L2.56365 6.16377H6.16365V2.56377Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M2.56365 8.63647C1.90091 8.63647 1.36365 9.17373 1.36365 9.83647V13.4365C1.36365 14.0992 1.90091 14.6365 2.56365 14.6365H6.16365C6.82639 14.6365 7.36365 14.0992 7.36365 13.4365V9.83647C7.36365 9.17373 6.82639 8.63647 6.16365 8.63647H2.56365ZM6.16365 9.83647H2.56365L2.56365 13.4365H6.16365V9.83647Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M9.83635 7.36377C9.17361 7.36377 8.63635 6.82651 8.63635 6.16377V2.56377C8.63635 1.90103 9.17361 1.36377 9.83635 1.36377H13.4364C14.0991 1.36377 14.6364 1.90103 14.6364 2.56377V6.16377C14.6364 6.82651 14.0991 7.36377 13.4364 7.36377H9.83635ZM9.83635 6.16377V2.56377L13.4364 2.56377V6.16377H9.83635Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    }
  ]
};
var Ct = (0, import_react.forwardRef)(function(r, e) {
  return (0, import_react.createElement)(z2, Object.assign({}, r, {
    id: "autofill-double-icon",
    ref: e,
    icon: cr
  }));
});
Ct.displayName = "AutofillDoubleIcon";
function lr2(i) {
  var h3;
  const { popup: r } = i, e = (h3 = r == null ? void 0 : r.extraProps) == null ? void 0 : h3.menuItems;
  if (!e) return null;
  const t = useDependency(Ls), n = useDependency(Fn), [s, a] = (0, import_react.useState)(false), [o2, c2] = (0, import_react.useState)(false), u2 = () => {
    c2(true);
  }, l2 = () => {
    c2(false);
  }, g2 = (p2) => {
    a(p2);
  }, d2 = (p2) => {
    t.executeCommand(p2.commandId, p2.commandParams), a(false);
  }, f3 = s || o2, w2 = e.filter((p2) => !p2.disable);
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      onMouseEnter: u2,
      onMouseLeave: l2,
      children: (0, import_jsx_runtime.jsx)(
        ep,
        {
          align: "start",
          items: w2.map((p2) => ({
            type: "item",
            children: n.t(p2.label),
            onSelect: () => d2(p2)
          })),
          open: s,
          onOpenChange: g2,
          children: (0, import_jsx_runtime.jsxs)(
            "div",
            {
              className: ie2("univer-flex univer-items-center univer-gap-2 univer-rounded univer-p-1 hover:univer-bg-gray-100 dark:hover:!univer-bg-gray-800", kt, {
                "univer-bg-gray-100 dark:!univer-bg-gray-800": s,
                "univer-bg-white dark:!univer-bg-gray-900": !s
              }),
              children: [
                (0, import_jsx_runtime.jsx)(
                  Ct,
                  {
                    className: "univer-fill-primary-600 univer-text-gray-900 dark:!univer-text-white"
                  }
                ),
                f3 && (0, import_jsx_runtime.jsx)(pt2, { className: "dark:!univer-text-white" })
              ]
            }
          )
        }
      )
    }
  );
}
var ur = Object.getOwnPropertyDescriptor;
var gr = (i, r, e, t) => {
  for (var n = t > 1 ? void 0 : t ? ur(r, e) : r, s = i.length - 1, a; s >= 0; s--)
    (a = i[s]) && (n = a(n) || n);
  return n;
};
var et4 = (i, r) => (e, t) => r(e, t, i);
var Ne = class extends Ve {
  constructor(i, r) {
    super(), this._componentManager = i, this._commandService = r, this._init();
  }
  _initCustomComponents() {
    const i = this._componentManager;
    this.disposeWithMe(i.register(Xt, lr2));
  }
  _initCommands() {
    [
      Ze,
      oe,
      ut2,
      ze,
      Pe2
    ].forEach((i) => this.disposeWithMe(this._commandService.registerCommand(i)));
  }
  _init() {
    this._initCommands(), this._initCustomComponents();
  }
};
Ne = gr([
  et4(0, Inject(S1)),
  et4(1, Ls)
], Ne);
function Le2(i, r) {
  const e = [];
  return i.forEach((t) => {
    const { oKey: n, left: s, top: a, height: o2, width: c2, angle: u2 } = t, l2 = r.getDrawingOKey(n);
    if (l2 == null)
      return e.push(null), true;
    const { unitId: g2, subUnitId: d2, drawingId: f3, drawingType: w2 } = l2, h3 = {
      unitId: g2,
      subUnitId: d2,
      drawingId: f3,
      drawingType: w2,
      transform: {
        left: s,
        top: a,
        height: o2,
        width: c2,
        angle: u2
      }
    };
    w2 === ng.DRAWING_IMAGE && (h3.srcRect = t.srcRect), e.push(h3);
  }), e;
}
function tt2(i, r, e, t) {
  const n = t.getDrawingByParam(i);
  if (n == null)
    return;
  const s = On(i), a = e.getObject(s);
  if (a && !(a instanceof s7))
    return;
  if (a != null) {
    a.addObject(r);
    return;
  }
  const o2 = new s7(s);
  e.addObject(o2, HT).attachTransformerTo(o2), o2.addObject(r);
  const { transform: c2 } = n;
  c2 && o2.transformByState(
    {
      left: c2.left,
      top: c2.top,
      angle: c2.angle
    }
  );
}
function St(i, r) {
  var s;
  const e = r ? i.getUnit(r) : i.getFocusedUnit();
  if (e == null)
    return;
  const t = e.getUnitId();
  let n;
  return e.type === we.UNIVER_SHEET ? n = (s = e.getActiveSheet()) == null ? void 0 : s.getSheetId() : (e.type === we.UNIVER_DOC || e.type === we.UNIVER_SLIDE) && (n = t), { unitId: t, subUnitId: n, current: e };
}
var dr = Object.getOwnPropertyDescriptor;
var hr2 = (i, r, e, t) => {
  for (var n = t > 1 ? void 0 : t ? dr(r, e) : r, s = i.length - 1, a; s >= 0; s--)
    (a = i[s]) && (n = a(n) || n);
  return n;
};
var be = (i, r) => (e, t) => r(e, t, i);
var Be = class extends Ve {
  constructor(r, e, t, n) {
    super();
    J3(this, "_sceneListenerOnDrawingMap", /* @__PURE__ */ new WeakSet());
    this._currentUniverService = r, this._commandService = e, this._renderManagerService = t, this._drawingManagerService = n, this._initialize();
  }
  dispose() {
    super.dispose();
  }
  _initialize() {
    this._recoveryImages(), this._drawingAddListener(), this._drawingRemoveListener(), this._drawingUpdateListener(), this._commandExecutedListener(), this._drawingArrangeListener(), this._drawingGroupListener(), this._drawingRefreshListener(), this._drawingVisibleListener();
  }
  _recoveryImages() {
    const r = this._drawingManagerService.drawingManagerData, e = St(this._currentUniverService);
    if (e == null)
      return;
    const { unitId: t, subUnitId: n } = e;
    Object.keys(r).forEach((s) => {
      Object.keys(r[s]).forEach((a) => {
        const o2 = r[s][a].data;
        o2 == null || s !== t || a !== n || Object.keys(o2).forEach((c2) => {
          o2[c2] && this._insertDrawing([{ unitId: s, subUnitId: a, drawingId: c2 }]);
        });
      });
    });
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((r) => {
        if (r.id === ze.id) {
          const e = r.params;
          if (e == null)
            return;
          this._drawingAlign(e);
        }
      })
    );
  }
  _drawingGroupListener() {
    this.disposeWithMe(
      this._drawingManagerService.group$.subscribe((r) => {
        this._groupDrawings(r);
      })
    ), this.disposeWithMe(
      this._drawingManagerService.ungroup$.subscribe((r) => {
        this._ungroupDrawings(r);
      })
    );
  }
  // private _drawingGroup(params: ISetImageGroupOperationParams) {
  //     const { groupType } = params;
  //     const drawings = this._drawingManagerService.getFocusDrawings();
  //     if (drawings.length === 0) {
  //         return;
  //     }
  //     switch (groupType) {
  //         case GroupType.group:
  //             this._groupDrawings(drawings);
  //             break;
  //         case GroupType.regroup:
  //             this._regroupDrawings(drawings);
  //             break;
  //         case GroupType.ungroup:
  //             this._ungroupDrawings(drawings);
  //             break;
  //         default:
  //             break;
  //     }
  // }
  _getSceneAndTransformerByDrawingSearch(r) {
    if (r == null)
      return;
    const e = this._renderManagerService.getRenderById(r), t = e == null ? void 0 : e.scene;
    if (t == null)
      return null;
    const n = t.getTransformerByCreate();
    return { scene: t, transformer: n };
  }
  _groupDrawings(r) {
    r.forEach((e) => {
      this._groupDrawing(e);
    });
  }
  _groupDrawing(r) {
    const { parent: e, children: t } = r, { unitId: n, subUnitId: s, drawingId: a } = e, o2 = this._getSceneAndTransformerByDrawingSearch(e.unitId);
    if (o2 == null)
      return;
    const { scene: c2, transformer: u2 } = o2;
    this._commandService.syncExecuteCommand(oe.id);
    const l2 = [];
    if (t.forEach((f3) => {
      const w2 = On(f3), h3 = c2.getObjectIncludeInGroup(w2);
      if (h3 == null || l2.includes(h3))
        return;
      l2.push(h3);
      const { transform: p2 } = f3;
      p2 != null && (h3.classType === V.GROUP ? h3.transformByState({ left: p2.left, top: p2.top }) : h3.transformByState(p2));
    }), l2.length === 0)
      return;
    const g2 = On({ unitId: n, subUnitId: s, drawingId: a }), d2 = new s7(g2);
    c2.addObject(d2, HT).attachTransformerTo(d2), d2.addObjects(...l2), e.transform && d2.transformByState({ left: e.transform.left, top: e.transform.top }), u2.clearSelectedObjects(), u2.setSelectedControl(d2);
  }
  // private _regroupDrawings(drawings: IDrawingSearch[]) {
  //     const renderObject = this._getSceneAndTransformerByDrawingSearch(drawings[0].unitId);
  //     if (renderObject == null) {
  //         return;
  //     }
  //     const { scene, transformer } = renderObject;
  //     const objects: BaseObject[] = [];
  //     let firstGroup: Nullable<Group> = null;
  //     drawings.forEach((drawing) => {
  //         const imageShapeKey = getDrawingShapeKeyByDrawingSearch(drawing);
  //         const o = scene.getObject(imageShapeKey);
  //         if (o == null) {
  //             return true;
  //         }
  //         const group = o.ancestorGroup as Nullable<Group>;
  //         if (group != null && firstGroup == null) {
  //             firstGroup = group;
  //         } else if (group != null && !objects.includes(group)) {
  //             objects.push(group);
  //         } else if (!objects.includes(o)) {
  //             objects.push(o);
  //         }
  //     });
  //     if (firstGroup == null) {
  //         return;
  //     }
  //     if (objects.length === 0) {
  //         return;
  //     }
  //     (firstGroup as Group).addObjects(...objects);
  //     (firstGroup as Group).reCalculateObjects();
  //     transformer.clearSelectedObjects();
  //     transformer.setSelectedControl(firstGroup);
  // }
  _ungroupDrawings(r) {
    r.forEach((e) => {
      this._ungroupDrawing(e);
    });
  }
  _ungroupDrawing(r) {
    const { parent: e, children: t } = r, n = this._getSceneAndTransformerByDrawingSearch(e.unitId);
    if (n == null)
      return;
    const { scene: s, transformer: a } = n;
    t.forEach((g2) => {
      const d2 = On(g2), f3 = s.getObjectIncludeInGroup(d2);
      if (f3 == null)
        return true;
      if (f3 == null)
        return;
      const { transform: w2 } = g2;
      w2 != null && (f3.classType === V.GROUP ? f3.transformByState({ left: w2.left, top: w2.top }) : f3.transformByState(w2));
    });
    const o2 = On(e), c2 = s.getObject(o2), { width: u2, height: l2 } = c2;
    c2.getObjects().forEach((g2) => {
      c2.removeSelfObjectAndTransform(g2.oKey, u2, l2);
    }), c2.dispose(), a.clearSelectedObjects();
  }
  _drawingAlign(r) {
    const { alignType: e } = r, t = this._drawingManagerService.getFocusDrawings();
    if (e === D2.default)
      return;
    const n = [];
    let s = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY, o2 = Number.NEGATIVE_INFINITY, c2 = Number.NEGATIVE_INFINITY, u2 = 0;
    t.forEach((l2) => {
      const { unitId: g2, subUnitId: d2, drawingId: f3, drawingType: w2 } = l2, h3 = this._drawingManagerService.getDrawingByParam({ unitId: g2, subUnitId: d2, drawingId: f3 });
      if (h3 == null || h3.transform == null)
        return;
      n.push({
        unitId: g2,
        subUnitId: d2,
        drawingId: f3,
        drawingType: w2,
        transform: h3.transform
      });
      const { left: p2 = 0, top: C = 0, width: _2 = 0, height: b = 0 } = h3.transform;
      s = Math.min(s, p2), a = Math.min(a, C), o2 = Math.max(o2, p2 + _2), c2 = Math.max(c2, C + b), u2++;
    }), u2 !== 0 && (this._sortDrawingTransform(n, e), this._applyAlignType(n, e, s, a, o2, c2, u2));
  }
  _applyAlignType(r, e, t, n, s, a, o2) {
    const c2 = Math.round((s - t) / o2 * 10) / 10, u2 = Math.round((a - n) / o2 * 10) / 10, l2 = [], g2 = this._getSceneAndTransformerByDrawingSearch(r[0].unitId);
    if (g2 == null)
      return;
    const { scene: d2, transformer: f3 } = g2;
    r.forEach((w2, h3) => {
      const { unitId: p2, subUnitId: C, drawingId: _2, transform: b, drawingType: R } = w2, { left: T = 0, top: S = 0, width: I = 0, height: y = 0 } = b;
      let O = T, M = S;
      switch (e) {
        case D2.left:
          O = t;
          break;
        case D2.center:
          O = t + (s - t) / 2 - I / 2;
          break;
        case D2.right:
          O = s - I;
          break;
        case D2.top:
          M = n;
          break;
        case D2.middle:
          M = n + (a - n) / 2 - y / 2;
          break;
        case D2.bottom:
          M = a - y;
          break;
        case D2.horizon:
          O = t + c2 * h3;
          break;
        case D2.vertical:
          M = n + u2 * h3;
          break;
      }
      (O !== T || M !== S) && l2.push({
        unitId: p2,
        subUnitId: C,
        drawingId: _2,
        drawingType: R,
        transform: {
          left: O,
          top: M
        }
      });
    }), this._drawingManagerService.featurePluginUpdateNotification(l2), f3.refreshControls().changeNotification();
  }
  _sortDrawingTransform(r, e) {
    r.sort((t, n) => {
      const s = t.transform, a = n.transform, {
        left: o2 = 0,
        top: c2 = 0,
        width: u2 = 0,
        height: l2 = 0
      } = s, {
        left: g2 = 0,
        top: d2 = 0,
        width: f3 = 0,
        height: w2 = 0
      } = a;
      switch (e) {
        case D2.left:
          return o2 - g2;
        case D2.center:
          return o2 + u2 / 2 - (g2 + f3 / 2);
        case D2.right:
          return o2 + u2 - (g2 + f3);
        case D2.top:
          return c2 - d2;
        case D2.middle:
          return c2 + l2 / 2 - (d2 + w2 / 2);
        case D2.bottom:
          return c2 + l2 - (d2 + w2);
        case D2.horizon:
          return o2 + u2 / 2 - (g2 + f3 / 2);
        case D2.vertical:
          return c2 + l2 / 2 - (d2 + w2 / 2);
        default:
          return 0;
      }
    });
  }
  _drawingArrangeListener() {
    this.disposeWithMe(
      this._drawingManagerService.order$.subscribe((r) => {
        this._drawingArrange(r);
      })
    );
  }
  _drawingArrange(r) {
    const { unitId: e, subUnitId: t, drawingIds: n } = r, s = this._getSceneAndTransformerByDrawingSearch(e);
    if (s == null)
      return;
    const { scene: a } = s;
    n.forEach((o2) => {
      const c2 = On({ unitId: e, subUnitId: t, drawingId: o2 }), u2 = a.fuzzyMathObjects(c2, true);
      if (u2 == null || u2.length === 0)
        return;
      const l2 = this._drawingManagerService.getDrawingOrder(e, t).indexOf(o2);
      for (const g2 of u2)
        g2.setProps({ zIndex: l2 }), g2.makeDirty();
    });
  }
  _drawingAddListener() {
    this.disposeWithMe(
      this._drawingManagerService.add$.subscribe((r) => {
        this._insertDrawing(r);
      })
    );
  }
  _insertDrawing(r) {
    const e = [];
    r.forEach((t) => {
      const { unitId: n } = t;
      if (this._drawingManagerService.getDrawingByParam(t) == null)
        return;
      const a = this._getSceneAndTransformerByDrawingSearch(n);
      if (a == null)
        return;
      const { scene: o2 } = a;
      e.includes(o2) || e.push(o2);
    }), e.forEach((t) => {
      this._sceneListenerOnDrawingMap.has(t) || (this._addListenerOnDrawing(t), this._sceneListenerOnDrawingMap.add(t));
    });
  }
  _drawingRemoveListener() {
    this.disposeWithMe(
      this._drawingManagerService.remove$.subscribe((r) => {
        r.forEach((e) => {
          var l2;
          const { unitId: t, subUnitId: n, drawingId: s } = e, a = this._getSceneAndTransformerByDrawingSearch(t);
          if (a == null)
            return;
          const { scene: o2 } = a, c2 = On({ unitId: t, subUnitId: n, drawingId: s }), u2 = o2.fuzzyMathObjects(c2, true);
          if (u2.length > 0) {
            for (const g2 of u2)
              g2.dispose();
            (l2 = o2.getTransformer()) == null || l2.clearSelectedObjects();
          }
        });
      })
    );
  }
  _drawingUpdateListener() {
    this.disposeWithMe(
      this._drawingManagerService.update$.subscribe((r) => {
        r.forEach((e) => {
          var I;
          const { unitId: t, subUnitId: n, drawingId: s } = e, a = this._drawingManagerService.getDrawingByParam(e);
          if (a == null)
            return;
          const { transform: o2, drawingType: c2 } = a, u2 = this._getSceneAndTransformerByDrawingSearch(t);
          if (u2 == null)
            return;
          const { scene: l2, transformer: g2 } = u2;
          if (o2 == null)
            return true;
          const { left: d2 = 0, top: f3 = 0, width: w2 = 0, height: h3 = 0, angle: p2 = 0, flipX: C = false, flipY: _2 = false, skewX: b = 0, skewY: R = 0 } = o2, T = On({ unitId: t, subUnitId: n, drawingId: s }), S = l2.getObject(T);
          if (S == null)
            return true;
          S.transformByState({ left: d2, top: f3, width: w2, height: h3, angle: p2, flipX: C, flipY: _2, skewX: b, skewY: R }), (I = l2.getTransformer()) == null || I.debounceRefreshControls();
        });
      })
    );
  }
  _drawingRefreshListener() {
    this.disposeWithMe(
      this._drawingManagerService.refreshTransform$.subscribe((r) => {
        r.forEach((e) => {
          const { unitId: t, subUnitId: n, drawingId: s } = e, a = this._getSceneAndTransformerByDrawingSearch(t);
          if (a == null)
            return;
          const o2 = this._drawingManagerService.getDrawingByParam(e);
          if (o2 == null)
            return;
          const { transform: c2 } = o2, { scene: u2 } = a, l2 = On({ unitId: t, subUnitId: n, drawingId: s }), g2 = u2.getObject(l2);
          if (g2 == null || c2 == null)
            return true;
          const {
            left: d2 = 0,
            top: f3 = 0,
            width: w2 = 0,
            height: h3 = 0,
            angle: p2 = 0,
            flipX: C = false,
            flipY: _2 = false,
            skewX: b = 0,
            skewY: R = 0
          } = c2;
          g2.transformByState({ left: d2, top: f3, width: w2, height: h3, angle: p2, flipX: C, flipY: _2, skewX: b, skewY: R });
        });
      })
    );
  }
  _drawingVisibleListener() {
    this.disposeWithMe(
      this._drawingManagerService.visible$.subscribe((r) => {
        r.forEach((e) => {
          const { unitId: t, subUnitId: n, drawingId: s, visible: a } = e, o2 = this._getSceneAndTransformerByDrawingSearch(t);
          if (o2 == null)
            return;
          const { scene: c2 } = o2, u2 = On({ unitId: t, subUnitId: n, drawingId: s }), l2 = c2.getObject(u2);
          if (l2 == null)
            return true;
          a ? l2.show() : l2.hide();
        });
      })
    );
  }
  _filterUpdateParams(r, e) {
    return r.filter((t, n) => {
      if (t == null)
        return false;
      const { transform: s } = t;
      return v1(s, e == null ? void 0 : e[n]);
    });
  }
  // group?.getObjects().forEach((o) => {
  //     const drawing = this._drawingManagerService.getDrawingOKey(o.oKey);
  //     if (drawing != null) {
  //         const { unitId, subUnitId, drawingId } = drawing;
  //         drawings.push({ unitId, subUnitId, drawingId });
  //     }
  // });
  _addListenerOnDrawing(r) {
    const e = r.getTransformerByCreate();
    let t = null;
    this.disposeWithMe(
      We(
        e.changeStart$.subscribe((n) => {
          const { objects: s } = n, a = Array.from(s.values()), o2 = [];
          t = a.map((c2) => {
            const { left: u2, top: l2, height: g2, width: d2, angle: f3, oKey: w2, isInGroup: h3 } = c2, p2 = this._drawingManagerService.getDrawingOKey(w2);
            if (h3 || c2 instanceof s7) {
              let C = c2.ancestorGroup;
              if (C == null && c2 instanceof s7 && (C = c2), C == null)
                return null;
              const _2 = this._drawingManagerService.getDrawingOKey(C.oKey);
              if (_2) {
                const { unitId: b, subUnitId: R, drawingId: T } = _2;
                o2.push({ unitId: b, subUnitId: R, drawingId: T });
                const { left: S, top: I, height: y, width: O, angle: M } = C;
                return { left: S, top: I, height: y, width: O, angle: M };
              }
            } else if (p2 != null) {
              const { unitId: C, subUnitId: _2, drawingId: b } = p2;
              return o2.push({ unitId: C, subUnitId: _2, drawingId: b }), { left: u2, top: l2, height: g2, width: d2, angle: f3 };
            }
            return null;
          }).filter((c2) => c2 != null), o2.length > 0 ? this._commandService.syncExecuteCommand(Qt.id, o2) : this._commandService.syncExecuteCommand(Qt.id, []);
        })
      )
    ), this.disposeWithMe(
      We(
        e.changeEnd$.subscribe((n) => {
          const { objects: s } = n, a = this._filterUpdateParams(Le2(s, this._drawingManagerService), t);
          a.length > 0 && this._drawingManagerService.featurePluginUpdateNotification(a);
        })
      )
    );
  }
};
Be = hr2([
  be(0, vr),
  be(1, Ls),
  be(2, ME),
  be(3, Mt2)
], Be);
var Ie = class extends x3 {
  constructor(e, t) {
    t == null && (t = {}), t.transformerConfig = {
      keepRatio: false,
      isCropper: true,
      anchorFill: "rgb(0, 0, 0)",
      anchorStroke: "rgb(255, 255, 255)",
      anchorSize: 24
    };
    super(e, t);
    J3(this, "_srcRect");
    J3(this, "_prstGeom");
    J3(this, "_applyTransform");
    J3(this, "_dragPadding", 8);
    J3(this, "_cacheCanvas");
    t != null && t.srcRect && (this._srcRect = t.srcRect), t != null && t.prstGeom && (this._prstGeom = t.prstGeom), t != null && t.applyTransform && (this._applyTransform = t.applyTransform), t != null && t.dragPadding && (this._dragPadding = t.dragPadding), this._applyProps();
  }
  refreshSrcRect(e, t) {
    this._srcRect = e, this._applyTransform = t, this._applyProps();
  }
  get srcRect() {
    return this._srcRect;
  }
  dispose() {
    var e;
    super.dispose(), (e = this._cacheCanvas) == null || e.dispose(), this._srcRect = null;
  }
  isHit(e) {
    const t = this.getInverseCoord(e);
    return t.x >= -this.strokeWidth / 2 && t.x <= this.width + this.strokeWidth / 2 && t.y >= -this.strokeWidth / 2 && t.y <= this.height + this.strokeWidth / 2 && !this._inSurround(t);
  }
  _inSurround(e) {
    const t = this._dragPadding;
    return e.x >= t - this.strokeWidth / 2 && e.x <= this.width + this.strokeWidth / 2 - t && e.y >= t - this.strokeWidth / 2 && e.y <= this.height + this.strokeWidth / 2 - t;
  }
  render(e, t) {
    return this.visible ? (e.save(), this._draw(e), e.restore(), this.makeDirty(false), this) : (this.makeDirty(false), this);
  }
  _draw(e) {
    var c2, u2;
    const n = this.getScene().getEngine(), { width: s, height: a } = n;
    this._initialCacheCanvas(), (c2 = this._cacheCanvas) == null || c2.clear();
    const o2 = (u2 = this._cacheCanvas) == null ? void 0 : u2.getContext();
    o2 != null && (o2.save(), I1.drawWith(o2, {
      left: 0,
      top: 0,
      width: s,
      height: a,
      fill: "rgba(0, 0, 0, 0.5)"
    }), o2.setTransform(e.getTransform()), this._clipForApplyObject(o2), this._applyCache(e), o2.restore());
  }
  _clipForApplyObject(e) {
    let t = 0;
    if (this._prstGeom != null && (t = 1), e.globalCompositeOperation = "destination-out", e.beginPath(), t === 0) {
      const n = this.transform.getMatrix();
      e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), e.rect(0, 0, this.width, this.height), e.fill();
    }
  }
  _applyProps() {
    if (this._applyTransform == null)
      return;
    let e = 0, t = 0, n = 0, s = 0;
    const { left: a = 0, top: o2 = 0, width: c2 = 0, height: u2 = 0, angle: l2 } = this._applyTransform;
    if (this._srcRect != null) {
      const { left: f3 = 0, top: w2 = 0, right: h3 = 0, bottom: p2 = 0 } = this._srcRect;
      e = f3, t = w2, n = h3, s = p2;
    }
    const g2 = a + e, d2 = o2 + t;
    this.transformByState({
      left: g2,
      top: d2,
      width: a + c2 - n - g2,
      height: o2 + u2 - s - d2,
      angle: l2
    });
  }
  _applyCache(e) {
    if (!e || this._cacheCanvas == null)
      return;
    const t = this._cacheCanvas.getContext();
    t.save(), e.save(), e.setTransform(1, 0, 0, 1, 0, 0), t.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(this._cacheCanvas.getCanvasEle(), 0, 0), e.restore(), t.restore();
  }
  _initialCacheCanvas() {
    if (this._cacheCanvas != null)
      return;
    const e = this.getScene();
    if (e == null) return;
    this._cacheCanvas = new ye();
    const t = e.getEngine();
    this._cacheCanvas.setSize(t.width, t.height), t.onTransformChange$.subscribeEvent(() => {
      var n;
      (n = this._cacheCanvas) == null || n.setSize(t.width, t.height), this.makeDirty(true);
    });
  }
};
var fr = Object.getOwnPropertyDescriptor;
var pr = (i, r, e, t) => {
  for (var n = t > 1 ? void 0 : t ? fr(r, e) : r, s = i.length - 1, a; s >= 0; s--)
    (a = i[s]) && (n = a(n) || n);
  return n;
};
var le = (i, r) => (e, t) => r(e, t, i);
var xe = class extends Ve {
  constructor(r, e, t, n, s, a) {
    super();
    J3(this, "_sceneListenerOnImageMap", /* @__PURE__ */ new WeakSet());
    this._commandService = r, this._drawingManagerService = e, this._renderManagerService = t, this._univerInstanceService = n, this._messageService = s, this._localeService = a, this._init();
  }
  _init() {
    this._initOpenCrop(), this._initCloseCrop(), this._initAutoCrop();
  }
  _initAutoCrop() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((r) => {
        if (r.id !== Pe2.id)
          return;
        const e = r.params;
        if (e == null)
          return;
        const { cropType: t } = e, n = this._drawingManagerService.getFocusDrawings();
        if (n.length !== 1)
          return;
        const s = n[0], { unitId: a, subUnitId: o2, drawingId: c2 } = s, u2 = this._renderManagerService.getRenderById(a), l2 = u2 == null ? void 0 : u2.scene;
        if (l2 == null)
          return true;
        this._searchCropObject(l2) != null && this._commandService.syncExecuteCommand(oe.id, { isAuto: true });
        const d2 = On({ unitId: a, subUnitId: o2, drawingId: c2 }), f3 = l2.getObject(d2);
        if (!(f3 instanceof GB)) {
          this._messageService.show({
            type: $C.Error,
            content: this._localeService.t("image-cropper.error")
          });
          return;
        }
        f3 != null && (this._updateCropperObject(t, f3), this._commandService.executeCommand(Ze.id, { unitId: a, subUnitId: o2, drawingId: c2 }));
      })
    );
  }
  _calculateSrcRectByRatio(r, e, t, n, s, a) {
    const o2 = t / n, c2 = s / a;
    let u2 = t, l2 = n;
    o2 > c2 ? u2 = n * c2 : l2 = t / c2;
    const g2 = (t - u2) / 2, d2 = (n - l2) / 2;
    return {
      left: de(g2, 1),
      top: de(d2, 1),
      right: de(t - (g2 + u2), 1),
      bottom: de(n - (d2 + l2), 1)
    };
  }
  _updateCropperObject(r, e) {
    const { left: t, top: n, width: s, height: a } = e.calculateTransformWithSrcRect();
    let o2;
    switch (r) {
      case x.R1_1:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 1, 1);
        break;
      case x.R16_9:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 16, 9);
        break;
      case x.R9_16:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 9, 16);
        break;
      case x.R5_4:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 5, 4);
        break;
      case x.R4_5:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 4, 5);
        break;
      case x.R4_3:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 4, 3);
        break;
      case x.R3_4:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 3, 4);
        break;
      case x.R3_2:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 3, 2);
        break;
      case x.R2_3:
        o2 = this._calculateSrcRectByRatio(t, n, s, a, 2, 3);
        break;
      case x.FREE:
    }
    if (o2 == null)
      return;
    e.setSrcRect(o2);
    const { left: c2 = 0, top: u2 = 0, bottom: l2 = 0, right: g2 = 0 } = o2;
    e.transformByStateCloseCropper({
      left: t + c2,
      top: n + u2,
      width: s - g2 - c2,
      height: a - l2 - u2
    });
  }
  _initOpenCrop() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((r) => {
        if (r.id !== Ze.id)
          return;
        const e = r.params;
        if (e == null)
          return;
        const { unitId: t, subUnitId: n, drawingId: s } = e, a = this._renderManagerService.getRenderById(t), o2 = a == null ? void 0 : a.scene;
        if (o2 == null)
          return true;
        if (this._sceneListenerOnImageMap.has(o2) || (this._addListenerOnImage(o2), this._sceneListenerOnImageMap.add(o2)), this._drawingManagerService.getDrawingByParam({ unitId: t, subUnitId: n, drawingId: s }) == null)
          return;
        const u2 = On({ unitId: t, subUnitId: n, drawingId: s }), l2 = o2.getObject(u2);
        if (l2 == null)
          return;
        if (!(l2 instanceof GB)) {
          this._messageService.show({
            type: $C.Error,
            content: this._localeService.t("image-cropper.error")
          });
          return;
        }
        const g2 = o2.getTransformer();
        g2 == null || g2.clearControls();
        const d2 = new Ie(`${u2}-crop`, {
          srcRect: l2.srcRect,
          prstGeom: l2.prstGeom,
          applyTransform: l2.calculateTransformWithSrcRect()
        });
        o2.addObject(d2, l2.getLayerIndex() + 1).attachTransformerTo(d2), g2 == null || g2.createControlForCopper(d2), this._addHoverForImageCopper(d2), l2.openRenderByCropper(), g2 == null || g2.refreshControls(), d2.makeDirty(true), this._commandService.syncExecuteCommand(Qt.id, [{ unitId: t, subUnitId: n, drawingId: s }]);
      })
    );
  }
  _searchCropObject(r) {
    const e = r.getAllObjectsByOrder();
    for (const t of e)
      if (t instanceof Ie)
        return t;
  }
  _initCloseCrop() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((e) => {
        if (e.id !== oe.id)
          return;
        const t = this._univerInstanceService.getFocusedUnit();
        if (t == null)
          return;
        const n = t.getUnitId(), s = this._renderManagerService.getRenderById(n), a = s == null ? void 0 : s.scene;
        if (a == null)
          return true;
        const o2 = this._searchCropObject(a);
        if (o2 == null)
          return;
        const c2 = this._getApplyObjectByCropObject(o2);
        if (c2 == null)
          return;
        const u2 = a.getTransformerByCreate();
        u2.detachFrom(o2), u2.clearCopperControl();
        const l2 = this._getSrcRectByTransformState(c2, o2), g2 = this._drawingManagerService.getDrawingOKey(c2.oKey);
        if (g2 != null) {
          const { left: d2, top: f3, height: w2, width: h3 } = o2;
          this._drawingManagerService.featurePluginUpdateNotification([{
            ...g2,
            transform: {
              ...g2.transform,
              left: d2,
              top: f3,
              height: w2,
              width: h3
            },
            srcRect: l2.srcRectAngle
          }]);
        }
        c2.setSrcRect({ ...l2.srcRectAngle }), c2.closeRenderByCropper(), c2.makeDirty(true), o2 == null || o2.dispose();
      })
    );
    const r = this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET).pipe(
      switchMap((e) => e ? e.activeSheet$ : of(null))
    );
    this.disposeWithMe(r.subscribe(() => {
      this._commandService.syncExecuteCommand(oe.id);
    }));
  }
  _getApplyObjectByCropObject(r) {
    const e = r.oKey, t = e.slice(0, e.length - 5), n = r.getScene();
    if (!n) return null;
    const s = n.getObject(t);
    return s == null ? null : s;
  }
  _addListenerOnImage(r) {
    const e = r.getTransformerByCreate();
    let t = null;
    this.disposeWithMe(
      e.changeStart$.subscribe((n) => {
        const { objects: s } = n, a = s.values().next().value;
        if (a == null || !(a instanceof Ie))
          return;
        const { left: o2, top: c2, height: u2, width: l2, angle: g2 } = a;
        t = { left: o2, top: c2, height: u2, width: l2, angle: g2 }, e.clearCopperControl();
      })
    ), this.disposeWithMe(
      e.changeEnd$.subscribe((n) => {
        const { objects: s } = n, a = s.values().next().value;
        if (a == null || !(a instanceof Ie))
          return;
        const { left: o2, top: c2, height: u2, width: l2, angle: g2 } = a;
        if (!v1({ left: o2, top: c2, height: u2, width: l2, angle: g2 }, t))
          return;
        const d2 = this._getApplyObjectByCropObject(a);
        if (d2 == null)
          return;
        const f3 = this._getSrcRectByTransformState(d2, a);
        a.refreshSrcRect(f3.srcRect, d2.getState()), e.createControlForCopper(a);
      })
    ), this._endCropListener(r);
  }
  _addHoverForImageCopper(r) {
    this.disposeWithMe(
      r.onPointerEnter$.subscribeEvent(() => {
        r.cursor = v12.MOVE;
      })
    ), this.disposeWithMe(
      r.onPointerLeave$.subscribeEvent(() => {
        r.cursor = v12.DEFAULT;
      })
    );
  }
  _endCropListener(r) {
    const e = r.getTransformerByCreate();
    this.disposeWithMe(
      e.clearControl$.subscribe((t) => {
        t === true && this._commandService.syncExecuteCommand(oe.id);
      })
    );
  }
  _getSrcRectByTransformState(r, e) {
    const { left: t, top: n, height: s, width: a, strokeWidth: o2, angle: c2 } = e, { left: u2, top: l2, width: g2, height: d2, angle: f3, strokeWidth: w2 } = r, h3 = t - u2, p2 = n - l2, C = {
      left: h3,
      top: p2,
      right: g2 - h3 - a,
      bottom: d2 - p2 - s
    }, _2 = { ...C };
    if (f3 !== 0) {
      const b = t + a / 2, R = n + s / 2, T = new U(b, R), S = g2 / 2 + u2, I = d2 / 2 + l2, y = new U(S, I), O = new U(u2, l2);
      O.rotateByPoint(Q1(f3), y);
      const M = O.clone();
      M.rotateByPoint(Q1(-f3), T);
      const N = t - M.x, B = n - M.y;
      _2.left = N, _2.top = B, _2.right = g2 - N - a, _2.bottom = d2 - B - s;
    }
    return {
      srcRect: C,
      srcRectAngle: _2
    };
  }
};
xe = pr([
  le(0, Ls),
  le(1, Mt2),
  le(2, ME),
  le(3, vr),
  le(4, et2),
  le(5, Inject(Fn))
], xe);
var mr = Object.getOwnPropertyDescriptor;
var wr2 = (i, r, e, t) => {
  for (var n = t > 1 ? void 0 : t ? mr(r, e) : r, s = i.length - 1, a; s >= 0; s--)
    (a = i[s]) && (n = a(n) || n);
  return n;
};
var Ve3 = (i, r) => (e, t) => r(e, t, i);
var Ue = class {
  constructor(i, r, e) {
    this._drawingManagerService = i, this._imageIoService = r, this._galleryService = e;
  }
  // eslint-disable-next-line max-lines-per-function
  async renderImages(i, r) {
    const {
      transform: e,
      drawingType: t,
      source: n,
      imageSourceType: s,
      srcRect: a,
      prstGeom: o2,
      groupId: c2,
      unitId: u2,
      subUnitId: l2,
      drawingId: g2,
      isMultiTransform: d2,
      transforms: f3
    } = i;
    if (t !== ng.DRAWING_IMAGE || !this._drawingManagerService.getDrawingVisible() || e == null)
      return;
    const w2 = d2 && f3 ? f3 : [e], h3 = [];
    for (const p2 of w2) {
      const { left: C, top: _2, width: b, height: R, angle: T, flipX: S, flipY: I, skewX: y, skewY: O } = p2, M = w2.indexOf(p2), N = On({ unitId: u2, subUnitId: l2, drawingId: g2 }, d2 ? M : void 0), B = r.getObject(N);
      if (B != null) {
        B.transformByState({ left: C, top: _2, width: b, height: R, angle: T, flipX: S, flipY: I, skewX: y, skewY: O });
        continue;
      }
      const W = this._drawingManagerService.getDrawingOrder(u2, l2), K = W.indexOf(g2), Y3 = { ...p2, zIndex: K === -1 ? W.length - 1 : K }, ve = this._imageIoService.getImageSourceCache(n, s);
      let ne = false;
      if (ve != null)
        Y3.image = ve;
      else {
        if (s === oc.UUID)
          try {
            Y3.url = await this._imageIoService.getImage(n);
          } catch (ke2) {
            console.error(ke2);
            continue;
          }
        else
          Y3.url = n;
        ne = true;
      }
      if (r.getObject(N))
        continue;
      Y3.printable = true;
      const $2 = new GB(N, Y3);
      ne && this._imageIoService.addImageSourceCache(n, s, $2.getNative()), this._drawingManagerService.getDrawingVisible() && (r.addObject($2, HT), this._drawingManagerService.getDrawingEditable() && r.attachTransformerTo($2), c2 && tt2({ drawingId: c2, unitId: u2, subUnitId: l2 }, $2, r, this._drawingManagerService), o2 != null && $2.setPrstGeom(o2), a != null && $2.setSrcRect(a), h3.push($2));
    }
    return h3;
  }
  renderFloatDom(i, r) {
    const {
      transform: e,
      drawingType: t,
      groupId: n,
      unitId: s,
      subUnitId: a,
      drawingId: o2,
      isMultiTransform: c2,
      transforms: u2
    } = i;
    if (t !== ng.DRAWING_DOM || !this._drawingManagerService.getDrawingVisible() || e == null)
      return;
    const l2 = c2 && u2 ? u2 : [e], g2 = [];
    for (const d2 of l2) {
      const { left: f3, top: w2, width: h3, height: p2, angle: C, flipX: _2, flipY: b, skewX: R, skewY: T } = d2, S = l2.indexOf(d2), I = On({ unitId: s, subUnitId: a, drawingId: o2 }, c2 ? S : void 0), y = r.getObject(I);
      if (y != null) {
        y.transformByState({ left: f3, top: w2, width: h3, height: p2, angle: C, flipX: _2, flipY: b, skewX: R, skewY: T });
        continue;
      }
      const O = this._drawingManagerService.getDrawingOrder(s, a), M = O.indexOf(o2), N = { ...d2, zIndex: M === -1 ? O.length - 1 : M };
      if (r.getObject(I))
        continue;
      N.printable = false;
      const B = new I1(I, N);
      this._drawingManagerService.getDrawingVisible() && (r.addObject(B, HT), this._drawingManagerService.getDrawingEditable() && i.allowTransform !== false && r.attachTransformerTo(B), n && tt2({ drawingId: n, unitId: s, subUnitId: a }, B, r, this._drawingManagerService), g2.push(B));
    }
    return g2;
  }
  renderDrawing(i, r) {
    const e = this._drawingManagerService.getDrawingByParam(i);
    if (e != null)
      switch (e.drawingType) {
        case ng.DRAWING_IMAGE:
          return this.renderImages(e, r);
      }
  }
  previewImage(i, r, e, t) {
    this._galleryService.open({
      images: [r],
      onOpenChange: (n) => {
        n || this._galleryService.close();
      }
    });
  }
  _adjustImageSize(i, r, e, t) {
    if (i <= e && r <= t)
      return {
        width: i,
        height: r
      };
    const n = e / i, s = t / r, a = Math.min(n, s);
    return {
      width: Math.floor(i * a),
      height: Math.floor(r * a)
    };
  }
};
Ue = wr2([
  Ve3(0, Mt2),
  Ve3(1, El),
  Ve3(2, ut)
], Ue);
var vr3 = Object.getOwnPropertyDescriptor;
var _r = (i, r, e, t) => {
  for (var n = t > 1 ? void 0 : t ? vr3(r, e) : r, s = i.length - 1, a; s >= 0; s--)
    (a = i[s]) && (n = a(n) || n);
  return n;
};
var ae = (i, r) => (e, t) => r(e, t, i);
var je = class extends Ve {
  constructor(i, r, e, t, n, s, a) {
    super(), this._commandService = i, this._renderManagerService = r, this._drawingManagerService = e, this._dialogService = t, this._imageIoService = n, this._currentUniverService = s, this._drawingRenderService = a, this._initialize();
  }
  dispose() {
    super.dispose();
  }
  _initialize() {
    this._drawingAddListener(), this._commandExecutedListener(), this._imageUpdateListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        if (i.id === ut2.id) {
          const r = i.params;
          if (r == null)
            return;
          this._resetImageSize(r);
        }
      })
    );
  }
  _getSceneAndTransformerByDrawingSearch(i) {
    if (i == null)
      return;
    const r = this._renderManagerService.getRenderById(i), e = r == null ? void 0 : r.scene;
    if (e == null)
      return null;
    const t = e.getTransformerByCreate();
    return { scene: e, transformer: t };
  }
  _resetImageSize(i) {
    const r = [], e = [];
    i.forEach((t) => {
      const { unitId: n, subUnitId: s, drawingId: a } = t, o2 = this._getSceneAndTransformerByDrawingSearch(n);
      if (o2 == null)
        return;
      const { scene: c2 } = o2, u2 = On({ unitId: n, subUnitId: s, drawingId: a }), l2 = c2.getObject(u2);
      if (l2 == null)
        return true;
      const g2 = this._drawingManagerService.getDrawingByParam(t);
      if (g2 == null)
        return true;
      if (g2.drawingType !== ng.DRAWING_IMAGE)
        return;
      l2.resetSize();
      const { width: d2, height: f3 } = l2.getNativeSize();
      e.includes(c2) === false && e.push(c2), r.push({
        ...g2,
        transform: {
          ...g2.transform,
          height: f3,
          width: d2,
          angle: 0
        },
        srcRect: null,
        prstGeom: null
      });
    }), this._drawingManagerService.featurePluginUpdateNotification(r), e.forEach((t) => {
      t.getTransformerByCreate().refreshControls().changeNotification();
    }), this._commandService.syncExecuteCommand(Qt.id, i);
  }
  _drawingAddListener() {
    this.disposeWithMe(
      this._drawingManagerService.add$.subscribe((i) => {
        this._insertImages(i);
      })
    );
  }
  _insertImages(i) {
    i.forEach(async (r) => {
      var c2;
      const { unitId: e, subUnitId: t } = r, n = this._getSceneAndTransformerByDrawingSearch(e), s = (c2 = St(this._currentUniverService, e)) == null ? void 0 : c2.subUnitId;
      if (n == null || s !== t)
        return;
      const a = this._drawingManagerService.getDrawingByParam(r);
      if (a == null)
        return;
      const o2 = await this._drawingRenderService.renderImages(a, n.scene);
      if (this._drawingManagerService.refreshTransform([a]), !(o2 == null || o2.length === 0))
        for (const u2 of o2)
          this._addHoverForImage(u2), this._addDialogForImage(u2);
    });
  }
  _imageUpdateListener() {
    this.disposeWithMe(
      this._drawingManagerService.update$.subscribe((i) => {
        i.forEach((r) => {
          const { unitId: e, subUnitId: t, drawingId: n } = r, s = this._drawingManagerService.getDrawingByParam(r);
          if (s == null)
            return;
          const { transform: a, drawingType: o2, srcRect: c2, prstGeom: u2, source: l2, imageSourceType: g2 } = s;
          if (o2 !== ng.DRAWING_IMAGE)
            return;
          const d2 = this._getSceneAndTransformerByDrawingSearch(e);
          if (d2 == null)
            return;
          const { scene: f3, transformer: w2 } = d2;
          if (a == null)
            return true;
          const h3 = On({ unitId: e, subUnitId: t, drawingId: n }), p2 = f3.getObject(h3);
          if (p2 == null)
            return true;
          p2.setSrcRect(c2), p2.setPrstGeom(u2), l2 != null && l2.length > 0 && (g2 === oc.BASE64 || g2 === oc.URL) && p2.changeSource(l2);
        });
      })
    );
  }
  _addHoverForImage(i) {
    this.disposeWithMe(
      We(
        i.onPointerEnter$.subscribeEvent(() => {
          i.cursor = v12.GRAB;
        })
      )
    ), this.disposeWithMe(
      We(
        i.onPointerLeave$.subscribeEvent(() => {
          i.cursor = v12.DEFAULT;
        })
      )
    );
  }
  _addDialogForImage(i) {
    this.disposeWithMe(
      We(
        i.onDblclick$.subscribeEvent(() => {
          const r = `${i.oKey}-viewer-dialog`;
          this._drawingRenderService.previewImage(r, i.getNative().src, i.getNativeSize().width, i.getNativeSize().height);
        })
      )
    );
  }
};
je = _r([
  ae(0, Ls),
  ae(1, ME),
  ae(2, Mt2),
  ae(3, ct),
  ae(4, El),
  ae(5, vr),
  ae(6, Inject(Ue))
], je);
var Cr2 = Object.getOwnPropertyDescriptor;
var Sr = (i, r, e, t) => {
  for (var n = t > 1 ? void 0 : t ? Cr2(r, e) : r, s = i.length - 1, a; s >= 0; s--)
    (a = i[s]) && (n = a(n) || n);
  return n;
};
var rt = (i, r) => (e, t) => r(e, t, i);
var br = "UNIVER_DRAWING_UI_PLUGIN";
var Ge;
var nt3 = (Ge = class extends Ol {
  constructor(i = Qe, r, e) {
    super(), this._config = i, this._injector = r, this._configService = e;
    const { menu: t, ...n } = oo(
      {},
      Qe,
      this._config
    );
    t && this._configService.setConfig("menu", t, { merge: true }), this._configService.setConfig(Yt2, n);
  }
  onStarting() {
    this._initDependencies();
  }
  onRendered() {
    this._injector.get(Be), this._injector.get(Ne), this._injector.get(xe), this._injector.get(je);
  }
  _initDependencies() {
    [
      [Ue],
      [Be],
      [Ne],
      [xe],
      [je]
    ].forEach((r) => this._injector.add(r));
  }
}, J3(Ge, "pluginName", br), Ge);
nt3 = Sr([
  rt(1, Inject(Injector)),
  rt(2, ic)
], nt3);
var Ir = (i) => {
  const r = useDependency(Ls), e = useDependency(Fn), { alignShow: t } = i, [n, s] = (0, import_react.useState)(D2.default), a = [
    {
      label: e.t("image-panel.align.default"),
      value: D2.default
    },
    {
      options: [
        {
          label: e.t("image-panel.align.left"),
          value: D2.left
        },
        {
          label: e.t("image-panel.align.center"),
          value: D2.center
        },
        {
          label: e.t("image-panel.align.right"),
          value: D2.right
        }
      ]
    },
    {
      options: [
        {
          label: e.t("image-panel.align.top"),
          value: D2.top
        },
        {
          label: e.t("image-panel.align.middle"),
          value: D2.middle
        },
        {
          label: e.t("image-panel.align.bottom"),
          value: D2.bottom
        }
      ]
    },
    {
      options: [
        {
          label: e.t("image-panel.align.horizon"),
          value: D2.horizon
        },
        {
          label: e.t("image-panel.align.vertical"),
          value: D2.vertical
        }
      ]
    }
  ];
  function o2(c2) {
    s(c2), r.executeCommand(ze.id, {
      alignType: c2
    });
  }
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      className: ie2("univer-relative univer-w-full", {
        "univer-hidden": !t
      }),
      children: [
        (0, import_jsx_runtime.jsx)(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: (0, import_jsx_runtime.jsx)("div", { children: e.t("image-panel.align.title") })
          }
        ),
        (0, import_jsx_runtime.jsx)("div", { className: "univer-relative univer-mt-2.5 univer-flex univer-h-full", children: (0, import_jsx_runtime.jsx)(
          "div",
          {
            className: "univer-w-full univer-text-gray-900 dark:!univer-text-white",
            children: (0, import_jsx_runtime.jsx)(LE, { value: n, options: a, onChange: o2 })
          }
        ) })
      ]
    }
  );
};
var yr = (i) => {
  const { arrangeShow: r, drawings: e } = i, t = useDependency(Fn), n = useDependency(Mt2), [s, a] = (0, import_react.useState)(e);
  (0, import_react.useEffect)(() => {
    const c2 = n.focus$.subscribe((u2) => {
      a(u2);
    });
    return () => {
      c2.unsubscribe();
    };
  }, []);
  const o2 = (c2) => {
    const u2 = s[0].unitId, l2 = s[0].subUnitId, g2 = s.map((d2) => d2.drawingId);
    n.featurePluginOrderUpdateNotification({ unitId: u2, subUnitId: l2, drawingIds: g2, arrangeType: c2 });
  };
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      className: ie2("univer-grid univer-gap-2 univer-py-2 univer-text-gray-400", {
        "univer-hidden": !r
      }),
      children: [
        (0, import_jsx_runtime.jsx)(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: (0, import_jsx_runtime.jsx)("div", { children: t.t("image-panel.arrange.title") })
          }
        ),
        (0, import_jsx_runtime.jsxs)("div", { className: "univer-grid univer-grid-cols-2 univer-gap-2", children: [
          (0, import_jsx_runtime.jsxs)(vr2, { onClick: () => {
            o2(tg.forward);
          }, children: [
            (0, import_jsx_runtime.jsx)(wt, {}),
            t.t("image-panel.arrange.forward")
          ] }),
          (0, import_jsx_runtime.jsxs)(vr2, { onClick: () => {
            o2(tg.backward);
          }, children: [
            (0, import_jsx_runtime.jsx)(mt2, {}),
            t.t("image-panel.arrange.backward")
          ] }),
          (0, import_jsx_runtime.jsxs)(vr2, { onClick: () => {
            o2(tg.front);
          }, children: [
            (0, import_jsx_runtime.jsx)(vt2, {}),
            t.t("image-panel.arrange.front")
          ] }),
          (0, import_jsx_runtime.jsxs)(vr2, { onClick: () => {
            o2(tg.back);
          }, children: [
            (0, import_jsx_runtime.jsx)(dt, {}),
            t.t("image-panel.arrange.back")
          ] })
        ] })
      ]
    }
  );
};
var Mr2 = (i) => {
  const r = useDependency(Fn), e = useDependency(ME), t = useDependency(Mt2), { hasGroup: n, drawings: s } = i, [a, o2] = (0, import_react.useState)(false), [c2, u2] = (0, import_react.useState)(true), [l2, g2] = (0, import_react.useState)(true), d2 = () => {
    const h3 = t.getFocusDrawings(), { unitId: p2, subUnitId: C } = h3[0], _2 = et(10), b = Xv(0, 0, h3.map((S) => S.transform || {})), R = {
      unitId: p2,
      subUnitId: C,
      drawingId: _2,
      drawingType: ng.DRAWING_GROUP,
      transform: b
    }, T = h3.map((S) => {
      const I = S.transform || { left: 0, top: 0 }, { unitId: y, subUnitId: O, drawingId: M } = S;
      return {
        unitId: y,
        subUnitId: O,
        drawingId: M,
        transform: {
          ...I,
          left: I.left - b.left,
          top: I.top - b.top
        },
        groupId: _2
      };
    });
    t.featurePluginGroupUpdateNotification([{
      parent: R,
      children: T
    }]);
  }, f3 = (h3) => {
    if (h3.drawingType !== ng.DRAWING_GROUP)
      return;
    const { unitId: p2, subUnitId: C, drawingId: _2, transform: b = { width: 0, height: 0 } } = h3;
    if (b == null)
      return;
    const R = t.getDrawingsByGroup({ unitId: p2, subUnitId: C, drawingId: _2 });
    if (R.length === 0)
      return;
    const T = R.map((S) => {
      const { transform: I } = S, { unitId: y, subUnitId: O, drawingId: M } = S, N = Vv(I || {}, b, b.width || 0, b.height || 0);
      return {
        unitId: y,
        subUnitId: O,
        drawingId: M,
        transform: {
          ...I,
          ...N
        },
        groupId: void 0
      };
    });
    return {
      parent: h3,
      children: T
    };
  }, w2 = () => {
    const p2 = t.getFocusDrawings().map(
      (C) => f3(C)
    ).filter((C) => C != null);
    p2.length !== 0 && t.featurePluginUngroupUpdateNotification(p2);
  };
  return (0, import_react.useEffect)(() => {
    const h3 = s[0];
    if (h3 == null)
      return;
    const { unitId: p2 } = h3, C = e.getRenderById(p2), _2 = C == null ? void 0 : C.scene;
    if (_2 == null)
      return;
    const b = _2.getTransformerByCreate(), R = b.clearControl$.subscribe((S) => {
      S === true && o2(false);
    }), T = b.changeStart$.subscribe((S) => {
      const { objects: I } = S, y = Le2(I, t), O = y.filter((W) => (W == null ? void 0 : W.drawingType) === ng.DRAWING_GROUP);
      let M = false, N = false;
      y.length > 1 && (M = true), O.length > 0 && (N = true), o2(M || N), u2(M), g2(N);
    });
    return () => {
      T.unsubscribe(), R.unsubscribe();
    };
  }, []), (0, import_jsx_runtime.jsxs)(
    "div",
    {
      className: ie2("univer-grid univer-gap-2 univer-py-2 univer-text-gray-400", {
        "univer-hidden": n === true && a === false || n === false
      }),
      children: [
        (0, import_jsx_runtime.jsx)(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: (0, import_jsx_runtime.jsx)("div", { children: r.t("image-panel.group.title") })
          }
        ),
        (0, import_jsx_runtime.jsxs)("div", { className: "univer-flex univer-items-center univer-justify-center univer-gap-2", children: [
          (0, import_jsx_runtime.jsxs)(
            vr2,
            {
              className: ie2({
                "univer-hidden": !c2
              }),
              onClick: d2,
              children: [
                (0, import_jsx_runtime.jsx)(ft, {}),
                r.t("image-panel.group.group")
              ]
            }
          ),
          (0, import_jsx_runtime.jsxs)(
            vr2,
            {
              className: ie2({
                "univer-hidden": !l2
              }),
              onClick: w2,
              children: [
                (0, import_jsx_runtime.jsx)(_t, {}),
                r.t("image-panel.group.unGroup")
              ]
            }
          )
        ] })
      ]
    }
  );
};
var ye3 = 20;
var Me = 20;
var it = [-360, 360];
var Re = 300;
var Rr = (i) => {
  var Ke2;
  const r = useDependency(Fn), e = useDependency(Mt2), t = useDependency(ME), { drawings: n, transformShow: s } = i, a = n[0];
  if (a == null)
    return;
  const o2 = a.transform;
  if (o2 == null)
    return;
  const { unitId: c2, subUnitId: u2, drawingId: l2, drawingType: g2 } = a, d2 = t.getRenderById(c2), f3 = d2 == null ? void 0 : d2.scene;
  if (f3 == null)
    return;
  const w2 = (Ke2 = f3.getEngine()) == null ? void 0 : Ke2.activeScene;
  if (w2 == null)
    return;
  const h3 = f3.getTransformerByCreate(), {
    width: p2 = 0,
    height: C = 0,
    left: _2 = 0,
    top: b = 0,
    angle: R = 0
  } = o2, [T, S] = (0, import_react.useState)(p2), [I, y] = (0, import_react.useState)(C), [O, M] = (0, import_react.useState)(_2), [N, B] = (0, import_react.useState)(b), [W, K] = (0, import_react.useState)(R), [Y3, ve] = (0, import_react.useState)(h3.keepRatio), ne = (m, E3, H, k) => {
    const { width: U2, height: X } = w2, { ancestorLeft: V2, ancestorTop: G3 } = f3;
    let Z = m, ie3 = E3, ge2 = H, de2 = k;
    return m + V2 < 0 && (Z = -V2), E3 + G3 < 0 && (ie3 = -G3), ge2 = U2 - Z - V2, ge2 < ye3 && (ge2 = ye3), de2 = X - ie3 - G3, de2 < Me && (de2 = Me), m + ge2 + V2 > U2 && (Z = U2 - H - V2), E3 + de2 + G3 > X && (ie3 = X - k - G3), {
      limitLeft: Z,
      limitTop: ie3,
      limitWidth: ge2,
      limitHeight: de2
    };
  }, $2 = (m) => {
    const { objects: E3 } = m, H = Le2(E3, e);
    if (H.length !== 1)
      return;
    const k = H[0];
    if (k == null)
      return;
    const { transform: U2 } = k;
    if (U2 == null)
      return;
    const {
      width: X,
      height: V2,
      left: G3,
      top: Z,
      angle: ie3
    } = U2;
    X != null && S(X), V2 != null && y(V2), G3 != null && M(G3), Z != null && B(Z), ie3 != null && K(ie3);
  };
  (0, import_react.useEffect)(() => {
    const m = [
      h3.changeStart$.subscribe((E3) => {
        $2(E3);
      }),
      h3.changing$.subscribe((E3) => {
        $2(E3);
      }),
      h3.changeEnd$.subscribe((E3) => {
        $2(E3);
      }),
      e.focus$.subscribe((E3) => {
        if (E3.length !== 1)
          return;
        const H = e.getDrawingByParam(E3[0]);
        if (H == null)
          return;
        const k = H.transform;
        if (k == null)
          return;
        const {
          width: U2,
          height: X,
          left: V2,
          top: G3,
          angle: Z
        } = k;
        U2 != null && S(U2), X != null && y(X), V2 != null && M(V2), G3 != null && B(G3), Z != null && K(Z);
      })
    ];
    return () => {
      m.forEach((E3) => E3.unsubscribe());
    };
  }, []);
  const ke2 = n1((m) => {
    if (m == null)
      return;
    const { limitWidth: E3, limitHeight: H } = ne(O, N, m, I);
    m = Math.min(m, E3);
    const k = { unitId: c2, subUnitId: u2, drawingId: l2, drawingType: g2, transform: { width: m } };
    if (Y3) {
      let U2 = m / T * I;
      if (U2 = Math.max(U2, Me), U2 > H)
        return;
      y(U2), k.transform.height = U2;
    }
    S(m), e.featurePluginUpdateNotification([k]), h3.refreshControls().changeNotification();
  }, Re), bt3 = n1((m) => {
    if (m == null)
      return;
    const { limitHeight: E3, limitWidth: H } = ne(O, N, T, m);
    m = Math.min(m, E3);
    const k = { unitId: c2, subUnitId: u2, drawingId: l2, drawingType: g2, transform: { height: m } };
    if (Y3) {
      let U2 = m / I * T;
      if (U2 = Math.max(U2, ye3), U2 > H)
        return;
      S(U2), k.transform.width = U2;
    }
    y(m), e.featurePluginUpdateNotification([k]), h3.refreshControls().changeNotification();
  }, Re), It2 = n1((m) => {
    if (m == null)
      return;
    const { limitLeft: E3 } = ne(m, N, T, I);
    m = E3;
    const H = { unitId: c2, subUnitId: u2, drawingId: l2, drawingType: g2, transform: { left: m } };
    M(m), e.featurePluginUpdateNotification([H]), h3.refreshControls().changeNotification();
  }, Re), yt2 = n1((m) => {
    if (m == null)
      return;
    const { limitTop: E3 } = ne(O, m, T, I);
    m = E3;
    const H = { unitId: c2, subUnitId: u2, drawingId: l2, drawingType: g2, transform: { top: m } };
    B(m), e.featurePluginUpdateNotification([H]), h3.refreshControls().changeNotification();
  }, Re), Mt4 = (m) => {
    if (m == null)
      return;
    const E3 = { unitId: c2, subUnitId: u2, drawingId: l2, drawingType: g2, transform: { angle: m } };
    K(m), e.featurePluginUpdateNotification([E3]), h3.refreshControls().changeNotification();
  }, Rt2 = (m) => {
    ve(m), h3.keepRatio = m;
  };
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      className: ie2("univer-grid univer-gap-2 univer-py-2 univer-text-gray-400", {
        "univer-hidden": !s
      }),
      children: [
        (0, import_jsx_runtime.jsx)(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: (0, import_jsx_runtime.jsx)("div", { children: r.t("image-panel.transform.title") })
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          "div",
          {
            className: "univer-grid univer-grid-cols-3 univer-gap-2 [&>div]:univer-grid [&>div]:univer-gap-2",
            children: [
              (0, import_jsx_runtime.jsxs)("div", { children: [
                (0, import_jsx_runtime.jsx)("span", { children: r.t("image-panel.transform.width") }),
                (0, import_jsx_runtime.jsx)(
                  xE,
                  {
                    precision: 1,
                    value: T,
                    min: ye3,
                    onChange: (m) => {
                      ke2(m);
                    }
                  }
                )
              ] }),
              (0, import_jsx_runtime.jsxs)("div", { children: [
                (0, import_jsx_runtime.jsx)("span", { children: r.t("image-panel.transform.height") }),
                (0, import_jsx_runtime.jsx)(
                  xE,
                  {
                    precision: 1,
                    value: I,
                    min: Me,
                    onChange: (m) => {
                      bt3(m);
                    }
                  }
                )
              ] }),
              (0, import_jsx_runtime.jsxs)("div", { children: [
                (0, import_jsx_runtime.jsx)("span", { children: r.t("image-panel.transform.lock") }),
                (0, import_jsx_runtime.jsx)("div", { className: "univer-text-center", children: (0, import_jsx_runtime.jsx)(em, { checked: Y3, onChange: Rt2 }) })
              ] })
            ]
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          "div",
          {
            className: "univer-grid univer-grid-cols-3 univer-gap-2 [&>div]:univer-grid [&>div]:univer-gap-2",
            children: [
              (0, import_jsx_runtime.jsxs)("div", { children: [
                (0, import_jsx_runtime.jsx)("span", { children: r.t("image-panel.transform.x") }),
                (0, import_jsx_runtime.jsx)(xE, { precision: 1, value: O, onChange: (m) => {
                  It2(m);
                } })
              ] }),
              (0, import_jsx_runtime.jsxs)("div", { children: [
                (0, import_jsx_runtime.jsx)("span", { children: r.t("image-panel.transform.y") }),
                (0, import_jsx_runtime.jsx)(xE, { precision: 1, value: N, onChange: (m) => {
                  yt2(m);
                } })
              ] }),
              (0, import_jsx_runtime.jsxs)("div", { children: [
                (0, import_jsx_runtime.jsx)("span", { children: r.t("image-panel.transform.rotate") }),
                (0, import_jsx_runtime.jsx)(
                  xE,
                  {
                    precision: 1,
                    value: W,
                    min: it[0],
                    max: it[1],
                    onChange: Mt4
                  }
                )
              ] })
            ]
          }
        )
      ]
    }
  );
};
var Or = (i) => {
  const r = useDependency(Ls), e = useDependency(Fn), { drawings: t, cropperShow: n } = i;
  if (t[0] == null)
    return;
  const [a, o2] = (0, import_react.useState)(x.FREE), c2 = (0, import_react.useRef)(false), u2 = [
    {
      label: e.t("image-panel.crop.mode"),
      value: x.FREE
    },
    {
      label: "1:1",
      value: x.R1_1
    },
    {
      label: "16:9",
      value: x.R16_9
    },
    {
      label: "9:16",
      value: x.R9_16
    },
    {
      label: "5:4",
      value: x.R5_4
    },
    {
      label: "4:5",
      value: x.R4_5
    },
    {
      label: "4:3",
      value: x.R4_3
    },
    {
      label: "3:4",
      value: x.R3_4
    },
    {
      label: "3:2",
      value: x.R3_2
    },
    {
      label: "2:3",
      value: x.R2_3
    }
  ];
  (0, import_react.useEffect)(() => {
    const d2 = r.onCommandExecuted((f3) => {
      if (f3.id === oe.id) {
        const w2 = f3.params;
        w2 != null && w2.isAuto || (c2.current = false);
      }
    });
    return () => {
      d2 == null || d2.dispose();
    };
  }, []);
  function l2(d2) {
    o2(d2), c2.current && r.executeCommand(Pe2.id, {
      cropType: d2
    });
  }
  const g2 = (d2) => {
    r.executeCommand(Pe2.id, {
      cropType: d2
    }), c2.current = true;
  };
  return (0, import_jsx_runtime.jsxs)(
    "div",
    {
      className: ie2("univer-grid univer-gap-2 univer-py-2 univer-text-gray-400", {
        "univer-hidden": !n
      }),
      children: [
        (0, import_jsx_runtime.jsx)(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: (0, import_jsx_runtime.jsx)("div", { children: e.t("image-panel.crop.title") })
          }
        ),
        (0, import_jsx_runtime.jsxs)("div", { className: "univer-flex univer-items-center univer-justify-center univer-gap-2", children: [
          (0, import_jsx_runtime.jsxs)(vr2, { onClick: () => {
            g2(a);
          }, children: [
            (0, import_jsx_runtime.jsx)(ht2, {}),
            e.t("image-panel.crop.start")
          ] }),
          (0, import_jsx_runtime.jsx)(LE, { value: a, options: u2, onChange: l2 })
        ] })
      ]
    }
  );
};
var Ar = (i) => {
  const r = useDependency(Mt2), e = useDependency(ME), t = useDependency(Fn), { drawings: n, hasArrange: s = true, hasTransform: a = true, hasAlign: o2 = true, hasCropper: c2 = true, hasGroup: u2 = true } = i, l2 = n[0];
  if (l2 == null)
    return;
  const { unitId: g2 } = l2, d2 = e.getRenderById(g2), f3 = d2 == null ? void 0 : d2.scene;
  if (f3 == null)
    return;
  const w2 = f3.getTransformerByCreate(), [h3, p2] = (0, import_react.useState)(true), [C, _2] = (0, import_react.useState)(true), [b, R] = (0, import_react.useState)(false), [T, S] = (0, import_react.useState)(true), [I, y] = (0, import_react.useState)(false);
  return (0, import_react.useEffect)(() => {
    const O = w2.clearControl$.subscribe((B) => {
      B === true && (p2(false), _2(false), R(false), S(false), y(true));
    }), M = w2.changeStart$.subscribe((B) => {
      const { objects: W } = B, K = Le2(W, r);
      K.length === 0 ? (p2(false), _2(false), R(false), S(false), y(true)) : K.length === 1 ? (p2(true), _2(true), R(false), S(true), y(false)) : (p2(true), _2(false), R(true), S(false), y(false));
    }), N = r.focus$.subscribe((B) => {
      B.length === 0 ? (p2(false), _2(false), R(false), S(false), y(true)) : B.length === 1 ? (p2(true), _2(true), R(false), S(true), y(false)) : (p2(true), _2(false), R(true), S(false), y(false));
    });
    return () => {
      M.unsubscribe(), O.unsubscribe(), N.unsubscribe();
    };
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: ie2("univer-h-full", {
          "univer-hidden": !I
        }),
        children: (0, import_jsx_runtime.jsx)("div", { className: "univer-flex univer-h-full univer-items-center univer-justify-center", children: (0, import_jsx_runtime.jsx)("span", { children: t.t("image-panel.null") }) })
      }
    ),
    (0, import_jsx_runtime.jsx)(yr, { arrangeShow: s === true ? h3 : false, drawings: n }),
    (0, import_jsx_runtime.jsx)(Rr, { transformShow: a === true ? C : false, drawings: n }),
    (0, import_jsx_runtime.jsx)(Ir, { alignShow: o2 === true ? b : false, drawings: n }),
    (0, import_jsx_runtime.jsx)(Or, { cropperShow: c2 === true ? T : false, drawings: n }),
    (0, import_jsx_runtime.jsx)(Mr2, { hasGroup: u2, drawings: n })
  ] });
};

// node_modules/@univerjs/sheets-drawing-ui/lib/es/index.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());
var yr2 = Object.defineProperty;
var Tr = (i, t, e) => t in i ? yr2(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var ee2 = (i, t, e) => Tr(i, typeof t != "symbol" ? t + "" : t, e);
function z3(i, t, e) {
  const { from: n, to: r, flipY: s = false, flipX: o2 = false, angle: a = 0, skewX: d2 = 0, skewY: u2 = 0 } = i, c2 = e.getCurrent();
  if (c2 == null)
    return;
  const l2 = e2(
    c2.unitId,
    c2.sheetId,
    { from: n, to: r },
    e
  );
  let { left: g2, top: h3, width: f3, height: p2 } = l2;
  const m = e.getCurrentSkeleton(), _2 = m.rowHeaderWidth + m.columnTotalWidth, v3 = m.columnHeaderHeight + m.rowTotalHeight;
  return g2 + f3 > _2 && (g2 = _2 - f3), h3 + p2 > v3 && (h3 = v3 - p2), {
    flipY: s,
    flipX: o2,
    angle: a,
    skewX: d2,
    skewY: u2,
    left: g2,
    top: h3,
    width: f3,
    height: p2
  };
}
function $(i, t) {
  const { left: e = 0, top: n = 0, width: r = 0, height: s = 0, flipY: o2 = false, flipX: a = false, angle: d2 = 0, skewX: u2 = 0, skewY: c2 = 0 } = i, l2 = t.getCellWithCoordByOffset(e, n);
  if (l2 == null)
    return;
  const g2 = {
    column: l2.actualColumn,
    columnOffset: de(e - l2.startX, 1),
    row: l2.actualRow,
    rowOffset: de(n - l2.startY, 1)
  }, h3 = t.getCellWithCoordByOffset(e + r, n + s);
  if (h3 == null)
    return;
  const f3 = {
    column: h3.actualColumn,
    columnOffset: de(e + r - h3.startX, 1),
    row: h3.actualRow,
    rowOffset: de(n + s - h3.startY, 1)
  };
  return {
    flipY: o2,
    flipX: a,
    angle: d2,
    skewX: u2,
    skewY: c2,
    from: g2,
    to: f3
  };
}
var Y2 = {
  id: "sheet.operation.clear-drawing-transformer",
  type: Ms.MUTATION,
  handler: (i, t) => {
    const e = i.get(ME);
    return t.forEach((n) => {
      var r, s;
      (s = (r = e.getRenderById(n)) == null ? void 0 : r.scene.getTransformer()) == null || s.debounceRefreshControls();
    }), true;
  }
};
var rt2 = {
  id: "sheet.command.remove-sheet-image",
  type: Ms.COMMAND,
  handler: (i, t) => {
    var v3, I, R;
    const e = i.get(Ls), n = i.get(Qo), r = i.get(G), s = i.get(E);
    if (!t) return false;
    const { drawings: o2 } = t, a = [];
    o2.forEach((S) => {
      const { unitId: C } = S;
      a.push(C);
    });
    const d2 = s.getBatchRemoveOp(o2), { unitId: u2, subUnitId: c2, undo: l2, redo: g2, objects: h3 } = d2, f3 = r.onCommandExecute({ id: rt2.id, params: t }), p2 = { id: g.id, params: { unitId: u2, subUnitId: c2, op: g2, objects: h3, type: h.REMOVE } }, m = { id: g.id, params: { unitId: u2, subUnitId: c2, op: l2, objects: h3, type: h.INSERT } };
    return fo([...(v3 = f3.preRedos) != null ? v3 : [], p2, ...f3.redos], e) ? (n.pushUndoRedo({
      unitID: u2,
      undoMutations: [
        ...(I = f3.preUndos) != null ? I : [],
        m,
        ...f3.undos,
        { id: Y2.id, params: a }
      ],
      redoMutations: [
        ...(R = f3.preRedos) != null ? R : [],
        p2,
        ...f3.redos,
        { id: Y2.id, params: a }
      ]
    }), true) : false;
  }
};
var hr3 = {
  id: "sheet.command.delete-drawing",
  type: Ms.COMMAND,
  handler: (i) => {
    const t = i.get(Ls), n = i.get(E).getFocusDrawings();
    if (n.length === 0)
      return false;
    const r = n[0].unitId, s = n.map((o2) => {
      const { unitId: a, subUnitId: d2, drawingId: u2, drawingType: c2 } = o2;
      return {
        unitId: a,
        subUnitId: d2,
        drawingId: u2,
        drawingType: c2
      };
    });
    return t.executeCommand(rt2.id, {
      unitId: r,
      drawings: s
    });
  }
};
function es(i) {
  const t = [];
  return i.forEach((e) => {
    const { parent: n, children: r } = e, { unitId: s, subUnitId: o2, drawingId: a } = n, d2 = Xv(0, 0, r.map((l2) => l2.transform || {})), u2 = r.map((l2) => {
      const g2 = l2.transform || { left: 0, top: 0 }, { unitId: h3, subUnitId: f3, drawingId: p2 } = l2;
      return {
        unitId: h3,
        subUnitId: f3,
        drawingId: p2,
        transform: {
          ...g2,
          left: g2.left - d2.left,
          top: g2.top - d2.top
        },
        groupId: a
      };
    }), c2 = {
      unitId: s,
      subUnitId: o2,
      drawingId: a,
      drawingType: ng.DRAWING_GROUP,
      transform: d2
    };
    t.push({
      parent: c2,
      children: u2
    });
  }), t;
}
function ts(i) {
  const t = [];
  return i.forEach((e) => {
    const { parent: n, children: r } = e, { unitId: s, subUnitId: o2, drawingId: a, transform: d2 = { width: 0, height: 0 } } = n;
    if (d2 == null)
      return;
    const u2 = r.map((l2) => {
      const { transform: g2 } = l2, { unitId: h3, subUnitId: f3, drawingId: p2 } = l2, m = Vv(g2 || {}, d2, d2.width || 0, d2.height || 0);
      return {
        unitId: h3,
        subUnitId: f3,
        drawingId: p2,
        transform: m,
        groupId: void 0
      };
    }), c2 = {
      unitId: s,
      subUnitId: o2,
      drawingId: a,
      drawingType: ng.DRAWING_GROUP,
      transform: {
        left: 0,
        top: 0
      }
    };
    t.push({
      parent: c2,
      children: u2
    });
  }), t;
}
var gr2 = {
  id: "sheet.command.group-sheet-image",
  type: Ms.COMMAND,
  handler: (i, t) => {
    const e = i.get(Ls), n = i.get(Qo), r = i.get(E);
    if (!t) return false;
    const s = [];
    t.forEach(({ parent: h3, children: f3 }) => {
      s.push(h3.unitId), f3.forEach((p2) => {
        s.push(p2.unitId);
      });
    });
    const o2 = r.getGroupDrawingOp(t), { unitId: a, subUnitId: d2, undo: u2, redo: c2, objects: l2 } = o2;
    return e.syncExecuteCommand(g.id, { op: c2, unitId: a, subUnitId: d2, objects: l2, type: h.GROUP }) ? (n.pushUndoRedo({
      unitID: a,
      undoMutations: [
        { id: g.id, params: { op: u2, unitId: a, subUnitId: d2, objects: ts(l2), type: h.UNGROUP } },
        { id: Y2.id, params: s }
      ],
      redoMutations: [
        { id: g.id, params: { op: c2, unitId: a, subUnitId: d2, objects: l2, type: h.GROUP } },
        { id: Y2.id, params: s }
      ]
    }), true) : false;
  }
};
var kt2 = {
  id: "sheet.command.insert-sheet-image",
  type: Ms.COMMAND,
  handler: (i, t) => {
    var v3, I, R;
    const e = i.get(Ls), n = i.get(Qo), r = i.get(E), s = i.get(G);
    if (!t) return false;
    const o2 = t.drawings, a = o2.map((S) => S.unitId), d2 = r.getBatchAddOp(o2), { unitId: u2, subUnitId: c2, undo: l2, redo: g2, objects: h3 } = d2, f3 = s.onCommandExecute({ id: kt2.id, params: t }), p2 = { id: g.id, params: { op: g2, unitId: u2, subUnitId: c2, objects: h3, type: h.INSERT } }, m = { id: g.id, params: { op: l2, unitId: u2, subUnitId: c2, objects: h3, type: h.REMOVE } };
    return fo([...(v3 = f3.preRedos) != null ? v3 : [], p2, ...f3.redos], e) ? (n.pushUndoRedo({
      unitID: u2,
      undoMutations: [
        ...(I = f3.preUndos) != null ? I : [],
        m,
        ...f3.undos,
        { id: Y2.id, params: a }
      ],
      redoMutations: [
        ...(R = f3.preRedos) != null ? R : [],
        p2,
        ...f3.redos,
        { id: Y2.id, params: a }
      ]
    }), true) : false;
  }
};
var fr2 = {
  id: "sheet.command.set-drawing-arrange",
  type: Ms.COMMAND,
  handler: (i, t) => {
    const e = i.get(Ls), n = i.get(Qo);
    if (!t) return false;
    const r = i.get(E), { unitId: s, subUnitId: o2, drawingIds: a, arrangeType: d2 } = t, u2 = { unitId: s, subUnitId: o2, drawingIds: a };
    let c2;
    if (d2 === tg.forward ? c2 = r.getForwardDrawingsOp(u2) : d2 === tg.backward ? c2 = r.getBackwardDrawingOp(u2) : d2 === tg.front ? c2 = r.getFrontDrawingsOp(u2) : d2 === tg.back && (c2 = r.getBackDrawingsOp(u2)), c2 == null)
      return false;
    const { objects: l2, redo: g2, undo: h3 } = c2;
    return e.syncExecuteCommand(g.id, { op: g2, unitId: s, subUnitId: o2, objects: l2, type: h.ARRANGE }) ? (n.pushUndoRedo({
      unitID: s,
      undoMutations: [
        { id: g.id, params: { op: h3, unitId: s, subUnitId: o2, objects: l2, type: h.ARRANGE } }
      ],
      redoMutations: [
        { id: g.id, params: { op: g2, unitId: s, subUnitId: o2, objects: l2, type: h.ARRANGE } }
      ]
    }), true) : false;
  }
};
var Wt = {
  id: "sheet.command.set-sheet-image",
  type: Ms.COMMAND,
  handler: (i, t) => {
    const e = i.get(Ls), n = i.get(Qo), r = i.get(E);
    if (!t) return false;
    const { drawings: s } = t, o2 = r.getBatchUpdateOp(s), { unitId: a, subUnitId: d2, undo: u2, redo: c2, objects: l2 } = o2;
    return e.syncExecuteCommand(g.id, { unitId: a, subUnitId: d2, op: c2, objects: l2, type: h.UPDATE }) ? (n.pushUndoRedo({
      unitID: a,
      undoMutations: [
        { id: g.id, params: { unitId: a, subUnitId: d2, op: u2, objects: l2, type: h.UPDATE } },
        { id: Y2.id, params: [a] }
      ],
      redoMutations: [
        { id: g.id, params: { unitId: a, subUnitId: d2, op: c2, objects: l2, type: h.UPDATE } },
        { id: Y2.id, params: [a] }
      ]
    }), true) : false;
  }
};
var mr2 = {
  id: "sheet.command.ungroup-sheet-image",
  type: Ms.COMMAND,
  handler: (i, t) => {
    const e = i.get(Ls), n = i.get(Qo), r = i.get(E);
    if (!t) return false;
    const s = [];
    t.forEach(({ parent: h3, children: f3 }) => {
      s.push(h3.unitId), f3.forEach((p2) => {
        s.push(p2.unitId);
      });
    });
    const o2 = r.getUngroupDrawingOp(t), { unitId: a, subUnitId: d2, undo: u2, redo: c2, objects: l2 } = o2;
    return e.syncExecuteCommand(g.id, { op: c2, unitId: a, subUnitId: d2, objects: l2, type: h.UNGROUP }) ? (n.pushUndoRedo({
      unitID: a,
      undoMutations: [
        { id: g.id, params: { op: u2, unitId: a, subUnitId: d2, objects: es(l2), type: h.GROUP } },
        { id: Y2.id, params: s }
      ],
      redoMutations: [
        { id: g.id, params: { op: c2, unitId: a, subUnitId: d2, objects: l2, type: h.UNGROUP } },
        { id: Y2.id, params: s }
      ]
    }), true) : false;
  }
};
var ns = Object.getOwnPropertyDescriptor;
var rs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? ns(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var te = (i, t) => (e, n) => t(e, n, i);
function is(i, t, e) {
  const n = e * Math.PI / 180, r = Math.abs(i * Math.cos(n)) + Math.abs(t * Math.sin(n)), s = Math.abs(i * Math.sin(n)) + Math.abs(t * Math.cos(n));
  return { rotatedWidth: r, rotatedHeight: s };
}
function en(i, t, e, n, r) {
  var v3;
  const { rotatedHeight: s, rotatedWidth: o2 } = is(e, n, r), d2 = i.get(ME).getRenderById(t.unitId);
  if (!d2)
    return false;
  const c2 = (v3 = d2.with(ue).getSkeletonParam(t.subUnitId)) == null ? void 0 : v3.skeleton;
  if (c2 == null)
    return false;
  const l2 = c2.getCellByIndex(t.row, t.col), g2 = l2.mergeInfo.endX - l2.mergeInfo.startX - 2, h3 = l2.mergeInfo.endY - l2.mergeInfo.startY - 2, f3 = o2 / s, m = Math.ceil(Math.min(g2, h3 * f3)) / o2, _2 = !m || Number.isNaN(m) ? 1e-3 : m;
  return {
    width: e * _2,
    height: n * _2
  };
}
var et5 = class extends Ve {
  constructor(t, e, n, r, s, o2, a, d2, u2, c2, l2, g2, h3) {
    super();
    ee2(this, "_workbookSelections");
    this._context = t, this._skeletonManagerService = e, this._commandService = n, this._selectionRenderService = r, this._imageIoService = s, this._fileOpenerService = o2, this._sheetDrawingService = a, this._drawingManagerService = d2, this._contextService = u2, this._messageService = c2, this._localeService = l2, this._injector = h3, this._workbookSelections = g2.getWorkbookSelections(this._context.unitId), this._updateImageListener(), this._updateOrderListener(), this._groupDrawingListener(), this._focusDrawingListener();
  }
  async insertFloatImage() {
    const t = await this._fileOpenerService.openFile({
      multiple: true,
      accept: Zt.map((n) => `.${n.replace("image/", "")}`).join(",")
    }), e = t.length;
    return e > mn2 ? (this._messageService.show({
      type: $C.Error,
      content: this._localeService.t("update-status.exceedMaxCount", String(mn2))
    }), false) : e === 0 ? false : (t.forEach(async (n) => await this.insertFloatImageByFile(n)), true);
  }
  async insertCellImage() {
    const e = (await this._fileOpenerService.openFile({
      multiple: false,
      accept: Zt.map((n) => `.${n.replace("image/", "")}`).join(",")
    }))[0];
    return e ? (await this._insertCellImage(e), true) : false;
  }
  insertCellImageByFile(t, e) {
    return this._insertCellImage(t, e);
  }
  async insertFloatImageByFile(t) {
    let e;
    try {
      e = await this._imageIoService.saveImage(t);
    } catch (v3) {
      const I = v3.message;
      I === pE.ERROR_EXCEED_SIZE ? this._messageService.show({
        type: $C.Error,
        content: this._localeService.t("update-status.exceedMaxSize", String(Yt / (1024 * 1024)))
      }) : I === pE.ERROR_IMAGE_TYPE ? this._messageService.show({
        type: $C.Error,
        content: this._localeService.t("update-status.invalidImageType")
      }) : I === pE.ERROR_IMAGE && this._messageService.show({
        type: $C.Error,
        content: this._localeService.t("update-status.invalidImage")
      });
    }
    if (e == null)
      return;
    const n = this._getUnitInfo(), { unitId: r, subUnitId: s } = n, { imageId: o2, imageSourceType: a, source: d2, base64Cache: u2 } = e, { width: c2, height: l2, image: g2 } = await wn(u2 || ""), { width: h3, height: f3 } = this._context.scene;
    this._imageIoService.addImageSourceCache(d2, a, g2);
    let p2 = 1;
    if (c2 > _n || l2 > vn) {
      const v3 = _n / c2, I = vn / l2;
      p2 = Math.max(v3, I);
    }
    const m = this._getImagePosition(c2 * p2, l2 * p2, h3, f3);
    if (m == null)
      return;
    const _2 = {
      unitId: r,
      subUnitId: s,
      drawingId: o2,
      drawingType: ng.DRAWING_IMAGE,
      imageSourceType: a,
      source: d2,
      transform: z3(m, this._selectionRenderService, this._skeletonManagerService),
      sheetTransform: m
    };
    return this._commandService.executeCommand(kt2.id, {
      unitId: r,
      drawings: [_2]
    });
  }
  // eslint-disable-next-line max-lines-per-function
  async _insertCellImage(t, e) {
    var I, R;
    let n;
    try {
      n = await this._imageIoService.saveImage(t);
    } catch (S) {
      const C = S.message;
      C === pE.ERROR_EXCEED_SIZE ? this._messageService.show({
        type: $C.Error,
        content: this._localeService.t("update-status.exceedMaxSize", String(Yt / (1024 * 1024)))
      }) : C === pE.ERROR_IMAGE_TYPE ? this._messageService.show({
        type: $C.Error,
        content: this._localeService.t("update-status.invalidImageType")
      }) : C === pE.ERROR_IMAGE && this._messageService.show({
        type: $C.Error,
        content: this._localeService.t("update-status.invalidImage")
      });
    }
    if (n == null)
      return false;
    const { imageId: r, imageSourceType: s, source: o2, base64Cache: a } = n, { width: d2, height: u2, image: c2 } = await wn(a || "");
    this._imageIoService.addImageSourceCache(o2, s, c2);
    const l2 = this._workbookSelections.getCurrentLastSelection();
    if (!l2)
      return false;
    let g2 = l2.primary.actualRow, h3 = l2.primary.actualColumn;
    l2.primary.isMerged && (g2 = l2.primary.startRow, h3 = l2.primary.startColumn);
    const f3 = Jr("", {}), p2 = en(
      this._injector,
      {
        unitId: this._context.unitId,
        subUnitId: this._context.unit.getActiveSheet().getSheetId(),
        row: g2,
        col: h3
      },
      d2,
      u2,
      0
    );
    if (!p2)
      return false;
    const m = {
      size: {
        width: p2.width,
        height: p2.height
      },
      positionH: {
        relativeFrom: Km.PAGE,
        posOffset: 0
      },
      positionV: {
        relativeFrom: Xm.PARAGRAPH,
        posOffset: 0
      },
      angle: 0
    }, _2 = {
      unitId: f3.getUnitId(),
      subUnitId: f3.getUnitId(),
      drawingId: r,
      drawingType: ng.DRAWING_IMAGE,
      imageSourceType: s,
      source: o2,
      transform: Xf(m),
      docTransform: m,
      behindDoc: ie.FALSE,
      title: "",
      description: "",
      layoutType: Fm.INLINE,
      // Insert inline drawing by default.
      wrapText: Pm.BOTH_SIDES,
      distB: 0,
      distL: 0,
      distR: 0,
      distT: 0
    }, v3 = Je.drawing.add({
      documentDataModel: f3,
      drawings: [_2],
      selection: {
        collapsed: true,
        startOffset: 0,
        endOffset: 0
      }
    });
    return v3 ? (f3.apply(v3), this._commandService.syncExecuteCommand(Sn.id, {
      value: {
        [(I = e == null ? void 0 : e.row) != null ? I : g2]: {
          [(R = e == null ? void 0 : e.col) != null ? R : h3]: {
            p: f3.getSnapshot(),
            t: 1
          }
        }
      },
      unitId: e == null ? void 0 : e.unitId,
      subUnitId: e == null ? void 0 : e.subUnitId
    })) : false;
  }
  // eslint-disable-next-line max-lines-per-function
  async insertCellImageByUrl(t, e) {
    var g2, h3;
    const { width: n, height: r, image: s } = await wn(t || "");
    this._imageIoService.addImageSourceCache(t, oc.URL, s);
    const o2 = this._workbookSelections.getCurrentLastSelection();
    if (!o2)
      return false;
    const a = Jr("", {}), d2 = en(
      this._injector,
      {
        unitId: this._context.unitId,
        subUnitId: this._context.unit.getActiveSheet().getSheetId(),
        row: o2.primary.actualRow,
        col: o2.primary.actualColumn
      },
      n,
      r,
      0
    );
    if (!d2)
      return false;
    const u2 = {
      size: {
        width: d2.width,
        height: d2.height
      },
      positionH: {
        relativeFrom: Km.PAGE,
        posOffset: 0
      },
      positionV: {
        relativeFrom: Xm.PARAGRAPH,
        posOffset: 0
      },
      angle: 0
    }, c2 = {
      unitId: a.getUnitId(),
      subUnitId: a.getUnitId(),
      drawingId: et(),
      drawingType: ng.DRAWING_IMAGE,
      imageSourceType: oc.URL,
      source: t,
      transform: Xf(u2),
      docTransform: u2,
      behindDoc: ie.FALSE,
      title: "",
      description: "",
      layoutType: Fm.INLINE,
      // Insert inline drawing by default.
      wrapText: Pm.BOTH_SIDES,
      distB: 0,
      distL: 0,
      distR: 0,
      distT: 0
    }, l2 = Je.drawing.add({
      documentDataModel: a,
      drawings: [c2],
      selection: {
        collapsed: true,
        startOffset: 0,
        endOffset: 0
      }
    });
    return l2 ? (a.apply(l2), this._commandService.syncExecuteCommand(Sn.id, {
      value: {
        [(g2 = e == null ? void 0 : e.row) != null ? g2 : o2.primary.actualRow]: {
          [(h3 = e == null ? void 0 : e.col) != null ? h3 : o2.primary.actualColumn]: {
            p: a.getSnapshot(),
            t: 1
          }
        }
      },
      unitId: e == null ? void 0 : e.unitId,
      subUnitId: e == null ? void 0 : e.subUnitId
    })) : false;
  }
  _getUnitInfo() {
    const t = this._context.unit, e = t.getActiveSheet(), n = t.getUnitId(), r = e.getSheetId();
    return {
      unitId: n,
      subUnitId: r
    };
  }
  _getImagePosition(t, e, n, r) {
    const s = this._workbookSelections.getCurrentSelections();
    let o2 = {
      startRow: 0,
      endRow: 0,
      startColumn: 0,
      endColumn: 0
    };
    s && s.length > 0 && (o2 = s[s.length - 1].range);
    const a = bo(this._skeletonManagerService.getCurrent().skeleton, o2);
    if (a == null)
      return;
    let { startColumn: d2, startRow: u2, startX: c2, startY: l2 } = a, g2 = false;
    if (c2 + t > n && (c2 = n - t, c2 < 0 && (c2 = 0, t = n), g2 = true), l2 + e > r && (l2 = r - e, l2 < 0 && (l2 = 0, e = r), g2 = true), g2) {
      const m = this._selectionRenderService.getCellWithCoordByOffset(c2, l2);
      if (m == null)
        return;
      c2 = m.startX, l2 = m.startY, d2 = m.actualColumn, u2 = m.actualRow;
    }
    const h3 = {
      column: d2,
      columnOffset: 0,
      row: u2,
      rowOffset: 0
    }, f3 = this._selectionRenderService.getCellWithCoordByOffset(c2 + t, l2 + e);
    if (f3 == null)
      return;
    const p2 = {
      column: f3.actualColumn,
      columnOffset: c2 + t - f3.startX,
      row: f3.actualRow,
      rowOffset: l2 + e - f3.startY
    };
    return {
      from: h3,
      to: p2
    };
  }
  _updateOrderListener() {
    this.disposeWithMe(this._drawingManagerService.featurePluginOrderUpdate$.subscribe((t) => {
      const { unitId: e, subUnitId: n, drawingIds: r, arrangeType: s } = t;
      this._commandService.executeCommand(fr2.id, {
        unitId: e,
        subUnitId: n,
        drawingIds: r,
        arrangeType: s
      });
    }));
  }
  _updateImageListener() {
    this.disposeWithMe(this._drawingManagerService.featurePluginUpdate$.subscribe((t) => {
      const e = [];
      t.length !== 0 && (t.forEach((n) => {
        const { unitId: r, subUnitId: s, drawingId: o2, drawingType: a, transform: d2 } = n;
        if (d2 == null)
          return;
        const u2 = this._sheetDrawingService.getDrawingByParam({ unitId: r, subUnitId: s, drawingId: o2 });
        if (u2 == null || u2.unitId !== this._context.unitId)
          return;
        const c2 = $({ ...u2.transform, ...d2 }, this._selectionRenderService);
        if (c2 == null)
          return;
        const l2 = {
          ...n,
          transform: { ...u2.transform, ...d2, ...z3(c2, this._selectionRenderService, this._skeletonManagerService) },
          sheetTransform: { ...c2 }
        };
        e.push(l2);
      }), e.length > 0 && this._commandService.executeCommand(Wt.id, {
        unitId: t[0].unitId,
        drawings: e
      }));
    }));
  }
  _groupDrawingListener() {
    this.disposeWithMe(this._drawingManagerService.featurePluginGroupUpdate$.subscribe((t) => {
      this._commandService.executeCommand(gr2.id, t);
      const { unitId: e, subUnitId: n, drawingId: r } = t[0].parent;
      this._commandService.syncExecuteCommand(Qt.id, [{ unitId: e, subUnitId: n, drawingId: r }]);
    })), this.disposeWithMe(this._drawingManagerService.featurePluginUngroupUpdate$.subscribe((t) => {
      this._commandService.executeCommand(mr2.id, t);
    }));
  }
  _focusDrawingListener() {
    this.disposeWithMe(
      this._drawingManagerService.focus$.subscribe((t) => {
        t == null || t.length === 0 ? (this._contextService.setContextValue(PR, false), this._sheetDrawingService.focusDrawing([])) : (this._contextService.setContextValue(PR, true), this._sheetDrawingService.focusDrawing(t));
      })
    );
  }
};
et5 = rs([
  te(1, Inject(ue)),
  te(2, Ls),
  te(3, gt),
  te(4, El),
  te(5, ar),
  te(6, E),
  te(7, Mt2),
  te(8, Nr),
  te(9, et2),
  te(10, Inject(Fn)),
  te(11, Inject(z)),
  te(12, Inject(Injector))
], et5);
var Bt = {
  id: "sheet.command.insert-float-image",
  type: Ms.COMMAND,
  handler: async (i, t) => {
    var o2, a;
    const e = i.get(vr), n = i.get(ME), r = (o2 = IE(
      we.UNIVER_SHEET,
      e,
      n
    )) == null ? void 0 : o2.with(et5);
    if (!r)
      return false;
    const s = t == null ? void 0 : t.files;
    if (s) {
      const d2 = s.map((u2) => r.insertFloatImageByFile(u2));
      return (await Promise.all(d2)).every((u2) => u2);
    } else
      return (a = r.insertFloatImage()) != null ? a : false;
  }
};
var dn = {
  id: "sheet.command.insert-cell-image",
  type: Ms.COMMAND,
  handler: (i) => {
    var n, r;
    const t = i.get(vr), e = i.get(ME);
    return (r = (n = IE(
      we.UNIVER_SHEET,
      t,
      e
    )) == null ? void 0 : n.with(et5).insertCellImage()) != null ? r : false;
  }
};
var it2 = {
  id: "sheet.command.move-drawing",
  type: Ms.COMMAND,
  handler: (i, t) => {
    const e = i.get(Ls), n = i.get(E), r = i.get(gt), { direction: s } = t, o2 = n.getFocusDrawings();
    if (o2.length === 0)
      return false;
    const a = o2[0].unitId, d2 = o2.map((c2) => {
      const { transform: l2 } = c2;
      if (l2 == null)
        return null;
      const g2 = { ...l2 }, { left: h3 = 0, top: f3 = 0 } = l2;
      return s === Cm.UP ? g2.top = f3 - 1 : s === Cm.DOWN ? g2.top = f3 + 1 : s === Cm.LEFT ? g2.left = h3 - 1 : s === Cm.RIGHT && (g2.left = h3 + 1), {
        ...c2,
        transform: g2,
        sheetTransform: $(g2, r)
      };
    }).filter((c2) => c2 != null);
    return e.syncExecuteCommand(Wt.id, {
      unitId: a,
      drawings: d2
    }) ? (e.syncExecuteCommand(Y2.id, [a]), true) : false;
  }
};
var pr2 = "COMPONENT_SHEET_DRAWING_PANEL";
var wr3 = {
  id: "sidebar.operation.sheet-image",
  type: Ms.COMMAND,
  handler: async (i, t) => {
    const e = i.get(we2), n = i.get(Fn), r = i.get(vr), s = i.get(Ls);
    if (!P(r)) return false;
    switch (t.value) {
      case "open":
        e.open({
          header: { title: n.t("sheetImage.panel.title") },
          children: { label: pr2 },
          onClose: () => {
            s.syncExecuteCommand(Qt.id, []);
          },
          width: 360
        });
        break;
      case "close":
      default:
        e.close();
        break;
    }
    return true;
  }
};
var _r2 = {
  id: "sheet.operation.edit-sheet-image",
  type: Ms.OPERATION,
  handler: (i, t) => {
    const e = i.get(Ls);
    return t == null ? false : (e.syncExecuteCommand(Qt.id, [t]), e.executeCommand(wr3.id, { value: "open" }), true);
  }
};
var ss = "sheets-drawing-ui.config";
var jn = {};
var os = Object.getOwnPropertyDescriptor;
var as = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? os(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var ce = (i, t) => (e, n) => t(e, n, i);
var Rt = class extends h1 {
  constructor(t, e, n, r, s, o2, a, d2, u2, c2) {
    super();
    ee2(this, "_initImagePopupMenu", /* @__PURE__ */ new Set());
    this._injector = t, this._localeService = e, this._drawingManagerService = n, this._canvasPopManagerService = r, this._renderManagerService = s, this._univerInstanceService = o2, this._messageService = a, this._contextService = d2, this._ioService = u2, this._commandService = c2, this._init();
  }
  _init() {
    this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET).pipe(takeUntil(this.dispose$)).subscribe((t) => this._create(t)), this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_SHEET).pipe(takeUntil(this.dispose$)).subscribe((t) => this._dispose(t)), this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET).forEach((t) => this._create(t)), this._setupLoadingStatus();
  }
  _setupLoadingStatus() {
    const t = "image-upload-loading";
    let e;
    this.disposeWithMe(this._ioService.change$.subscribe((n) => {
      n > 0 && !e ? e = this._messageService.show({
        id: t,
        type: $C.Loading,
        content: `${this._localeService.t("uploadLoading.loading")}: ${n}`,
        duration: 0
      }) : n === 0 && (e == null || e.dispose(), e = void 0);
    }));
  }
  _dispose(t) {
    super.dispose();
    const e = t.getUnitId();
    this._renderManagerService.removeRender(e);
  }
  _create(t) {
    if (!t)
      return;
    const e = t.getUnitId();
    this._renderManagerService.has(e) && !this._initImagePopupMenu.has(e) && (this._popupMenuListener(e), this._initImagePopupMenu.add(e));
  }
  _hasCropObject(t) {
    const e = t.getAllObjectsByOrder();
    for (const n of e)
      if (n instanceof Ie)
        return true;
    return false;
  }
  _popupMenuListener(t) {
    var s;
    const e = (s = this._renderManagerService.getRenderById(t)) == null ? void 0 : s.scene;
    if (!e)
      return;
    const n = e.getTransformerByCreate();
    if (!n)
      return;
    let r;
    this.disposeWithMe(
      n.createControl$.subscribe(() => {
        if (this._contextService.setContextValue(PR, true), this._hasCropObject(e))
          return;
        const o2 = n.getSelectedObjectMap();
        if (o2.size > 1) {
          r == null || r.dispose();
          return;
        }
        const a = o2.values().next().value;
        if (!a)
          return;
        const d2 = a.oKey, u2 = this._drawingManagerService.getDrawingOKey(d2);
        if (!u2)
          return;
        const { unitId: c2, subUnitId: l2, drawingId: g2, drawingType: h3 } = u2, f3 = u2.data;
        if (f3 && f3.disablePopup)
          return;
        r == null || r.dispose();
        const p2 = this._canvasPopManagerService.getFeatureMenu(c2, l2, g2, h3);
        r = this.disposeWithMe(this._canvasPopManagerService.attachPopupToObject(a, {
          componentKey: Xt,
          direction: "horizontal",
          offset: [2, 0],
          extraProps: {
            menuItems: p2 || this._getImageMenuItems(c2, l2, g2, h3)
          }
        }));
      })
    ), this.disposeWithMe(
      n.clearControl$.subscribe(() => {
        r == null || r.dispose(), this._contextService.setContextValue(PR, false), this._commandService.syncExecuteCommand(Qt.id, []);
      })
    ), this.disposeWithMe(
      this._contextService.contextChanged$.subscribe((o2) => {
        o2[PR] === false && (r == null || r.dispose());
      })
    ), this.disposeWithMe(
      n.changing$.subscribe(() => {
        r == null || r.dispose();
      })
    );
  }
  _getImageMenuItems(t, e, n, r) {
    return [
      {
        label: "image-popup.edit",
        index: 0,
        commandId: _r2.id,
        commandParams: { unitId: t, subUnitId: e, drawingId: n },
        disable: r === ng.DRAWING_DOM
      },
      {
        label: "image-popup.delete",
        index: 1,
        commandId: rt2.id,
        commandParams: { unitId: t, drawings: [{ unitId: t, subUnitId: e, drawingId: n }] },
        disable: false
      },
      {
        label: "image-popup.crop",
        index: 2,
        commandId: Ze.id,
        commandParams: { unitId: t, subUnitId: e, drawingId: n },
        disable: r === ng.DRAWING_DOM
      },
      {
        label: "image-popup.reset",
        index: 3,
        commandId: ut2.id,
        commandParams: [{ unitId: t, subUnitId: e, drawingId: n }],
        disable: r === ng.DRAWING_DOM
      }
    ];
  }
};
Rt = as([
  ce(0, Inject(Injector)),
  ce(1, Inject(Fn)),
  ce(2, Mt2),
  ce(3, Inject(yi)),
  ce(4, ME),
  ce(5, vr),
  ce(6, et2),
  ce(7, Nr),
  ce(8, El),
  ce(9, Ls)
], Rt);
var cs2 = Object.getOwnPropertyDescriptor;
var ds2 = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? cs2(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var vt3 = (i, t) => (e, n) => t(e, n, i);
var tn = class extends Ve {
  constructor(t, e, n, r, s) {
    super();
    ee2(this, "_isSetCursor", false);
    this._context = t, this._hoverManagerService = e, this._selectionsService = n, this._drawingRenderService = r, this._sheetSkeletonManagerService = s, this._initHover(), this._initImageClick();
  }
  _initHover() {
    this.disposeWithMe(this._hoverManagerService.currentRichTextNoDistinct$.pipe(throttleTime(33)).subscribe((t) => {
      var n, r;
      let e = [];
      t !== null && (e = this._selectionsService.getWorkbookSelections(this._context.unitId).getCurrentSelections()), e.length > 0 && (t == null ? void 0 : t.unitId) === this._context.unitId && (t != null && t.drawing) && e.length === 1 && ((n = e[0].primary) == null ? void 0 : n.actualRow) === t.row && ((r = e[0].primary) == null ? void 0 : r.actualColumn) === t.col ? (this._isSetCursor = true, this._context.scene.setCursor(v12.ZOOM_IN)) : this._isSetCursor && (this._isSetCursor = false, this._context.scene.resetCursor());
    }));
  }
  _initImageClick() {
    this.disposeWithMe(this._hoverManagerService.currentClickedCell$.subscribe((t) => {
      var e;
      if (t != null && t.drawing && this._isSetCursor) {
        const n = t.drawing.drawing.drawingOrigin, r = (e = this._sheetSkeletonManagerService.getCurrentSkeleton()) == null ? void 0 : e.imageCacheMap.getImage(n.imageSourceType, n.source);
        if (!r) return;
        this._drawingRenderService.previewImage("preview-cell-image", r.src, r.width, r.height), this._context.scene.resetCursor(), this._isSetCursor = false;
      }
    }));
  }
};
tn = ds2([
  vt3(1, Inject(Mr)),
  vt3(2, Inject(z)),
  vt3(3, Inject(Ue)),
  vt3(4, Inject(ue))
], tn);
var ls2 = Object.getOwnPropertyDescriptor;
var us = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? ls2(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var It = (i, t) => (e, n) => t(e, n, i);
var nn2 = class extends Ve {
  constructor(i, t, e, n, r) {
    super(), this._context = i, this._sheetDrawingService = t, this._drawingManagerService = e, this._sheetSelectionRenderService = n, this._sheetSkeletonManagerService = r, this._init();
  }
  _init() {
    this._drawingInitializeListener();
  }
  _drawingInitializeListener() {
    this._sheetDrawingService.initializeNotification(this._context.unitId);
    const i = this._sheetDrawingService.getDrawingDataForUnit(this._context.unitId);
    for (const t in i) {
      const e = i[t];
      for (const n in e.data) {
        const r = e.data[n];
        r.sheetTransform && (r.transform = z3(r.sheetTransform, this._sheetSelectionRenderService, this._sheetSkeletonManagerService));
      }
    }
    this._drawingManagerService.registerDrawingData(this._context.unitId, this._sheetDrawingService.getDrawingDataForUnit(this._context.unitId)), this._drawingManagerService.initializeNotification(this._context.unitId);
  }
};
nn2 = us([
  It(1, E),
  It(2, Mt2),
  It(3, Inject(gt)),
  It(4, Inject(ue))
], nn2);
var hs = Object.getOwnPropertyDescriptor;
var gs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? hs(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var Ae = (i, t) => (e, n) => t(e, n, i);
function Sr2(i, t, e) {
  var n, r, s, o2;
  if (((r = (n = e == null ? void 0 : e.p) == null ? void 0 : n.body) == null ? void 0 : r.dataStream.length) === 3 && ((o2 = (s = e.p) == null ? void 0 : s.drawingsOrder) == null ? void 0 : o2.length) === 1) {
    const a = e.p.drawings[e.p.drawingsOrder[0]], d2 = en(
      i,
      {
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        row: t.row,
        col: t.col
      },
      a.docTransform.size.width,
      a.docTransform.size.height,
      a.docTransform.angle
    );
    if (d2)
      return a.transform.width = d2.width, a.transform.height = d2.height, a.docTransform.size.width = d2.width, a.docTransform.size.height = d2.height, a.transform.left = 0, a.transform.top = 0, a.docTransform.positionH.posOffset = 0, a.docTransform.positionV.posOffset = 0, e.p.documentStyle.pageSize.width = 1 / 0, e.p.documentStyle.pageSize.height = 1 / 0, true;
  }
  return false;
}
var bt2 = class extends Ve {
  constructor(i, t, e, n, r, s) {
    super(), this._commandService = i, this._sheetInterceptorService = t, this._injector = e, this._drawingManagerService = n, this._docDrawingController = r, this._editorBridgeService = s, this._handleInitEditor(), this._initCellContentInterceptor();
  }
  _handleInitEditor() {
    this.disposeWithMe(this._editorBridgeService.visible$.subscribe((i) => {
      i.visible ? i.visible && (this._drawingManagerService.removeDrawingDataForUnit(Dl), this._docDrawingController.loadDrawingDataForUnit(Dl), this._drawingManagerService.initializeNotification(Dl)) : this._drawingManagerService.removeDrawingDataForUnit(Dl);
    })), this.disposeWithMe(this._commandService.onCommandExecuted((i) => {
      i.id === _a.id && i.params.unitId === Hc && (this._drawingManagerService.removeDrawingDataForUnit(Hc), this._docDrawingController.loadDrawingDataForUnit(Hc), this._drawingManagerService.initializeNotification(Hc));
    }));
  }
  _initCellContentInterceptor() {
    this.disposeWithMe(
      this._sheetInterceptorService.intercept(
        ht.CELL_CONTENT,
        {
          effect: sr.Style,
          priority: ha.CELL_IMAGE,
          handler: (i, t, e) => {
            var n;
            return i != null && i.p && ((n = i.p.drawingsOrder) != null && n.length) && (i === t.rawData && (i = { ...t.rawData }), i.interceptorStyle || (i.interceptorStyle = {}), i.interceptorStyle.tr = { a: 0 }, Sr2(this._injector, { unitId: t.unitId, subUnitId: t.subUnitId, row: t.row, col: t.col }, i)), e(i);
          }
        }
      )
    );
  }
};
bt2 = gs([
  Ae(0, Ls),
  Ae(1, Inject(G)),
  Ae(2, Inject(Injector)),
  Ae(3, Mt2),
  Ae(4, Inject(D)),
  Ae(5, Inject(qe))
], bt2);
var fs = Object.getOwnPropertyDescriptor;
var ms = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? fs(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var $n = (i, t) => (e, n) => t(e, n, i);
var Mt3 = class extends Ve {
  constructor(i, t) {
    super(), this._autoFillService = i, this._injector = t, this._initAutoFillHooks();
  }
  _initAutoFillHooks() {
    this.disposeWithMe(
      this._autoFillService.addHook({
        id: "sheet-cell-image-autofill",
        onBeforeSubmit: (i, t, e, n) => {
          new pt(n).forValue((r, s, o2) => {
            Sr2(this._injector, { unitId: i.unitId, subUnitId: i.subUnitId, row: r, col: s }, o2);
          });
        }
      })
    );
  }
};
Mt3 = ms([
  $n(0, Inject(Hr)),
  $n(1, Inject(Injector))
], Mt3);
var ps = Object.getOwnPropertyDescriptor;
var ws = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? ps(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var He = (i, t) => (e, n) => t(e, n, i);
var _s = [
  Dl,
  Ul,
  Hc
];
var yt = class extends Ve {
  constructor(i, t, e, n, r) {
    super(), this._commandService = i, this._univerInstanceService = t, this._dialogService = e, this._renderManagerService = n, this._localeService = r, this._initDocImageCopyPasteHooks();
  }
  _setCellImage(i) {
    var r;
    const t = Jr("", {}), e = (r = IE(we.UNIVER_SHEET, this._univerInstanceService, this._renderManagerService)) == null ? void 0 : r.with(Ri), n = Je.drawing.add({
      documentDataModel: t,
      drawings: [i],
      selection: {
        collapsed: true,
        startOffset: 0,
        endOffset: 0
      }
    });
    n && (t.apply(n), e && e.submitCellData(t));
  }
  _initDocImageCopyPasteHooks() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((i) => {
        var t, e;
        if (i.id === Sa.id) {
          const n = i.params, { doc: r } = n, s = this._univerInstanceService.getCurrentUnitOfType(we.UNIVER_DOC);
          if (s == null || !Object.keys((t = r.drawings) != null ? t : {}).length)
            return;
          const o2 = s.getUnitId();
          if (_s.includes(o2)) {
            if (o2 !== Hc) {
              const a = () => {
                this._dialogService.close("sheet-cell-image-copy-paste"), this._commandService.syncExecuteCommand(tt.id, {
                  visible: false
                });
              };
              ((e = s.getBody()) == null ? void 0 : e.dataStream) === `\r
` ? (this._commandService.syncExecuteCommand(tt.id, {
                visible: false
              }), this._setCellImage(Object.values(r.drawings)[0])) : this._dialogService.open({
                id: "sheet-cell-image-copy-paste",
                title: {
                  label: this._localeService.t("cell-image.pasteTitle")
                },
                children: {
                  label: this._localeService.t("cell-image.pasteContent")
                },
                width: 320,
                destroyOnClose: true,
                onClose: a,
                showOk: true,
                showCancel: true,
                onOk: () => {
                  a(), this._setCellImage(Object.values(r.drawings)[0]);
                },
                onCancel: a
              });
            }
            throw new Error("Sheet cell image copy paste is not supported in this unit");
          }
        }
      })
    );
  }
};
yt = ws([
  He(0, Ls),
  He(1, vr),
  He(2, ct),
  He(3, ME),
  He(4, Inject(Fn))
], yt);
var Ss = Object.getOwnPropertyDescriptor;
var vs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ss(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var ze2 = (i, t) => (e, n) => t(e, n, i);
var vr4 = "image/png";
function Is(i) {
  const t = i.split(","), e = atob(t[1]), n = e.length, r = new Uint8Array(n);
  for (let s = 0; s < n; s++)
    r[s] = e.charCodeAt(s);
  return new Blob([r], { type: vr4 });
}
function Cs(i) {
  const t = new ClipboardItem({ [vr4]: Is(i) });
  navigator.clipboard.write([t]).catch((e) => {
    console.error("Could not copy image using clipboard API: ", e);
  });
}
function Ds() {
  function i() {
    const n = document.createElement("input");
    return n.style.position = "absolute", n.style.height = "1px", n.style.width = "1px", n.style.opacity = "0", n;
  }
  const t = document.activeElement, e = i();
  return document.body.appendChild(e), e.focus(), () => {
    e.blur(), document.body.removeChild(e), t instanceof HTMLElement && t.focus();
  };
}
var Fn3 = [
  et3.SPECIAL_PASTE_COL_WIDTH,
  et3.SPECIAL_PASTE_VALUE,
  et3.SPECIAL_PASTE_FORMAT,
  et3.SPECIAL_PASTE_FORMULA
];
var Tt2 = class extends Ve {
  constructor(t, e, n, r, s) {
    super();
    ee2(this, "_copyInfo");
    this._sheetClipboardService = t, this._renderManagerService = e, this._drawingService = n, this._clipboardInterfaceService = r, this._commandService = s, this._initCopyPaste();
  }
  get _focusedDrawings() {
    return this._drawingService.getFocusDrawings();
  }
  // eslint-disable-next-line max-lines-per-function
  _initCopyPaste() {
    this._sheetClipboardService.addClipboardHook({
      id: "SHEET_IMAGE_UI_PLUGIN",
      onBeforeCopy: (t, e, n, r) => {
        const s = this._focusedDrawings;
        if (s.length > 0) {
          const [o2] = s;
          if (r === Yn.CUT) {
            const d2 = {
              unitId: t,
              drawings: [o2]
            };
            this._commandService.executeCommand(rt2.id, d2);
          }
          setTimeout(() => {
            const d2 = Ds();
            o2.drawingType === ng.DRAWING_IMAGE && o2.imageSourceType === oc.BASE64 ? Cs(o2.source) : this._clipboardInterfaceService.writeText(""), d2();
          }, 200);
          const a = {
            unitId: o2.unitId,
            subUnitId: o2.subUnitId,
            drawings: [o2]
          };
          this._copyInfo = a;
        } else {
          const o2 = this._createDrawingsCopyInfoByRange(t, e, n);
          this._copyInfo = o2;
        }
      },
      onPasteCells: (t, e, n, r) => {
        if (!this._copyInfo)
          return { redos: [], undos: [] };
        const { copyType: s = Yn.COPY, pasteType: o2 } = r, { range: a } = t || {}, { range: d2, unitId: u2, subUnitId: c2 } = e;
        return this._copyInfo.copyRange ? this._generateRangeDrawingsPasteMutations({ pasteType: o2, unitId: u2, subUnitId: c2, pasteRange: d2 }, { copyRange: a, copyType: s }) : this._generateSingleDrawingPasteMutations({ pasteTo: e, pasteType: o2 }, Yn.COPY);
      },
      onPastePlainText: (t, e) => ({ undos: [], redos: [] }),
      onPasteUnrecognized: (t) => this._copyInfo ? this._generateSingleDrawingPasteMutations({ pasteTo: t, pasteType: et3.DEFAULT_PASTE }, Yn.COPY) : { undos: [], redos: [] },
      onPasteFiles: (t, e) => {
        if (this._copyInfo)
          return this._generateSingleDrawingPasteMutations({ pasteTo: t, pasteType: et3.DEFAULT_PASTE }, Yn.COPY);
        {
          const n = e.filter((r) => r.type.includes("image"));
          if (n.length)
            return {
              undos: [],
              redos: [
                {
                  id: Bt.id,
                  params: { files: n }
                }
              ]
            };
        }
        return { undos: [], redos: [] };
      }
    });
  }
  _createDrawingsCopyInfoByRange(t, e, n) {
    var g2;
    const r = (g2 = this._renderManagerService.getRenderById(t)) == null ? void 0 : g2.with(ue);
    if (!r) return;
    const s = r.attachRangeWithCoord(n);
    if (!s)
      return;
    const { startX: o2, endX: a, startY: d2, endY: u2 } = s, c2 = this._drawingService.getDrawingData(t, e), l2 = this._focusedDrawings.slice();
    if (Object.keys(c2).forEach((h3) => {
      const f3 = c2[h3], { transform: p2 } = f3;
      if (f3.anchorType !== Y.Both || !p2)
        return;
      const { left: m = 0, top: _2 = 0, width: v3 = 0, height: I = 0 } = p2, { drawingStartX: R, drawingEndX: S, drawingStartY: C, drawingEndY: w2 } = {
        drawingStartX: m,
        drawingEndX: m + v3,
        drawingStartY: _2,
        drawingEndY: _2 + I
      };
      o2 <= R && S <= a && d2 <= C && w2 <= u2 && l2.push(f3);
    }), l2.length)
      return {
        copyRange: n,
        drawings: l2,
        unitId: t,
        subUnitId: e
      };
  }
  _generateSingleDrawingPasteMutations(t, e) {
    const { pasteType: n, pasteTo: r } = t;
    if (Fn3.includes(n))
      return { redos: [], undos: [] };
    const { unitId: s, subUnitId: o2, range: a } = r, d2 = this._renderManagerService.getRenderById(s), u2 = d2 == null ? void 0 : d2.with(ue), c2 = d2 == null ? void 0 : d2.with(gt), l2 = this._copyInfo;
    if (!u2 || !c2)
      return { redos: [], undos: [] };
    const { drawings: g2 } = l2, h3 = Cr(a);
    return this._generateMutations(g2, {
      unitId: s,
      subUnitId: o2,
      isCut: e === Yn.CUT,
      getTransform: (f3, p2) => {
        var v3;
        const m = u2.attachRangeWithCoord({
          startRow: h3.startRow,
          endRow: h3.endRow,
          startColumn: h3.startColumn,
          endColumn: h3.endColumn
        }), _2 = {
          ...f3,
          left: m == null ? void 0 : m.startX,
          top: m == null ? void 0 : m.startY
        };
        return {
          transform: _2,
          sheetTransform: (v3 = $(_2, c2)) != null ? v3 : p2
        };
      }
    });
  }
  _generateMutations(t, e) {
    const {
      unitId: n,
      subUnitId: r,
      getTransform: s,
      isCut: o2
    } = e, a = [], d2 = [], { _drawingService: u2 } = this;
    return t.forEach((c2) => {
      const { transform: l2, sheetTransform: g2 } = c2;
      if (!l2)
        return;
      const h3 = s(l2, g2), f3 = {
        ...c2,
        unitId: n,
        subUnitId: r,
        drawingId: o2 ? c2.drawingId : et(),
        transform: h3.transform,
        sheetTransform: h3.sheetTransform
      };
      if (o2) {
        const { undo: p2, redo: m, objects: _2 } = u2.getBatchUpdateOp([f3]);
        a.push({
          id: g.id,
          params: {
            unitId: n,
            subUnitId: r,
            type: h.UPDATE,
            op: m,
            objects: _2
          }
        }), d2.push({
          id: g.id,
          params: {
            unitId: n,
            subUnitId: r,
            type: h.UPDATE,
            op: p2,
            objects: _2
          }
        });
      } else {
        const { undo: p2, redo: m, objects: _2 } = u2.getBatchAddOp([f3]);
        a.push({ id: g.id, params: { op: m, unitId: n, subUnitId: r, objects: _2, type: h.INSERT } }), d2.push({ id: g.id, params: { op: p2, unitId: n, subUnitId: r, objects: _2, type: h.REMOVE } });
      }
    }), { redos: a, undos: d2 };
  }
  // eslint-disable-next-line max-lines-per-function
  _generateRangeDrawingsPasteMutations(t, e) {
    var y;
    const {
      unitId: n,
      subUnitId: r,
      pasteType: s,
      pasteRange: o2
    } = t, {
      copyRange: a,
      copyType: d2
    } = e;
    if (Fn3.includes(s))
      return { redos: [], undos: [] };
    const u2 = (y = this._renderManagerService.getRenderById(n)) == null ? void 0 : y.with(ue);
    if (!u2 || !this._copyInfo)
      return { redos: [], undos: [] };
    const { drawings: c2 } = this._copyInfo;
    if (!a)
      return this._generateSingleDrawingPasteMutations({
        pasteTo: { unitId: n, subUnitId: r, range: Cr(o2) },
        pasteType: s
      }, d2);
    const { ranges: [l2, g2], mapFunc: h3 } = wr([a, o2]), { row: f3, col: p2 } = h3(l2.startRow, l2.startColumn), { row: m, col: _2 } = h3(g2.startRow, g2.startColumn), v3 = u2.attachRangeWithCoord({
      startRow: f3,
      endRow: f3,
      startColumn: p2,
      endColumn: p2
    }), I = u2.attachRangeWithCoord({
      startRow: m,
      endRow: m,
      startColumn: _2,
      endColumn: _2
    });
    if (!v3 || !I || !this._copyInfo)
      return { redos: [], undos: [] };
    const R = I.startX - v3.startX, S = I.startY - v3.startY, C = m - f3, w2 = _2 - p2;
    return this._generateMutations(c2, {
      unitId: n,
      subUnitId: r,
      getTransform: (D3, T) => {
        var E3, M;
        return {
          transform: {
            ...D3,
            left: ((E3 = D3 == null ? void 0 : D3.left) != null ? E3 : 0) + R,
            top: ((M = D3 == null ? void 0 : D3.top) != null ? M : 0) + S
          },
          sheetTransform: {
            ...T,
            to: {
              ...T.to,
              row: T.to.row + C,
              column: T.to.column + w2
            },
            from: {
              ...T.from,
              row: T.from.row + C,
              column: T.from.column + w2
            }
          }
        };
      },
      isCut: d2 === Yn.CUT
    });
  }
};
Tt2 = vs([
  ze2(0, nn),
  ze2(1, ME),
  ze2(2, Mt2),
  ze2(3, lr),
  ze2(4, Ls)
], Tt2);
var Rs2 = Object.getOwnPropertyDescriptor;
var bs2 = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Rs2(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var Ke = (i, t) => (e, n) => t(e, n, i);
var Et = class extends Ve {
  constructor(i, t, e, n, r) {
    super(), this._drawingManagerService = i, this._renderManagerService = t, this._permissionService = e, this._univerInstanceService = n, this._userManagerService = r, this._initDrawingVisible(), this._initDrawingEditable(), this._initViewPermissionChange(), this._initEditPermissionChange();
  }
  _initDrawingVisible() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET), t = this._userManagerService.currentUser$, e = combineLatest([i, t]);
    this.disposeWithMe(
      e.pipe(
        switchMap(([n, r]) => n ? n.activeSheet$.pipe(
          tap((s) => {
            if (!s) {
              this._drawingManagerService.setDrawingVisible(false);
              return;
            }
            const o2 = n.getUnitId(), a = s.getSheetId();
            this._permissionService.composePermission([
              new hr(o2).id,
              new ls(o2, a).id
            ]).every((u2) => u2.value) ? this._drawingManagerService.setDrawingVisible(true) : this._handleDrawingVisibilityFalse(n, s);
          })
        ) : (this._drawingManagerService.setDrawingVisible(false), EMPTY))
      ).subscribe()
    );
  }
  _handleDrawingVisibilityFalse(i, t) {
    this._drawingManagerService.setDrawingVisible(false);
    const e = i.getUnitId(), n = t.getSheetId(), r = this._drawingManagerService.getDrawingData(e, n), s = Object.values(r), o2 = this._renderManagerService.getRenderById(e), a = o2 == null ? void 0 : o2.scene;
    if (!a)
      return;
    a.getAllObjectsByOrder().forEach((u2) => {
      u2.classType === V.IMAGE && s.some((c2) => u2.oKey.includes(c2.drawingId)) && a.removeObject(u2);
    });
  }
  _initDrawingEditable() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET), t = this._userManagerService.currentUser$, e = combineLatest([i, t]);
    this.disposeWithMe(
      e.pipe(
        switchMap(([n, r]) => n ? n.activeSheet$.pipe(
          tap((s) => {
            if (!s) {
              this._drawingManagerService.setDrawingEditable(false);
              return;
            }
            const o2 = n.getUnitId(), a = s.getSheetId();
            this._permissionService.composePermission([
              new Pe(o2).id,
              new Ve2(o2, a).id
            ]).every((u2) => u2.value) ? this._drawingManagerService.setDrawingEditable(true) : this._handleDrawingEditableFalse(n, s);
          })
        ) : (this._drawingManagerService.setDrawingEditable(false), EMPTY))
      ).subscribe()
    );
  }
  _handleDrawingEditableFalse(i, t) {
    this._drawingManagerService.setDrawingEditable(false);
    const e = i.getUnitId(), n = t.getSheetId(), r = this._drawingManagerService.getDrawingData(e, n), s = Object.values(r), o2 = this._renderManagerService.getRenderById(e), a = o2 == null ? void 0 : o2.scene;
    if (!a)
      return;
    a.getAllObjectsByOrder().forEach((u2) => {
      u2.classType === V.IMAGE && s.some((c2) => u2.oKey.includes(c2.drawingId)) && a.detachTransformerFrom(u2);
    });
  }
  _initViewPermissionChange() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET), t = this._userManagerService.currentUser$;
    this.disposeWithMe(
      combineLatest([i, t]).pipe(
        switchMap(([e, n]) => e ? e.activeSheet$.pipe(
          switchMap((r) => {
            if (!r)
              return EMPTY;
            const s = e.getUnitId(), o2 = r.getSheetId(), a = this._renderManagerService.getRenderById(s), d2 = a == null ? void 0 : a.scene;
            if (!d2)
              return EMPTY;
            const u2 = d2.getTransformerByCreate();
            return this._permissionService.composePermission$([
              new hr(s).id,
              new ls(s, o2).id
            ]).pipe(
              map((l2) => l2.every((g2) => g2.value)),
              distinctUntilChanged()
            ).pipe(
              map((l2) => ({
                permission: l2,
                scene: d2,
                transformer: u2,
                unitId: s,
                subUnitId: o2
              }))
            );
          })
        ) : EMPTY)
      ).subscribe({
        next: ({ permission: e, scene: n, transformer: r, unitId: s, subUnitId: o2 }) => {
          this._drawingManagerService.setDrawingVisible(e);
          const a = n.getAllObjectsByOrder(), d2 = this._drawingManagerService.getDrawingData(s, o2), u2 = Object.values(d2);
          e ? this._drawingManagerService.addNotification(u2) : (a.forEach((c2) => {
            c2.classType === V.IMAGE && u2.some((l2) => c2.oKey.includes(l2.drawingId)) && n.removeObject(c2);
          }), r.clearSelectedObjects());
        },
        complete: () => {
          this._drawingManagerService.setDrawingVisible(true);
          const e = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET), n = e == null ? void 0 : e.getActiveSheet(), r = e == null ? void 0 : e.getUnitId(), s = n == null ? void 0 : n.getSheetId();
          if (!r || !s)
            return;
          const o2 = this._drawingManagerService.getDrawingData(r, s), a = Object.values(o2);
          this._drawingManagerService.addNotification(a);
        }
      })
    );
  }
  _initEditPermissionChange() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET), t = this._userManagerService.currentUser$;
    this.disposeWithMe(
      combineLatest([i, t]).pipe(
        switchMap(([e, n]) => e ? e.activeSheet$.pipe(
          switchMap((r) => {
            if (!r)
              return EMPTY;
            const s = e.getUnitId(), o2 = r.getSheetId(), a = this._renderManagerService.getRenderById(s), d2 = a == null ? void 0 : a.scene;
            if (!d2)
              return EMPTY;
            const u2 = d2.getTransformerByCreate();
            return this._permissionService.composePermission$([
              new Pe(s).id,
              new Ve2(s, o2).id
            ]).pipe(
              map((l2) => l2.every((g2) => g2.value)),
              distinctUntilChanged()
            ).pipe(
              map((l2) => ({
                permission: l2,
                scene: d2,
                transformer: u2,
                unitId: s,
                subUnitId: o2
              }))
            );
          })
        ) : EMPTY)
      ).subscribe({
        next: ({ permission: e, scene: n, transformer: r, unitId: s, subUnitId: o2 }) => {
          this._drawingManagerService.setDrawingEditable(e);
          const a = n.getAllObjectsByOrder(), d2 = this._drawingManagerService.getDrawingData(s, o2), u2 = Object.values(d2);
          e ? (a.forEach((c2) => {
            c2.classType === V.IMAGE && u2.some((l2) => c2.oKey.includes(l2.drawingId)) && n.attachTransformerTo(c2);
          }), this._drawingManagerService.addNotification(u2)) : (a.forEach((c2) => {
            c2.classType === V.IMAGE && u2.some((l2) => c2.oKey.includes(l2.drawingId)) && n.detachTransformerFrom(c2);
          }), r.clearSelectedObjects());
        },
        complete: () => {
          const e = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET);
          if (!e)
            return;
          const n = e.getUnitId(), r = e.getActiveSheet();
          if (!r)
            return;
          const s = r.getSheetId(), o2 = this._renderManagerService.getRenderById(n), a = o2 == null ? void 0 : o2.scene;
          if (!a)
            return;
          const d2 = this._drawingManagerService.getDrawingData(n, s), u2 = Object.values(d2);
          this._drawingManagerService.setDrawingEditable(true), a.getAllObjectsByOrder().forEach((l2) => {
            l2.classType === V.IMAGE && u2.some((g2) => l2.oKey.includes(g2.drawingId)) && a.detachTransformerFrom(l2);
          });
        }
      })
    );
  }
};
Et = bs2([
  Ke(0, Mt2),
  Ke(1, ME),
  Ke(2, eC),
  Ke(3, vr),
  Ke(4, Inject(Rs))
], Et);
var Ms2 = Object.getOwnPropertyDescriptor;
var ys = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ms2(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var Ce = (i, t) => (e, n) => t(e, n, i);
function Ir2(i, t, e, n, r, s = false) {
  const { scaleX: o2, scaleY: a } = t.getAncestorScale(), d2 = t.getViewport(k2.VIEW_MAIN), u2 = n.getFreeze(), { startColumn: c2, startRow: l2, xSplit: g2, ySplit: h3 } = u2, f3 = {
    left: true,
    // left means the left of pic is in a viewMainLeft
    top: true
  };
  if (!d2)
    return {
      ...i,
      absolute: f3
    };
  const { left: p2, right: m, top: _2, bottom: v3 } = i;
  let { top: I, left: R, viewportScrollX: S, viewportScrollY: C } = d2;
  const { boundsOfViewArea: w2, scrollDirectionResponse: y } = r || {}, { rowHeaderWidth: D3, columnHeaderHeight: T } = e, E3 = {
    top: s ? 0 : T,
    left: s ? 0 : D3
  };
  w2 && (J.isDefine(E3.top) && (E3.top = w2.top), J.isDefine(E3.left) && (E3.left = w2.left)), y === "HORIZONTAL" && (C = 0), y === "VERTICAL" && (S = 0);
  let M = 0, b = 0;
  const N = e.rowStartY(l2 - h3) + T, x2 = e.colStartX(c2 - g2) + D3, q = e.rowStartY(l2) + T, H = e.colStartX(c2) + D3;
  if (g2 === 0)
    f3.left = false, M = (p2 - S) * o2, b = (m - S) * o2;
  else {
    const k = p2 - (x2 - D3), ae2 = m - (x2 - D3);
    m < H ? (M = k * o2, b = ae2 * o2) : p2 <= H && m >= H ? (M = k * o2, b = Math.max(R, (m - S) * o2)) : p2 > H && (f3.left = false, M = Math.max((p2 - S) * o2, R), b = Math.max((m - S) * o2, R));
  }
  let L2 = 0, G3 = 0;
  if (h3 === 0)
    f3.top = false, L2 = (_2 - C) * a, G3 = (v3 - C) * a;
  else {
    const k = _2 - (N - T), ae2 = v3 - (N - T);
    v3 < q ? (L2 = k * a, G3 = ae2 * a) : _2 <= q && v3 >= q ? (L2 = k * a, G3 = Math.max(I, (v3 - C) * a)) : _2 > q && (f3.top = false, L2 = Math.max((_2 - C) * a, I), G3 = Math.max((v3 - C) * a, I));
  }
  return M = Math.max(M, E3.left), L2 = Math.max(L2, E3.top), b = Math.max(b, E3.left), G3 = Math.max(G3, E3.top), {
    left: M,
    right: b,
    top: L2,
    bottom: G3,
    absolute: f3
  };
}
var ge = (i, t, e, n, r) => {
  const { left: s, top: o2, width: a, height: d2, angle: u2 } = i, c2 = {
    left: s,
    right: s + a,
    top: o2,
    bottom: o2 + d2
  }, l2 = Ir2(c2, t, e, n, r), { scaleX: g2, scaleY: h3 } = t.getAncestorScale();
  return {
    startX: l2.left,
    endX: l2.right,
    startY: l2.top,
    endY: l2.bottom,
    rotate: u2,
    width: a * g2,
    height: d2 * h3,
    absolute: l2.absolute
  };
};
var tt3 = class extends Ve {
  constructor(t, e, n, r, s, o2, a) {
    super();
    ee2(this, "_domLayerInfoMap", /* @__PURE__ */ new Map());
    ee2(this, "_transformChange$", new Subject());
    ee2(this, "transformChange$", this._transformChange$.asObservable());
    ee2(this, "_add$", new Subject());
    ee2(this, "add$", this._add$.asObservable());
    ee2(this, "_remove$", new Subject());
    ee2(this, "remove$", this._remove$.asObservable());
    this._renderManagerService = t, this._univerInstanceService = e, this._commandService = n, this._drawingManagerService = r, this._canvasFloatDomService = s, this._sheetDrawingService = o2, this._lifecycleService = a, this._drawingAddListener(), this._featureUpdateListener(), this._deleteListener(), this._bindScrollEvent();
  }
  _bindScrollEvent() {
    this._lifecycleService.lifecycle$.pipe(filter((t) => t === ke.Rendered), take(1)).subscribe(() => {
      this._scrollUpdateListener();
    });
  }
  getFloatDomInfo(t) {
    return this._domLayerInfoMap.get(t);
  }
  getFloatDomsBySubUnitId(t, e) {
    return Array.from(this._domLayerInfoMap.values()).filter((n) => n.subUnitId === e && n.unitId === t);
  }
  _getSceneAndTransformerByDrawingSearch(t) {
    if (t == null)
      return;
    const e = this._renderManagerService.getRenderById(t), n = e == null ? void 0 : e.scene;
    if (e == null || n == null)
      return null;
    const r = n.getTransformerByCreate(), s = e.engine.getCanvasElement();
    return { scene: n, transformer: r, renderUnit: e, canvas: s };
  }
  // eslint-disable-next-line max-lines-per-function
  _drawingAddListener() {
    this.disposeWithMe(
      // eslint-disable-next-line max-lines-per-function
      this._drawingManagerService.add$.subscribe((t) => {
        t.forEach((e) => {
          var K;
          const { unitId: n, subUnitId: r, drawingId: s } = e, o2 = P(this._univerInstanceService, { unitId: n, subUnitId: r }), a = this._drawingManagerService.getDrawingByParam(e), d2 = this._univerInstanceService.getUnit(n, we.UNIVER_SHEET);
          if (!d2)
            return;
          const u2 = d2.getActiveSheet().getSheetId();
          if (!a || !o2)
            return;
          const c2 = (K = this._renderManagerService.getRenderById(n)) == null ? void 0 : K.with(ue).getSkeletonParam(r);
          if (!c2)
            return;
          const { transform: l2, drawingType: g2, data: h3 } = a;
          if (g2 !== ng.DRAWING_DOM && g2 !== ng.DRAWING_CHART)
            return;
          const f3 = this._getSceneAndTransformerByDrawingSearch(n);
          if (f3 == null)
            return;
          const { scene: p2, canvas: m } = f3;
          if (l2 == null)
            return true;
          if (u2 !== r)
            return;
          const { left: _2, top: v3, width: I, height: R, angle: S, flipX: C, flipY: w2, skewX: y, skewY: D3 } = l2, T = On({ unitId: n, subUnitId: r, drawingId: s }), E3 = p2.getObject(T);
          if (E3 != null) {
            E3.transformByState({ left: _2, top: v3, width: I, height: R, angle: S, flipX: C, flipY: w2, skewX: y, skewY: D3 });
            return;
          }
          const M = {
            left: _2,
            top: v3,
            width: I,
            height: R,
            zIndex: this._drawingManagerService.getDrawingOrder(n, r).length - 1
          }, b = g2 === ng.DRAWING_CHART;
          if (M.rotateEnabled = false, b) {
            const k = h3 ? h3.backgroundColor : "white";
            M.fill = k, h3 && h3.border && (M.stroke = h3.border), M.paintFirst = "stroke", M.strokeWidth = 1, M.borderEnabled = false, M.radius = 8;
          }
          const N = new I1(T, M);
          b && N.setObjectType(w3.CHART), p2.addObject(N, HT), a.allowTransform !== false && p2.attachTransformerTo(N);
          const x2 = new ao(), q = ge(N, f3.renderUnit.scene, c2.skeleton, o2.worksheet), H = new BehaviorSubject(q), L2 = {
            dispose: x2,
            rect: N,
            position$: H,
            unitId: n,
            subUnitId: r,
            id: s
          };
          this._canvasFloatDomService.addFloatDom({
            position$: H,
            id: s,
            componentKey: a.componentKey,
            onPointerDown: (k) => {
              m.dispatchEvent(new PointerEvent(k.type, k));
            },
            onPointerMove: (k) => {
              m.dispatchEvent(new PointerEvent(k.type, k));
            },
            onPointerUp: (k) => {
              m.dispatchEvent(new PointerEvent(k.type, k));
            },
            onWheel: (k) => {
              m.dispatchEvent(new WheelEvent(k.type, k));
            },
            data: h3,
            unitId: n
          });
          const G3 = N.onTransformChange$.subscribeEvent(() => {
            const k = ge(N, f3.renderUnit.scene, c2.skeleton, o2.worksheet);
            H.next(
              k
            );
          });
          x2.add(() => {
            this._canvasFloatDomService.removeFloatDom(s);
          }), G3 && x2.add(G3), this._domLayerInfoMap.set(s, L2);
        });
      })
    ), this.disposeWithMe(
      this._drawingManagerService.remove$.subscribe((t) => {
        t.forEach((e) => {
          var l2;
          const { unitId: n, subUnitId: r, drawingId: s } = e, o2 = On({ unitId: n, subUnitId: r, drawingId: s }), a = this._getSceneAndTransformerByDrawingSearch(n);
          if (a == null)
            return;
          const { transformer: d2, scene: u2 } = a, c2 = u2.getObject(o2);
          c2 != null && c2.oKey && (d2.clearControlByIds([c2 == null ? void 0 : c2.oKey]), (l2 = u2.getTransformer()) == null || l2.clearSelectedObjects());
        });
      })
    );
  }
  _scrollUpdateListener() {
    const t = (e, n) => {
      var d2;
      const r = this._getSceneAndTransformerByDrawingSearch(e), s = Array.from(this._domLayerInfoMap.keys()).map((u2) => ({ id: u2, ...this._domLayerInfoMap.get(u2) })).filter((u2) => u2.subUnitId === n && u2.unitId === e).map((u2) => u2.id), o2 = P(this._univerInstanceService, { unitId: e, subUnitId: n }), a = (d2 = this._renderManagerService.getRenderById(e)) == null ? void 0 : d2.with(ue).getSkeletonParam(n);
      !r || !o2 || !a || s.forEach((u2) => {
        const c2 = this._domLayerInfoMap.get(u2);
        if (c2) {
          const l2 = ge(c2.rect, r.renderUnit.scene, a.skeleton, o2.worksheet, c2);
          c2.position$.next(l2);
        }
      });
    };
    this.disposeWithMe(
      this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_SHEET).pipe(
        switchMap((e) => e ? e.activeSheet$ : of(null)),
        map((e) => {
          if (!e) return null;
          const n = e.getUnitId(), r = this._renderManagerService.getRenderById(n);
          return r ? { render: r, unitId: n, subUnitId: e.getSheetId() } : null;
        }),
        switchMap(
          (e) => e ? TR(e.render.scene.getViewport(k2.VIEW_MAIN).onScrollAfter$).pipe(map(() => ({ unitId: e.unitId, subUnitId: e.subUnitId }))) : of(null)
        )
      ).subscribe((e) => {
        if (!e) return;
        const { unitId: n, subUnitId: r } = e;
        t(n, r);
      })
    ), this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      if (e.id === Jt.id) {
        const n = e.params, { unitId: r } = n;
        Array.from(this._domLayerInfoMap.values()).filter((o2) => o2.unitId === r).map((o2) => o2.subUnitId).forEach((o2) => {
          t(r, o2);
        });
      } else if (e.id === st.id) {
        const { unitId: n, subUnitId: r } = e.params;
        t(n, r);
      }
    }));
  }
  updateFloatDomProps(t, e, n, r) {
    const s = this._domLayerInfoMap.get(n), o2 = this._getSceneAndTransformerByDrawingSearch(t);
    if (s && o2) {
      const { scene: a } = o2, d2 = On({ unitId: t, subUnitId: e, drawingId: n }), u2 = a.getObject(d2);
      u2 && u2 instanceof I1 && u2.setProps(r);
    }
  }
  _getPosition(t, e) {
    var g2;
    const { startX: n, endX: r, startY: s, endY: o2 } = t, a = (g2 = this._renderManagerService.getRenderById(e)) == null ? void 0 : g2.with(gt);
    if (a == null)
      return;
    const d2 = a.getCellWithCoordByOffset(n, s);
    if (d2 == null)
      return;
    const u2 = {
      column: d2.actualColumn,
      columnOffset: n - d2.startX,
      row: d2.actualRow,
      rowOffset: s - d2.startY
    }, c2 = a.getCellWithCoordByOffset(r, o2);
    if (c2 == null)
      return;
    const l2 = {
      column: c2.actualColumn,
      columnOffset: r - c2.startX,
      row: c2.actualRow,
      rowOffset: o2 - c2.startY
    };
    return {
      from: u2,
      to: l2
    };
  }
  _featureUpdateListener() {
    this.disposeWithMe(
      this._drawingManagerService.update$.subscribe((t) => {
        t.forEach((e) => {
          const n = this._drawingManagerService.getDrawingByParam(e);
          if (!n || n.drawingType !== ng.DRAWING_DOM && n.drawingType !== ng.DRAWING_CHART)
            return;
          const r = {
            ...n.transform
          };
          this._transformChange$.next({ id: e.drawingId, value: r }), this._canvasFloatDomService.updateFloatDom(e.drawingId, {
            ...n
          });
          const s = this._getSceneAndTransformerByDrawingSearch(e.unitId);
          if (s && n.drawingType !== ng.DRAWING_CHART) {
            const { scene: o2 } = s, a = this._domLayerInfoMap.get(e.drawingId);
            a != null && a.rect && (n.allowTransform === false ? o2.detachTransformerFrom(a.rect) : o2.attachTransformerTo(a.rect));
          }
        });
      })
    );
  }
  _deleteListener() {
    this.disposeWithMe(
      this._drawingManagerService.remove$.subscribe((t) => {
        t.forEach((e) => {
          this._removeDom(e.drawingId);
        });
      })
    );
  }
  // CreateFloatDomCommand --> floatDomService.addFloatDomToPosition
  addFloatDomToPosition(t, e) {
    const n = P(this._univerInstanceService, {
      unitId: t.unitId,
      subUnitId: t.subUnitId
    });
    if (!n)
      throw new Error("cannot find current target!");
    const { unitId: r, subUnitId: s } = n, { initPosition: o2, componentKey: a, data: d2, allowTransform: u2 = true } = t, c2 = e != null ? e : et(), l2 = this._getPosition(o2, r);
    if (l2 == null)
      return;
    const g2 = {
      unitId: r,
      subUnitId: s,
      drawingId: c2,
      drawingType: t.type || ng.DRAWING_DOM,
      componentKey: a,
      sheetTransform: l2,
      transform: {
        left: o2.startX,
        top: o2.startY,
        width: o2.endX - o2.startX,
        height: o2.endY - o2.startY
      },
      data: d2,
      allowTransform: u2
    };
    return this._commandService.executeCommand(kt2.id, {
      unitId: r,
      drawings: [g2]
    }), this._add$.next({ unitId: r, subUnitId: s, id: c2 }), {
      id: c2,
      dispose: () => {
        this._removeDom(c2, true);
      }
    };
  }
  _removeDom(t, e = false) {
    const n = this._domLayerInfoMap.get(t);
    if (!n)
      return;
    const { unitId: r, subUnitId: s } = n;
    this._domLayerInfoMap.delete(t), n.dispose.dispose();
    const o2 = this._getSceneAndTransformerByDrawingSearch(r);
    if (o2 && o2.scene.removeObject(n.rect), e) {
      const a = this._drawingManagerService.getDrawingByParam({ unitId: r, subUnitId: s, drawingId: t });
      if (!a)
        return;
      const d2 = this._sheetDrawingService.getBatchRemoveOp([a]), { redo: u2, objects: c2 } = d2;
      this._commandService.syncExecuteCommand(g.id, { unitId: r, subUnitId: s, op: u2, objects: c2, type: h.REMOVE });
    }
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  addFloatDomToRange(t, e, n, r) {
    var C, w2, y;
    const s = P(this._univerInstanceService, {
      unitId: e.unitId,
      subUnitId: e.subUnitId
    });
    if (!s)
      throw new Error("cannot find current target!");
    const { unitId: o2, subUnitId: a } = s, d2 = this._getSceneAndTransformerByDrawingSearch(o2);
    if (!d2) return;
    const u2 = this._renderManagerService.getRenderById(o2);
    if (!u2) return;
    const c2 = (C = this._renderManagerService.getRenderById(o2)) == null ? void 0 : C.with(ue).getWorksheetSkeleton(a);
    if (!c2) return;
    const { componentKey: l2, data: g2, allowTransform: h3 = true } = e, f3 = r != null ? r : et(), { position: p2, position$: m } = this._createRangePositionObserver(t, u2, c2.skeleton);
    if (this._getPosition(p2, o2) == null)
      return;
    const v3 = d2.scene, { scaleX: I } = v3.getAncestorScale(), R = Ct2(p2, n, I), S = {
      unitId: o2,
      subUnitId: a,
      drawingId: f3,
      drawingType: e.type || ng.DRAWING_DOM,
      componentKey: l2,
      transform: {
        left: R.startX,
        top: R.startY,
        width: R.width,
        height: R.height
      },
      data: g2,
      allowTransform: h3
    };
    {
      const { unitId: D3, subUnitId: T, drawingId: E3 } = S, M = P(this._univerInstanceService, { unitId: D3, subUnitId: T }), b = S, N = this._univerInstanceService.getUnit(D3, we.UNIVER_SHEET);
      if (!N)
        return;
      const x2 = N.getActiveSheet().getSheetId();
      if (!b || !M)
        return;
      const q = (w2 = this._renderManagerService.getRenderById(D3)) == null ? void 0 : w2.with(ue);
      if (!q)
        return;
      const H = q.getWorksheetSkeleton(T);
      if (!H)
        return;
      const { transform: L2, drawingType: G3, data: K } = b;
      if (G3 !== ng.DRAWING_DOM && G3 !== ng.DRAWING_CHART)
        return;
      const k = this._getSceneAndTransformerByDrawingSearch(D3);
      if (k == null)
        return;
      const { scene: ae2, canvas: be2 } = k;
      if (L2 == null || x2 !== T)
        return;
      const { left: ot2, top: at, width: ct2, height: dt2, angle: jt, flipX: $t, flipY: lt, skewX: ut3, skewY: Me2 } = L2, ht3 = On({ unitId: D3, subUnitId: T, drawingId: E3 }), de2 = ae2.getObject(ht3);
      if (de2 != null) {
        de2.transformByState({ left: ot2, top: at, width: ct2, height: dt2, angle: jt, flipX: $t, flipY: lt, skewX: ut3, skewY: Me2 });
        return;
      }
      const Q = {
        left: ot2,
        // from floatDomParam.transform
        top: at,
        width: ct2,
        height: dt2,
        zIndex: this._drawingManagerService.getDrawingOrder(D3, T).length - 1
      }, ye4 = G3 === ng.DRAWING_CHART;
      if (ye4) {
        const W = K ? K.backgroundColor : "white";
        Q.fill = W, Q.rotateEnabled = false, K && K.border && (Q.stroke = K.border), Q.paintFirst = "stroke", Q.strokeWidth = 1, Q.borderEnabled = false, Q.radius = 8;
      }
      const le2 = new I1(ht3, Q);
      ye4 && le2.setObjectType(w3.CHART), ae2.addObject(le2, HT), b.allowTransform !== false && ae2.attachTransformerTo(le2);
      const ue2 = new ao(), gt3 = ae2.getMainViewport(), { rowHeaderWidth: Te, columnHeaderHeight: Xe2 } = H.skeleton, ft2 = {
        top: Xe2,
        left: Te,
        bottom: gt3.bottom,
        right: gt3.right
      }, he2 = {
        dispose: ue2,
        rect: le2,
        boundsOfViewArea: ft2,
        domAnchor: n,
        unitId: D3,
        subUnitId: T
      }, j2 = ge(le2, k.renderUnit.scene, H.skeleton, M.worksheet, he2), Ee = new BehaviorSubject(j2);
      he2.position$ = Ee;
      let Le3 = {
        position$: Ee,
        id: E3,
        componentKey: b.componentKey,
        onPointerDown: () => {
        },
        onPointerMove: () => {
        },
        onPointerUp: () => {
        },
        onWheel: (W) => {
          be2.dispatchEvent(new WheelEvent(W.type, W));
        },
        data: K,
        unitId: D3
      };
      e.eventPassThrough && (Le3 = {
        ...Le3,
        onPointerDown: (W) => {
          be2.dispatchEvent(new PointerEvent(W.type, W));
        },
        onPointerMove: (W) => {
          be2.dispatchEvent(new PointerEvent(W.type, W));
        },
        onPointerUp: (W) => {
          be2.dispatchEvent(new PointerEvent(W.type, W));
        }
      }), this._canvasFloatDomService.addFloatDom(Le3), this.disposeWithMe(m.subscribe((W) => {
        var un2, hn, gn2, fn2;
        const ln3 = Ct2({
          startX: W.startX,
          startY: W.startY,
          endX: W.endX,
          endY: W.endY,
          width: (un2 = n.width) != null ? un2 : W.width,
          height: (hn = n.height) != null ? hn : W.height,
          absolute: {
            left: p2.absolute.left,
            top: p2.absolute.top
          }
        }, n), Rr2 = On({ unitId: D3, subUnitId: T, drawingId: E3 }), br2 = new I1(Rr2, {
          left: ln3.startX,
          top: ln3.startY,
          width: (gn2 = n.width) != null ? gn2 : W.width,
          height: (fn2 = n.height) != null ? fn2 : W.height,
          zIndex: this._drawingManagerService.getDrawingOrder(D3, T).length - 1
        }), Mr3 = ge(br2, k.renderUnit.scene, H.skeleton, M.worksheet, he2);
        Ee.next(Mr3);
      }));
      const Ve4 = (y = this._renderManagerService.getRenderById(D3)) == null ? void 0 : y.with(ue);
      Ve4 == null || Ve4.currentSkeleton$.subscribe((W) => {
        W && H.sheetId !== W.sheetId && this._removeDom(f3, true);
      });
      const mt3 = le2.onTransformChange$.subscribeEvent(() => {
        const W = ge(le2, k.renderUnit.scene, H.skeleton, M.worksheet, he2);
        Ee.next(
          W
        );
      });
      ue2.add(() => {
        this._canvasFloatDomService.removeFloatDom(E3);
      }), mt3 && ue2.add(mt3), this._domLayerInfoMap.set(E3, he2);
    }
    return {
      id: f3,
      dispose: () => {
        this._removeDom(f3, true);
      }
    };
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  addFloatDomToColumnHeader(t, e, n, r) {
    var R, S, C;
    const s = P(this._univerInstanceService, {
      unitId: e.unitId,
      subUnitId: e.subUnitId
    });
    if (!s)
      throw new Error("cannot find current target!");
    const { unitId: o2, subUnitId: a } = s;
    if (!this._getSceneAndTransformerByDrawingSearch(o2)) return;
    const u2 = this._renderManagerService.getRenderById(o2);
    if (!u2) return;
    const c2 = (R = this._renderManagerService.getRenderById(o2)) == null ? void 0 : R.with(ue).getWorksheetSkeleton(a);
    if (!c2) return;
    const { componentKey: l2, data: g2, allowTransform: h3 = true } = e, f3 = r != null ? r : et(), { position: p2, position$: m } = this._createRangePositionObserver({
      startRow: 0,
      endRow: 0,
      startColumn: t,
      endColumn: t
    }, u2, c2.skeleton), _2 = p2;
    if (_2.startY = 0, this._getPosition(p2, o2) == null)
      return;
    const I = {
      unitId: o2,
      subUnitId: a,
      drawingId: f3,
      drawingType: e.type || ng.DRAWING_DOM,
      componentKey: l2,
      transform: {
        left: _2.startX,
        top: _2.startY,
        width: _2.width,
        height: _2.height
      },
      data: g2,
      allowTransform: h3
    };
    {
      const { unitId: w2, subUnitId: y, drawingId: D3 } = I, T = P(this._univerInstanceService, { unitId: w2, subUnitId: y }), E3 = I, M = this._univerInstanceService.getUnit(w2, we.UNIVER_SHEET);
      if (!M)
        return;
      const b = M.getActiveSheet().getSheetId();
      if (!E3 || !T)
        return;
      const N = (S = this._renderManagerService.getRenderById(w2)) == null ? void 0 : S.with(ue);
      if (!N)
        return;
      const x2 = N.getWorksheetSkeleton(y);
      if (!x2)
        return;
      const { transform: q, data: H } = E3, L2 = this._getSceneAndTransformerByDrawingSearch(w2);
      if (L2 == null)
        return;
      const { scene: G3, canvas: K } = L2;
      if (q == null || b !== y)
        return;
      const { left: k, top: ae2, width: be2, height: ot2, angle: at, flipX: ct2, flipY: dt2, skewX: jt, skewY: $t } = q, lt = On({ unitId: w2, subUnitId: y, drawingId: D3 }), ut3 = G3.getObject(lt);
      if (ut3 != null) {
        ut3.transformByState({ left: k, top: ae2, width: be2, height: ot2, angle: at, flipX: ct2, flipY: dt2, skewX: jt, skewY: $t });
        return;
      }
      const Me2 = Ct2({
        startX: _2.startX,
        startY: 0,
        endX: p2.endX,
        endY: p2.endY,
        width: n.width,
        height: n.height,
        absolute: {
          left: p2.absolute.left,
          top: p2.absolute.top
        }
      }, n), ht3 = {
        left: Me2.startX,
        top: Me2.startY,
        width: Me2.width,
        height: Me2.height,
        zIndex: this._drawingManagerService.getDrawingOrder(w2, y).length - 1
      }, de2 = new I1(lt, ht3);
      G3.addObject(de2, HT), E3.allowTransform !== false && G3.attachTransformerTo(de2);
      const Q = new ao(), ye4 = G3.getMainViewport(), le2 = {
        top: 0,
        //viewMain.top,
        left: ye4.left,
        bottom: ye4.bottom,
        right: ye4.right
      }, ue2 = {
        dispose: Q,
        rect: de2,
        // position$,
        unitId: w2,
        subUnitId: y,
        boundsOfViewArea: le2,
        domAnchor: n,
        scrollDirectionResponse: "HORIZONTAL"
        /* HORIZONTAL */
      }, gt3 = ge(de2, L2.renderUnit.scene, x2.skeleton, T.worksheet, ue2), Te = new BehaviorSubject(gt3);
      ue2.position$ = Te;
      let Xe2 = {
        position$: Te,
        id: D3,
        componentKey: E3.componentKey,
        onPointerDown: () => {
        },
        onPointerMove: () => {
        },
        onPointerUp: () => {
        },
        onWheel: (j2) => {
          K.dispatchEvent(new WheelEvent(j2.type, j2));
        },
        data: H,
        unitId: w2
      };
      e.eventPassThrough && (Xe2 = {
        ...Xe2,
        onPointerDown: (j2) => {
          K.dispatchEvent(new PointerEvent(j2.type, j2));
        },
        onPointerMove: (j2) => {
          K.dispatchEvent(new PointerEvent(j2.type, j2));
        },
        onPointerUp: (j2) => {
          K.dispatchEvent(new PointerEvent(j2.type, j2));
        }
      }), this._canvasFloatDomService.addFloatDom(Xe2);
      const ft2 = de2.onTransformChange$.subscribeEvent(() => {
        const j2 = ge(de2, L2.renderUnit.scene, x2.skeleton, T.worksheet, ue2);
        Te.next(
          j2
        );
      });
      this.disposeWithMe(m.subscribe((j2) => {
        const Ee = Ct2({
          startX: j2.startX,
          startY: 0,
          endX: j2.endX,
          endY: j2.endY,
          width: n.width,
          height: n.height,
          absolute: {
            left: p2.absolute.left,
            top: p2.absolute.top
          }
        }, n), Le3 = On({ unitId: w2, subUnitId: y, drawingId: D3 }), Ve4 = new I1(Le3, {
          left: Ee.startX,
          top: 0,
          width: n.width,
          height: n.height,
          zIndex: this._drawingManagerService.getDrawingOrder(w2, y).length - 1
        }), mt3 = ge(Ve4, L2.renderUnit.scene, x2.skeleton, T.worksheet, ue2);
        Te.next(mt3);
      }));
      const he2 = (C = this._renderManagerService.getRenderById(w2)) == null ? void 0 : C.with(ue);
      he2 == null || he2.currentSkeleton$.subscribe((j2) => {
        j2 && c2.sheetId !== j2.sheetId && this._removeDom(f3, true);
      }), Q.add(() => {
        this._canvasFloatDomService.removeFloatDom(D3);
      }), ft2 && Q.add(ft2), this._domLayerInfoMap.set(D3, ue2);
    }
    return {
      id: f3,
      dispose: () => {
        this._removeDom(f3, true);
      }
    };
  }
  /**
   * Unlike _createCellPositionObserver, this accept a range not a single cell.
   *
   * @param initialRow
   * @param initialCol
   * @param currentRender
   * @param skeleton
   * @param activeViewport
   * @returns position of cell to canvas.
   */
  // eslint-disable-next-line max-lines-per-function
  _createRangePositionObserver(t, e, n) {
    let { startRow: r, startColumn: s } = t;
    const o2 = Je2(r, s, n), a = new BehaviorSubject(o2), d2 = Je2(t.endRow, t.endColumn, n), u2 = new BehaviorSubject(d2), c2 = () => {
      const m = Je2(r, s, n), _2 = Je2(t.endRow, t.endColumn, n);
      a.next(m), u2.next(_2);
    }, l2 = new ao();
    l2.add(e.engine.clientRect$.subscribe(() => c2())), l2.add(this._commandService.onCommandExecuted((m) => {
      if (m.id === Xo.id && m.params.rowsAutoHeightInfo.findIndex((v3) => v3.row === r) > -1) {
        c2();
        return;
      }
      (mh.indexOf(m.id) > -1 || m.id === gn.id || m.id === Jt.id) && c2();
    }));
    const g2 = (m, _2) => {
      r = m, s = _2, c2();
    }, h3 = () => ({
      rotate: 0,
      width: d2.right - o2.left,
      height: d2.bottom - o2.top,
      absolute: {
        left: true,
        top: true
      },
      startX: o2.left,
      startY: o2.top,
      endX: d2.right,
      endY: d2.bottom
    }), f3 = a.pipe(
      map((m) => {
        const _2 = Je2(t.endRow, t.endColumn, n);
        return {
          rotate: 0,
          width: _2.right - m.left,
          height: _2.bottom - m.top,
          absolute: {
            left: true,
            top: true
          },
          startX: m.left,
          startY: m.top,
          endX: _2.right,
          endY: _2.bottom
        };
      })
    ), p2 = h3();
    return {
      position$: f3,
      position: p2,
      updateRowCol: g2,
      topLeftPos$: a,
      rightBottomPos$: u2,
      disposable: l2
    };
  }
};
tt3 = ys([
  Ce(0, Inject(ME)),
  Ce(1, vr),
  Ce(2, Inject(Ls)),
  Ce(3, Mt2),
  Ce(4, Inject(nt)),
  Ce(5, E),
  Ce(6, Inject(Wn))
], tt3);
function Je2(i, t, e) {
  const n = e.getCellWithCoordByIndex(i, t), r = n.isMergedMainCell ? n.mergeInfo : n;
  return {
    left: r.startX,
    right: r.endX,
    top: r.startY,
    bottom: r.endY
  };
}
function Ct2(i, t, e) {
  var u2, c2;
  e = e != null ? e : 1;
  const n = i.endX - i.startX, r = i.endY - i.startY, s = (u2 = t == null ? void 0 : t.width) != null ? u2 : n, o2 = (c2 = t == null ? void 0 : t.height) != null ? c2 : r;
  let a = 0, d2 = 0;
  if (t) {
    if (t.horizonOffsetAlign === "right") {
      const l2 = Dt2(t.marginX, n * e);
      a = i.endX - l2 - s;
    } else
      a = i.startX + Dt2(t.marginX, n);
    if (t.verticalOffsetAlign === "bottom") {
      const l2 = Dt2(t.marginY, r * e);
      d2 = i.endY - l2 - o2;
    } else
      d2 = i.startY + Dt2(t.marginY, r);
  }
  return {
    rotate: 0,
    startX: a,
    startY: d2,
    endX: i.endX,
    endY: i.endY,
    width: s,
    height: o2,
    absolute: {
      left: i.absolute.left,
      top: i.absolute.top
    }
  };
}
function Dt2(i, t) {
  if (i === void 0) return 0;
  if (typeof i == "number") return i;
  const e = Number.parseFloat(i);
  return t * e / 100;
}
var Ts = (i) => {
  const { floatDomInfos: t, scene: e, skeleton: n, worksheet: r } = i, s = (0, import_react2.useMemo)(() => t.map((o2) => {
    const { width: a, height: d2, angle: u2, left: c2, top: l2 } = o2.transform, g2 = Ir2(
      {
        left: c2 != null ? c2 : 0,
        right: (c2 != null ? c2 : 0) + (a != null ? a : 0),
        top: l2 != null ? l2 : 0,
        bottom: (l2 != null ? l2 : 0) + (d2 != null ? d2 : 0)
      },
      e,
      n,
      r,
      void 0,
      true
    ), { scaleX: h3, scaleY: f3 } = e.getAncestorScale(), p2 = {
      startX: g2.left,
      endX: g2.right,
      startY: g2.top,
      endY: g2.bottom,
      rotate: u2,
      width: a * h3,
      height: d2 * f3,
      absolute: g2.absolute
    }, m = {
      position$: new BehaviorSubject(p2),
      position: p2,
      id: o2.drawingId,
      componentKey: o2.componentKey,
      onPointerMove: () => {
      },
      onPointerDown: () => {
      },
      onPointerUp: () => {
      },
      onWheel: () => {
      },
      unitId: o2.unitId,
      data: o2.data
    };
    return [o2.drawingId, m];
  }), [t, e, n, r]);
  return (0, import_jsx_runtime2.jsx)("div", { style: { position: "absolute", top: 0, left: 0 }, children: s.map(([o2, a]) => (0, import_jsx_runtime2.jsx)(u7, { layer: a, id: o2, position: a.position }, o2)) });
};
var Es2 = Object.getOwnPropertyDescriptor;
var Os = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Es2(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var De2 = (i, t) => (e, n) => t(e, n, i);
var Ot2 = class extends Ve {
  constructor(i, t, e, n, r, s, o2) {
    super(), this._sheetPrintInterceptorService = i, this._drawingRenderService = t, this._drawingManagerService = e, this._renderManagerService = n, this._canvasFloatDomManagerService = r, this._componetManager = s, this._injector = o2, this._initPrinting(), this._initPrintingDom();
  }
  _initPrinting() {
    this.disposeWithMe(
      this._sheetPrintInterceptorService.interceptor.intercept(
        this._sheetPrintInterceptorService.interceptor.getInterceptPoints().PRINTING_COMPONENT_COLLECT,
        {
          handler: (i, t, e) => {
            const { unitId: n, scene: r, subUnitId: s } = t, o2 = this._drawingManagerService.getDrawingDataForUnit(n), a = o2 == null ? void 0 : o2[s];
            return a && a.order.forEach((d2) => {
              const u2 = a.data[d2];
              u2.drawingType !== ng.DRAWING_CHART && u2.drawingType !== ng.DRAWING_DOM && this._drawingRenderService.renderDrawing(u2, r);
            }), e();
          }
        }
      )
    ), this.disposeWithMe(
      this._sheetPrintInterceptorService.interceptor.intercept(
        this._sheetPrintInterceptorService.interceptor.getInterceptPoints().PRINTING_RANGE,
        {
          handler: (i, t, e) => {
            const { unitId: n, subUnitId: r } = t, s = this._renderManagerService.getRenderById(n);
            if (!s)
              return e(i);
            const o2 = s.with(ue).getSkeletonParam(r);
            if (!o2)
              return e(i);
            const a = this._drawingManagerService.getDrawingDataForUnit(n), d2 = a == null ? void 0 : a[t.subUnitId];
            if (!d2)
              return e(i);
            const { scaleX: u2, scaleY: c2 } = s.scene, l2 = i ? { ...i } : { startColumn: 0, endColumn: 0, endRow: 0, startRow: 0 }, g2 = d2.order.map((h3) => d2.data[h3]);
            return g2.length ? (g2.forEach((h3) => {
              if (!h3.groupId && h3.transform && J.isDefine(h3.transform.left) && J.isDefine(h3.transform.top) && J.isDefine(h3.transform.width) && J.isDefine(h3.transform.height)) {
                const f3 = o2.skeleton.getCellIndexByOffset(h3.transform.left, h3.transform.top, u2, c2, { x: 0, y: 0 }), p2 = o2.skeleton.getCellIndexByOffset(h3.transform.left + h3.transform.width, h3.transform.top + h3.transform.height, u2, c2, { x: 0, y: 0 });
                f3.column < l2.startColumn && (l2.startColumn = f3.column), f3.row < l2.startRow && (l2.startRow = f3.row), l2.endRow < p2.row && (l2.endRow = p2.row), l2.endColumn < p2.column && (l2.endColumn = p2.column);
              }
            }), e(l2)) : e(i);
          }
        }
      )
    );
  }
  _initPrintingDom() {
    this.disposeWithMe(
      this._sheetPrintInterceptorService.interceptor.intercept(
        this._sheetPrintInterceptorService.interceptor.getInterceptPoints().PRINTING_DOM_COLLECT,
        {
          handler: (i, t, e) => {
            const { unitId: n, subUnitId: r } = t, s = this._drawingManagerService.getDrawingDataForUnit(n), o2 = s == null ? void 0 : s[r];
            if (o2) {
              const a = o2.order.map((u2) => {
                const c2 = o2.data[u2];
                if (c2.drawingType === ng.DRAWING_CHART)
                  return {
                    ...c2,
                    componentKey: this._componetManager.get(dR)
                  };
                if (c2.drawingType === ng.DRAWING_DOM) {
                  const l2 = this._sheetPrintInterceptorService.getPrintComponent(c2.componentKey);
                  return {
                    ...c2,
                    componentKey: this._componetManager.get(l2 || c2.componentKey)
                  };
                }
                return null;
              }).filter(Boolean), d2 = connectInjector(Ts, this._injector);
              return UE(
                (0, import_jsx_runtime2.jsx)(d2, { floatDomInfos: a, scene: t.scene, skeleton: t.skeleton, worksheet: t.worksheet }),
                t.root
              ), i == null || i.add(() => {
                GE(t.root);
              }), e(i);
            }
          }
        }
      )
    );
  }
};
Ot2 = Os([
  De2(0, Inject(Ap)),
  De2(1, Inject(Ue)),
  De2(2, Mt2),
  De2(3, ME),
  De2(4, Inject(tt3)),
  De2(5, Inject(S1)),
  De2(6, Inject(Injector))
], Ot2);
var Us = Object.getOwnPropertyDescriptor;
var Ps = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Us(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var me = (i, t) => (e, n) => t(e, n, i);
var As = [
  Ye.id,
  Xe.id,
  cs.id,
  ds.id,
  vt.id,
  Mt.id,
  Nt.id,
  an.id,
  zn.id,
  Gn.id,
  Fn2.id,
  Bn.id,
  Es.id,
  fn.id,
  mn.id,
  bs.id,
  ln.id,
  un.id,
  bt.id
];
var Ns = [
  Tt.id,
  Pt.id,
  rn.id,
  on.id,
  nt2.id,
  mt.id
];
var rn2 = class extends Ve {
  constructor(i, t, e, n, r, s, o2, a, d2) {
    super(), this._context = i, this._renderManagerService = t, this._commandService = e, this._selectionRenderService = n, this._skeletonManagerService = r, this._sheetInterceptorService = s, this._sheetDrawingService = o2, this._drawingManagerService = a, this._univerInstanceService = d2, this._sheetInterceptorListener(), this._commandListener(), this._sheetRefreshListener();
  }
  _sheetInterceptorListener() {
    this.disposeWithMe(
      this._sheetInterceptorService.interceptAfterCommand({
        /* eslint-disable-next-line complexity */
        getMutations: (i) => {
          if (!As.includes(i.id))
            return { redos: [], undos: [] };
          if (i.params == null)
            return { redos: [], undos: [] };
          const t = i.id;
          if (t === Ye.id)
            return this._moveRowInterceptor(i.params, "insert");
          if ([ln.id, un.id, bt.id].includes(t))
            return this._moveRangeInterceptor(i.params);
          if (t === Xe.id)
            return this._moveColInterceptor(i.params, "insert");
          if (t === cs.id)
            return this._moveRowInterceptor(i.params, "remove");
          if (t === ds.id)
            return this._moveColInterceptor(i.params, "remove");
          if (t === vt.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              0
              /* deleteLeft */
            );
          } else if (t === Mt.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              1
              /* deleteUp */
            );
          } else if (t === Nt.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              2
              /* insertDown */
            );
          } else if (t === an.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              3
              /* insertRight */
            );
          } else if (t === Es.id || t === fn.id) {
            const e = i.params, { unitId: n, subUnitId: r, ranges: s } = e;
            return this._getDrawingUndoForRowVisible(n, r, s);
          } else if (t === mn.id || t === bs.id) {
            const e = i.params, { unitId: n, subUnitId: r, ranges: s } = e;
            return this._getDrawingUndoForColVisible(n, r, s);
          } else if (t === zn.id || t === Gn.id || t === Fn2.id || t === Bn.id) {
            const e = i.params, { unitId: n, subUnitId: r, ranges: s } = e, o2 = t === zn.id || t === Gn.id;
            return this._getDrawingUndoForRowAndColSize(n, r, s, o2);
          }
          return { redos: [], undos: [] };
        }
      })
    );
  }
  _getRangeMoveUndo(i, t) {
    const e = P(this._univerInstanceService);
    if (e == null)
      return { redos: [], undos: [] };
    const n = e.unitId, r = e.subUnitId, s = [], o2 = [], a = this._sheetDrawingService.getDrawingData(n, r), d2 = [], u2 = [];
    if (Object.keys(a).forEach((c2) => {
      const l2 = a[c2], { updateDrawings: g2, deleteDrawings: h3 } = this._getUpdateOrDeleteDrawings(i, t, l2);
      d2.push(...g2), u2.push(...h3);
    }), d2.length === 0 && u2.length === 0)
      return { redos: [], undos: [] };
    if (d2.length > 0) {
      const c2 = this._sheetDrawingService.getBatchUpdateOp(d2), { undo: l2, redo: g2, objects: h3 } = c2;
      s.push({ id: g.id, params: { unitId: n, subUnitId: r, op: g2, objects: h3, type: h.UPDATE } }), o2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: l2, objects: h3, type: h.UPDATE } });
    }
    if (u2.length > 0) {
      const c2 = this._sheetDrawingService.getBatchRemoveOp(u2), l2 = c2.undo, g2 = c2.redo, h3 = c2.objects;
      s.push({ id: g.id, params: { unitId: n, subUnitId: r, op: g2, objects: h3, type: h.REMOVE } }), o2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: l2, objects: h3, type: h.INSERT } });
    }
    return s.push({ id: Y2.id, params: [n] }), o2.push({ id: Y2.id, params: [n] }), {
      redos: s,
      undos: o2
    };
  }
  _getUpdateOrDeleteDrawings(i, t, e) {
    const n = [], r = [], { sheetTransform: s, anchorType: o2 = Y.Position, transform: a, unitId: d2, subUnitId: u2, drawingId: c2 } = e, { from: l2, to: g2 } = s, { row: h3, column: f3 } = l2, { row: p2, column: m } = g2;
    if (s == null || a == null)
      return {
        updateDrawings: n,
        deleteDrawings: r
      };
    const { startRow: _2, endRow: v3, startColumn: I, endColumn: R } = i;
    let S = null, C = null;
    if (t === 0 && h3 >= _2 && p2 <= v3)
      if (f3 >= I && m <= R)
        r.push({ unitId: d2, subUnitId: u2, drawingId: c2 });
      else {
        const w2 = this._shrinkCol(s, a, I, R, o2);
        S = w2 == null ? void 0 : w2.newSheetTransform, C = w2 == null ? void 0 : w2.newTransform;
      }
    else if (t === 1 && f3 >= I && m <= R)
      if (h3 >= _2 && p2 <= v3)
        r.push({ unitId: d2, subUnitId: u2, drawingId: c2 });
      else {
        const w2 = this._shrinkRow(s, a, _2, v3, o2);
        S = w2 == null ? void 0 : w2.newSheetTransform, C = w2 == null ? void 0 : w2.newTransform;
      }
    else if (t === 2) {
      const w2 = this._expandRow(s, a, _2, v3, o2);
      S = w2 == null ? void 0 : w2.newSheetTransform, C = w2 == null ? void 0 : w2.newTransform;
    } else if (t === 3) {
      const w2 = this._expandCol(s, a, I, R, o2);
      S = w2 == null ? void 0 : w2.newSheetTransform, C = w2 == null ? void 0 : w2.newTransform;
    }
    if (S != null && C != null) {
      const w2 = z3(S, this._selectionRenderService, this._skeletonManagerService);
      n.push({ ...e, sheetTransform: S, transform: w2 });
    }
    return { updateDrawings: n, deleteDrawings: r };
  }
  _remainDrawingSize(i, t, e) {
    const n = $({ ...i }, this._selectionRenderService);
    n != null && t.push({
      ...e,
      sheetTransform: n
    });
  }
  // eslint-disable-next-line max-lines-per-function
  _getDrawingUndoForColVisible(i, t, e) {
    const n = this._drawingManagerService.getDrawingData(i, t), r = [], s = [];
    if (Object.keys(n).forEach((c2) => {
      const l2 = n[c2], { sheetTransform: g2, transform: h3, anchorType: f3 = Y.Position } = l2;
      if (f3 === Y.None)
        this._remainDrawingSize(h3, r, l2);
      else {
        const { from: p2, to: m } = g2, { row: _2, column: v3 } = p2, { row: I, column: R } = m;
        for (let S = 0; S < e.length; S++) {
          const C = e[S], { startRow: w2, endRow: y, startColumn: D3, endColumn: T } = C;
          if (R < D3)
            continue;
          if (f3 === Y.Position) {
            let b = null, N = null;
            if (v3 >= D3 && v3 <= T) {
              const x2 = this._skeletonManagerService.attachRangeWithCoord({ startColumn: v3, endColumn: T, startRow: p2.row, endRow: m.row });
              if (x2 == null)
                return;
              N = { ...h3, left: x2.startX };
            }
            if (N != null && (b = $(N, this._selectionRenderService), b != null && N != null)) {
              r.push({ ...l2, sheetTransform: b, transform: N });
              break;
            }
            this._remainDrawingSize(h3, r, l2);
            continue;
          }
          if (v3 >= D3 && R <= T)
            continue;
          let E3 = null, M = null;
          if (v3 >= D3 && v3 <= T) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: v3, endColumn: T, startRow: p2.row, endRow: m.row });
            if (b == null)
              return;
            M = {
              ...h3,
              left: (b == null ? void 0 : b.startX) || 0,
              width: ((h3 == null ? void 0 : h3.width) || 0) - b.endX + b.startX
            };
          } else if (R >= D3 && R <= T) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: D3, endColumn: R, startRow: p2.row, endRow: m.row });
            if (b == null)
              return;
            M = {
              ...h3,
              left: b.startX - ((h3 == null ? void 0 : h3.width) || 0)
            };
          } else {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: D3, endColumn: T, startRow: p2.row, endRow: m.row });
            if (b == null)
              return;
            if (M = {
              ...h3,
              width: ((h3 == null ? void 0 : h3.width) || 0) - b.endX + b.startX
            }, E3 = $(M, this._selectionRenderService), E3 != null && M != null) {
              s.push({ ...l2, sheetTransform: E3, transform: M });
              break;
            }
          }
          if (M != null && (E3 = $(M, this._selectionRenderService)), M != null && E3 != null) {
            r.push({ ...l2, sheetTransform: E3, transform: M });
            break;
          } else
            this._remainDrawingSize(h3, r, l2);
        }
      }
    }), r.length === 0 && s.length === 0)
      return { redos: [], undos: [] };
    const { redos: o2, undos: a } = this._createUndoAndRedoMutation(i, t, r), d2 = [], u2 = [];
    if (s.length > 0) {
      const { redos: c2, undos: l2 } = this._createUndoAndRedoMutation(i, t, s);
      d2.push(...c2), u2.push(...l2);
    }
    return {
      redos: o2,
      undos: a,
      preRedos: d2,
      preUndos: u2
    };
  }
  _createUndoAndRedoMutation(i, t, e) {
    const n = this._sheetDrawingService.getBatchUpdateOp(e), { undo: r, redo: s, objects: o2 } = n, a = [
      { id: g.id, params: { unitId: i, subUnitId: t, op: s, objects: o2, type: h.UPDATE } },
      { id: Y2.id, params: [i] }
    ], d2 = [
      { id: g.id, params: { unitId: i, subUnitId: t, op: r, objects: o2, type: h.UPDATE } },
      { id: Y2.id, params: [i] }
    ];
    return {
      redos: a,
      undos: d2
    };
  }
  // eslint-disable-next-line max-lines-per-function
  _getDrawingUndoForRowVisible(i, t, e) {
    const n = this._drawingManagerService.getDrawingData(i, t), r = [], s = [];
    if (Object.keys(n).forEach((c2) => {
      const l2 = n[c2], { sheetTransform: g2, transform: h3, anchorType: f3 = Y.Position } = l2;
      if (f3 === Y.None)
        this._remainDrawingSize(h3, r, l2);
      else {
        const { from: p2, to: m } = g2, { row: _2, column: v3 } = p2, { row: I, column: R } = m;
        for (let S = 0; S < e.length; S++) {
          const C = e[S], { startRow: w2, endRow: y, startColumn: D3, endColumn: T } = C;
          if (I < w2)
            continue;
          if (f3 === Y.Position) {
            let b = null, N = null;
            if (_2 >= w2 && _2 <= y) {
              const x2 = this._skeletonManagerService.attachRangeWithCoord({ startColumn: p2.column, endColumn: m.column, startRow: _2, endRow: y });
              if (x2 == null)
                return;
              N = { ...h3, top: x2.startY };
            }
            if (N != null && (b = $(N, this._selectionRenderService), b != null && N != null)) {
              r.push({ ...l2, sheetTransform: b, transform: N });
              break;
            }
            this._remainDrawingSize(h3, r, l2);
            continue;
          }
          if (_2 >= w2 && I <= y)
            continue;
          let E3 = null, M = null;
          if (_2 >= w2 && _2 <= y) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: p2.column, endColumn: m.column, startRow: _2, endRow: y });
            if (b == null)
              return;
            M = {
              ...h3,
              top: (b == null ? void 0 : b.startY) || 0,
              height: ((h3 == null ? void 0 : h3.height) || 0) - b.endY + b.startY
            };
          } else if (I >= w2 && I <= y) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: p2.column, endColumn: m.column, startRow: w2, endRow: I });
            if (b == null)
              return;
            M = {
              ...h3,
              top: b.startY - ((h3 == null ? void 0 : h3.height) || 0)
            };
          } else {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: p2.column, endColumn: m.column, startRow: w2, endRow: y });
            if (b == null)
              return;
            if (M = {
              ...h3,
              height: ((h3 == null ? void 0 : h3.height) || 0) - b.endY + b.startY
            }, E3 = $(M, this._selectionRenderService), E3 != null && M != null) {
              s.push({ ...l2, sheetTransform: E3, transform: M });
              break;
            }
          }
          if (M != null && (E3 = $(M, this._selectionRenderService)), M != null && E3 != null) {
            r.push({ ...l2, sheetTransform: E3, transform: M });
            break;
          } else
            this._remainDrawingSize(h3, r, l2);
        }
      }
    }), r.length === 0 && s.length === 0)
      return { redos: [], undos: [] };
    const { redos: o2, undos: a } = this._createUndoAndRedoMutation(i, t, r), d2 = [], u2 = [];
    if (s.length > 0) {
      const { redos: c2, undos: l2 } = this._createUndoAndRedoMutation(i, t, s);
      d2.push(...c2), u2.push(...l2);
    }
    return {
      redos: o2,
      undos: a,
      preRedos: d2,
      preUndos: u2
    };
  }
  _getDrawingUndoForRowAndColSize(i, t, e, n) {
    const r = this._drawingManagerService.getDrawingData(i, t), s = [];
    return Object.keys(r).forEach((o2) => {
      const a = r[o2], { sheetTransform: d2, transform: u2, anchorType: c2 = Y.Position } = a;
      if (c2 === Y.None)
        this._remainDrawingSize(u2, s, a);
      else {
        const { from: l2, to: g2 } = d2, { row: h3, column: f3 } = l2, { row: p2, column: m } = g2;
        for (let _2 = 0; _2 < e.length; _2++) {
          const v3 = e[_2], { startRow: I, endRow: R, startColumn: S, endColumn: C } = v3;
          if (p2 < I || m < S)
            continue;
          if (c2 === Y.Position && (h3 <= I && p2 >= R || f3 <= S && m >= C)) {
            this._remainDrawingSize(u2, s, a);
            continue;
          }
          const w2 = z3({ ...d2 }, this._selectionRenderService, this._skeletonManagerService);
          if (w2 != null) {
            s.push({
              ...a,
              transform: w2
            });
            break;
          }
        }
      }
    }), s.length === 0 ? { redos: [], undos: [] } : this._createUndoAndRedoMutation(i, t, s);
  }
  _getUnitIdAndSubUnitId(i, t) {
    let e, n;
    if (t === "insert")
      e = i.unitId, n = i.subUnitId;
    else {
      const r = P(this._univerInstanceService);
      if (r == null)
        return;
      e = r.unitId, n = r.subUnitId;
    }
    return { unitId: e, subUnitId: n };
  }
  _moveRangeInterceptor(i) {
    var I, R;
    const { toRange: t, fromRange: e } = i, n = P(this._univerInstanceService);
    if (!n)
      return { redos: [], undos: [] };
    const { unitId: r, subUnitId: s } = n, o2 = (R = (I = this._renderManagerService.getRenderById(r)) == null ? void 0 : I.with(ue)) == null ? void 0 : R.getCurrentSkeleton();
    if (!o2)
      return { redos: [], undos: [] };
    const a = bo(o2, e);
    if (!a)
      return { redos: [], undos: [] };
    const { startX: d2, endX: u2, startY: c2, endY: l2 } = a, g2 = this._sheetDrawingService.getDrawingData(r, s), h3 = [];
    Object.keys(g2).forEach((S) => {
      const C = g2[S];
      if (C.anchorType !== Y.Both)
        return;
      const { transform: w2 } = C;
      if (!w2)
        return;
      const { left: y = 0, top: D3 = 0, width: T = 0, height: E3 = 0 } = w2, { drawingStartX: M, drawingEndX: b, drawingStartY: N, drawingEndY: x2 } = {
        drawingStartX: y,
        drawingEndX: y + T,
        drawingStartY: D3,
        drawingEndY: D3 + E3
      };
      d2 <= M && b <= u2 && c2 <= N && x2 <= l2 && h3.push(C);
    });
    const f3 = [], p2 = [], m = t.startRow - e.startRow, _2 = t.startColumn - e.startColumn, v3 = h3.map((S) => {
      const C = S.sheetTransform, w2 = {
        to: { ...C.to, row: C.to.row + m, column: C.to.column + _2 },
        from: { ...C.from, row: C.from.row + m, column: C.from.column + _2 }
      }, y = z3(w2, this._selectionRenderService, this._skeletonManagerService);
      return {
        unitId: r,
        subUnitId: s,
        drawingId: S.drawingId,
        transform: y,
        sheetTransform: w2
      };
    });
    if (v3.length) {
      const S = this._sheetDrawingService.getBatchUpdateOp(v3), { undo: C, redo: w2, objects: y } = S;
      f3.push({ id: g.id, params: { unitId: r, subUnitId: s, op: w2, objects: y, type: h.UPDATE } }), p2.push({ id: g.id, params: { unitId: r, subUnitId: s, op: C, objects: y, type: h.UPDATE } });
    }
    return { redos: f3, undos: p2 };
  }
  _moveRowInterceptor(i, t) {
    const e = this._getUnitIdAndSubUnitId(i, t);
    if (e == null)
      return { redos: [], undos: [] };
    const { unitId: n, subUnitId: r } = e, { range: s } = i, o2 = s.startRow, a = s.endRow, d2 = [], u2 = [], c2 = this._sheetDrawingService.getDrawingData(n, r), l2 = [], g2 = [];
    if (Object.keys(c2).forEach((h3) => {
      const f3 = c2[h3], { sheetTransform: p2, transform: m, anchorType: _2 = Y.Position } = f3;
      if (p2 == null || m == null)
        return;
      let v3, I;
      if (t === "insert") {
        const S = this._expandRow(p2, m, o2, a, _2);
        v3 = S == null ? void 0 : S.newSheetTransform, I = S == null ? void 0 : S.newTransform;
      } else {
        const { from: S, to: C } = p2, { row: w2 } = S, { row: y } = C;
        if (_2 === Y.Both && w2 >= o2 && y <= a)
          g2.push({ unitId: n, subUnitId: r, drawingId: h3 });
        else {
          const D3 = this._shrinkRow(p2, m, o2, a, _2);
          v3 = D3 == null ? void 0 : D3.newSheetTransform, I = D3 == null ? void 0 : D3.newTransform;
        }
      }
      if (!v3 || !I)
        return;
      const R = { unitId: n, subUnitId: r, drawingId: h3, transform: I, sheetTransform: v3 };
      l2.push(R);
    }), l2.length === 0 && g2.length === 0)
      return { redos: [], undos: [] };
    if (l2.length > 0) {
      const h3 = this._sheetDrawingService.getBatchUpdateOp(l2), { undo: f3, redo: p2, objects: m } = h3;
      d2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: p2, objects: m, type: h.UPDATE } }), u2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: f3, objects: m, type: h.UPDATE } });
    }
    if (g2.length > 0) {
      const h3 = this._sheetDrawingService.getBatchRemoveOp(g2), f3 = h3.undo, p2 = h3.redo, m = h3.objects;
      d2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: p2, objects: m, type: h.REMOVE } }), u2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: f3, objects: m, type: h.INSERT } });
    }
    return d2.push({ id: Y2.id, params: [n] }), u2.push({ id: Y2.id, params: [n] }), {
      redos: d2,
      undos: u2
    };
  }
  _moveColInterceptor(i, t) {
    const e = this._getUnitIdAndSubUnitId(i, t);
    if (e == null)
      return { redos: [], undos: [] };
    const { unitId: n, subUnitId: r } = e, { range: s } = i, o2 = s.startColumn, a = s.endColumn, d2 = [], u2 = [], c2 = this._sheetDrawingService.getDrawingData(n, r), l2 = [], g2 = [];
    if (Object.keys(c2).forEach((h3) => {
      const f3 = c2[h3], { sheetTransform: p2, transform: m, anchorType: _2 = Y.Position } = f3;
      if (p2 == null || m == null)
        return;
      let v3, I;
      if (t === "insert") {
        const S = this._expandCol(p2, m, o2, a, _2);
        v3 = S == null ? void 0 : S.newSheetTransform, I = S == null ? void 0 : S.newTransform;
      } else {
        const { from: S, to: C } = p2, { column: w2 } = S, { column: y } = C;
        if (_2 === Y.Both && w2 >= o2 && y <= a)
          g2.push({ unitId: n, subUnitId: r, drawingId: h3 });
        else {
          const D3 = this._shrinkCol(p2, m, o2, a, _2);
          v3 = D3 == null ? void 0 : D3.newSheetTransform, I = D3 == null ? void 0 : D3.newTransform;
        }
      }
      if (!v3 || !I)
        return;
      const R = { unitId: n, subUnitId: r, drawingId: h3, transform: I, sheetTransform: v3 };
      l2.push(R);
    }), l2.length === 0 && g2.length === 0)
      return { redos: [], undos: [] };
    if (l2.length > 0) {
      const h3 = this._sheetDrawingService.getBatchUpdateOp(l2), { undo: f3, redo: p2, objects: m } = h3;
      d2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: p2, objects: m, type: h.UPDATE } }), u2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: f3, objects: m, type: h.UPDATE } });
    }
    if (g2.length > 0) {
      const h3 = this._sheetDrawingService.getBatchRemoveOp(g2), f3 = h3.undo, p2 = h3.redo, m = h3.objects;
      d2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: p2, objects: m, type: h.REMOVE } }), u2.push({ id: g.id, params: { unitId: n, subUnitId: r, op: f3, objects: m, type: h.INSERT } });
    }
    return d2.push({ id: Y2.id, params: [n] }), u2.push({ id: Y2.id, params: [n] }), { redos: d2, undos: u2 };
  }
  _expandCol(i, t, e, n, r = Y.Position) {
    const s = n - e + 1, { from: o2, to: a } = i, { column: d2 } = o2, { column: u2 } = a;
    if (r === Y.None)
      return {
        newSheetTransform: $({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c2 = null, l2 = null;
    if (d2 >= e) {
      const g2 = this._skeletonManagerService.attachRangeWithCoord({ startColumn: e, endColumn: n, startRow: o2.row, endRow: a.row });
      if (g2 == null)
        return;
      l2 = { ...t, left: (t.left || 0) + g2.endX - g2.startX }, c2 = $(l2, this._selectionRenderService);
    } else if (u2 >= n)
      if (r === Y.Both)
        c2 = {
          from: { ...o2 },
          to: { ...a, column: u2 + s }
        }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
      else
        return {
          newSheetTransform: $({ ...t }, this._selectionRenderService),
          newTransform: t
        };
    return c2 != null && l2 != null ? {
      newSheetTransform: c2,
      newTransform: l2
    } : null;
  }
  _shrinkCol(i, t, e, n, r = Y.Position) {
    const s = n - e + 1, { from: o2, to: a } = i, { column: d2 } = o2, { column: u2 } = a;
    if (r === Y.None)
      return {
        newSheetTransform: $({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c2 = null, l2 = null;
    if (d2 > n)
      c2 = {
        from: { ...o2, column: d2 - s },
        to: { ...a, column: u2 - s }
      }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
    else {
      if (d2 >= e && u2 <= n)
        return null;
      if (d2 < e && u2 > n)
        if (r === Y.Both)
          c2 = {
            from: { ...o2 },
            to: { ...a, column: u2 - s }
          }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
        else
          return {
            newSheetTransform: $({ ...t }, this._selectionRenderService),
            newTransform: t
          };
      else if (d2 >= e && d2 <= n) {
        if (d2 === e)
          l2 = { ...t, left: (t.left || 0) - i.from.columnOffset };
        else {
          const g2 = this._skeletonManagerService.attachRangeWithCoord({ startColumn: e, endColumn: d2 - 1, startRow: o2.row, endRow: a.row });
          if (g2 == null)
            return;
          l2 = { ...t, left: (t.left || 0) - g2.endX + g2.startX - i.from.columnOffset };
        }
        c2 = $(l2, this._selectionRenderService);
      } else if (u2 >= e && u2 <= n && r === Y.Both) {
        const g2 = this._skeletonManagerService.attachRangeWithCoord({
          startColumn: e - 1,
          endColumn: e - 1,
          startRow: o2.row,
          endRow: a.row
        });
        if (g2 == null)
          return;
        c2 = {
          from: { ...o2 },
          to: { ...a, column: e - 1, columnOffset: g2.endX - g2.startX }
        }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
      }
    }
    return c2 != null && l2 != null ? {
      newSheetTransform: c2,
      newTransform: l2
    } : null;
  }
  _expandRow(i, t, e, n, r = Y.Position) {
    const s = n - e + 1, { from: o2, to: a } = i, { row: d2 } = o2, { row: u2 } = a;
    if (r === Y.None)
      return {
        newSheetTransform: $({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c2 = null, l2 = null;
    if (d2 >= e) {
      const g2 = this._skeletonManagerService.attachRangeWithCoord({ startRow: e, endRow: n, startColumn: o2.column, endColumn: a.column });
      if (g2 == null)
        return;
      l2 = { ...t, top: (t.top || 0) + g2.endY - g2.startY }, c2 = $(l2, this._selectionRenderService);
    } else if (u2 >= n)
      if (r === Y.Both)
        c2 = {
          from: { ...o2 },
          to: {
            ...a,
            row: u2 + s
          }
        }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
      else
        return {
          newSheetTransform: $({ ...t }, this._selectionRenderService),
          newTransform: t
        };
    return c2 != null && l2 != null ? {
      newSheetTransform: c2,
      newTransform: l2
    } : null;
  }
  _shrinkRow(i, t, e, n, r = Y.Position) {
    const s = n - e + 1, { from: o2, to: a } = i, { row: d2 } = o2, { row: u2 } = a;
    if (r === Y.None)
      return {
        newSheetTransform: $({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c2 = null, l2 = null;
    if (d2 > n)
      c2 = {
        from: { ...o2, row: d2 - s },
        to: { ...a, row: u2 - s }
      }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
    else {
      if (d2 >= e && u2 <= n)
        return null;
      if (d2 < e && u2 > n)
        if (r === Y.Both)
          c2 = {
            from: { ...o2 },
            to: { ...a, row: u2 - s }
          }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
        else
          return {
            newSheetTransform: $({ ...t }, this._selectionRenderService),
            newTransform: t
          };
      else if (d2 >= e && d2 <= n) {
        if (d2 === e)
          l2 = { ...t, top: (t.top || 0) - i.from.rowOffset };
        else {
          const g2 = this._skeletonManagerService.attachRangeWithCoord({ startRow: e, endRow: d2 - 1, startColumn: o2.column, endColumn: a.column });
          if (g2 == null)
            return;
          l2 = { ...t, top: (t.top || 0) - g2.endY + g2.startY - i.from.rowOffset };
        }
        c2 = $(l2, this._selectionRenderService);
      } else if (u2 >= e && u2 <= n && r === Y.Both) {
        const g2 = this._skeletonManagerService.attachRangeWithCoord({ startColumn: o2.column, endColumn: o2.column, startRow: e - 1, endRow: e - 1 });
        if (g2 == null)
          return;
        c2 = {
          from: { ...o2 },
          to: { ...a, row: e - 1, rowOffset: g2.endY - g2.startY }
        }, l2 = z3(c2, this._selectionRenderService, this._skeletonManagerService);
      }
    }
    return c2 != null && l2 != null ? {
      newSheetTransform: c2,
      newTransform: l2
    } : null;
  }
  _commandListener() {
    this.disposeWithMe(
      // TODO@weird94: this should subscribe to the command service
      // but the skeleton changes like other render modules. These two signals are not equivalent.
      // As a temp solution, I subscribed to activate$ here.
      this._commandService.onCommandExecuted((i) => {
        if (i.id === pn.id) {
          const { unitId: t, subUnitId: e } = i.params;
          this._updateDrawings(t, e);
        }
      })
    ), this.disposeWithMe(
      this._context.activated$.subscribe((i) => {
        const { unit: t, unitId: e } = this._context;
        if (i) {
          const n = t.getActiveSheet().getSheetId();
          this._updateDrawings(e, n);
        } else
          this._clearDrawings(e);
      })
    );
  }
  _clearDrawings(i) {
    setTimeout(() => {
      const t = this._drawingManagerService.drawingManagerData, e = [];
      Object.keys(t).forEach((n) => {
        const r = t[n];
        r != null && Object.keys(r).forEach((s) => {
          const o2 = r[s].data;
          o2 != null && Object.keys(o2).forEach((a) => {
            n === i && e.push(o2[a]);
          });
        });
      }), this._drawingManagerService.removeNotification(e);
    });
  }
  _updateDrawings(i, t) {
    setTimeout(() => {
      const e = this._drawingManagerService.drawingManagerData, n = [], r = [];
      Object.keys(e).forEach((s) => {
        const o2 = e[s];
        o2 != null && Object.keys(o2).forEach((a) => {
          const d2 = o2[a].data;
          d2 != null && Object.keys(d2).forEach((u2) => {
            if (s === i && a === t) {
              const c2 = d2[u2];
              c2.transform = z3(c2.sheetTransform, this._selectionRenderService, this._skeletonManagerService), n.push(d2[u2]);
            } else
              r.push(d2[u2]);
          });
        });
      }), this._drawingManagerService.removeNotification(r), this._drawingManagerService.addNotification(n);
    }, 0);
  }
  _sheetRefreshListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        Ns.includes(i.id) && requestIdleCallback(() => {
          const t = i.params, { unitId: e, subUnitId: n, ranges: r } = t;
          this._refreshDrawingTransform(e, n, r);
        });
      })
    );
  }
  _refreshDrawingTransform(i, t, e) {
    const n = this._drawingManagerService.getDrawingData(i, t), r = [];
    Object.keys(n).forEach((s) => {
      const o2 = n[s], { sheetTransform: a, transform: d2, anchorType: u2 = Y.Position } = o2;
      if (u2 === Y.None)
        return true;
      const { from: c2, to: l2 } = a, { row: g2, column: h3 } = c2, { row: f3, column: p2 } = l2;
      for (let m = 0; m < e.length; m++) {
        const _2 = e[m], { startRow: v3, endRow: I, startColumn: R, endColumn: S } = _2;
        if (En.intersects(
          {
            startRow: v3,
            endRow: I,
            startColumn: R,
            endColumn: S
          },
          {
            startRow: g2,
            endRow: f3,
            startColumn: h3,
            endColumn: p2
          }
        ) || g2 > I || h3 > S) {
          const C = u2 === Y.Position, w2 = z3(a, this._selectionRenderService, this._skeletonManagerService);
          r.push({
            ...o2,
            transform: {
              ...w2,
              width: C ? d2 == null ? void 0 : d2.width : w2 == null ? void 0 : w2.width,
              height: C ? d2 == null ? void 0 : d2.height : w2 == null ? void 0 : w2.height
            }
          });
          break;
        }
      }
    }), r.length !== 0 && (this._drawingManagerService.refreshTransform(r), this._commandService.syncExecuteCommand(Y2.id, [i]));
  }
};
rn2 = Ps([
  me(1, ME),
  me(2, Ls),
  me(3, gt),
  me(4, Inject(ue)),
  me(5, Inject(G)),
  me(6, E),
  me(7, Mt2),
  me(8, vr)
], rn2);
var ks = (i) => {
  var v3;
  const t = useDependency(Ls), e = useDependency(Fn), n = useDependency(Mt2), r = useDependency(ME), { drawings: s } = i, o2 = s[0];
  if (o2 == null)
    return;
  const { unitId: a } = o2, d2 = r.getRenderById(a), u2 = d2 == null ? void 0 : d2.scene;
  if (u2 == null)
    return;
  const c2 = u2.getTransformerByCreate(), [l2, g2] = (0, import_react2.useState)(true), h3 = (v3 = o2.anchorType) != null ? v3 : Y.Position, [f3, p2] = (0, import_react2.useState)(h3);
  function m(I, R) {
    const S = [];
    return I.forEach((C) => {
      const { oKey: w2 } = C, y = R.getDrawingOKey(w2);
      if (y == null)
        return S.push(null), true;
      const { unitId: D3, subUnitId: T, drawingId: E3, drawingType: M, anchorType: b, sheetTransform: N } = y;
      S.push({
        unitId: D3,
        subUnitId: T,
        drawingId: E3,
        anchorType: b,
        sheetTransform: N,
        drawingType: M
      });
    }), S;
  }
  (0, import_react2.useEffect)(() => {
    const I = c2.clearControl$.subscribe((S) => {
      S === true && g2(false);
    }), R = c2.changeStart$.subscribe((S) => {
      var y;
      const { objects: C } = S, w2 = m(C, n);
      if (w2.length === 0)
        g2(false);
      else if (w2.length >= 1) {
        g2(true);
        const D3 = ((y = w2[0]) == null ? void 0 : y.anchorType) || Y.Position;
        p2(D3);
      }
    });
    return () => {
      R.unsubscribe(), I.unsubscribe();
    };
  }, []);
  function _2(I) {
    p2(I);
    const R = n.getFocusDrawings();
    if (R.length === 0)
      return;
    const S = R.map((C) => ({
      unitId: C.unitId,
      subUnitId: C.subUnitId,
      drawingId: C.drawingId,
      anchorType: I
    }));
    t.executeCommand(Wt.id, {
      unitId: R[0].unitId,
      drawings: S
    });
  }
  return (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      className: ie2("univer-grid univer-gap-2 univer-py-2 univer-text-gray-400", {
        "univer-hidden": !l2
      }),
      children: [
        (0, import_jsx_runtime2.jsx)(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: (0, import_jsx_runtime2.jsx)("div", { children: e.t("drawing-anchor.title") })
          }
        ),
        (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsxs)(kE, { value: f3, onChange: _2, direction: "vertical", children: [
          (0, import_jsx_runtime2.jsx)(TE, { value: Y.Both, children: e.t("drawing-anchor.both") }),
          (0, import_jsx_runtime2.jsx)(TE, { value: Y.Position, children: e.t("drawing-anchor.position") }),
          (0, import_jsx_runtime2.jsx)(TE, { value: Y.None, children: e.t("drawing-anchor.none") })
        ] }) })
      ]
    }
  );
};
var Ws = () => {
  const i = useDependency(Mt2), t = i.getFocusDrawings(), [e, n] = (0, import_react2.useState)(t);
  return (0, import_react2.useEffect)(() => {
    const r = i.focus$.subscribe((s) => {
      n(s);
    });
    return () => {
      r.unsubscribe();
    };
  }, []), !!(e != null && e.length) && (0, import_jsx_runtime2.jsxs)("div", { className: "univer-text-sm", children: [
    (0, import_jsx_runtime2.jsx)(Ar, { drawings: e }),
    (0, import_jsx_runtime2.jsx)(ks, { drawings: e })
  ] });
};
var Cr3 = "sheet.menu.image";
function Bs(i) {
  return {
    id: Cr3,
    type: H1.SUBITEMS,
    icon: "AddImageIcon",
    tooltip: "sheetImage.title",
    hidden$: Bi(i, we.UNIVER_SHEET),
    disabled$: he(i, { workbookTypes: [Pe], worksheetTypes: [Ve2], rangeTypes: [Le] })
  };
}
function js(i) {
  return {
    id: Bt.id,
    title: "sheetImage.upload.float",
    type: H1.BUTTON,
    hidden$: Bi(i, we.UNIVER_SHEET)
  };
}
function $s(i) {
  return {
    id: dn.id,
    title: "sheetImage.upload.cell",
    type: H1.BUTTON,
    hidden$: Bi(i, we.UNIVER_SHEET)
  };
}
var Fs = {
  [De.MEDIA]: {
    [Cr3]: {
      order: 0,
      menuItemFactory: Bs,
      [Bt.id]: {
        order: 0,
        menuItemFactory: js
      },
      [dn.id]: {
        order: 1,
        menuItemFactory: $s
      }
    }
  }
};
function st2(i) {
  return !i.getContextValue(gE) && !i.getContextValue(mE) && !i.getContextValue(UR) && i.getContextValue(PR);
}
var xs = {
  id: it2.id,
  description: "shortcut.drawing-move-down",
  group: "4_drawing-view",
  binding: q1.ARROW_DOWN,
  priority: 100,
  preconditions: st2,
  staticParameters: {
    direction: Cm.DOWN
  }
};
var Ys = {
  id: it2.id,
  description: "shortcut.drawing-move-up",
  group: "4_drawing-view",
  binding: q1.ARROW_UP,
  priority: 100,
  preconditions: st2,
  staticParameters: {
    direction: Cm.UP
  }
};
var Gs = {
  id: it2.id,
  description: "shortcut.drawing-move-left",
  group: "4_drawing-view",
  binding: q1.ARROW_LEFT,
  priority: 100,
  preconditions: st2,
  staticParameters: {
    direction: Cm.LEFT
  }
};
var Xs = {
  id: it2.id,
  description: "shortcut.drawing-move-right",
  group: "4_drawing-view",
  binding: q1.ARROW_RIGHT,
  priority: 100,
  preconditions: st2,
  staticParameters: {
    direction: Cm.RIGHT
  }
};
var Ls2 = {
  id: hr3.id,
  description: "shortcut.drawing-delete",
  group: "4_drawing-view",
  // when focusing on any other input tag do not trigger this shortcut
  preconditions: st2,
  binding: q1.DELETE,
  mac: q1.BACKSPACE
};
var Vs = Object.getOwnPropertyDescriptor;
var Hs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Vs(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var Ne2 = (i, t) => (e, n) => t(e, n, i);
var Ut = class extends Ve {
  constructor(i, t, e, n, r, s) {
    super(), this._componentManager = i, this._menuManagerService = t, this._commandService = e, this._shortcutService = n, this._drawingManagerService = r, this._sheetsSelectionsService = s, this._init();
  }
  _initCustomComponents() {
    const i = this._componentManager;
    this.disposeWithMe(i.register(pr2, Ws));
  }
  _initMenus() {
    this._menuManagerService.mergeMenu(Fs);
  }
  _initCommands() {
    [
      Bt,
      dn,
      kt2,
      rt2,
      Wt,
      wr3,
      Y2,
      _r2,
      gr2,
      mr2,
      it2,
      hr3,
      fr2
    ].forEach((i) => this.disposeWithMe(this._commandService.registerCommand(i)));
  }
  _initShortcuts() {
    [
      // sheet drawing shortcuts
      xs,
      Ys,
      Gs,
      Xs,
      Ls2
    ].forEach((i) => {
      this.disposeWithMe(this._shortcutService.registerShortcut(i));
    });
  }
  _init() {
    this._initCommands(), this._initCustomComponents(), this._initMenus(), this._initShortcuts();
  }
};
Ut = Hs([
  Ne2(0, Inject(S1)),
  Ne2(1, B1),
  Ne2(2, Ls),
  Ne2(3, ye2),
  Ne2(4, Mt2),
  Ne2(5, Inject(z))
], Ut);
var zs = Object.defineProperty;
var Ks = Object.getOwnPropertyDescriptor;
var Js = (i, t, e) => t in i ? zs(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var Zs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ks(t, e) : t, s = i.length - 1, o2; s >= 0; s--)
    (o2 = i[s]) && (r = o2(r) || r);
  return r;
};
var Lt = (i, t) => (e, n) => t(e, n, i);
var Dr = (i, t, e) => Js(i, typeof t != "symbol" ? t + "" : t, e);
var qs = "SHEET_IMAGE_UI_PLUGIN";
var Pt2 = class extends Ol {
  constructor(i = jn, t, e, n) {
    super(), this._config = i, this._injector = t, this._renderManagerService = e, this._configService = n;
    const { menu: r, ...s } = oo(
      {},
      jn,
      this._config
    );
    r && this._configService.setConfig("menu", r, { merge: true }), this._configService.setConfig(ss, s);
  }
  onStarting() {
    GC(this._injector, [
      [tt3],
      [Ut],
      [Rt],
      [Ot2],
      [Et],
      [Tt2],
      [bt2],
      [Mt3],
      [yt]
    ]), zc(this._injector, [
      [tt3]
    ]);
  }
  onReady() {
    zc(this._injector, [
      [Tt2],
      [yt]
    ]);
  }
  onRendered() {
    this._registerRenderModules(), zc(this._injector, [
      [Et],
      [Ot2],
      [Ut],
      [bt2],
      [Mt3]
    ]);
  }
  onSteady() {
    this._injector.get(Rt);
  }
  _registerRenderModules() {
    [
      [et5],
      [rn2],
      [nn2],
      [tn]
    ].forEach((i) => {
      this.disposeWithMe(this._renderManagerService.registerRenderModule(we.UNIVER_SHEET, i));
    });
  }
};
Dr(Pt2, "type", we.UNIVER_SHEET);
Dr(Pt2, "pluginName", qs);
Pt2 = Zs([
  qR(At, h2, nt3, f),
  Lt(1, Inject(Injector)),
  Lt(2, ME),
  Lt(3, ic)
], Pt2);

export {
  d,
  l,
  w,
  D,
  h2 as h,
  ze,
  Ze,
  oe,
  Pe2 as Pe,
  ut2 as ut,
  Xt,
  lr2 as lr,
  Le2 as Le,
  Ie,
  Ue,
  nt3 as nt,
  Ar,
  z3 as z,
  $,
  Y2 as Y,
  rt2 as rt,
  hr3 as hr,
  gr2 as gr,
  kt2 as kt,
  fr2 as fr,
  Wt,
  mr2 as mr,
  et5 as et,
  Bt,
  it2 as it,
  wr3 as wr,
  _r2 as _r,
  ge,
  tt3 as tt,
  Cr3 as Cr,
  Pt2 as Pt
};
//# sourceMappingURL=chunk-ZTXDQJG2.js.map
