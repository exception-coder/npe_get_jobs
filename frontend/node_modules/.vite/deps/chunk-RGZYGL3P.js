import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/@wendellhu/redi/dist/esm/index.js
var IdentifierDecoratorSymbol = Symbol("$$IDENTIFIER_DECORATOR");
function isIdentifierDecorator(thing) {
  return thing && thing[IdentifierDecoratorSymbol] === true;
}
function isCtor(thing) {
  return typeof thing === "function";
}
function isClassDependencyItem(thing) {
  if (thing && typeof thing.useClass !== "undefined") return true;
  return false;
}
function isFactoryDependencyItem(thing) {
  if (thing && typeof thing.useFactory !== "undefined") return true;
  return false;
}
function isValueDependencyItem(thing) {
  if (thing && typeof thing.useValue !== "undefined") return true;
  return false;
}
function isExistingDependencyItem(thing) {
  if (thing && typeof thing.useExisting !== "undefined") return true;
  return false;
}
function isAsyncDependencyItem(thing) {
  if (thing && typeof thing.useAsync !== "undefined") return true;
  return false;
}
var AsyncHookSymbol = Symbol("AsyncHook");
function isAsyncHook(thing) {
  if (thing && thing.__symbol === AsyncHookSymbol) return true;
  return false;
}
function prettyPrintIdentifier(id2) {
  return isCtor(id2) && !id2[IdentifierDecoratorSymbol] ? id2.name : id2.toString();
}
var RediError = class extends Error {
  constructor(message) {
    super(`[redi]: ${message}`);
  }
};
var Quantity = function(Quantity$1) {
  Quantity$1["MANY"] = "many";
  Quantity$1["OPTIONAL"] = "optional";
  Quantity$1["REQUIRED"] = "required";
  return Quantity$1;
}({});
var LookUp = function(LookUp$1) {
  LookUp$1["SELF"] = "self";
  LookUp$1["SKIP_SELF"] = "skipSelf";
  return LookUp$1;
}({});
var TARGET = Symbol("$$TARGET");
var DEPENDENCIES = Symbol("$$DEPENDENCIES");
var DependencyDescriptorNotFoundError = class extends RediError {
  constructor(index, target) {
    const msg = `Could not find dependency registered on the ${index} (indexed) parameter of the constructor of "${prettyPrintIdentifier(target)}".`;
    super(msg);
  }
};
var RequiredDecoratorMissusedError = class extends RediError {
  constructor(target, index) {
    const msg = `It seems that you forgot to provide a parameter to @Required() on the ${index}th parameter of "${prettyPrintIdentifier(target)}"`;
    super(msg);
  }
};
var IdentifierUndefinedError = class extends RediError {
  constructor(target, index) {
    const msg = `It seems that you register "undefined" as dependency on the ${index}th parameter of "${prettyPrintIdentifier(target)}". Please make sure that there is not cyclic dependency among your TypeScript files, or consider using "forwardRef". For more info please visit our website https://redi.wendell.fun/docs/faq#could-not-find-dependency-registered-on`;
    super(msg);
  }
};
function getDependencies(registerTarget) {
  const target = registerTarget;
  return target[DEPENDENCIES] || [];
}
function getDependencyByIndex(registerTarget, index) {
  const allDependencies = getDependencies(registerTarget);
  const dep = allDependencies.find((descriptor) => descriptor.paramIndex === index);
  if (!dep) throw new DependencyDescriptorNotFoundError(index, registerTarget);
  return dep;
}
function setDependency(registerTarget, identifier, paramIndex, quantity = Quantity.REQUIRED, lookUp) {
  const descriptor = {
    paramIndex,
    identifier,
    quantity,
    lookUp,
    withNew: false
  };
  if (typeof identifier === "undefined") throw new IdentifierUndefinedError(registerTarget, paramIndex);
  const target = registerTarget;
  if (target[TARGET] === target) target[DEPENDENCIES].push(descriptor);
  else {
    target[DEPENDENCIES] = [descriptor];
    target[TARGET] = target;
  }
}
var knownIdentifiers = /* @__PURE__ */ new Set();
var cachedIdentifiers = /* @__PURE__ */ new Map();
function createIdentifier(id2) {
  if (knownIdentifiers.has(id2)) {
    console.error(`Identifier "${id2}" already exists. Returning the cached identifier decorator.`);
    return cachedIdentifiers.get(id2);
  }
  const decorator = function(registerTarget, _key, index) {
    setDependency(registerTarget, decorator, index);
  };
  decorator.decoratorName = id2;
  decorator.toString = () => decorator.decoratorName;
  decorator[IdentifierDecoratorSymbol] = true;
  knownIdentifiers.add(id2);
  cachedIdentifiers.set(id2, decorator);
  return decorator;
}
function changeLookup(target, index, lookUp) {
  const descriptor = getDependencyByIndex(target, index);
  descriptor.lookUp = lookUp;
}
function lookupDecoratorFactoryProducer(lookUp) {
  return function DecoratorFactory() {
    if (this instanceof DecoratorFactory) return this;
    return function(target, _key, index) {
      changeLookup(target, index, lookUp);
    };
  };
}
var SkipSelf = lookupDecoratorFactoryProducer(LookUp.SKIP_SELF);
var Self = lookupDecoratorFactoryProducer(LookUp.SELF);
function mapQuantityToNumber(quantity) {
  if (quantity === Quantity.OPTIONAL) return "0 or 1";
  else return "1";
}
var QuantityCheckError = class extends RediError {
  constructor(id2, quantity, actual) {
    let msg = `Expect ${mapQuantityToNumber(quantity)} dependency item(s) for id "${prettyPrintIdentifier(id2)}" but get ${actual}.`;
    if (actual === 0) msg += " Did you forget to register it?";
    if (actual > 1) msg += " You register it more than once.";
    super(msg);
    this.quantity = quantity;
    this.actual = actual;
  }
};
function checkQuantity(id2, quantity, length) {
  if (quantity === Quantity.OPTIONAL && length > 1 || quantity === Quantity.REQUIRED && length !== 1) throw new QuantityCheckError(id2, quantity, length);
}
function retrieveQuantity(quantity, arr) {
  if (quantity === Quantity.MANY) return arr;
  else return arr[0];
}
function changeQuantity(target, index, quantity) {
  const descriptor = getDependencyByIndex(target, index);
  descriptor.quantity = quantity;
}
function quantifyDecoratorFactoryProducer(quantity) {
  return function decoratorFactory(id2) {
    if (this instanceof decoratorFactory) return this;
    return function(registerTarget, _key, index) {
      if (id2) setDependency(registerTarget, id2, index, quantity);
      else {
        if (quantity === Quantity.REQUIRED) throw new RequiredDecoratorMissusedError(registerTarget, index);
        changeQuantity(registerTarget, index, quantity);
      }
    };
  };
}
var Many = quantifyDecoratorFactoryProducer(Quantity.MANY);
var Optional = quantifyDecoratorFactoryProducer(Quantity.OPTIONAL);
var Inject = quantifyDecoratorFactoryProducer(Quantity.REQUIRED);
function normalizeFactoryDeps(deps, startIndex = 0) {
  if (!deps) return [];
  return deps.map((dep, index) => {
    index += startIndex;
    if (!Array.isArray(dep)) return {
      paramIndex: index,
      identifier: dep,
      quantity: Quantity.REQUIRED,
      withNew: false
    };
    const modifiers = dep.slice(0, dep.length - 1);
    const identifier = dep[dep.length - 1];
    let lookUp;
    let quantity = Quantity.REQUIRED;
    let withNew = false;
    modifiers.forEach((modifier) => {
      if (modifier instanceof Self) lookUp = LookUp.SELF;
      else if (modifier instanceof SkipSelf) lookUp = LookUp.SKIP_SELF;
      else if (modifier instanceof Optional) quantity = Quantity.OPTIONAL;
      else if (modifier instanceof Many) quantity = Quantity.MANY;
      else withNew = true;
    });
    return {
      paramIndex: index,
      identifier,
      quantity,
      lookUp,
      withNew
    };
  });
}
function setDependencies(registerTarget, deps, startIndex = 0) {
  const normalizedDescriptors = normalizeFactoryDeps(deps, startIndex);
  normalizedDescriptors.forEach((descriptor) => {
    setDependency(registerTarget, descriptor.identifier, descriptor.paramIndex, descriptor.quantity, descriptor.lookUp);
  });
}
function forwardRef(wrapper) {
  return { unwrap: wrapper };
}
function isForwardRef(thing) {
  return !!thing && typeof thing.unwrap === "function";
}
function normalizeForwardRef(id2) {
  if (isForwardRef(id2)) return id2.unwrap();
  return id2;
}
function changeToSelf(target, index, withNew) {
  const descriptor = getDependencyByIndex(target, index);
  descriptor.withNew = withNew;
}
function withNewDecoratorFactoryProducer(withNew) {
  return function DecoratorFactory() {
    if (this instanceof DecoratorFactory) return this;
    return function(target, _key, index) {
      changeToSelf(target, index, withNew);
    };
  };
}
var WithNew = withNewDecoratorFactoryProducer(true);
function isDisposable(thing) {
  return !!thing && typeof thing.dispose === "function";
}
function isBareClassDependency(thing) {
  return thing.length === 1;
}
var ResolvingStack = [];
function pushResolvingStack(id2) {
  ResolvingStack.push(id2);
}
function popupResolvingStack() {
  ResolvingStack.pop();
}
function clearResolvingStack() {
  ResolvingStack.length = 0;
}
var DependencyNotFoundForModuleError = class extends RediError {
  constructor(toInstantiate, id2, index) {
    const msg = `Cannot find "${prettyPrintIdentifier(id2)}" registered by any injector. It is the ${index}th param of "${isIdentifierDecorator(toInstantiate) ? prettyPrintIdentifier(toInstantiate) : toInstantiate.name}".`;
    super(msg);
  }
};
var DependencyNotFoundError = class extends RediError {
  constructor(id2) {
    const msg = `Cannot find "${prettyPrintIdentifier(id2)}" registered by any injector. The stack of dependencies is: "${ResolvingStack.map((id$1) => prettyPrintIdentifier(id$1)).join(" -> ")}".`;
    super(msg);
    clearResolvingStack();
  }
};
var DependencyCollection = class {
  constructor(dependencies) {
    __publicField(this, "dependencyMap", /* @__PURE__ */ new Map());
    this.normalizeDependencies(dependencies).map((pair) => this.add(pair[0], pair[1]));
  }
  add(ctorOrId, val) {
    if (typeof val === "undefined") val = {
      useClass: ctorOrId,
      lazy: false
    };
    let arr = this.dependencyMap.get(ctorOrId);
    if (typeof arr === "undefined") {
      arr = [];
      this.dependencyMap.set(ctorOrId, arr);
    }
    arr.push(val);
  }
  delete(id2) {
    this.dependencyMap.delete(id2);
  }
  get(id2, quantity) {
    const ret = this.dependencyMap.get(id2);
    checkQuantity(id2, quantity, ret.length);
    return retrieveQuantity(quantity, ret);
  }
  has(id2) {
    return this.dependencyMap.has(id2);
  }
  dispose() {
    this.dependencyMap.clear();
  }
  /**
  * normalize dependencies to `DependencyItem`
  */
  normalizeDependencies(dependencies) {
    return dependencies.map((dependency) => {
      const id2 = dependency[0];
      let val;
      if (isBareClassDependency(dependency)) val = {
        useClass: dependency[0],
        lazy: false
      };
      else val = dependency[1];
      return [id2, val];
    });
  }
};
var ResolvedDependencyCollection = class {
  constructor() {
    __publicField(this, "resolvedDependencies", /* @__PURE__ */ new Map());
  }
  add(id2, val) {
    let arr = this.resolvedDependencies.get(id2);
    if (typeof arr === "undefined") {
      arr = [];
      this.resolvedDependencies.set(id2, arr);
    }
    arr.push(val);
  }
  has(id2) {
    return this.resolvedDependencies.has(id2);
  }
  get(id2, quantity) {
    const ret = this.resolvedDependencies.get(id2);
    if (!ret) throw new DependencyNotFoundError(id2);
    checkQuantity(id2, quantity, ret.length);
    if (quantity === Quantity.MANY) return ret;
    else return ret[0];
  }
  dispose() {
    Array.from(this.resolvedDependencies.values()).forEach((items) => {
      items.forEach((item) => isDisposable(item) ? item.dispose() : void 0);
    });
    this.resolvedDependencies.clear();
  }
};
var runWhenIdle;
(function() {
  if (typeof requestIdleCallback !== "undefined" && typeof cancelIdleCallback !== "undefined") runWhenIdle = (runner, timeout2) => {
    const handle = requestIdleCallback(runner, typeof timeout2 === "number" ? { timeout: timeout2 } : void 0);
    let disposed = false;
    return () => {
      if (disposed) return;
      disposed = true;
      cancelIdleCallback(handle);
    };
  };
  else {
    const dummyIdle = Object.freeze({
      didTimeout: true,
      timeRemaining() {
        return 15;
      }
    });
    runWhenIdle = (runner) => {
      const handle = setTimeout(() => runner(dummyIdle));
      let disposed = false;
      return () => {
        if (disposed) return;
        disposed = true;
        clearTimeout(handle);
      };
    };
  }
})();
var IdleValue = class {
  constructor(executor) {
    __publicField(this, "executor");
    __publicField(this, "disposeIdleCallback");
    __publicField(this, "didRun", false);
    __publicField(this, "value");
    __publicField(this, "error");
    this.executor = () => {
      try {
        this.value = executor();
      } catch (err) {
        this.error = err;
      } finally {
        this.didRun = true;
      }
    };
    this.disposeIdleCallback = runWhenIdle(() => this.executor());
  }
  hasRun() {
    return this.didRun;
  }
  dispose() {
    this.disposeIdleCallback();
  }
  getValue() {
    if (!this.didRun) {
      this.disposeIdleCallback();
      this.executor();
    }
    if (this.error) throw this.error;
    return this.value;
  }
};
var MAX_RESOLUTIONS_QUEUED = 300;
var NotInstantiatedSymbol = Symbol("$$NOT_INSTANTIATED_SYMBOL");
var CircularDependencyError = class extends RediError {
  constructor(id2) {
    super(`Detecting cyclic dependency. The last identifier is "${prettyPrintIdentifier(id2)}".`);
  }
};
var InjectorAlreadyDisposedError = class extends RediError {
  constructor() {
    super("Injector cannot be accessed after it was disposed.");
  }
};
var AsyncItemReturnAsyncItemError = class extends RediError {
  constructor(id2) {
    super(`Async item "${prettyPrintIdentifier(id2)}" returns another async item.`);
  }
};
var GetAsyncItemFromSyncApiError = class extends RediError {
  constructor(id2) {
    super(`Cannot get async item "${prettyPrintIdentifier(id2)}" from sync api.`);
  }
};
var AddDependencyAfterResolutionError = class extends RediError {
  constructor(id2) {
    super(`Cannot add dependency "${prettyPrintIdentifier(id2)}" after it is already resolved.`);
  }
};
var DeleteDependencyAfterResolutionError = class extends RediError {
  constructor(id2) {
    super(`Cannot delete dependency "${prettyPrintIdentifier(id2)}" when it is already resolved.`);
  }
};
var Injector = class Injector2 {
  /**
  * Create a new `Injector` instance
  * @param dependencies Dependencies that should be resolved by this injector instance.
  * @param parent Optional parent injector.
  */
  constructor(dependencies, parent = null) {
    __publicField(this, "dependencyCollection");
    __publicField(this, "resolvedDependencyCollection");
    __publicField(this, "children", []);
    __publicField(this, "resolutionOngoing", 0);
    __publicField(this, "disposingCallbacks", /* @__PURE__ */ new Set());
    __publicField(this, "disposed", false);
    this.parent = parent;
    this.dependencyCollection = new DependencyCollection(dependencies || []);
    this.resolvedDependencyCollection = new ResolvedDependencyCollection();
    if (parent) parent.children.push(this);
  }
  /**
  * Add a callback function that will be triggered when the Injector is disposed.
  * Please note that when you callback is invoked, the injector is already disposed and
  * you will not be able to interact with this Injector any more.
  *
  * @param {() => void} callback The callback function that will be invoked when
  * the Injector is disposed.
  * @returns A disposable that will remove the callback.
  */
  onDispose(callback) {
    this.disposingCallbacks.add(callback);
    return { dispose: () => this.disposingCallbacks.delete(callback) };
  }
  /**
  * Create a child inject with a set of dependencies.
  * @param dependencies Dependencies that should be resolved by the newly created child injector.
  * @returns The child injector.
  */
  createChild(dependencies) {
    this._ensureInjectorNotDisposed();
    return new Injector2(dependencies, this);
  }
  /**
  * Dispose the injector and all dependencies held by this injector. Note that its child injectors will dispose first.
  */
  dispose() {
    this.children.forEach((c) => c.dispose());
    this.children.length = 0;
    this.dependencyCollection.dispose();
    this.resolvedDependencyCollection.dispose();
    this.deleteSelfFromParent();
    this.disposed = true;
    this.disposingCallbacks.forEach((callback) => callback());
    this.disposingCallbacks.clear();
  }
  deleteSelfFromParent() {
    if (this.parent) {
      const index = this.parent.children.indexOf(this);
      this.parent.children.splice(index, 1);
    }
  }
  /**
  * Add a dependency or its instance into injector. It would throw an error if the dependency
  * has already been instantiated.
  *
  * @param dependency The dependency or an instance that would be add in the injector.
  */
  add(dependency) {
    this._ensureInjectorNotDisposed();
    const identifierOrCtor = dependency[0];
    const item = dependency[1];
    if (this.resolvedDependencyCollection.has(identifierOrCtor)) throw new AddDependencyAfterResolutionError(identifierOrCtor);
    if (typeof item === "undefined") this.dependencyCollection.add(identifierOrCtor);
    else if (isAsyncDependencyItem(item) || isClassDependencyItem(item) || isValueDependencyItem(item) || isFactoryDependencyItem(item)) this.dependencyCollection.add(identifierOrCtor, item);
    else this.resolvedDependencyCollection.add(identifierOrCtor, item);
  }
  /**
  * Replace an injection mapping for interface-based injection. It would throw an error if the dependency
  * has already been instantiated.
  *
  * @param dependency The dependency that will replace the already existed dependency.
  */
  replace(dependency) {
    this._ensureInjectorNotDisposed();
    const identifier = dependency[0];
    if (this.resolvedDependencyCollection.has(identifier)) throw new AddDependencyAfterResolutionError(identifier);
    this.dependencyCollection.delete(identifier);
    this.dependencyCollection.add(identifier, dependency[1]);
  }
  /**
  * Delete a dependency from an injector. It would throw an error when the deleted dependency
  * has already been instantiated.
  *
  * @param identifier The identifier of the dependency that is supposed to be deleted.
  */
  delete(identifier) {
    this._ensureInjectorNotDisposed();
    if (this.resolvedDependencyCollection.has(identifier)) throw new DeleteDependencyAfterResolutionError(identifier);
    this.dependencyCollection.delete(identifier);
  }
  /**
  * Invoke a function with dependencies injected. The function could only get dependency from the injector
  * and other methods are not accessible for the function.
  *
  * @param cb the function to be executed
  * @param args arguments to be passed into the function
  * @returns the return value of the function
  */
  invoke(cb, ...args) {
    this._ensureInjectorNotDisposed();
    const accessor = {
      get: (id2, quantityOrLookup, lookUp) => {
        return this._get(id2, quantityOrLookup, lookUp);
      },
      has: (id2) => {
        return this.has(id2);
      }
    };
    return cb(accessor, ...args);
  }
  /**
  * Check if the injector could initialize a dependency.
  *
  * @param id Identifier of the dependency
  */
  has(id2) {
    var _a2;
    return this.dependencyCollection.has(id2) || ((_a2 = this.parent) == null ? void 0 : _a2.has(id2)) || false;
  }
  /**
  * Get dependency instance(s).
  *
  * @param id Identifier of the dependency
  * @param quantityOrLookup @link{Quantity} or @link{LookUp}
  * @param lookUp @link{LookUp}
  */
  get(id2, quantityOrLookup, lookUp) {
    this._ensureInjectorNotDisposed();
    const newResult = this._get(id2, quantityOrLookup, lookUp);
    if (Array.isArray(newResult) && newResult.some((r) => isAsyncHook(r)) || isAsyncHook(newResult)) throw new GetAsyncItemFromSyncApiError(id2);
    return newResult;
  }
  _get(id2, quantityOrLookup, lookUp, withNew) {
    let quantity = Quantity.REQUIRED;
    if (quantityOrLookup === Quantity.REQUIRED || quantityOrLookup === Quantity.OPTIONAL || quantityOrLookup === Quantity.MANY) quantity = quantityOrLookup;
    else lookUp = quantityOrLookup;
    if (!withNew) {
      const cachedResult = this.getValue(id2, quantity, lookUp);
      if (cachedResult !== NotInstantiatedSymbol) return cachedResult;
    }
    const shouldCache = !withNew;
    return this.createDependency(id2, quantity, lookUp, shouldCache);
  }
  /**
  * Get a dependency in the async way.
  */
  getAsync(id2) {
    this._ensureInjectorNotDisposed();
    const cachedResult = this.getValue(id2, Quantity.REQUIRED);
    if (cachedResult !== NotInstantiatedSymbol) return Promise.resolve(cachedResult);
    const newResult = this.createDependency(id2, Quantity.REQUIRED);
    if (!isAsyncHook(newResult)) return Promise.resolve(newResult);
    return newResult.whenReady();
  }
  /**
  * Instantiate a class. The created instance would not be held by the injector.
  */
  createInstance(ctor, ...customArgs) {
    this._ensureInjectorNotDisposed();
    return this._resolveClassImpl({ useClass: ctor }, ...customArgs);
  }
  _resolveDependency(id2, item, shouldCache = true) {
    let result;
    pushResolvingStack(id2);
    try {
      if (isValueDependencyItem(item)) result = this._resolveValueDependency(id2, item);
      else if (isFactoryDependencyItem(item)) result = this._resolveFactory(id2, item, shouldCache);
      else if (isClassDependencyItem(item)) result = this._resolveClass(id2, item, shouldCache);
      else if (isExistingDependencyItem(item)) result = this._resolveExisting(id2, item);
      else result = this._resolveAsync(id2, item);
      popupResolvingStack();
    } catch (e) {
      popupResolvingStack();
      throw e;
    }
    return result;
  }
  _resolveExisting(id2, item) {
    const thing = this.get(item.useExisting);
    this.resolvedDependencyCollection.add(id2, thing);
    return thing;
  }
  _resolveValueDependency(id2, item) {
    const thing = item.useValue;
    this.resolvedDependencyCollection.add(id2, thing);
    return thing;
  }
  _resolveClass(id2, item, shouldCache) {
    let thing;
    if (item.lazy) {
      const idle = new IdleValue(() => {
        this._ensureInjectorNotDisposed();
        return this._resolveClassImpl(item);
      });
      thing = new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key) {
          if (key in target) return target[key];
          const thing$1 = idle.getValue();
          let property = thing$1[key];
          if (typeof property !== "function") return property;
          property = property.bind(thing$1);
          target[key] = property;
          return property;
        },
        set(_target, key, value) {
          idle.getValue()[key] = value;
          return true;
        }
      });
    } else thing = this._resolveClassImpl(item);
    if (id2 && shouldCache) this.resolvedDependencyCollection.add(id2, thing);
    return thing;
  }
  _resolveClassImpl(item, ...extraParams) {
    var _a2;
    const Ctor = item.useClass;
    this.markNewResolution(Ctor);
    const declaredDependencies = getDependencies(Ctor).sort((a, b) => a.paramIndex - b.paramIndex).map((descriptor) => ({
      ...descriptor,
      identifier: normalizeForwardRef(descriptor.identifier)
    }));
    const resolvedArgs = [];
    for (const dep of declaredDependencies) try {
      const thing$1 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
      resolvedArgs.push(thing$1);
    } catch (error) {
      if (error instanceof DependencyNotFoundError || error instanceof QuantityCheckError && error.actual === 0) throw new DependencyNotFoundForModuleError(Ctor, dep.identifier, dep.paramIndex);
      throw error;
    }
    let args = [...extraParams];
    const firstDependencyArgIndex = declaredDependencies.length > 0 ? declaredDependencies[0].paramIndex : args.length;
    if (args.length !== firstDependencyArgIndex) {
      console.warn(`[redi]: Expect ${firstDependencyArgIndex} custom parameter(s) of ${prettyPrintIdentifier(Ctor)} but get ${args.length}.`);
      const delta = firstDependencyArgIndex - args.length;
      if (delta > 0) args = [...args, ...Array.from({ length: delta }).fill(void 0)];
      else args = args.slice(0, firstDependencyArgIndex);
    }
    const thing = new Ctor(...args, ...resolvedArgs);
    (_a2 = item == null ? void 0 : item.onInstantiation) == null ? void 0 : _a2.call(item, thing);
    this.markResolutionCompleted();
    return thing;
  }
  _resolveFactory(id2, item, shouldCache) {
    var _a2;
    this.markNewResolution(id2);
    const declaredDependencies = normalizeFactoryDeps(item.deps);
    const resolvedArgs = [];
    for (const dep of declaredDependencies) try {
      const thing$1 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
      resolvedArgs.push(thing$1);
    } catch (error) {
      if (error instanceof DependencyNotFoundError || error instanceof QuantityCheckError && error.actual === 0) throw new DependencyNotFoundForModuleError(id2, dep.identifier, dep.paramIndex);
      throw error;
    }
    const thing = item.useFactory.apply(null, resolvedArgs);
    if (shouldCache) this.resolvedDependencyCollection.add(id2, thing);
    this.markResolutionCompleted();
    (_a2 = item == null ? void 0 : item.onInstantiation) == null ? void 0 : _a2.call(item, thing);
    return thing;
  }
  _resolveAsync(id2, item) {
    const asyncLoader = {
      __symbol: AsyncHookSymbol,
      whenReady: () => this._resolveAsyncImpl(id2, item)
    };
    return asyncLoader;
  }
  _resolveAsyncImpl(id2, item) {
    return item.useAsync().then((thing) => {
      const resolvedCheck = this.getValue(id2);
      if (resolvedCheck !== NotInstantiatedSymbol) return resolvedCheck;
      let ret;
      if (Array.isArray(thing)) {
        const item$1 = thing[1];
        if (isAsyncDependencyItem(item$1)) throw new AsyncItemReturnAsyncItemError(id2);
        else ret = this._resolveDependency(id2, item$1);
      } else if (isCtor(thing)) ret = this._resolveClassImpl({
        useClass: thing,
        onInstantiation: item.onInstantiation
      });
      else ret = thing;
      this.resolvedDependencyCollection.add(id2, ret);
      return ret;
    });
  }
  getValue(id2, quantity = Quantity.REQUIRED, lookUp) {
    const onSelf = () => {
      if (this.dependencyCollection.has(id2) && !this.resolvedDependencyCollection.has(id2)) return NotInstantiatedSymbol;
      return this.resolvedDependencyCollection.get(id2, quantity);
    };
    const onParent = () => {
      if (this.parent) return this.parent.getValue(id2, quantity);
      else {
        if (quantity === Quantity.OPTIONAL) return null;
        else if (quantity === Quantity.MANY) return [];
        throw new QuantityCheckError(id2, Quantity.REQUIRED, 0);
      }
    };
    if (lookUp === LookUp.SKIP_SELF) return onParent();
    if (id2 === Injector2) return this;
    if (lookUp === LookUp.SELF) return onSelf();
    if (this.resolvedDependencyCollection.has(id2) || this.dependencyCollection.has(id2)) return onSelf();
    return onParent();
  }
  createDependency(id2, quantity, lookUp, shouldCache = true) {
    const onSelf = () => {
      const registrations = this.dependencyCollection.get(id2, quantity);
      let ret = null;
      if (Array.isArray(registrations)) ret = registrations.map((dependencyItem) => this._resolveDependency(id2, dependencyItem, shouldCache));
      else ret = this._resolveDependency(id2, registrations, shouldCache);
      return ret;
    };
    const onParent = () => {
      if (this.parent) return this.parent.createDependency(id2, quantity, void 0, shouldCache);
      else {
        if (quantity === Quantity.OPTIONAL) return null;
        else if (quantity === Quantity.MANY) return [];
        pushResolvingStack(id2);
        throw new DependencyNotFoundError(id2);
      }
    };
    if (lookUp === LookUp.SKIP_SELF) return onParent();
    if (this.dependencyCollection.has(id2)) return onSelf();
    return onParent();
  }
  markNewResolution(id2) {
    this.resolutionOngoing += 1;
    if (this.resolutionOngoing >= MAX_RESOLUTIONS_QUEUED) throw new CircularDependencyError(id2);
  }
  markResolutionCompleted() {
    this.resolutionOngoing -= 1;
  }
  _ensureInjectorNotDisposed() {
    if (this.disposed) throw new InjectorAlreadyDisposedError();
  }
};
var globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global !== "undefined" && global;
var __REDI_GLOBAL_LOCK__ = "REDI_GLOBAL_LOCK";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
if (globalObject[__REDI_GLOBAL_LOCK__]) {
  if (!isNode) console.error(`[redi]: You are loading scripts of redi more than once! This may cause undesired behavior in your application.
Maybe your dependencies added redi as its dependency and bundled redi to its dist files. Or you import different versions of redi.
For more info please visit our website: https://redi.wendell.fun/en-US/docs/faq#import-scripts-of-redi-more-than-once`);
} else globalObject[__REDI_GLOBAL_LOCK__] = true;

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __2() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op2[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done) return t;
      if (y = 0, t) op2 = [op2[0] & 2, t.value];
      switch (op2[0]) {
        case 0:
        case 1:
          t = op2;
          break;
        case 4:
          _.label++;
          return { value: op2[1], done: false };
        case 5:
          _.label++;
          y = op2[1];
          op2 = [0];
          continue;
        case 7:
          op2 = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
            _.label = op2[1];
            break;
          }
          if (op2[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op2;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op2);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op2 = body.call(thisArg, _);
    } catch (e) {
      op2 = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op2[0] & 5) throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar2; i < l; i++) {
    if (ar2 || !(i in from2)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from2, 0, i);
      ar2[i] = from2[i];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn2, thisArg) {
  return _bind.call(fn2, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    fns[_i2] = arguments[_i2];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      operations[_i2] = arguments[_i2];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a2;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id2 = 0;
    var run = function() {
      if (!subscriber.closed) {
        id2 = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id2 = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id2) {
        animationFrameProvider.cancelAnimationFrame(id2);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
            var observer = _c2.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a2;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a2 = this, id2 = _a2.id, scheduler = _a2.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    var _a2;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    var actions = scheduler.actions;
    if (id2 != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id2) {
      immediateProvider.clearImmediate(id2);
      if (scheduler._scheduled === id2) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    var _a2;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    var actions = scheduler.actions;
    if (id2 != null && id2 === scheduler._scheduled && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id2) {
      animationFrameProvider.cancelAnimationFrame(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a2, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a2 = _b.sent(), value = _a2.value, done = _a2.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a2;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return)) _a2.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a2;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return))) return [3, 8];
          return [4, _a2.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a2;
        var value;
        var done;
        try {
          _a2 = iterator2.next(), value = _a2.value, done = _a2.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a2;
    return isFunction((_a2 = nextOrObserver) === null || _a2 === void 0 ? void 0 : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a2, _b, _c2;
  var _d2 = notification, kind = _d2.kind, value = _d2.value, error = _d2.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c2 = observer.complete) === null || _c2 === void 0 ? void 0 : _c2.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn2, args) {
  return isArray(args) ? fn2.apply(void 0, __spreadArray([], __read(args))) : fn2(args);
}
function mapOneOrManyArgs(fn2) {
  return map(function(args) {
    return callOrApply(fn2, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a2 = argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii2) {
        return resultSelector(a, b, i, ii2);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a2 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a2[0], remove = _a2[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function race() {
  var sources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    sources[_i2] = arguments[_i2];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/audit.js
function audit(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var _a2, _b;
  var otherArgs = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    otherArgs[_i2 - 1] = arguments[_i2];
  }
  var scheduler = (_a2 = popScheduler(otherArgs)) !== null && _a2 !== void 0 ? _a2 : asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule(subs, scheduler, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a3;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a3 = recordsCopy_1.return)) _a3.call(recordsCopy_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b = buffer2;
      buffer2 = [];
      b && subscriber.next(b);
      innerFrom(closingSelector()).subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop));
    };
    openBuffer();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    otherSources[_i2] = arguments[_i2];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value) {
  return map(function() {
    return value;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index) {
    return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/delay.js
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration = timer(due, scheduler);
  return delayWhen(function() {
    return duration;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}

// node_modules/rxjs/dist/esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a2 = config2.count, count2 = _a2 === void 0 ? Infinity : _a2, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.connector, connector = _a2 === void 0 ? function() {
    return new Subject();
  } : _a2, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c2 = options.resetOnComplete, resetOnComplete = _c2 === void 0 ? true : _c2, _d2 = options.resetOnRefCountZero, resetOnRefCountZero = _d2 === void 0 ? true : _d2;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a2, _b, _c2;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c2 = configOrBufferSize.refCount, refCount2 = _c2 === void 0 ? false : _c2, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/skip.js
function skip(count2) {
  return filter(function(_, index) {
    return count2 <= index;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    values[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a2;
    (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a3;
      (_a3 = tapObserver.next) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.complete) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.error) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a3, _b;
      if (isUnsub) {
        (_a3 = tapObserver.unsubscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  return operate(function(source, subscriber) {
    var _a2 = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a2.leading, leading = _b === void 0 ? true : _b, _c2 = _a2.trailing, trailing = _c2 === void 0 ? false : _c2;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration$ = timer(duration, scheduler);
  return throttle(function() {
    return duration$;
  }, config2);
}

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    inputs[_i2] = arguments[_i2];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/@univerjs/themes/lib/es/index.js
var F = {
  white: "#FFFFFF",
  black: "#000000",
  primary: {
    50: "#F3F5FF",
    100: "#E9EDFF",
    200: "#D2DAFA",
    300: "#BAC6F8",
    400: "#6280F9",
    500: "#466AF7",
    600: "#2C53F1",
    700: "#143EE3",
    800: "#083AD1",
    900: "#1033BF"
  },
  gray: {
    50: "#F9FAFB",
    100: "#EEEFF1",
    200: "#E3E5EA",
    300: "#A8B0BD",
    400: "#7D8698",
    500: "#4E5565",
    600: "#31363F",
    700: "#272A2F",
    800: "#1F2124",
    900: "#1B1C1F"
  },
  blue: {
    50: "#EBF5FF",
    100: "#E1EFFE",
    200: "#C3DDFD",
    300: "#A4CAFE",
    400: "#76A9FA",
    500: "#3F83F8",
    600: "#1C64F2",
    700: "#1A56DB",
    800: "#1E429F",
    900: "#233876"
  },
  red: {
    50: "#FDF2F2",
    100: "#FDE8E8",
    200: "#FBD5D5",
    300: "#F8B4B4",
    400: "#F98080",
    500: "#F05252",
    600: "#E02424",
    700: "#C81E1E",
    800: "#9B1C1C",
    900: "#771D1D"
  },
  orange: {
    50: "#FFF8F1",
    100: "#FEECDC",
    200: "#FCD9BD",
    300: "#FDBA8C",
    400: "#FF8A4C",
    500: "#FF5A1F",
    600: "#D03801",
    700: "#B43403",
    800: "#8A2C0D",
    900: "#771D1D"
  },
  yellow: {
    50: "#FDFCEA",
    100: "#FFF4B9",
    200: "#FCDC6A",
    300: "#FAC815",
    400: "#F1B312",
    500: "#D49D0F",
    600: "#AB7F0E",
    700: "#9A6D15",
    800: "#725213",
    900: "#634312"
  },
  green: {
    50: "#F3FAF7",
    100: "#DEF7EC",
    200: "#BCF0DA",
    300: "#84E1BC",
    400: "#31C48D",
    500: "#0DA471",
    600: "#057A55",
    700: "#046C4E",
    800: "#03543F",
    900: "#014737"
  },
  jiqing: {
    50: "#EDFAFA",
    100: "#D5F5F6",
    200: "#AFECEF",
    300: "#7EDCE2",
    400: "#16BDCA",
    500: "#0694A2",
    600: "#047481",
    700: "#036672",
    800: "#05505C",
    900: "#014451"
  },
  indigo: {
    50: "#F3F5FF",
    100: "#E9EDFF",
    200: "#D2DAFA",
    300: "#BAC6F8",
    400: "#6280F9",
    500: "#466AF7",
    600: "#2C53F1",
    700: "#143EE3",
    800: "#083AD1",
    900: "#1033BF"
  },
  purple: {
    50: "#F6F5FF",
    100: "#EDEBFE",
    200: "#DCD7FE",
    300: "#CABFFD",
    400: "#AC94FA",
    500: "#9061F9",
    600: "#7E3AF2",
    700: "#6C2BD9",
    800: "#5521B5",
    900: "#4A1D96"
  },
  pink: {
    50: "#FDF2F8",
    100: "#FCE8F3",
    200: "#FAD1E8",
    300: "#F8B4D9",
    400: "#F17EB8",
    500: "#E74694",
    600: "#D61F69",
    700: "#BF125D",
    800: "#99154B",
    900: "#751A3D"
  },
  "loop-color": {
    1: "purple.400",
    2: "green.500",
    3: "blue.500",
    4: "yellow.400",
    5: "pink.300",
    6: "jiqing.600",
    7: "orange.400",
    8: "gray.800",
    9: "indigo.500",
    10: "red.300",
    11: "green.600",
    12: "yellow.700"
  }
};
var D = {
  white: "#FFFFFF",
  black: "#000000",
  primary: {
    50: "#F3FAF7",
    100: "#DEF7EC",
    200: "#BCF0DA",
    300: "#84E1BC",
    400: "#31C48D",
    500: "#0DA471",
    600: "#057A55",
    700: "#046C4E",
    800: "#03543F",
    900: "#014737"
  },
  gray: {
    50: "#F9FAFB",
    100: "#EEEFF1",
    200: "#E3E5EA",
    300: "#A8B0BD",
    400: "#7D8698",
    500: "#4E5565",
    600: "#31363F",
    700: "#272A2F",
    800: "#1F2124",
    900: "#1B1C1F"
  },
  blue: {
    50: "#EBF5FF",
    100: "#E1EFFE",
    200: "#C3DDFD",
    300: "#A4CAFE",
    400: "#76A9FA",
    500: "#3F83F8",
    600: "#1C64F2",
    700: "#1A56DB",
    800: "#1E429F",
    900: "#233876"
  },
  red: {
    50: "#FDF2F2",
    100: "#FDE8E8",
    200: "#FBD5D5",
    300: "#F8B4B4",
    400: "#F98080",
    500: "#F05252",
    600: "#E02424",
    700: "#C81E1E",
    800: "#9B1C1C",
    900: "#771D1D"
  },
  orange: {
    50: "#FFF8F1",
    100: "#FEECDC",
    200: "#FCD9BD",
    300: "#FDBA8C",
    400: "#FF8A4C",
    500: "#FF5A1F",
    600: "#D03801",
    700: "#B43403",
    800: "#8A2C0D",
    900: "#771D1D"
  },
  yellow: {
    50: "#FDFCEA",
    100: "#FFF4B9",
    200: "#FCDC6A",
    300: "#FAC815",
    400: "#F1B312",
    500: "#D49D0F",
    600: "#AB7F0E",
    700: "#9A6D15",
    800: "#725213",
    900: "#634312"
  },
  green: {
    50: "#F3FAF7",
    100: "#DEF7EC",
    200: "#BCF0DA",
    300: "#84E1BC",
    400: "#31C48D",
    500: "#0DA471",
    600: "#057A55",
    700: "#046C4E",
    800: "#03543F",
    900: "#014737"
  },
  jiqing: {
    50: "#EDFAFA",
    100: "#D5F5F6",
    200: "#AFECEF",
    300: "#7EDCE2",
    400: "#16BDCA",
    500: "#0694A2",
    600: "#047481",
    700: "#036672",
    800: "#05505C",
    900: "#014451"
  },
  indigo: {
    50: "#F3F5FF",
    100: "#E9EDFF",
    200: "#D2DAFA",
    300: "#BAC6F8",
    400: "#6280F9",
    500: "#466AF7",
    600: "#2C53F1",
    700: "#143EE3",
    800: "#083AD1",
    900: "#1033BF"
  },
  purple: {
    50: "#F6F5FF",
    100: "#EDEBFE",
    200: "#DCD7FE",
    300: "#CABFFD",
    400: "#AC94FA",
    500: "#9061F9",
    600: "#7E3AF2",
    700: "#6C2BD9",
    800: "#5521B5",
    900: "#4A1D96"
  },
  pink: {
    50: "#FDF2F8",
    100: "#FCE8F3",
    200: "#FAD1E8",
    300: "#F8B4D9",
    400: "#F17EB8",
    500: "#E74694",
    600: "#D61F69",
    700: "#BF125D",
    800: "#99154B",
    900: "#751A3D"
  },
  "loop-color": {
    1: "purple.400",
    2: "green.500",
    3: "blue.500",
    4: "yellow.400",
    5: "pink.300",
    6: "jiqing.600",
    7: "orange.400",
    8: "gray.800",
    9: "indigo.500",
    10: "red.300",
    11: "green.600",
    12: "yellow.700"
  }
};

// node_modules/@univerjs/core/lib/es/index.js
var _c = Object.defineProperty;
var pc = (e, t, n) => t in e ? _c(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var p = (e, t, n) => pc(e, typeof t != "symbol" ? t + "" : t, n);
function Tc(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const s in r)
        if (s !== "default" && !(s in e)) {
          const i = Object.getOwnPropertyDescriptor(r, s);
          i && Object.defineProperty(e, s, i.get ? i : {
            enumerable: true,
            get: () => r[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Dt = typeof global < "u" ? global : typeof self < "u" ? self : window;
function Mc() {
  const t = /* @__PURE__ */ new Map();
  let n = 0;
  typeof Dt.requestIdleCallback != "function" && (Dt.requestIdleCallback = function(s) {
    const i = Date.now(), o = ++n, a = setTimeout(function() {
      t.delete(o);
      const u = Math.max(0, 50 - (Date.now() - i));
      s({
        didTimeout: u === 0,
        timeRemaining() {
          return u;
        }
      });
    }, 1);
    return t.set(o, a), o;
  }), typeof Dt.cancelIdleCallback != "function" && (Dt.cancelIdleCallback = function(s) {
    const i = t.get(s);
    i !== void 0 && (clearTimeout(i), t.delete(s));
  });
}
function Lc() {
  typeof Dt.Array.prototype.findLastIndex != "function" && (Dt.Array.prototype.findLastIndex = function(t, n) {
    if (this == null)
      throw new TypeError("Array.prototype.findLastIndex called on null or undefined");
    if (typeof t != "function")
      throw new TypeError("callback must be a function");
    const r = this.length >>> 0;
    for (let s = r - 1; s >= 0; s--)
      if (s in this && t.call(n, this[s], s, this))
        return s;
    return -1;
  }), typeof Dt.Array.prototype.findLast != "function" && (Dt.Array.prototype.findLast = function(t, n) {
    const r = this.findLastIndex(t, n);
    return r !== -1 ? this[r] : void 0;
  });
}
function xc() {
  typeof Dt.String.prototype.at != "function" && (Dt.String.prototype.at = function(t) {
    if (this == null)
      throw new TypeError("String.prototype.at called on null or undefined");
    const n = this.length;
    if (t < 0 && (t = n + t), !(t < 0 || t >= n))
      return this.charAt(t);
  });
}
function Dc() {
  Mc(), Lc(), xc();
}
function Os(e, t) {
  const n = e.indexOf(t);
  return n > -1 ? (e.splice(n, 1), true) : false;
}
function $C(e) {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const r of e)
    t.has(r) || (t.add(r), n.push(r));
  return n;
}
function HC(e, t) {
  const n = /* @__PURE__ */ new Set(), r = [];
  for (const s of e) {
    const i = t(s);
    n.has(i) || (n.add(i), r.push(s));
  }
  return r;
}
function Uc(e, t) {
  for (let n = e.length - 1; n > -1; n--) {
    const r = e[n];
    if (t(r, n))
      return r;
  }
  return null;
}
function BC(e, t) {
  if (e.length === 0)
    return e;
  const n = t % e.length;
  return e.slice(n).concat(e.slice(0, n));
}
function jC(e, t) {
  const n = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    const s = t(r);
    let i = n.get(s);
    n.has(s) || (i = [], n.set(s, i)), i.push(r);
  }), n;
}
function WC(e) {
  return Array.isArray(e) ? e : [e];
}
function Rt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ws;
var ra;
function kc() {
  if (ra) return Ws;
  ra = 1;
  var e = function(t) {
    if (t = t || {}, this.Promise = t.Promise || Promise, this.queues = /* @__PURE__ */ Object.create(null), this.domainReentrant = t.domainReentrant || false, this.domainReentrant) {
      if (typeof process > "u" || typeof process.domain > "u")
        throw new Error(
          "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
        );
      this.domains = /* @__PURE__ */ Object.create(null);
    }
    this.timeout = t.timeout || e.DEFAULT_TIMEOUT, this.maxOccupationTime = t.maxOccupationTime || e.DEFAULT_MAX_OCCUPATION_TIME, this.maxExecutionTime = t.maxExecutionTime || e.DEFAULT_MAX_EXECUTION_TIME, t.maxPending === 1 / 0 || Number.isInteger(t.maxPending) && t.maxPending >= 0 ? this.maxPending = t.maxPending : this.maxPending = e.DEFAULT_MAX_PENDING;
  };
  return e.DEFAULT_TIMEOUT = 0, e.DEFAULT_MAX_OCCUPATION_TIME = 0, e.DEFAULT_MAX_EXECUTION_TIME = 0, e.DEFAULT_MAX_PENDING = 1e3, e.prototype.acquire = function(t, n, r, s) {
    if (Array.isArray(t))
      return this._acquireBatch(t, n, r, s);
    if (typeof n != "function")
      throw new Error("You must pass a function to execute");
    var i = null, o = null, a = null;
    typeof r != "function" && (s = r, r = null, a = new this.Promise(function(P, W) {
      i = P, o = W;
    })), s = s || {};
    var l = false, u = null, c = null, h = null, d = this, f = function(P, W, w) {
      c && (clearTimeout(c), c = null), h && (clearTimeout(h), h = null), P && (d.queues[t] && d.queues[t].length === 0 && delete d.queues[t], d.domainReentrant && delete d.domains[t]), l || (a ? W ? o(W) : i(w) : typeof r == "function" && r(W, w), l = true), P && d.queues[t] && d.queues[t].length > 0 && d.queues[t].shift()();
    }, g = function(P) {
      if (l)
        return f(P);
      u && (clearTimeout(u), u = null), d.domainReentrant && P && (d.domains[t] = process.domain);
      var W = s.maxExecutionTime || d.maxExecutionTime;
      if (W && (h = setTimeout(function() {
        d.queues[t] && f(P, new Error("Maximum execution time is exceeded " + t));
      }, W)), n.length === 1) {
        var w = false;
        try {
          n(function(C, v) {
            w || (w = true, f(P, C, v));
          });
        } catch (C) {
          w || (w = true, f(P, C));
        }
      } else
        d._promiseTry(function() {
          return n();
        }).then(function(C) {
          f(P, void 0, C);
        }, function(C) {
          f(P, C);
        });
    };
    d.domainReentrant && process.domain && (g = process.domain.bind(g));
    var _ = s.maxPending || d.maxPending;
    if (!d.queues[t])
      d.queues[t] = [], g(true);
    else if (d.domainReentrant && process.domain && process.domain === d.domains[t])
      g(false);
    else if (d.queues[t].length >= _)
      f(false, new Error("Too many pending tasks in queue " + t));
    else {
      var R = function() {
        g(true);
      };
      s.skipQueue ? d.queues[t].unshift(R) : d.queues[t].push(R);
      var b = s.timeout || d.timeout;
      b && (u = setTimeout(function() {
        u = null, f(false, new Error("async-lock timed out in queue " + t));
      }, b));
    }
    var H = s.maxOccupationTime || d.maxOccupationTime;
    if (H && (c = setTimeout(function() {
      d.queues[t] && f(false, new Error("Maximum occupation time is exceeded in queue " + t));
    }, H)), a)
      return a;
  }, e.prototype._acquireBatch = function(t, n, r, s) {
    typeof r != "function" && (s = r, r = null);
    var i = this, o = function(l, u) {
      return function(c) {
        i.acquire(l, u, c, s);
      };
    }, a = t.reduceRight(function(l, u) {
      return o(u, l);
    }, n);
    if (typeof r == "function")
      a(r);
    else
      return new this.Promise(function(l, u) {
        a.length === 1 ? a(function(c, h) {
          c ? u(c) : l(h);
        }) : l(a());
      });
  }, e.prototype.isBusy = function(t) {
    return t ? !!this.queues[t] : Object.keys(this.queues).length > 0;
  }, e.prototype._promiseTry = function(t) {
    try {
      return this.Promise.resolve(t());
    } catch (n) {
      return this.Promise.reject(n);
    }
  }, Ws = e, Ws;
}
var Ys;
var sa;
function Pc() {
  return sa || (sa = 1, Ys = kc()), Ys;
}
var Fc = Pc();
var YC = Rt(Fc);
var $c = /* @__PURE__ */ new Set(["true", "false"]);
function zC(e) {
  return $c.has(e.toLowerCase());
}
var Ar = "__INTERNAL_EDITOR__";
var Dl = `${Ar}DOCS_NORMAL`;
var Ul = `${Ar}DOCS_FORMULA_BAR`;
var Hc = `${Ar}ZEN_EDITOR`;
var Bc = `\r
`;
var jc = "isRowStylePrecedeColumnStyle";
var Wc = Symbol("AUTO_HEIGHT_FOR_MERGED_CELLS");
function VC(e) {
  return `${Ar}${e}`;
}
function Yc(e) {
  return e.startsWith(Ar);
}
function GC(e, t) {
  t.forEach((n) => e.add(n));
}
function zc(e, t) {
  t.forEach(([n]) => {
    e.has(n) && e.get(n);
  });
}
function Vc(e, t) {
  if (Object.is(e, t))
    return true;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return false;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return false;
  const s = Object.prototype.hasOwnProperty.bind(t);
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (!s(o))
      return false;
    const a = e[o], l = t[o];
    if (a !== l)
      return false;
  }
  return true;
}
var _i = class extends Error {
  constructor(t) {
    super(t), this.name = "CustomCommandExecutionError";
  }
};
var KC = class extends _i {
  constructor() {
    super("Canceled by facade"), this.name = "CanceledError";
  }
};
function XC(e, t = 16) {
  let n = 0, r = null;
  return function(...i) {
    const o = Date.now();
    o - n < t ? (r && clearTimeout(r), r = setTimeout(() => {
      n = o, e.apply(this, i);
    }, t)) : (n = o, e.apply(this, i));
  };
}
var sr = ((e) => (e[e.Style = 1] = "Style", e[e.Value = 2] = "Value", e))(sr || {});
function qC(e) {
  return `sheet_interceptor_${e}`;
}
var Gc = (e) => function(t, n) {
  let r = -1, s = t;
  for (let i = 0; i <= e.length; i++) {
    if (i <= r)
      throw new Error("[SheetInterceptorService]: next() called multiple times!");
    if (r = i, i === e.length)
      return s;
    const o = e[i];
    let a = false;
    if (s = o.handler(s, n, (l) => (a = true, l)), !a)
      break;
  }
  return s;
};
var ZC = class {
  constructor(t) {
    p(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    p(this, "_interceptorPoints");
    this._interceptorPoints = t;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughInterceptors(t, n) {
    const r = t;
    let s = this._interceptorsByName.get(r);
    return n && (s = s.filter(n)), Gc(s || []);
  }
  intercept(t, n) {
    const r = t;
    this._interceptorsByName.has(r) || this._interceptorsByName.set(r, []);
    const s = this._interceptorsByName.get(r);
    return s.push(n), this._interceptorsByName.set(
      r,
      s.sort((i, o) => {
        var a, l;
        return ((a = o.priority) != null ? a : 0) - ((l = i.priority) != null ? l : 0);
      })
      // from large to small
    ), () => Os(this._interceptorsByName.get(r), n);
  }
  getInterceptPoints() {
    return this._interceptorPoints;
  }
  dispose() {
    this._interceptorsByName.clear();
  }
};
function JC(e) {
  return `sheet_async_interceptor_${e}`;
}
var Kc = (e) => async function(t, n) {
  let r = -1, s = t;
  for (let i = 0; i <= e.length; i++) {
    if (i <= r)
      throw new Error("[SheetInterceptorService]: next() called multiple times!");
    if (r = i, i === e.length)
      return s;
    const o = e[i];
    let a = false;
    if (s = await o.handler(s, n, async (l) => (a = true, l)), !a)
      break;
  }
  return s;
};
var QC = class {
  constructor(t) {
    p(this, "_asyncInterceptorsByName", /* @__PURE__ */ new Map());
    p(this, "_asyncInterceptorPoints");
    this._asyncInterceptorPoints = t;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughAsyncInterceptors(t, n) {
    const r = t;
    let s = this._asyncInterceptorsByName.get(r);
    return n && (s = s.filter(n)), Kc(s || []);
  }
  async interceptAsync(t, n) {
    const r = t;
    this._asyncInterceptorsByName.has(r) || this._asyncInterceptorsByName.set(r, []);
    const s = this._asyncInterceptorsByName.get(r);
    return s.push(n), this._asyncInterceptorsByName.set(
      r,
      s.sort((i, o) => {
        var a, l;
        return ((a = o.priority) != null ? a : 0) - ((l = i.priority) != null ? l : 0);
      })
      // from large to small
    ), () => Os(this._asyncInterceptorsByName.get(r), n);
  }
  getInterceptPoints() {
    return this._asyncInterceptorPoints;
  }
  dispose() {
    this._asyncInterceptorsByName.clear();
  }
};
function kl(e) {
  return e.map((t) => t / 255);
}
function Pl(e) {
  return e.map((t) => Math.round(t * 255));
}
function Xc([e, t, n]) {
  const r = Math.max(e, t, n), s = Math.min(e, t, n), i = (r + s) / 2;
  let o = 0, a = 0;
  if (r !== s) {
    const l = r - s;
    switch (a = i > 0.5 ? l / (2 - r - s) : l / (r + s), r) {
      case e:
        o = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        o = (n - e) / l + 2;
        break;
      case n:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return [o, a, i];
}
function ds(e, t, n) {
  const r = [e, t, n].map((s) => s <= 0.03928 ? s / 12.92 : ((s + 0.055) / 1.055) ** 2.4);
  return 0.2126 * r[0] + 0.7152 * r[1] + 0.0722 * r[2];
}
function ia(e, t) {
  return (Math.max(e, t) + 0.05) / (Math.min(e, t) + 0.05);
}
function qc(e, t, n) {
  let r, s, i;
  if (t === 0)
    r = s = i = n;
  else {
    const o = (u, c, h) => {
      let d = h;
      return d < 0 && (d += 1), d > 1 && (d -= 1), d < 0.16666666666666666 ? u + (c - u) * 6 * d : d < 0.5 ? c : d < 0.6666666666666666 ? u + (c - u) * (0.6666666666666666 - d) * 6 : u;
    }, a = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
    r = o(l, a, e + 1 / 3), s = o(l, a, e), i = o(l, a, e - 1 / 3);
  }
  return [r, s, i];
}
var zs = { r: 1, g: 1, b: 1 };
var Vs = { r: 0, g: 0, b: 0 };
var Zc = ds(zs.r, zs.g, zs.b);
var Jc = ds(Vs.r, Vs.g, Vs.b);
function Qc(e) {
  const t = ds(e[0], e[1], e[2]), n = ia(
    Zc,
    t
  ), r = Xc(e);
  let s = 1 - r[2], i, o, a;
  do
    i = qc(r[0], r[1], s), o = ds(i[0], i[1], i[2]), a = ia(o, Jc), s += 0.01;
  while (s <= 1 && s >= 0 && Math.abs(a - n) < 0.01);
  return i;
}
function e1(e) {
  return Pl(Qc(kl(e)));
}
var mt = [
  [0.333, -0.667, -0.667, 0, 1],
  [-0.667, 0.333, -0.667, 0, 1],
  [-0.667, -0.667, 0.333, 0, 1],
  [0, 0, 0, 1, 0]
];
function eh(e) {
  const t = e[0], n = e[1], r = e[2];
  let s = [
    mt[0][0] * t + mt[0][1] * n + mt[0][2] * r + mt[0][4],
    mt[1][0] * t + mt[1][1] * n + mt[1][2] * r + mt[1][4],
    mt[2][0] * t + mt[2][1] * n + mt[2][2] * r + mt[2][4]
  ];
  return s = s.map((i) => i > 1 ? 1 : i < 0 ? 0 : i), s;
}
function t1(e) {
  return Pl(eh(kl(e)));
}
var Fl = typeof global == "object" && global && global.Object === Object && global;
var th = typeof self == "object" && self && self.Object === Object && self;
var Cn = Fl || th || Function("return this")();
var $n = Cn.Symbol;
var $l = Object.prototype;
var nh = $l.hasOwnProperty;
var rh = $l.toString;
var qn = $n ? $n.toStringTag : void 0;
function sh(e) {
  var t = nh.call(e, qn), n = e[qn];
  try {
    e[qn] = void 0;
    var r = true;
  } catch {
  }
  var s = rh.call(e);
  return r && (t ? e[qn] = n : delete e[qn]), s;
}
var ih = Object.prototype;
var oh = ih.toString;
function ah(e) {
  return oh.call(e);
}
var lh = "[object Null]";
var uh = "[object Undefined]";
var oa = $n ? $n.toStringTag : void 0;
function yr(e) {
  return e == null ? e === void 0 ? uh : lh : oa && oa in Object(e) ? sh(e) : ah(e);
}
function zn(e) {
  return e != null && typeof e == "object";
}
var ch = "[object Symbol]";
function vs(e) {
  return typeof e == "symbol" || zn(e) && yr(e) == ch;
}
function hh(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, s = Array(r); ++n < r; )
    s[n] = t(e[n], n, e);
  return s;
}
var Hn = Array.isArray;
var aa = $n ? $n.prototype : void 0;
var la = aa ? aa.toString : void 0;
function Hl(e) {
  if (typeof e == "string")
    return e;
  if (Hn(e))
    return hh(e, Hl) + "";
  if (vs(e))
    return la ? la.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var dh = /\s/;
function fh(e) {
  for (var t = e.length; t-- && dh.test(e.charAt(t)); )
    ;
  return t;
}
var mh = /^\s+/;
function gh(e) {
  return e && e.slice(0, fh(e) + 1).replace(mh, "");
}
function Ct(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var ua = NaN;
var _h = /^[-+]0x[0-9a-f]+$/i;
var ph = /^0b[01]+$/i;
var Eh = /^0o[0-7]+$/i;
var Ch = parseInt;
function ca(e) {
  if (typeof e == "number")
    return e;
  if (vs(e))
    return ua;
  if (Ct(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ct(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = gh(e);
  var n = ph.test(e);
  return n || Eh.test(e) ? Ch(e.slice(2), n ? 2 : 8) : _h.test(e) ? ua : +e;
}
function Bl(e) {
  return e;
}
var Rh = "[object AsyncFunction]";
var Ih = "[object Function]";
var wh = "[object GeneratorFunction]";
var Sh = "[object Proxy]";
function Qi(e) {
  if (!Ct(e))
    return false;
  var t = yr(e);
  return t == Ih || t == wh || t == Rh || t == Sh;
}
var Gs = Cn["__core-js_shared__"];
var ha = function() {
  var e = /[^.]+$/.exec(Gs && Gs.keys && Gs.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Oh(e) {
  return !!ha && ha in e;
}
var vh = Function.prototype;
var bh = vh.toString;
function Ah(e) {
  if (e != null) {
    try {
      return bh.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var yh = /[\\^$.*+?()[\]{}|]/g;
var Nh = /^\[object .+?Constructor\]$/;
var Th = Function.prototype;
var Mh = Object.prototype;
var Lh = Th.toString;
var xh = Mh.hasOwnProperty;
var Dh = RegExp(
  "^" + Lh.call(xh).replace(yh, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Uh(e) {
  if (!Ct(e) || Oh(e))
    return false;
  var t = Qi(e) ? Dh : Nh;
  return t.test(Ah(e));
}
function kh(e, t) {
  return e == null ? void 0 : e[t];
}
function eo(e, t) {
  var n = kh(e, t);
  return Uh(n) ? n : void 0;
}
var da = Object.create;
var Ph = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Ct(t))
      return {};
    if (da)
      return da(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function Fh(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function $h(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var Hh = 800;
var Bh = 16;
var jh = Date.now;
function Wh(e) {
  var t = 0, n = 0;
  return function() {
    var r = jh(), s = Bh - (r - n);
    if (n = r, s > 0) {
      if (++t >= Hh)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function Yh(e) {
  return function() {
    return e;
  };
}
var fs = function() {
  try {
    var e = eo(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
var zh = fs ? function(e, t) {
  return fs(e, "toString", {
    configurable: true,
    enumerable: false,
    value: Yh(t),
    writable: true
  });
} : Bl;
var Vh = Wh(zh);
var Gh = 9007199254740991;
var Kh = /^(?:0|[1-9]\d*)$/;
function to(e, t) {
  var n = typeof e;
  return t = t == null ? Gh : t, !!t && (n == "number" || n != "symbol" && Kh.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function no(e, t, n) {
  t == "__proto__" && fs ? fs(e, t, {
    configurable: true,
    enumerable: true,
    value: n,
    writable: true
  }) : e[t] = n;
}
function bs(e, t) {
  return e === t || e !== e && t !== t;
}
var Xh = Object.prototype;
var qh = Xh.hasOwnProperty;
function jl(e, t, n) {
  var r = e[t];
  (!(qh.call(e, t) && bs(r, n)) || n === void 0 && !(t in e)) && no(e, t, n);
}
function Zh(e, t, n, r) {
  var s = !n;
  n || (n = {});
  for (var i = -1, o = t.length; ++i < o; ) {
    var a = t[i], l = void 0;
    l === void 0 && (l = e[a]), s ? no(n, a, l) : jl(n, a, l);
  }
  return n;
}
var fa = Math.max;
function Jh(e, t, n) {
  return t = fa(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, s = -1, i = fa(r.length - t, 0), o = Array(i); ++s < i; )
      o[s] = r[t + s];
    s = -1;
    for (var a = Array(t + 1); ++s < t; )
      a[s] = r[s];
    return a[t] = n(o), Fh(e, this, a);
  };
}
function Qh(e, t) {
  return Vh(Jh(e, t, Bl), e + "");
}
var ed = 9007199254740991;
function Wl(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= ed;
}
function ro(e) {
  return e != null && Wl(e.length) && !Qi(e);
}
function td(e, t, n) {
  if (!Ct(n))
    return false;
  var r = typeof t;
  return (r == "number" ? ro(n) && to(t, n.length) : r == "string" && t in n) ? bs(n[t], e) : false;
}
function Yl(e) {
  return Qh(function(t, n) {
    var r = -1, s = n.length, i = s > 1 ? n[s - 1] : void 0, o = s > 2 ? n[2] : void 0;
    for (i = e.length > 3 && typeof i == "function" ? (s--, i) : void 0, o && td(n[0], n[1], o) && (i = s < 3 ? void 0 : i, s = 1), t = Object(t); ++r < s; ) {
      var a = n[r];
      a && e(t, a, r, i);
    }
    return t;
  });
}
var nd = Object.prototype;
function zl(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || nd;
  return e === n;
}
function rd(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var sd = "[object Arguments]";
function ma(e) {
  return zn(e) && yr(e) == sd;
}
var Vl = Object.prototype;
var id = Vl.hasOwnProperty;
var od = Vl.propertyIsEnumerable;
var pi = ma(/* @__PURE__ */ function() {
  return arguments;
}()) ? ma : function(e) {
  return zn(e) && id.call(e, "callee") && !od.call(e, "callee");
};
function ad() {
  return false;
}
var Gl = typeof exports == "object" && exports && !exports.nodeType && exports;
var ga = Gl && typeof module == "object" && module && !module.nodeType && module;
var ld = ga && ga.exports === Gl;
var _a = ld ? Cn.Buffer : void 0;
var ud = _a ? _a.isBuffer : void 0;
var Kl = ud || ad;
var cd = "[object Arguments]";
var hd = "[object Array]";
var dd = "[object Boolean]";
var fd = "[object Date]";
var md = "[object Error]";
var gd = "[object Function]";
var _d = "[object Map]";
var pd = "[object Number]";
var Ed = "[object Object]";
var Cd = "[object RegExp]";
var Rd = "[object Set]";
var Id = "[object String]";
var wd = "[object WeakMap]";
var Sd = "[object ArrayBuffer]";
var Od = "[object DataView]";
var vd = "[object Float32Array]";
var bd = "[object Float64Array]";
var Ad = "[object Int8Array]";
var yd = "[object Int16Array]";
var Nd = "[object Int32Array]";
var Td = "[object Uint8Array]";
var Md = "[object Uint8ClampedArray]";
var Ld = "[object Uint16Array]";
var xd = "[object Uint32Array]";
var Ue = {};
Ue[vd] = Ue[bd] = Ue[Ad] = Ue[yd] = Ue[Nd] = Ue[Td] = Ue[Md] = Ue[Ld] = Ue[xd] = true;
Ue[cd] = Ue[hd] = Ue[Sd] = Ue[dd] = Ue[Od] = Ue[fd] = Ue[md] = Ue[gd] = Ue[_d] = Ue[pd] = Ue[Ed] = Ue[Cd] = Ue[Rd] = Ue[Id] = Ue[wd] = false;
function Dd(e) {
  return zn(e) && Wl(e.length) && !!Ue[yr(e)];
}
function Ud(e) {
  return function(t) {
    return e(t);
  };
}
var Xl = typeof exports == "object" && exports && !exports.nodeType && exports;
var _r = Xl && typeof module == "object" && module && !module.nodeType && module;
var kd = _r && _r.exports === Xl;
var Ks = kd && Fl.process;
var pa = function() {
  try {
    var e = _r && _r.require && _r.require("util").types;
    return e || Ks && Ks.binding && Ks.binding("util");
  } catch {
  }
}();
var Ea = pa && pa.isTypedArray;
var ql = Ea ? Ud(Ea) : Dd;
function Pd(e, t) {
  var n = Hn(e), r = !n && pi(e), s = !n && !r && Kl(e), i = !n && !r && !s && ql(e), o = n || r || s || i, a = o ? rd(e.length, String) : [], l = a.length;
  for (var u in e)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    to(u, l)) || a.push(u);
  return a;
}
function Fd(e, t) {
  return function(n) {
    return e(t(n));
  };
}
function $d(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var Hd = Object.prototype;
var Bd = Hd.hasOwnProperty;
function jd(e) {
  if (!Ct(e))
    return $d(e);
  var t = zl(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !Bd.call(e, r)) || n.push(r);
  return n;
}
function Zl(e) {
  return ro(e) ? Pd(e) : jd(e);
}
var Wd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Yd = /^\w*$/;
function zd(e, t) {
  if (Hn(e))
    return false;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || vs(e) ? true : Yd.test(e) || !Wd.test(e) || t != null && e in Object(t);
}
var Ir = eo(Object, "create");
function Vd() {
  this.__data__ = Ir ? Ir(null) : {}, this.size = 0;
}
function Gd(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Kd = "__lodash_hash_undefined__";
var Xd = Object.prototype;
var qd = Xd.hasOwnProperty;
function Zd(e) {
  var t = this.__data__;
  if (Ir) {
    var n = t[e];
    return n === Kd ? void 0 : n;
  }
  return qd.call(t, e) ? t[e] : void 0;
}
var Jd = Object.prototype;
var Qd = Jd.hasOwnProperty;
function ef(e) {
  var t = this.__data__;
  return Ir ? t[e] !== void 0 : Qd.call(t, e);
}
var tf = "__lodash_hash_undefined__";
function nf(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Ir && t === void 0 ? tf : t, this;
}
function _n(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
_n.prototype.clear = Vd;
_n.prototype.delete = Gd;
_n.prototype.get = Zd;
_n.prototype.has = ef;
_n.prototype.set = nf;
function rf() {
  this.__data__ = [], this.size = 0;
}
function As(e, t) {
  for (var n = e.length; n--; )
    if (bs(e[n][0], t))
      return n;
  return -1;
}
var sf = Array.prototype;
var of2 = sf.splice;
function af(e) {
  var t = this.__data__, n = As(t, e);
  if (n < 0)
    return false;
  var r = t.length - 1;
  return n == r ? t.pop() : of2.call(t, n, 1), --this.size, true;
}
function lf(e) {
  var t = this.__data__, n = As(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function uf(e) {
  return As(this.__data__, e) > -1;
}
function cf(e, t) {
  var n = this.__data__, r = As(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Vt(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Vt.prototype.clear = rf;
Vt.prototype.delete = af;
Vt.prototype.get = lf;
Vt.prototype.has = uf;
Vt.prototype.set = cf;
var Jl = eo(Cn, "Map");
function hf() {
  this.size = 0, this.__data__ = {
    hash: new _n(),
    map: new (Jl || Vt)(),
    string: new _n()
  };
}
function df(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function ys(e, t) {
  var n = e.__data__;
  return df(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function ff(e) {
  var t = ys(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function mf(e) {
  return ys(this, e).get(e);
}
function gf(e) {
  return ys(this, e).has(e);
}
function _f(e, t) {
  var n = ys(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function en(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
en.prototype.clear = hf;
en.prototype.delete = ff;
en.prototype.get = mf;
en.prototype.has = gf;
en.prototype.set = _f;
var pf = "Expected a function";
function so(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(pf);
  var n = function() {
    var r = arguments, s = t ? t.apply(this, r) : r[0], i = n.cache;
    if (i.has(s))
      return i.get(s);
    var o = e.apply(this, r);
    return n.cache = i.set(s, o) || i, o;
  };
  return n.cache = new (so.Cache || en)(), n;
}
so.Cache = en;
var Ef = 500;
function Cf(e) {
  var t = so(e, function(r) {
    return n.size === Ef && n.clear(), r;
  }), n = t.cache;
  return t;
}
var Rf = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var If = /\\(\\)?/g;
var wf = Cf(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Rf, function(n, r, s, i) {
    t.push(s ? i.replace(If, "$1") : r || n);
  }), t;
});
function Sf(e) {
  return e == null ? "" : Hl(e);
}
function Ql(e, t) {
  return Hn(e) ? e : zd(e, t) ? [e] : wf(Sf(e));
}
function eu(e) {
  if (typeof e == "string" || vs(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function Of(e, t) {
  t = Ql(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[eu(t[n++])];
  return n && n == r ? e : void 0;
}
function vf(e, t, n) {
  var r = e == null ? void 0 : Of(e, t);
  return r === void 0 ? n : r;
}
var tu = Fd(Object.getPrototypeOf, Object);
var bf = "[object Object]";
var Af = Function.prototype;
var yf = Object.prototype;
var nu = Af.toString;
var Nf = yf.hasOwnProperty;
var Tf = nu.call(Object);
function Mf(e) {
  if (!zn(e) || yr(e) != bf)
    return false;
  var t = tu(e);
  if (t === null)
    return true;
  var n = Nf.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && nu.call(n) == Tf;
}
function Lf() {
  this.__data__ = new Vt(), this.size = 0;
}
function xf(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function Df(e) {
  return this.__data__.get(e);
}
function Uf(e) {
  return this.__data__.has(e);
}
var kf = 200;
function Pf(e, t) {
  var n = this.__data__;
  if (n instanceof Vt) {
    var r = n.__data__;
    if (!Jl || r.length < kf - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new en(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Vn(e) {
  var t = this.__data__ = new Vt(e);
  this.size = t.size;
}
Vn.prototype.clear = Lf;
Vn.prototype.delete = xf;
Vn.prototype.get = Df;
Vn.prototype.has = Uf;
Vn.prototype.set = Pf;
var ru = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ca = ru && typeof module == "object" && module && !module.nodeType && module;
var Ff = Ca && Ca.exports === ru;
var Ra = Ff ? Cn.Buffer : void 0;
Ra && Ra.allocUnsafe;
function $f(e, t) {
  return e.slice();
}
var Ia = Cn.Uint8Array;
function Hf(e) {
  var t = new e.constructor(e.byteLength);
  return new Ia(t).set(new Ia(e)), t;
}
function Bf(e, t) {
  var n = Hf(e.buffer);
  return new e.constructor(n, e.byteOffset, e.length);
}
function jf(e) {
  return typeof e.constructor == "function" && !zl(e) ? Ph(tu(e)) : {};
}
function Wf(e) {
  return function(t, n, r) {
    for (var s = -1, i = Object(t), o = r(t), a = o.length; a--; ) {
      var l = o[++s];
      if (n(i[l], l, i) === false)
        break;
    }
    return t;
  };
}
var Yf = Wf();
var Xs = function() {
  return Cn.Date.now();
};
var zf = "Expected a function";
var Vf = Math.max;
var Gf = Math.min;
function n1(e, t, n) {
  var r, s, i, o, a, l, u = 0, c = false, h = false, d = true;
  if (typeof e != "function")
    throw new TypeError(zf);
  t = ca(t) || 0, Ct(n) && (c = !!n.leading, h = "maxWait" in n, i = h ? Vf(ca(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function f(C) {
    var v = r, y = s;
    return r = s = void 0, u = C, o = e.apply(y, v), o;
  }
  function g(C) {
    return u = C, a = setTimeout(b, t), c ? f(C) : o;
  }
  function _(C) {
    var v = C - l, y = C - u, F2 = t - v;
    return h ? Gf(F2, i - y) : F2;
  }
  function R(C) {
    var v = C - l, y = C - u;
    return l === void 0 || v >= t || v < 0 || h && y >= i;
  }
  function b() {
    var C = Xs();
    if (R(C))
      return H(C);
    a = setTimeout(b, _(C));
  }
  function H(C) {
    return a = void 0, d && r ? f(C) : (r = s = void 0, o);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = s = a = void 0;
  }
  function W() {
    return a === void 0 ? o : H(Xs());
  }
  function w() {
    var C = Xs(), v = R(C);
    if (r = arguments, s = this, l = C, v) {
      if (a === void 0)
        return g(l);
      if (h)
        return clearTimeout(a), a = setTimeout(b, t), f(l);
    }
    return a === void 0 && (a = setTimeout(b, t)), o;
  }
  return w.cancel = P, w.flush = W, w;
}
function Ei(e, t, n) {
  (n !== void 0 && !bs(e[t], n) || n === void 0 && !(t in e)) && no(e, t, n);
}
function Kf(e) {
  return zn(e) && ro(e);
}
function Ci(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Xf(e) {
  return Zh(e, Zl(e));
}
function qf(e, t, n, r, s, i, o) {
  var a = Ci(e, n), l = Ci(t, n), u = o.get(l);
  if (u) {
    Ei(e, n, u);
    return;
  }
  var c = i ? i(a, l, n + "", e, t, o) : void 0, h = c === void 0;
  if (h) {
    var d = Hn(l), f = !d && Kl(l), g = !d && !f && ql(l);
    c = l, d || f || g ? Hn(a) ? c = a : Kf(a) ? c = $h(a) : f ? (h = false, c = $f(l)) : g ? (h = false, c = Bf(l)) : c = [] : Mf(l) || pi(l) ? (c = a, pi(a) ? c = Xf(a) : (!Ct(a) || Qi(a)) && (c = jf(l))) : h = false;
  }
  h && (o.set(l, c), s(c, l, r, i, o), o.delete(l)), Ei(e, n, c);
}
function io(e, t, n, r, s) {
  e !== t && Yf(t, function(i, o) {
    if (s || (s = new Vn()), Ct(i))
      qf(e, t, o, n, io, r, s);
    else {
      var a = r ? r(Ci(e, o), i, o + "", e, t, s) : void 0;
      a === void 0 && (a = i), Ei(e, o, a);
    }
  }, Zl);
}
var r1 = Yl(function(e, t, n, r) {
  io(e, t, n, r);
});
var oo = Yl(function(e, t, n) {
  io(e, t, n);
});
function Zf(e, t, n, r) {
  if (!Ct(e))
    return e;
  t = Ql(t, e);
  for (var s = -1, i = t.length, o = i - 1, a = e; a != null && ++s < i; ) {
    var l = eu(t[s]), u = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (s != o) {
      var c = a[l];
      u = void 0, u === void 0 && (u = Ct(c) ? c : to(t[s + 1]) ? [] : {});
    }
    jl(a, l, u), a = a[l];
  }
  return e;
}
function s1(e, t, n) {
  return e == null ? e : Zf(e, t, n);
}
var Gn = class {
  constructor() {
    p(this, "cursor", 0);
  }
  reset() {
    return this.cursor = 0, this;
  }
  moveCursor(t) {
    this.cursor += t;
  }
  moveCursorTo(t) {
    this.cursor = t;
  }
};
function i1(e, t) {
  for (const n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
}
function Jf(e) {
  return /^-?\d+(\.\d+)?$/.test(e);
}
function o1(e) {
  return Jf(e) ? Number(e) <= Number.MAX_SAFE_INTEGER : false;
}
function a1(e) {
  return Number(e) > Number.MAX_SAFE_INTEGER || e.length >= 18;
}
var su = class _su {
  constructor() {
    p(this, "_data", []);
  }
  static create() {
    return new _su();
  }
  add(t) {
    this._data.indexOf(t) > -1 || this._data.push(t);
  }
  delete(t) {
    const n = this._data.indexOf(t);
    this._data.splice(n, 1);
  }
  getData() {
    return this._data;
  }
};
var iu = class _iu {
  constructor() {
    p(this, "_data", /* @__PURE__ */ new Map());
  }
  static create() {
    return new _iu();
  }
  add(t, n) {
    this._data.has(t) || this._data.set(t, n);
  }
  delete(t) {
    this._data.delete(t);
  }
  getData() {
    return this._data;
  }
};
function l1(e) {
  const t = new MessageChannel();
  let n = false;
  const r = () => {
    n || e();
  };
  return t.port1.onmessage = r, t.port2.postMessage(null), () => {
    n = true, t.port1.onmessage = null, t.port1.close(), t.port2.close();
  };
}
async function Qf(e) {
  for (const [t, n] of e.entries())
    try {
      if (!await n())
        return {
          index: t,
          result: false
        };
    } catch (r) {
      return {
        index: t,
        result: false,
        error: r
      };
    }
  return {
    result: true,
    index: -1
  };
}
function em(e) {
  for (const [t, n] of e.entries())
    try {
      if (!n())
        return {
          index: t,
          result: false
        };
    } catch (r) {
      return {
        index: t,
        result: false,
        error: r
      };
    }
  return {
    result: true,
    index: -1
  };
}
function u1(e, t) {
  return t.forEach((n) => e.add(n)), e;
}
function tm(e) {
  return e instanceof Subscription || e instanceof Subject || e && "closed" in e && typeof e.unsubscribe < "u";
}
function We(e) {
  let t = false;
  return e ? tm(e) ? {
    dispose: () => e.unsubscribe()
  } : typeof e == "function" ? {
    dispose: () => {
      t || (t = true, e());
    }
  } : e : We(() => {
  });
}
function c1(e) {
  return We(() => {
    e.unsubscribe();
  });
}
var ao = class {
  constructor() {
    p(this, "_disposables", /* @__PURE__ */ new Set());
  }
  add(t) {
    const n = We(t);
    return this._disposables.add(n), {
      dispose: (r = false) => {
        r || n.dispose(), this._disposables.delete(n);
      }
    };
  }
  dispose() {
    this._disposables.forEach((t) => {
      t.dispose();
    }), this._disposables.clear();
  }
};
var Ve = class {
  constructor() {
    p(this, "_disposed", false);
    p(this, "_collection", new ao());
  }
  disposeWithMe(t) {
    return this._collection.add(t);
  }
  ensureNotDisposed() {
    if (this._disposed)
      throw new Error("[Disposable]: object is disposed!");
  }
  dispose() {
    this._disposed || (this._disposed = true, this._collection.dispose());
  }
};
var h1 = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "dispose$", new Subject());
  }
  dispose() {
    super.dispose(), this.dispose$.next(), this.dispose$.complete();
  }
};
var d1 = class extends Ve {
  constructor(n) {
    super();
    p(this, "_ref", 0);
    this._rootDisposable = n;
  }
  inc() {
    if (this._disposed)
      throw new Error("[RCDisposable]: should not ref to a disposed.");
    this._ref += 1;
  }
  dec() {
    this._ref -= 1, this._ref === 0 && (this._rootDisposable.dispose(), this.dispose());
  }
};
var we = ((e) => (e[e.UNIVER_UNKNOWN = 0] = "UNIVER_UNKNOWN", e[e.UNIVER_DOC = 1] = "UNIVER_DOC", e[e.UNIVER_SHEET = 2] = "UNIVER_SHEET", e[e.UNIVER_SLIDE = 3] = "UNIVER_SLIDE", e[e.UNIVER_PROJECT = 4] = "UNIVER_PROJECT", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(we || {});
var xt = ((e) => (e[e.Reader = 0] = "Reader", e[e.Editor = 1] = "Editor", e[e.Owner = 2] = "Owner", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(xt || {});
var Ri = ((e) => (e[e.SomeCollaborator = 0] = "SomeCollaborator", e[e.AllCollaborator = 1] = "AllCollaborator", e[e.OneSelf = 2] = "OneSelf", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(Ri || {});
var lo = class extends Ve {
};
var nm = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var rm = (e) => crypto.getRandomValues(new Uint8Array(e));
var sm = (e, t, n) => {
  let r = (2 << Math.log2(e.length - 1)) - 1, s = -~(1.6 * r * t / e.length);
  return (i = t) => {
    let o = "";
    for (; ; ) {
      let a = n(s), l = s | 0;
      for (; l--; )
        if (o += e[a[l] & r] || "", o.length >= i) return o;
    }
  };
};
var im = (e, t = 21) => sm(e, t | 0, rm);
var om = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += nm[n[e] & 63];
  return t;
};
var ou = /* @__PURE__ */ new Set([
  "ac",
  "ad",
  "ae",
  "aero",
  "af",
  "ag",
  "ai",
  "al",
  "am",
  "ao",
  "aq",
  "ar",
  "arpa",
  "as",
  "asia",
  "at",
  "au",
  "aw",
  "ax",
  "az",
  "ba",
  "bb",
  "bd",
  "be",
  "bf",
  "bg",
  "bh",
  "bi",
  "biz",
  "bj",
  "bm",
  "bn",
  "bo",
  "br",
  "bs",
  "bt",
  "bv",
  "bw",
  "by",
  "bz",
  "ca",
  "cat",
  "cc",
  "cd",
  "cf",
  "cg",
  "ch",
  "ci",
  "ck",
  "cl",
  "cm",
  "cn",
  "co",
  "com",
  "coop",
  "cr",
  "cu",
  "cv",
  "cw",
  "cx",
  "cy",
  "cz",
  "de",
  "dj",
  "dk",
  "dm",
  "do",
  "dz",
  "ec",
  "edu",
  "ee",
  "eg",
  "er",
  "es",
  "et",
  "eu",
  "fi",
  "fj",
  "fk",
  "fm",
  "fo",
  "fr",
  "ga",
  "gb",
  "gd",
  "ge",
  "gf",
  "gg",
  "gh",
  "gi",
  "gl",
  "gm",
  "gn",
  "gov",
  "gp",
  "gq",
  "gr",
  "gs",
  "gt",
  "gu",
  "gw",
  "gy",
  "hk",
  "hm",
  "hn",
  "hr",
  "ht",
  "hu",
  "id",
  "ie",
  "il",
  "im",
  "in",
  "info",
  "int",
  "io",
  "iq",
  "ir",
  "is",
  "it",
  "je",
  "jm",
  "jo",
  "jobs",
  "jp",
  "ke",
  "kg",
  "kh",
  "ki",
  "km",
  "kn",
  "kp",
  "kr",
  "kw",
  "ky",
  "kz",
  "la",
  "lb",
  "lc",
  "li",
  "lk",
  "lr",
  "ls",
  "lt",
  "lu",
  "lv",
  "ly",
  "ma",
  "mc",
  "md",
  "me",
  "mg",
  "mh",
  "mil",
  "mk",
  "ml",
  "mm",
  "mn",
  "mo",
  "mobi",
  "mp",
  "mq",
  "mr",
  "ms",
  "mt",
  "mu",
  "museum",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "name",
  "nc",
  "ne",
  "net",
  "nf",
  "ng",
  "ni",
  "nl",
  "no",
  "np",
  "nr",
  "nu",
  "nz",
  "om",
  "onion",
  "org",
  "pa",
  "pe",
  "pf",
  "pg",
  "ph",
  "pk",
  "pl",
  "pm",
  "pn",
  "post",
  "pr",
  "pro",
  "ps",
  "pt",
  "pw",
  "py",
  "qa",
  "re",
  "ro",
  "rs",
  "ru",
  "rw",
  "sa",
  "sb",
  "sc",
  "sd",
  "se",
  "sg",
  "sh",
  "si",
  "sj",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sr",
  "ss",
  "st",
  "su",
  "sv",
  "sx",
  "sy",
  "sz",
  "tc",
  "td",
  "tel",
  "tf",
  "tg",
  "th",
  "tj",
  "tk",
  "tl",
  "tm",
  "tn",
  "to",
  "tr",
  "tt",
  "tv",
  "tw",
  "tz",
  "ua",
  "ug",
  "uk",
  "us",
  "uy",
  "uz",
  "va",
  "vc",
  "ve",
  "vg",
  "vi",
  "vn",
  "vu",
  "wf",
  "ws",
  "yt",
  "za",
  "zm",
  "zw"
]);
var am = new RegExp(
  "^(?:(?:(?:https?|ftp):)?\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$",
  "i"
);
function lm(e) {
  if (!Number.isNaN(+e))
    return false;
  if (e.startsWith("http://localhost:3002") || e.startsWith("localhost:3002"))
    return true;
  if (am.test(e)) {
    if (au(e))
      return true;
    try {
      const r = new URL(lu(e)).hostname.split(".").pop();
      if (r && ou.has(r))
        return true;
    } catch {
      return false;
    }
  }
  return false;
}
function au(e) {
  return /^[a-zA-Z]+:\/\//.test(e);
}
function um(e) {
  return /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(e);
}
function lu(e) {
  return au(e) ? e : um(e) ? `mailto://${e}` : `https://${e}`;
}
var Xt = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z"
];
function uo(e, t) {
  const n = J.getValueType(e), r = J.getValueType(t);
  return n !== r ? false : J.isArray(e) ? cm(e, t) : J.isObject(e) ? hm(e, t) : J.isDate(e) ? e.getTime() === t.getTime() : J.isRegExp(e) ? e.toString() === t.toString() : e === t;
}
function cm(e, t) {
  if (e.length !== t.length)
    return false;
  for (let n = 0, r = e.length; n < r; n++) {
    const s = e[n], i = t[n];
    if (!uo(s, i))
      return false;
  }
  return true;
}
function hm(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return false;
  for (const s of n) {
    if (!r.includes(s))
      return false;
    const i = e[s], o = t[s];
    if (!uo(i, o))
      return false;
  }
  return true;
}
var J = class _J {
  static deleteNull(t) {
    for (const n in t)
      (t[n] === null || t[n] === void 0) && delete t[n];
    return t;
  }
  static stringAt(t) {
    let n = "", r = t;
    for (; r >= Xt.length; )
      r /= Xt.length, r -= 1, n += Xt[r % Xt.length];
    const s = t % Xt.length;
    return n += Xt[s], n;
  }
  static indexAt(t) {
    let n = 0;
    for (let r = 0; r < t.length - 1; r += 1) {
      const s = t.charCodeAt(r) - 65, i = t.length - 1 - r;
      n += Xt.length ** i + Xt.length * s;
    }
    return n += t.charCodeAt(t.length - 1) - 65, n;
  }
  static deleteBlank(t) {
    return _J.isString(t) ? t.replace(/\s/g, "") : t;
  }
  // eslint-disable-next-line complexity
  static getSystemType() {
    const t = navigator.userAgent, n = navigator.platform === "Win32" || navigator.platform === "Windows", r = navigator.platform === "Mac68K" || navigator.platform === "MacPPC" || navigator.platform === "Macintosh" || navigator.platform === "MacIntel";
    if (r) return "Mac";
    if (navigator.platform === "X11" && !n && !r) return "Unix";
    if (String(navigator.platform).indexOf("Linux") > -1) return "Linux";
    if (n) {
      if (t.indexOf("Windows NT 5.0") > -1 || t.indexOf("Windows 2000") > -1) return "Windows 2000";
      if (t.indexOf("Windows NT 5.1") > -1 || t.indexOf("Windows XP") > -1) return "Windows XP";
      if (t.indexOf("Windows NT 5.2") > -1 || t.indexOf("Windows 2003") > -1) return "Windows 2003";
      if (t.indexOf("Windows NT 6.0") > -1 || t.indexOf("Windows Vista") > -1) return "Windows Vista";
      if (t.indexOf("Windows NT 6.1") > -1 || t.indexOf("Windows 7") > -1) return "Windows 7";
      if (t.indexOf("Windows NT 10") > -1 || t.indexOf("Windows 10") > -1) return "Windows 10";
      if (t.indexOf("Windows NT 11") > -1 || t.indexOf("Windows 11") > -1) return "Windows 11";
    }
    return "Unknown system";
  }
  static getBrowserType() {
    const t = navigator.userAgent, n = t.indexOf("Opera") > -1, r = t.indexOf("compatible") > -1 && t.indexOf("MSIE") > -1 && !n, s = t.indexOf("Trident") > -1 && t.indexOf("rv:11.0") > -1, i = t.indexOf("Edge") > -1, o = t.indexOf("Firefox") > -1, a = t.indexOf("Safari") > -1 && t.indexOf("Chrome") === -1, l = t.indexOf("Chrome") > -1 && t.indexOf("Safari") > -1;
    if (r) {
      new RegExp("MSIE (\\d+\\.\\d+);").test(t);
      const c = Number.parseFloat(RegExp.$1);
      return c === 7 ? "IE7" : c === 8 ? "IE8" : c === 9 ? "IE9" : c === 10 ? "IE10" : "0";
    }
    return o ? "FF" : n ? "Opera" : a ? "Safari" : l ? "Chrome" : i ? "Edge" : s ? "IE11" : "Unknown browser";
  }
  static getClassName(t) {
    return t.constructor.name;
  }
  /** @deprecated This method is deprecated, please use `import { merge } from '@univerjs/core` instead */
  static deepMerge(t, ...n) {
    n.forEach((o) => o && i(o));
    function r(o, a) {
      o.forEach((l, u) => {
        var c, h;
        if (_J.isArray(l)) {
          const d = (c = a[u]) != null ? c : [];
          a[u] = d, r(l, d);
          return;
        }
        if (_J.isObject(l)) {
          const d = (h = a[u]) != null ? h : {};
          a[u] = d, s(l, d);
          return;
        }
        a[u] = l;
      });
    }
    function s(o, a) {
      Object.keys(o).forEach((l) => {
        var c, h;
        const u = o[l];
        if (_J.isObject(u)) {
          const d = (c = a[l]) != null ? c : {};
          a[l] = d, s(u, d);
          return;
        }
        if (_J.isArray(u)) {
          const d = (h = a[l]) != null ? h : [];
          a[l] = d, r(u, d);
          return;
        }
        a[l] = u;
      });
    }
    function i(o) {
      Object.keys(o).forEach((a) => {
        var u, c;
        const l = o[a];
        if (_J.isArray(l)) {
          const h = (u = t[a]) != null ? u : [];
          t[a] = h, r(l, h);
          return;
        }
        if (_J.isObject(l)) {
          const h = (c = t[a]) != null ? c : {};
          t[a] = h, s(l, h);
          return;
        }
        t[a] = l;
      });
    }
    return t;
  }
  static numberFixed(t, n) {
    return Number(Number(t).toFixed(n));
  }
  static diffValue(t, n) {
    return uo(t, n);
  }
  static deepClone(t) {
    if (!this.isDefine(t))
      return t;
    if (this.isRegExp(t))
      return new RegExp(t);
    if (this.isDate(t))
      return new Date(t);
    if (this.isArray(t)) {
      const n = [];
      return t.forEach((r, s) => {
        n[s] = _J.deepClone(r);
      }), n;
    }
    if (this.isObject(t)) {
      const n = {};
      return Object.keys(t).forEach((r) => {
        const s = t[r];
        n[r] = _J.deepClone(s);
      }), Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n;
    }
    return t;
  }
  static getLanguage() {
    const t = "en-US";
    return globalThis.navigator && (navigator.languages && navigator.languages[0] || navigator.language) || t;
  }
  static getValueType(t) {
    return Object.prototype.toString.apply(t);
  }
  static isDefine(t) {
    return t != null;
  }
  static isBlank(t) {
    return this.isDefine(t) ? this.isString(t) ? t.trim() === "" : false : true;
  }
  static isPlainObject(t) {
    return this.isDefine(t) ? Object.getPrototypeOf(t) === Object.getPrototypeOf({}) : false;
  }
  static isDate(t) {
    return this.getValueType(t) === "[object Date]";
  }
  static isRegExp(t) {
    return this.getValueType(t) === "[object RegExp]";
  }
  static isArray(t) {
    return this.getValueType(t) === "[object Array]";
  }
  static isString(t) {
    return this.getValueType(t) === "[object String]";
  }
  static isNumber(t) {
    return this.getValueType(t) === "[object Number]";
  }
  static isStringNumber(t) {
    return !isNaN(Number.parseFloat(t)) && isFinite(t);
  }
  static isObject(t) {
    return this.getValueType(t) === "[object Object]";
  }
  static isEmptyObject(t) {
    for (const n in t)
      return false;
    return true;
  }
  static isTablet() {
    return /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
  }
  static isIPhone() {
    return /iPhone/i.test(navigator.userAgent);
  }
  static isLegalUrl(t) {
    return lm(t);
  }
  static normalizeUrl(t) {
    return lu(t);
  }
  static topLevelDomainCombiningString() {
    return [...ou].join("|");
  }
  /**
   * remove all null from object
   * @param obj
   * @returns
   */
  static removeNull(t) {
    return this.isObject(t) && Object.keys(t).forEach((n) => {
      const r = t[n];
      r == null ? delete t[n] : _J.removeNull(r);
    }), t;
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  static fillTwoDimensionalArray(t, n, r) {
    return new Array(t).fill(r).map((s) => new Array(n).fill(r));
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  // static fillObjectMatrix<T>(rows: number, columns: number, value: T): IObjectMatrixPrimitiveType<T> {
  //     const matrix = new ObjectMatrix<T>();
  //     for (let r = 0; r < rows; r++) {
  //         for (let c = 0; c < columns; c++) {
  //             matrix.setValue(r, c, value);
  //         }
  //     }
  //     return matrix.getData();
  // }
  static numToWord(t) {
    let n = "";
    for (; t > 0; ) {
      let r = t % 26;
      r = r === 0 ? r = 26 : r, n = String.fromCharCode(96 + r) + n, t = (t - r) / 26;
    }
    return n.toLocaleUpperCase();
  }
  /**
   * Column subscript letter to number
   *
   * @param a - Column subscript letter,e.g.,"A1"
   * @returns Column subscript number,e.g.,0
   *
   */
  static ABCatNum(t) {
    if (t == null || t.length === 0)
      return Number.NaN;
    const n = t.toLowerCase().split(""), r = n.length;
    let s = 0, i = 0;
    for (let o = 0; o < r; o++)
      i = n[o].charCodeAt(0) - 96, s += i * 26 ** (r - o - 1);
    return s === 0 ? Number.NaN : s - 1;
  }
  /**
   * Column subscript number to letter
   *
   * @param n Column subscript number,e.g.,0
   * @returns Column subscript letter,e.g.,"A1"
   */
  static chatAtABC(t) {
    let i = "";
    for (; t >= 0; )
      i = String.fromCharCode(t % 26 + 97) + i, t = Math.floor(t / 26) - 1;
    return i.toUpperCase();
  }
  /**
   * extend two objects
   * @param originJson
   * @param extendJson
   * @returns
   */
  static commonExtend(t, n) {
    const r = {};
    for (const s in t)
      r[s] = t[s];
    for (const s in n)
      n[s] != null && (r[s] = n[s]);
    return r;
  }
  static hasIntersectionBetweenTwoRanges(t, n, r, s) {
    return n >= r && s >= t;
  }
  static isStartValidPosition(t) {
    return /^[A-Za-z--_]/.test(t);
  }
  static isValidParameter(t) {
    const n = /[~!@#$%^&*()+=\-{}\[\]\|:;"'<>,?\/ ]+/.test(t), r = t.length <= 255;
    return !n && r;
  }
  static clamp(t, n, r) {
    return Math.max(n, Math.min(r, t));
  }
  static now() {
    return performance && performance.now ? performance.now() : Date.now();
  }
};
function et(e = 21, t) {
  return t ? im(t, e)() : om(e);
}
function xr(...e) {
  const t = {}, n = e.length;
  for (let r = n - 1; r >= 0; r--) {
    const s = e[r];
    if (s) {
      const i = Object.keys(s);
      for (const o of i)
        t[o] === void 0 && (t[o] = s[o]);
    }
  }
  return t;
}
var f1 = () => typeof process < "u" && process.versions != null && process.versions.node != null;
function m1(e) {
  const n = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/\\\*/g, ".*").replace(/\\\?/g, ".");
  return new RegExp(`^${n}$`, "i");
}
var dm = ((e) => (e[e.DEFAULT_SERIES = 0] = "DEFAULT_SERIES", e[e.ALTERNATE_SERIES = 1] = "ALTERNATE_SERIES", e))(dm || {});
var Le = ((e) => (e[e.NONE = 0] = "NONE", e[e.THIN = 1] = "THIN", e[e.HAIR = 2] = "HAIR", e[e.DOTTED = 3] = "DOTTED", e[e.DASHED = 4] = "DASHED", e[e.DASH_DOT = 5] = "DASH_DOT", e[e.DASH_DOT_DOT = 6] = "DASH_DOT_DOT", e[e.DOUBLE = 7] = "DOUBLE", e[e.MEDIUM = 8] = "MEDIUM", e[e.MEDIUM_DASHED = 9] = "MEDIUM_DASHED", e[e.MEDIUM_DASH_DOT = 10] = "MEDIUM_DASH_DOT", e[e.MEDIUM_DASH_DOT_DOT = 11] = "MEDIUM_DASH_DOT_DOT", e[e.SLANT_DASH_DOT = 12] = "SLANT_DASH_DOT", e[e.THICK = 13] = "THICK", e))(Le || {});
var fm = ((e) => (e.TOP = "top", e.BOTTOM = "bottom", e.LEFT = "left", e.RIGHT = "right", e.NONE = "none", e.ALL = "all", e.OUTSIDE = "outside", e.INSIDE = "inside", e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e.TLBR = "tlbr", e.TLBC_TLMR = "tlbc_tlmr", e.TLBR_TLBC_TLMR = "tlbr_tlbc_tlmr", e.BLTR = "bl_tr", e.MLTR_BCTR = "mltr_bctr", e))(fm || {});
var At = ((e) => (e[e.UNSUPPORTED = 0] = "UNSUPPORTED", e[e.RGB = 1] = "RGB", e[e.HEX = 2] = "HEX", e[e.THEME = 3] = "THEME", e))(At || {});
var mm = ((e) => (e[e.ON = 0] = "ON", e[e.OFF = 1] = "OFF", e))(mm || {});
var gm = ((e) => (e[e.PASTE_NORMAL = 0] = "PASTE_NORMAL", e[e.PASTE_NO_BORDERS = 1] = "PASTE_NO_BORDERS", e[e.PASTE_FORMAT = 2] = "PASTE_FORMAT", e[e.PASTE_FORMULA = 3] = "PASTE_FORMULA", e[e.PASTE_DATA_VALIDATION = 4] = "PASTE_DATA_VALIDATION", e[e.PASTE_VALUES = 5] = "PASTE_VALUES", e[e.PASTE_CONDITIONAL_FORMATTING = 6] = "PASTE_CONDITIONAL_FORMATTING", e[e.PASTE_COLUMN_WIDTHS = 7] = "PASTE_COLUMN_WIDTHS", e))(gm || {});
var _m = ((e) => (e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e))(_m || {});
var pm = ((e) => (e[e.DOCUMENT = 0] = "DOCUMENT", e[e.PROJECT = 1] = "PROJECT", e))(pm || {});
var Em = ((e) => (e[e.COLUMNS = 0] = "COLUMNS", e[e.ROWS = 1] = "ROWS", e))(Em || {});
var Cm = ((e) => (e[e.UP = 0] = "UP", e[e.RIGHT = 1] = "RIGHT", e[e.DOWN = 2] = "DOWN", e[e.LEFT = 3] = "LEFT", e))(Cm || {});
function g1(e) {
  switch (e) {
    case 3:
      return 1;
    case 1:
      return 3;
    case 0:
      return 2;
    case 2:
      return 0;
  }
}
var Rm = ((e) => (e[e.INTERPOLATION_POINT_TYPE_UNSPECIFIED = 0] = "INTERPOLATION_POINT_TYPE_UNSPECIFIED", e[e.MIN = 1] = "MIN", e[e.MAX = 2] = "MAX", e[e.NUMBER = 3] = "NUMBER", e[e.PERCENT = 4] = "PERCENT", e[e.PERCENTILE = 5] = "PERCENTILE", e))(Rm || {});
var Ns = ((e) => (e.EN_US = "enUS", e.FR_FR = "frFR", e.ZH_CN = "zhCN", e.RU_RU = "ruRU", e.ZH_TW = "zhTW", e.VI_VN = "viVN", e.FA_IR = "faIR", e.KO_KR = "koKR", e.ES_ES = "esES", e.CA_ES = "caES", e))(Ns || {});
var Ii = ((e) => (e[e.PERSON = 0] = "PERSON", e[e.FILE = 1] = "FILE", e[e.DATE = 2] = "DATE", e[e.LOCATION = 3] = "LOCATION", e[e.EVENT = 4] = "EVENT", e))(Ii || {});
var Im = ((e) => (e[e.RANGE = 0] = "RANGE", e[e.SHEET = 1] = "SHEET", e))(Im || {});
var wm = ((e) => (e.Line = "line", e.LineInv = "lineInv", e.Triangle = "triangle", e.RtTriangle = "rtTriangle", e.Rect = "rect", e.Diamond = "diamond", e.Parallelogram = "parallelogram", e.Trapezoid = "trapezoid", e.NonIsocelesTrapezoid = "nonIsocelesTrapezoid", e.Pentagon = "pentagon", e.Hexagon = "hexagon", e.Heptagon = "heptagon", e.Octagon = "octagon", e.Decagon = "decagon", e.Dodecagon = "dodecagon", e.Star4 = "star4", e.Star5 = "star5", e.Star6 = "star6", e.Star7 = "star7", e.Star8 = "star8", e.Star10 = "star10", e.Star12 = "star12", e.Star16 = "star16", e.Star24 = "star24", e.Star32 = "star32", e.RoundRect = "roundRect", e.Round1Rect = "round1Rect", e.Round2SameRect = "round2SameRect", e.Round2DiagRect = "round2DiagRect", e.Ellipse = "ellipse", e))(wm || {});
var Sm = ((e) => (e.RightArrow = "rightArrow", e.LeftArrow = "leftArrow", e.UpArrow = "upArrow", e.DownArrow = "downArrow", e.LeftRightArrow = "leftRightArrow", e.UpDownArrow = "upDownArrow", e.QuadArrow = "quadArrow", e.LeftRightUpArrow = "leftRightUpArrow", e.BentArrow = "bentArrow", e.UturnArrow = "uturnArrow", e.CircularArrow = "circularArrow", e.NotchedRightArrow = "notchedRightArrow", e.HomePlate = "homePlate", e.Chevron = "chevron", e.LeftCircularArrow = "leftCircularArrow", e.LeftRightCircularArrow = "leftRightCircularArrow", e))(Sm || {});
var Om = ((e) => (e.Plaque = "plaque", e.Can = "can", e.Cube = "cube", e.Bevel = "bevel", e.Donut = "donut", e.NoSmoking = "noSmoking", e.BlockArc = "blockArc", e.FoldedCorner = "foldedCorner", e))(Om || {});
var vm = ((e) => (e.SmileyFace = "smileyFace", e.Heart = "heart", e.LightningBolt = "lightningBolt", e.Sun = "sun", e.Moon = "moon", e.Cloud = "cloud", e.Arc = "arc", e.Backpack = "backpack", e.Frame = "frame", e.HalfFrame = "halfFrame", e.Corner = "corner", e.Chord = "chord", e.Pie = "pie", e.Teardrop = "teardrop", e.WedgeRectCallout = "wedgeRectCallout", e.WedgeRRectCallout = "wedgeRRectCallout", e.WedgeEllipseCallout = "wedgeEllipseCallout", e.CloudCallout = "cloudCallout", e.BorderCallout1 = "borderCallout1", e.BorderCallout2 = "borderCallout2", e.BorderCallout3 = "borderCallout3", e.AccentCallout1 = "accentCallout1", e.AccentCallout2 = "accentCallout2", e.AccentCallout3 = "accentCallout3", e.Callout1 = "callout1", e.Callout2 = "callout2", e.Callout3 = "callout3", e.ActionButtonBackPrevious = "actionButtonBackPrevious", e.ActionButtonEnd = "actionButtonEnd", e.ActionButtonForwardNext = "actionButtonForwardNext", e.ActionButtonHelp = "actionButtonHelp", e.ActionButtonHome = "actionButtonHome", e.ActionButtonInformation = "actionButtonInformation", e.ActionButtonMovie = "actionButtonMovie", e.ActionButtonReturn = "actionButtonReturn", e.ActionButtonSound = "actionButtonSound", e))(vm || {});
var bm = ((e) => (e[e.RELATIVE_DATE_UNSPECIFIED = 0] = "RELATIVE_DATE_UNSPECIFIED", e[e.PAST_YEAR = 1] = "PAST_YEAR", e[e.PAST_MONTH = 2] = "PAST_MONTH", e[e.PAST_WEEK = 3] = "PAST_WEEK", e[e.YESTERDAY = 4] = "YESTERDAY", e[e.TODAY = 5] = "TODAY", e[e.TOMORROW = 6] = "TOMORROW", e))(bm || {});
var Am = ((e) => (e[e.GRID = 0] = "GRID", e[e.KANBAN = 1] = "KANBAN", e[e.GANTT = 2] = "GANTT", e))(Am || {});
var ms = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LEFT_TO_RIGHT = 1] = "LEFT_TO_RIGHT", e[e.RIGHT_TO_LEFT = 2] = "RIGHT_TO_LEFT", e))(ms || {});
var ym = ((e) => (e[e.DASH = 0] = "DASH", e[e.DASH_DOT_DOT_HEAVY = 1] = "DASH_DOT_DOT_HEAVY", e[e.DASH_DOT_HEAVY = 2] = "DASH_DOT_HEAVY", e[e.DASHED_HEAVY = 3] = "DASHED_HEAVY", e[e.DASH_LONG = 4] = "DASH_LONG", e[e.DASH_LONG_HEAVY = 5] = "DASH_LONG_HEAVY", e[e.DOT_DASH = 6] = "DOT_DASH", e[e.DOT_DOT_DASH = 7] = "DOT_DOT_DASH", e[e.DOTTED = 8] = "DOTTED", e[e.DOTTED_HEAVY = 9] = "DOTTED_HEAVY", e[e.DOUBLE = 10] = "DOUBLE", e[e.NONE = 11] = "NONE", e[e.SINGLE = 12] = "SINGLE", e[e.THICK = 13] = "THICK", e[e.WAVE = 14] = "WAVE", e[e.WAVY_DOUBLE = 15] = "WAVY_DOUBLE", e[e.WAVY_HEAVY = 16] = "WAVY_HEAVY", e[e.WORDS = 17] = "WORDS", e))(ym || {});
var Ut = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LEFT = 1] = "LEFT", e[e.CENTER = 2] = "CENTER", e[e.RIGHT = 3] = "RIGHT", e[e.JUSTIFIED = 4] = "JUSTIFIED", e[e.BOTH = 5] = "BOTH", e[e.DISTRIBUTED = 6] = "DISTRIBUTED", e))(Ut || {});
var xn = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.TOP = 1] = "TOP", e[e.MIDDLE = 2] = "MIDDLE", e[e.BOTTOM = 3] = "BOTTOM", e))(xn || {});
var Bn = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.OVERFLOW = 1] = "OVERFLOW", e[e.CLIP = 2] = "CLIP", e[e.WRAP = 3] = "WRAP", e))(Bn || {});
var wi = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.ITALIC = 1] = "ITALIC", e))(wi || {});
var Si = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.BOLD = 1] = "BOLD", e))(Si || {});
var Zt = ((e) => (e[e.NORMAL = 1] = "NORMAL", e[e.SUBSCRIPT = 2] = "SUBSCRIPT", e[e.SUPERSCRIPT = 3] = "SUPERSCRIPT", e))(Zt || {});
var ie = ((e) => (e[e.FALSE = 0] = "FALSE", e[e.TRUE = 1] = "TRUE", e))(ie || {});
var fn = ((e) => (e[e.STRING = 1] = "STRING", e[e.NUMBER = 2] = "NUMBER", e[e.BOOLEAN = 3] = "BOOLEAN", e[e.FORCE_STRING = 4] = "FORCE_STRING", e))(fn || {});
var st = ((e) => (e[e.DARK1 = 0] = "DARK1", e[e.LIGHT1 = 1] = "LIGHT1", e[e.DARK2 = 2] = "DARK2", e[e.LIGHT2 = 3] = "LIGHT2", e[e.ACCENT1 = 4] = "ACCENT1", e[e.ACCENT2 = 5] = "ACCENT2", e[e.ACCENT3 = 6] = "ACCENT3", e[e.ACCENT4 = 7] = "ACCENT4", e[e.ACCENT5 = 8] = "ACCENT5", e[e.ACCENT6 = 9] = "ACCENT6", e[e.HYPERLINK = 10] = "HYPERLINK", e[e.FOLLOWED_HYPERLINK = 11] = "FOLLOWED_HYPERLINK", e))(st || {});
var co = ((e) => (e.OFFICE = "Office", e.OFFICE_2007_2010 = "Office 2007-2010", e.GRAYSCALE = "Grayscale", e.BLUE_WARM = "Blue Warm", e.BLUE = "Blue", e.BLUE_II = "Blue II", e.BLUE_GREEN = "Blue Green", e.GREEN = "Green", e.GREEN_YELLOW = "Green Yellow", e.YELLOW = "Yellow", e.YELLOW_ORANGE = "Yellow Orange", e.ORANGE = "Orange", e.ORANGE_RED = "Orange Red", e.RED_ORANGE = "Red Orange", e.RED = "Red", e.RED_VIOLET = "Red Violet", e.VIOLET = "Violet", e.VIOLET_II = "Violet II", e.MEDIAN = "Median", e.PAPER = "Paper", e.MARQUEE = "Marquee", e.SLIPSTREAM = "Slipstream", e.Aspect = "Aspect", e))(co || {});
var Nm = ((e) => (e[e.character = 0] = "character", e[e.paragraph = 1] = "paragraph", e[e.table = 2] = "table", e[e.numbering = 3] = "numbering", e))(Nm || {});
var Tm = ((e) => (e[e.TAB = 0] = "TAB", e[e.SPACE = 1] = "SPACE", e[e.NOTHING = 2] = "NOTHING", e))(Tm || {});
var me = ((e) => (e[e.BULLET = 0] = "BULLET", e[e.NONE = 1] = "NONE", e[e.DECIMAL = 2] = "DECIMAL", e[e.DECIMAL_ZERO = 3] = "DECIMAL_ZERO", e[e.UPPER_LETTER = 4] = "UPPER_LETTER", e[e.LOWER_LETTER = 5] = "LOWER_LETTER", e[e.UPPER_ROMAN = 6] = "UPPER_ROMAN", e[e.LOWER_ROMAN = 7] = "LOWER_ROMAN", e[e.ORDINAL = 8] = "ORDINAL", e[e.CARDINAL_TEXT = 9] = "CARDINAL_TEXT", e[e.ORDINAL_TEXT = 10] = "ORDINAL_TEXT", e[e.HEX = 11] = "HEX", e[e.CHICAGO = 12] = "CHICAGO", e[e.IDEOGRAPH_DIGITAL = 13] = "IDEOGRAPH_DIGITAL", e[e.JAPANESE_COUNTING = 14] = "JAPANESE_COUNTING", e[e.AIUEO = 15] = "AIUEO", e[e.IROHA = 16] = "IROHA", e[e.DECIMAL_FULL_WIDTH = 17] = "DECIMAL_FULL_WIDTH", e[e.DECIMAL_HALF_WIDTH = 18] = "DECIMAL_HALF_WIDTH", e[e.JAPANESE_LEGAL = 19] = "JAPANESE_LEGAL", e[e.JAPANESE_DIGITAL_TEN_THOUSAND = 20] = "JAPANESE_DIGITAL_TEN_THOUSAND", e[e.DECIMAL_ENCLOSED_CIRCLE = 21] = "DECIMAL_ENCLOSED_CIRCLE", e[e.DECIMAL_FULL_WIDTH2 = 22] = "DECIMAL_FULL_WIDTH2", e[e.AIUEO_FULL_WIDTH = 23] = "AIUEO_FULL_WIDTH", e[e.IROHA_FULL_WIDTH = 24] = "IROHA_FULL_WIDTH", e[e.GANADA = 25] = "GANADA", e[e.CHOSUNG = 26] = "CHOSUNG", e[e.DECIMAL_ENCLOSED_FULLSTOP = 27] = "DECIMAL_ENCLOSED_FULLSTOP", e[e.DECIMAL_ENCLOSED_PAREN = 28] = "DECIMAL_ENCLOSED_PAREN", e[e.DECIMAL_ENCLOSED_CIRCLE_CHINESE = 29] = "DECIMAL_ENCLOSED_CIRCLE_CHINESE", e[e.IDEOGRAPH_ENCLOSED_CIRCLE = 30] = "IDEOGRAPH_ENCLOSED_CIRCLE", e[e.IDEOGRAPH_TRADITIONAL = 31] = "IDEOGRAPH_TRADITIONAL", e[e.IDEOGRAPH_ZODIAC = 32] = "IDEOGRAPH_ZODIAC", e[e.IDEOGRAPH_ZODIAC_TRADITIONAL = 33] = "IDEOGRAPH_ZODIAC_TRADITIONAL", e[e.TAIWANESE_COUNTING = 34] = "TAIWANESE_COUNTING", e[e.IDEOGRAPH_LEGAL_TRADITIONAL = 35] = "IDEOGRAPH_LEGAL_TRADITIONAL", e[e.TAIWANESE_COUNTING_THOUSAND = 36] = "TAIWANESE_COUNTING_THOUSAND", e[e.TAIWANESE_DIGITAL = 37] = "TAIWANESE_DIGITAL", e[e.CHINESE_COUNTING = 38] = "CHINESE_COUNTING", e[e.CHINESE_LEGAL_SIMPLIFIED = 39] = "CHINESE_LEGAL_SIMPLIFIED", e[e.CHINESE_COUNTING_THOUSAND = 40] = "CHINESE_COUNTING_THOUSAND", e[e.KOREAN_DIGITAL = 41] = "KOREAN_DIGITAL", e[e.KOREAN_COUNTING = 42] = "KOREAN_COUNTING", e[e.KOREAN_LEGAL = 43] = "KOREAN_LEGAL", e[e.KOREAN_DIGITAL2 = 44] = "KOREAN_DIGITAL2", e[e.VIETNAMESE_COUNTING = 45] = "VIETNAMESE_COUNTING", e[e.RUSSIAN_LOWER = 46] = "RUSSIAN_LOWER", e[e.RUSSIAN_UPPER = 47] = "RUSSIAN_UPPER", e[e.NUMBER_IN_DASH = 48] = "NUMBER_IN_DASH", e[e.HEBREW1 = 49] = "HEBREW1", e[e.HEBREW2 = 50] = "HEBREW2", e[e.ARABIC_ALPHA = 51] = "ARABIC_ALPHA", e[e.ARABIC_ABJAD = 52] = "ARABIC_ABJAD", e[e.HINDI_VOWELS = 53] = "HINDI_VOWELS", e[e.HINDI_CONSONANTS = 54] = "HINDI_CONSONANTS", e[e.HINDI_NUMBERS = 55] = "HINDI_NUMBERS", e[e.HINDI_COUNTING = 56] = "HINDI_COUNTING", e[e.THAI_LETTERS = 57] = "THAI_LETTERS", e[e.THAI_NUMBERS = 58] = "THAI_NUMBERS", e[e.THAI_COUNTING = 59] = "THAI_COUNTING", e[e.CUSTOM = 60] = "CUSTOM", e))(me || {});
var Ts = ((e) => (e[e.BULLET_ALIGNMENT_UNSPECIFIED = 0] = "BULLET_ALIGNMENT_UNSPECIFIED", e[e.START = 1] = "START", e[e.CENTER = 2] = "CENTER", e[e.END = 3] = "END", e[e.BOTH = 4] = "BOTH", e))(Ts || {});
var pn = ((e) => (e[e.HYPERLINK = 0] = "HYPERLINK", e[e.FIELD = 1] = "FIELD", e[e.SDT = 2] = "SDT", e[e.BOOKMARK = 3] = "BOOKMARK", e[e.COMMENT = 4] = "COMMENT", e[e.CUSTOM = 5] = "CUSTOM", e[e.MENTION = 6] = "MENTION", e[e.UNI_FORMULA = 7] = "UNI_FORMULA", e[e.DELTED = 9999] = "DELTED", e))(pn || {});
var Dn = ((e) => (e[e.COMMENT = 0] = "COMMENT", e[e.DELETED = 9999] = "DELETED", e))(Dn || {});
var Mm = ((e) => (e[e.DRAWING = 0] = "DRAWING", e[e.CUSTOM = 1] = "CUSTOM", e))(Mm || {});
var uu = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.TRADITIONAL = 1] = "TRADITIONAL", e[e.MODERN = 2] = "MODERN", e))(uu || {});
var Lm = ((e) => (e[e.DEFAULT = 0] = "DEFAULT", e[e.LINES = 1] = "LINES", e[e.LINES_AND_CHARS = 2] = "LINES_AND_CHARS", e[e.SNAP_TO_CHARS = 3] = "SNAP_TO_CHARS", e))(Lm || {});
var xm = ((e) => (e[e.SECTION_TYPE_UNSPECIFIED = 0] = "SECTION_TYPE_UNSPECIFIED", e[e.CONTINUOUS = 1] = "CONTINUOUS", e[e.NEXT_PAGE = 2] = "NEXT_PAGE", e[e.EVEN_PAGE = 3] = "EVEN_PAGE", e[e.ODD_PAGE = 4] = "ODD_PAGE", e))(xm || {});
var Dm = ((e) => (e[e.COLUMN_SEPARATOR_STYLE_UNSPECIFIED = 0] = "COLUMN_SEPARATOR_STYLE_UNSPECIFIED", e[e.NONE = 1] = "NONE", e[e.BETWEEN_EACH_COLUMN = 2] = "BETWEEN_EACH_COLUMN", e))(Dm || {});
var Um = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.TBRL = 1] = "TBRL", e[e.LRTBV = 2] = "LRTBV", e))(Um || {});
var km = ((e) => (e[e.TEXT_RUN = 0] = "TEXT_RUN", e[e.AUTO_TEXT = 1] = "AUTO_TEXT", e[e.PAGE_BREAK = 2] = "PAGE_BREAK", e[e.COLUMN_BREAK = 3] = "COLUMN_BREAK", e[e.FOOT_NOTE_REFERENCE = 4] = "FOOT_NOTE_REFERENCE", e[e.HORIZONTAL_RULE = 5] = "HORIZONTAL_RULE", e[e.EQUATION = 6] = "EQUATION", e[e.DRAWING = 7] = "DRAWING", e[e.PERSON = 8] = "PERSON", e[e.RICH_LINK = 9] = "RICH_LINK", e))(km || {});
var Pm = ((e) => (e[e.BOTH_SIDES = 0] = "BOTH_SIDES", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.LARGEST = 3] = "LARGEST", e))(Pm || {});
var Fm = ((e) => (e[e.INLINE = 0] = "INLINE", e[e.WRAP_NONE = 1] = "WRAP_NONE", e[e.WRAP_POLYGON = 2] = "WRAP_POLYGON", e[e.WRAP_SQUARE = 3] = "WRAP_SQUARE", e[e.WRAP_THROUGH = 4] = "WRAP_THROUGH", e[e.WRAP_TIGHT = 5] = "WRAP_TIGHT", e[e.WRAP_TOP_AND_BOTTOM = 6] = "WRAP_TOP_AND_BOTTOM", e))(Fm || {});
var qe = ((e) => (e[e.NAMED_STYLE_TYPE_UNSPECIFIED = 0] = "NAMED_STYLE_TYPE_UNSPECIFIED", e[e.NORMAL_TEXT = 1] = "NORMAL_TEXT", e[e.TITLE = 2] = "TITLE", e[e.SUBTITLE = 3] = "SUBTITLE", e[e.HEADING_1 = 4] = "HEADING_1", e[e.HEADING_2 = 5] = "HEADING_2", e[e.HEADING_3 = 6] = "HEADING_3", e[e.HEADING_4 = 7] = "HEADING_4", e[e.HEADING_5 = 8] = "HEADING_5", e))(qe || {});
var $m = ((e) => (e[e.AUTO = 0] = "AUTO", e[e.AT_LEAST = 1] = "AT_LEAST", e[e.EXACT = 2] = "EXACT", e))($m || {});
var Hm = ((e) => (e[e.DASH_STYLE_UNSPECIFIED = 0] = "DASH_STYLE_UNSPECIFIED", e[e.SOLID = 1] = "SOLID", e[e.DOT = 2] = "DOT", e[e.DASH = 3] = "DASH", e))(Hm || {});
var Bm = ((e) => (e[e.TAB_STOP_ALIGNMENT_UNSPECIFIED = 0] = "TAB_STOP_ALIGNMENT_UNSPECIFIED", e[e.START = 1] = "START", e[e.CENTER = 2] = "CENTER", e[e.END = 3] = "END", e))(Bm || {});
var jm = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.SPECIFIED = 1] = "SPECIFIED", e))(jm || {});
var Wm = ((e) => (e[e.START = 0] = "START", e[e.CENTER = 1] = "CENTER", e[e.END = 2] = "END", e))(Wm || {});
var Ym = ((e) => (e[e.AUTO_FIT = 0] = "AUTO_FIT", e[e.FIXED = 1] = "FIXED", e))(Ym || {});
var zm = ((e) => (e[e.NONE = 0] = "NONE", e[e.WRAP = 1] = "WRAP", e))(zm || {});
var Vm = ((e) => (e[e.AUTO = 0] = "AUTO", e[e.AT_LEAST = 1] = "AT_LEAST", e[e.EXACT = 2] = "EXACT", e))(Vm || {});
var Gm = ((e) => (e[e.CONTENT_ALIGNMENT_UNSPECIFIED = 0] = "CONTENT_ALIGNMENT_UNSPECIFIED", e[e.BOTH = 1] = "BOTH", e[e.TOP = 2] = "TOP", e[e.CENTER = 3] = "CENTER", e[e.BOTTOM = 4] = "BOTTOM", e))(Gm || {});
var ir = ((e) => (e.NORMAL = "normal", e.BOLD = "bold", e.ITALIC = "italic", e))(ir || {});
var Km = ((e) => (e[e.PAGE = 0] = "PAGE", e[e.COLUMN = 1] = "COLUMN", e[e.CHARACTER = 2] = "CHARACTER", e[e.MARGIN = 3] = "MARGIN", e[e.INSIDE_MARGIN = 4] = "INSIDE_MARGIN", e[e.OUTSIDE_MARGIN = 5] = "OUTSIDE_MARGIN", e[e.LEFT_MARGIN = 6] = "LEFT_MARGIN", e[e.RIGHT_MARGIN = 7] = "RIGHT_MARGIN", e))(Km || {});
var Xm = ((e) => (e[e.PAGE = 0] = "PAGE", e[e.PARAGRAPH = 1] = "PARAGRAPH", e[e.LINE = 2] = "LINE", e[e.MARGIN = 3] = "MARGIN", e[e.TOP_MARGIN = 4] = "TOP_MARGIN", e[e.BOTTOM_MARGIN = 5] = "BOTTOM_MARGIN", e[e.INSIDE_MARGIN = 6] = "INSIDE_MARGIN", e[e.OUTSIDE_MARGIN = 7] = "OUTSIDE_MARGIN", e))(Xm || {});
var qm = ((e) => (e[e.POINT = 0] = "POINT", e[e.LINE = 1] = "LINE", e[e.CHARACTER = 2] = "CHARACTER", e[e.PIXEL = 3] = "PIXEL", e[e.PERCENT = 4] = "PERCENT", e))(qm || {});
var Zm = ((e) => (e[e.CENTER = 0] = "CENTER", e[e.INSIDE = 1] = "INSIDE", e[e.LEFT = 2] = "LEFT", e[e.OUTSIDE = 3] = "OUTSIDE", e[e.RIGHT = 4] = "RIGHT", e[e.BOTH = 5] = "BOTH", e[e.DISTRIBUTE = 6] = "DISTRIBUTE", e))(Zm || {});
var Jm = ((e) => (e[e.BOTTOM = 0] = "BOTTOM", e[e.CENTER = 1] = "CENTER", e[e.INSIDE = 2] = "INSIDE", e[e.OUTSIDE = 3] = "OUTSIDE", e[e.TOP = 4] = "TOP", e))(Jm || {});
var Qm = ((e) => (e[e.compressPunctuation = 0] = "compressPunctuation", e[e.compressPunctuationAndJapaneseKana = 1] = "compressPunctuationAndJapaneseKana", e[e.doNotCompress = 2] = "doNotCompress", e))(Qm || {});
var eg = ((e) => (e[e.PORTRAIT = 0] = "PORTRAIT", e[e.LANDSCAPE = 1] = "LANDSCAPE", e))(eg || {});
var gt = ((e) => (e.Letter = "Letter", e.Tabloid = "Tabloid", e.Legal = "Legal", e.Statement = "Statement", e.Executive = "Executive", e.Folio = "Folio", e.A3 = "A3", e.A4 = "A4", e.A5 = "A5", e.B4 = "B4", e.B5 = "B5", e))(gt || {});
var _1 = [
  "A3",
  "A4",
  "A5",
  "B4",
  "B5",
  "Letter",
  "Tabloid",
  "Legal",
  "Statement",
  "Executive",
  "Folio"
  /* Folio */
];
var tg = ((e) => (e[e.forward = 0] = "forward", e[e.backward = 1] = "backward", e[e.front = 2] = "front", e[e.back = 3] = "back", e))(tg || {});
var ng = ((e) => (e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e[e.DRAWING_IMAGE = 0] = "DRAWING_IMAGE", e[e.DRAWING_SHAPE = 1] = "DRAWING_SHAPE", e[e.DRAWING_CHART = 2] = "DRAWING_CHART", e[e.DRAWING_TABLE = 3] = "DRAWING_TABLE", e[e.DRAWING_SMART_ART = 4] = "DRAWING_SMART_ART", e[e.DRAWING_VIDEO = 5] = "DRAWING_VIDEO", e[e.DRAWING_GROUP = 6] = "DRAWING_GROUP", e[e.DRAWING_UNIT = 7] = "DRAWING_UNIT", e[e.DRAWING_DOM = 8] = "DRAWING_DOM", e))(ng || {});
var cu = ((e) => (e[e.SLIDE = 0] = "SLIDE", e[e.MASTER = 1] = "MASTER", e[e.LAYOUT = 2] = "LAYOUT", e[e.HANDOUT_MASTER = 3] = "HANDOUT_MASTER", e[e.NOTES_MASTER = 4] = "NOTES_MASTER", e))(cu || {});
var rg = ((e) => (e[e.SHAPE = 0] = "SHAPE", e[e.IMAGE = 1] = "IMAGE", e[e.TEXT = 2] = "TEXT", e[e.SPREADSHEET = 3] = "SPREADSHEET", e[e.DOCUMENT = 4] = "DOCUMENT", e[e.SLIDE = 5] = "SLIDE", e))(rg || {});
var sg = ((e) => (e[e.RELATIVE_SLIDE_LINK_UNSPECIFIED = 0] = "RELATIVE_SLIDE_LINK_UNSPECIFIED", e[e.NEXT_SLIDE = 1] = "NEXT_SLIDE", e[e.PREVIOUS_SLIDE = 2] = "PREVIOUS_SLIDE", e[e.FIRST_SLIDE = 3] = "FIRST_SLIDE", e[e.LAST_SLIDE = 4] = "LAST_SLIDE", e))(sg || {});
function ig(e = et(6), t = Ns.EN_US, n = "") {
  return {
    id: e,
    locale: t,
    title: n,
    // title should get from request.
    tableSource: {},
    drawings: {},
    drawingsOrder: [],
    headers: {},
    footers: {},
    body: {
      dataStream: `\r
`,
      textRuns: [],
      customBlocks: [],
      tables: [],
      paragraphs: [
        {
          startIndex: 0,
          paragraphStyle: {
            spaceAbove: { v: 5 },
            lineSpacing: 1,
            spaceBelow: { v: 0 }
          }
        }
      ],
      sectionBreaks: [
        {
          startIndex: 1
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: 793.3333333333334,
        height: 1122.6666666666667
      },
      documentFlavor: uu.TRADITIONAL,
      marginTop: 50,
      marginBottom: 50,
      marginRight: 50,
      marginLeft: 50,
      renderConfig: {
        zeroWidthParagraphBreak: ie.FALSE,
        vertexAngle: 0,
        centerAngle: 0,
        background: {
          rgb: "#ccc"
        }
      },
      autoHyphenation: ie.TRUE,
      doNotHyphenateCaps: ie.FALSE,
      consecutiveHyphenLimit: 2,
      defaultHeaderId: "",
      defaultFooterId: "",
      evenPageHeaderId: "",
      evenPageFooterId: "",
      firstPageHeaderId: "",
      firstPageFooterId: "",
      evenAndOddHeaders: ie.FALSE,
      useFirstPageHeaderFooter: ie.FALSE,
      marginHeader: 30,
      marginFooter: 30
    },
    settings: {}
  };
}
var an = {};
var Zn = {};
var Dr = {};
var wa;
function og() {
  if (wa) return Dr;
  wa = 1, Object.defineProperty(Dr, "__esModule", { value: true });
  function e(r, s) {
    if (Array.isArray(s))
      return false;
    for (let i in r)
      if (!n(r[i], s[i]))
        return false;
    for (let i in s)
      if (r[i] === void 0)
        return false;
    return true;
  }
  function t(r, s) {
    if (!Array.isArray(s) || r.length !== s.length)
      return false;
    for (let i = 0; i < r.length; i++)
      if (!n(r[i], s[i]))
        return false;
    return true;
  }
  function n(r, s) {
    return r === s ? true : r === null || s === null || typeof r != "object" || typeof s != "object" ? false : Array.isArray(r) ? t(r, s) : e(r, s);
  }
  return Dr.default = n, Dr;
}
var Ur = {};
var Sa;
function ag() {
  if (Sa) return Ur;
  Sa = 1, Object.defineProperty(Ur, "__esModule", { value: true });
  function e(t) {
    if (t === null)
      return null;
    if (Array.isArray(t))
      return t.map(e);
    if (typeof t == "object") {
      const n = {};
      for (let r in t)
        n[r] = e(t[r]);
      return n;
    } else
      return t;
  }
  return Ur.default = e, Ur;
}
var qs = {};
var Oa;
function hu() {
  return Oa || (Oa = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.eachChildOf = e.advancer = e.readCursor = e.writeCursor = e.WriteCursor = e.ReadCursor = e.isValidPathItem = void 0;
    function t(c, h) {
      if (!c)
        throw new Error(h);
    }
    const n = (c) => c != null && typeof c == "object" && !Array.isArray(c), r = (c, h) => (
      // All the numbers, then all the letters. Just as the gods of ascii intended.
      typeof c == typeof h ? c > h : typeof c == "string" && typeof h == "number"
    );
    function s(c, h) {
      for (let d in c) {
        const f = d;
        h.write(f, c[f]);
      }
    }
    e.isValidPathItem = (c) => typeof c == "number" || typeof c == "string" && c !== "__proto__";
    class i {
      constructor(h = null) {
        this.parents = [], this.indexes = [], this.lcIdx = -1, this.idx = -1, this.container = h;
      }
      ascend() {
        t(this.parents.length === this.indexes.length / 2), this.idx === 0 ? this.parents.length ? (this.lcIdx = this.indexes.pop(), this.container = this.parents.pop(), this.idx = this.indexes.pop()) : (this.lcIdx = 0, this.idx = -1) : (t(this.idx > 0), this.idx--, n(this.container[this.idx]) && this.idx--);
      }
      getPath() {
        const h = [];
        let d = this.container, f = this.parents.length - 1, g = this.idx;
        for (; g >= 0; )
          h.unshift(d[g]), g === 0 ? (g = this.indexes[f * 2], d = this.parents[f--]) : g -= n(d[g - 1]) ? 2 : 1;
        return h;
      }
    }
    class o extends i {
      get() {
        return this.container ? this.container.slice(this.idx + 1) : null;
      }
      // Its only valid to call this after descending into a child.
      getKey() {
        return t(this.container != null, "Invalid call to getKey before cursor descended"), this.container[this.idx];
      }
      getComponent() {
        let h;
        return this.container && this.container.length > this.idx + 1 && n(h = this.container[this.idx + 1]) ? h : null;
      }
      descendFirst() {
        let h = this.idx + 1;
        if (!this.container || h >= this.container.length || n(this.container[h]) && h + 1 >= this.container.length)
          return false;
        n(this.container[h]) && h++;
        const d = this.container[h];
        return Array.isArray(d) ? (this.indexes.push(this.idx), this.parents.push(this.container), this.indexes.push(h), this.idx = 0, this.container = d) : this.idx = h, true;
      }
      nextSibling() {
        if (t(this.parents.length === this.indexes.length / 2), this.idx > 0 || this.parents.length === 0)
          return false;
        const h = this.indexes[this.indexes.length - 1] + 1, d = this.parents[this.parents.length - 1];
        return h >= d.length ? false : (t(!isNaN(h)), this.indexes[this.indexes.length - 1] = h, this.container = d[h], true);
      }
      _init(h, d, f, g) {
        this.container = h, this.idx = d, this.parents = f.slice(), this.indexes = g.slice();
      }
      clone() {
        const h = new o();
        return h._init(this.container, this.idx, this.parents, this.indexes), h;
      }
      *[Symbol.iterator]() {
        if (this.descendFirst()) {
          do
            yield this.getKey();
          while (this.nextSibling());
          this.ascend();
        }
      }
      // TODO(cleanup): Consider moving these functions out of cursor, since
      // they're really just helper methods.
      // It'd be really nice to do this using generators.
      traverse(h, d) {
        const f = this.getComponent();
        f && d(f, h);
        for (const g of this)
          h && h.descend(g), this.traverse(h, d), h && h.ascend();
      }
      eachPick(h, d) {
        this.traverse(h, (f, g) => {
          f.p != null && d(f.p, g);
        });
      }
      eachDrop(h, d) {
        this.traverse(h, (f, g) => {
          f.d != null && d(f.d, g);
        });
      }
    }
    e.ReadCursor = o;
    class a extends i {
      constructor(h = null) {
        super(h), this.pendingDescent = [], this._op = h;
      }
      flushDescent() {
        t(this.parents.length === this.indexes.length / 2), this.container === null && (this._op = this.container = []);
        for (let h = 0; h < this.pendingDescent.length; h++) {
          const d = this.pendingDescent[h];
          let f = this.idx + 1;
          if (f < this.container.length && n(this.container[f]) && f++, t(f === this.container.length || !n(this.container[f])), f === this.container.length)
            this.container.push(d), this.idx = f;
          else if (this.container[f] === d)
            this.idx = f;
          else {
            if (!Array.isArray(this.container[f])) {
              const g = this.container.splice(f, this.container.length - f);
              this.container.push(g), this.lcIdx > -1 && (this.lcIdx = f);
            }
            for (this.indexes.push(this.idx), this.parents.push(this.container), this.lcIdx !== -1 && (t(r(d, this.container[this.lcIdx][0])), f = this.lcIdx + 1, this.lcIdx = -1); f < this.container.length && r(d, this.container[f][0]); )
              f++;
            if (this.indexes.push(f), this.idx = 0, f < this.container.length && this.container[f][0] === d)
              this.container = this.container[f];
            else {
              const g = [d];
              this.container.splice(f, 0, g), this.container = g;
            }
          }
        }
        this.pendingDescent.length = 0;
      }
      reset() {
        this.lcIdx = -1;
      }
      // Creates and returns a component, creating one if need be. You should
      // probably write to it immediately - ops are not valid with empty
      // components.
      getComponent() {
        this.flushDescent();
        const h = this.idx + 1;
        if (h < this.container.length && n(this.container[h]))
          return this.container[h];
        {
          const d = {};
          return this.container.splice(h, 0, d), d;
        }
      }
      write(h, d) {
        const f = this.getComponent();
        t(f[h] == null || f[h] === d, "Internal consistency error: Overwritten component. File a bug"), f[h] = d;
      }
      get() {
        return this._op;
      }
      descend(h) {
        if (!e.isValidPathItem(h))
          throw Error("Invalid JSON key");
        this.pendingDescent.push(h);
      }
      descendPath(h) {
        return this.pendingDescent.push(...h), this;
      }
      ascend() {
        this.pendingDescent.length ? this.pendingDescent.pop() : super.ascend();
      }
      mergeTree(h, d = s) {
        if (h === null)
          return;
        if (t(Array.isArray(h)), h === this._op)
          throw Error("Cannot merge into my own tree");
        const f = this.lcIdx, g = this.parents.length;
        let _ = 0;
        for (let R = 0; R < h.length; R++) {
          const b = h[R];
          typeof b == "string" || typeof b == "number" ? (_++, this.descend(b)) : Array.isArray(b) ? this.mergeTree(b, d) : typeof b == "object" && d(b, this);
        }
        for (; _--; )
          this.ascend();
        this.lcIdx = this.parents.length === g ? f : -1;
      }
      at(h, d) {
        this.descendPath(h), d(this);
        for (let f = 0; f < h.length; f++)
          this.ascend();
        return this;
      }
      // This is used by helpers, so the strict ordering guarantees are
      // relaxed.
      writeAtPath(h, d, f) {
        return this.at(h, () => this.write(d, f)), this.reset(), this;
      }
      writeMove(h, d, f = 0) {
        return this.writeAtPath(h, "p", f).writeAtPath(d, "d", f);
      }
      getPath() {
        const h = super.getPath();
        return h.push(...this.pendingDescent), h;
      }
    }
    e.WriteCursor = a, e.writeCursor = () => new a(), e.readCursor = (c) => new o(c);
    function l(c, h, d) {
      let f, g;
      g = f = c ? c.descendFirst() : false;
      function _(R) {
        let b;
        for (; g; ) {
          const H = b = c.getKey();
          if (R != null) {
            let P = false;
            if (h && typeof H == "number" && (b = h(H, c.getComponent()), b < 0 && (b = ~b, P = true)), r(b, R))
              return null;
            if (b === R && !P)
              return c;
          }
          d && typeof b == "number" && d(b, c.getComponent()), g = c.nextSibling();
        }
        return null;
      }
      return _.end = () => {
        f && c.ascend();
      }, _;
    }
    e.advancer = l;
    function u(c, h, d) {
      let f, g, _, R;
      for (f = g = c && c.descendFirst(), _ = R = h && h.descendFirst(); f || _; ) {
        let b = f ? c.getKey() : null, H = _ ? h.getKey() : null;
        b !== null && H !== null && (r(H, b) ? H = null : b !== H && (b = null)), d(b == null ? H : b, b != null ? c : null, H != null ? h : null), b != null && f && (f = c.nextSibling()), H != null && _ && (_ = h.nextSibling());
      }
      g && c.ascend(), R && h.ascend();
    }
    e.eachChildOf = u;
  }(qs)), qs;
}
var Zs = {};
var va;
function du() {
  return va || (va = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.ConflictType = void 0, function(t) {
      t[t.RM_UNEXPECTED_CONTENT = 1] = "RM_UNEXPECTED_CONTENT", t[t.DROP_COLLISION = 2] = "DROP_COLLISION", t[t.BLACKHOLE = 3] = "BLACKHOLE";
    }(e.ConflictType || (e.ConflictType = {}));
  }(Zs)), Zs;
}
var vt = {};
var ln = {};
var ba;
function ho() {
  return ba || (ba = 1, Object.defineProperty(ln, "__esModule", { value: true }), ln.uniToStrPos = ln.strPosToUni = void 0, ln.strPosToUni = (e, t = e.length) => {
    let n = 0, r = 0;
    for (; r < t; r++) {
      const s = e.charCodeAt(r);
      s >= 55296 && s <= 57343 && (n++, r++);
    }
    if (r !== t)
      throw Error("Invalid offset - splits unicode bytes");
    return r - n;
  }, ln.uniToStrPos = (e, t) => {
    let n = 0;
    for (; t > 0; t--) {
      const r = e.charCodeAt(n);
      n += r >= 55296 && r <= 57343 ? 2 : 1;
    }
    return n;
  }), ln;
}
var Js = {};
var Aa;
function Oi() {
  return Aa || (Aa = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.uniSlice = e.dlen = e.eachOp = void 0;
    const t = ho(), n = (w) => {
      if (!Array.isArray(w))
        throw Error("Op must be an array of components");
      let C = null;
      for (let v = 0; v < w.length; v++) {
        const y = w[v];
        switch (typeof y) {
          case "object":
            if (typeof y.d != "number" && typeof y.d != "string")
              throw Error("Delete must be number or string");
            if (e.dlen(y.d) <= 0)
              throw Error("Deletes must not be empty");
            break;
          case "string":
            if (!(y.length > 0))
              throw Error("Inserts cannot be empty");
            break;
          case "number":
            if (!(y > 0))
              throw Error("Skip components must be >0");
            if (typeof C == "number")
              throw Error("Adjacent skip components should be combined");
            break;
        }
        C = y;
      }
      if (typeof C == "number")
        throw Error("Op has a trailing skip");
    };
    function r(w, C) {
      let v = 0, y = 0;
      for (let F2 = 0; F2 < w.length; F2++) {
        const $ = w[F2];
        switch (C($, v, y), typeof $) {
          case "object":
            v += e.dlen($.d);
            break;
          case "string":
            y += t.strPosToUni($);
            break;
          case "number":
            v += $, y += $;
            break;
        }
      }
    }
    e.eachOp = r;
    function s(w, C) {
      const v = [], y = a(v);
      return r(w, (F2, $, m) => {
        y(C(F2, $, m));
      }), h(v);
    }
    const i = (w) => w, o = (w) => s(w, i);
    e.dlen = (w) => typeof w == "number" ? w : t.strPosToUni(w);
    const a = (w) => (C) => {
      if (!(!C || C.d === 0 || C.d === "")) if (w.length === 0)
        w.push(C);
      else if (typeof C == typeof w[w.length - 1])
        if (typeof C == "object") {
          const v = w[w.length - 1];
          v.d = typeof v.d == "string" && typeof C.d == "string" ? v.d + C.d : e.dlen(v.d) + e.dlen(C.d);
        } else
          w[w.length - 1] += C;
      else
        w.push(C);
    }, l = (w) => typeof w == "number" ? w : typeof w == "string" ? t.strPosToUni(w) : typeof w.d == "number" ? w.d : t.strPosToUni(w.d);
    e.uniSlice = (w, C, v) => {
      const y = t.uniToStrPos(w, C), F2 = v == null ? 1 / 0 : t.uniToStrPos(w, v);
      return w.slice(y, F2);
    };
    const u = (w, C, v) => typeof w == "number" ? v == null ? w - C : Math.min(w, v) - C : e.uniSlice(w, C, v), c = (w) => {
      let C = 0, v = 0;
      return { take: ($, m) => {
        if (C === w.length)
          return $ === -1 ? null : $;
        const D2 = w[C];
        let S;
        if (typeof D2 == "number")
          return $ === -1 || D2 - v <= $ ? (S = D2 - v, ++C, v = 0, S) : (v += $, $);
        if (typeof D2 == "string") {
          if ($ === -1 || m === "i" || t.strPosToUni(D2.slice(v)) <= $)
            return S = D2.slice(v), ++C, v = 0, S;
          {
            const T = v + t.uniToStrPos(D2.slice(v), $);
            return S = D2.slice(v, T), v = T, S;
          }
        } else {
          if ($ === -1 || m === "d" || e.dlen(D2.d) - v <= $)
            return S = { d: u(D2.d, v) }, ++C, v = 0, S;
          {
            let T = u(D2.d, v, v + $);
            return v += $, { d: T };
          }
        }
      }, peek: () => w[C] };
    }, h = (w) => (w.length > 0 && typeof w[w.length - 1] == "number" && w.pop(), w);
    function d(w, C, v) {
      if (v !== "left" && v !== "right")
        throw Error("side (" + v + ") must be 'left' or 'right'");
      n(w), n(C);
      const y = [], F2 = a(y), { take: $, peek: m } = c(w);
      for (let S = 0; S < C.length; S++) {
        const T = C[S];
        let A, O;
        switch (typeof T) {
          case "number":
            for (A = T; A > 0; )
              O = $(A, "i"), F2(O), typeof O != "string" && (A -= l(O));
            break;
          case "string":
            v === "left" && typeof m() == "string" && F2($(-1)), F2(t.strPosToUni(T));
            break;
          case "object":
            for (A = e.dlen(T.d); A > 0; )
              switch (O = $(A, "i"), typeof O) {
                case "number":
                  A -= O;
                  break;
                case "string":
                  F2(O);
                  break;
                case "object":
                  A -= e.dlen(O.d);
              }
            break;
        }
      }
      let D2;
      for (; D2 = $(-1); )
        F2(D2);
      return h(y);
    }
    function f(w, C) {
      n(w), n(C);
      const v = [], y = a(v), { take: F2 } = c(w);
      for (let m = 0; m < C.length; m++) {
        const D2 = C[m];
        let S, T;
        switch (typeof D2) {
          case "number":
            for (S = D2; S > 0; )
              T = F2(S, "d"), y(T), typeof T != "object" && (S -= l(T));
            break;
          case "string":
            y(D2);
            break;
          case "object":
            S = e.dlen(D2.d);
            let A = 0;
            for (; A < S; )
              switch (T = F2(S - A, "d"), typeof T) {
                case "number":
                  y({ d: u(D2.d, A, A + T) }), A += T;
                  break;
                case "string":
                  A += t.strPosToUni(T);
                  break;
                case "object":
                  y(T);
              }
            break;
        }
      }
      let $;
      for (; $ = F2(-1); )
        y($);
      return h(v);
    }
    const g = (w, C) => {
      let v = 0;
      for (let y = 0; y < C.length && w > v; y++) {
        const F2 = C[y];
        switch (typeof F2) {
          case "number": {
            v += F2;
            break;
          }
          case "string":
            const $ = t.strPosToUni(F2);
            v += $, w += $;
            break;
          case "object":
            w -= Math.min(e.dlen(F2.d), w - v);
            break;
        }
      }
      return w;
    }, _ = (w, C) => typeof w == "number" ? g(w, C) : w.map((v) => g(v, C));
    function R(w, C, v) {
      return s(w, (y, F2) => typeof y == "object" && typeof y.d == "number" ? { d: v.slice(C, F2, F2 + y.d) } : y);
    }
    function b(w) {
      return s(w, (C) => {
        switch (typeof C) {
          case "object":
            if (typeof C.d == "number")
              throw Error("Cannot invert text op: Deleted characters missing from operation. makeInvertible must be called first.");
            return C.d;
          case "string":
            return { d: C };
          case "number":
            return C;
        }
      });
    }
    function H(w) {
      return s(w, (C) => typeof C == "object" && typeof C.d == "string" ? { d: t.strPosToUni(C.d) } : C);
    }
    function P(w) {
      let C = true;
      return r(w, (v) => {
        typeof v == "object" && typeof v.d == "number" && (C = false);
      }), C;
    }
    function W(w) {
      return {
        name: "text-unicode",
        uri: "http://sharejs.org/types/text-unicode",
        trim: h,
        normalize: o,
        checkOp: n,
        /** Create a new text snapshot.
         *
         * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
         * @returns {Snap} Initial document snapshot object
         */
        create(C = "") {
          if (typeof C != "string")
            throw Error("Initial data must be a string");
          return w.create(C);
        },
        /** Apply an operation to a document snapshot
         */
        apply(C, v) {
          n(v);
          const y = w.builder(C);
          for (let F2 = 0; F2 < v.length; F2++) {
            const $ = v[F2];
            switch (typeof $) {
              case "number":
                y.skip($);
                break;
              case "string":
                y.append($);
                break;
              case "object":
                y.del(e.dlen($.d));
                break;
            }
          }
          return y.build();
        },
        transform: d,
        compose: f,
        transformPosition: g,
        transformSelection: _,
        isInvertible: P,
        makeInvertible(C, v) {
          return R(C, v, w);
        },
        stripInvertible: H,
        invert: b,
        invertWithDoc(C, v) {
          return b(R(C, v, w));
        },
        isNoop: (C) => C.length === 0
      };
    }
    e.default = W;
  }(Js)), Js;
}
var kr = {};
var ya;
function lg() {
  if (ya) return kr;
  ya = 1, Object.defineProperty(kr, "__esModule", { value: true });
  const e = Oi(), t = ho();
  function n(r, s) {
    return {
      // Returns the text content of the document
      get: r,
      // Returns the number of characters in the string
      getLength() {
        return r().length;
      },
      // Insert the specified text at the given position in the document
      insert(i, o, a) {
        const l = t.strPosToUni(r(), i);
        return s([l, o], a);
      },
      remove(i, o, a) {
        const l = t.strPosToUni(r(), i);
        return s([l, { d: o }], a);
      },
      // When you use this API, you should implement these two methods
      // in your editing context.
      //onInsert: function(pos, text) {},
      //onRemove: function(pos, removedLength) {},
      _onOp(i) {
        e.eachOp(i, (o, a, l) => {
          switch (typeof o) {
            case "string":
              this.onInsert && this.onInsert(l, o);
              break;
            case "object":
              const u = e.dlen(o.d);
              this.onRemove && this.onRemove(l, u);
          }
        });
      },
      onInsert: null,
      onRemove: null
    };
  }
  return kr.default = n, n.provides = { text: true }, kr;
}
var Na;
function ug() {
  return Na || (Na = 1, function(e) {
    var t = vt && vt.__createBinding || (Object.create ? function(d, f, g, _) {
      _ === void 0 && (_ = g), Object.defineProperty(d, _, { enumerable: true, get: function() {
        return f[g];
      } });
    } : function(d, f, g, _) {
      _ === void 0 && (_ = g), d[_] = f[g];
    }), n = vt && vt.__setModuleDefault || (Object.create ? function(d, f) {
      Object.defineProperty(d, "default", { enumerable: true, value: f });
    } : function(d, f) {
      d.default = f;
    }), r = vt && vt.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var f = {};
      if (d != null) for (var g in d) Object.hasOwnProperty.call(d, g) && t(f, d, g);
      return n(f, d), f;
    }, s = vt && vt.__importDefault || function(d) {
      return d && d.__esModule ? d : { default: d };
    };
    Object.defineProperty(e, "__esModule", { value: true }), e.type = e.remove = e.insert = void 0;
    const i = ho(), o = r(Oi()), a = s(lg()), l = {
      create(d) {
        return d;
      },
      toString(d) {
        return d;
      },
      builder(d) {
        if (typeof d != "string")
          throw Error("Invalid document snapshot: " + d);
        const f = [];
        return {
          skip(g) {
            let _ = i.uniToStrPos(d, g);
            if (_ > d.length)
              throw Error("The op is too long for this document");
            f.push(d.slice(0, _)), d = d.slice(_);
          },
          append(g) {
            f.push(g);
          },
          del(g) {
            d = d.slice(i.uniToStrPos(d, g));
          },
          build() {
            return f.join("") + d;
          }
        };
      },
      slice: o.uniSlice
    }, u = o.default(l), c = Object.assign(Object.assign({}, u), { api: a.default });
    e.type = c, e.insert = (d, f) => f.length === 0 ? [] : d === 0 ? [f] : [d, f], e.remove = (d, f) => o.dlen(f) === 0 ? [] : d === 0 ? [{ d: f }] : [d, { d: f }];
    var h = Oi();
    Object.defineProperty(e, "makeType", { enumerable: true, get: function() {
      return h.default;
    } });
  }(vt)), vt;
}
var Ta;
function cg() {
  return Ta || (Ta = 1, function(e) {
    var t = Zn && Zn.__importDefault || function(I) {
      return I && I.__esModule ? I : {
        default: I
      };
    };
    Object.defineProperty(e, "__esModule", {
      value: true
    }), e.editOp = e.replaceOp = e.insertOp = e.moveOp = e.removeOp = e.type = void 0;
    const n = t(og()), r = t(ag()), s = hu(), i = du();
    function o(I, x) {
      if (!I) throw new Error(x);
    }
    e.type = {
      name: "json1",
      uri: "http://sharejs.org/types/JSONv1",
      readCursor: s.readCursor,
      writeCursor: s.writeCursor,
      create: (I) => I,
      isNoop: (I) => I == null,
      setDebug(I) {
      },
      registerSubtype: b,
      checkValidOp: F2,
      normalize: $,
      apply: m,
      transformPosition: D2,
      compose: S,
      tryTransform: L,
      transform: q,
      makeInvertible: O,
      invert: T,
      invertWithDoc: N,
      RM_UNEXPECTED_CONTENT: i.ConflictType.RM_UNEXPECTED_CONTENT,
      DROP_COLLISION: i.ConflictType.DROP_COLLISION,
      BLACKHOLE: i.ConflictType.BLACKHOLE,
      transformNoConflict: (I, x, Y) => le(() => true, I, x, Y),
      typeAllowingConflictsPred: (I) => Object.assign(Object.assign({}, e.type), {
        transform: (x, Y, z) => le(I, x, Y, z)
      })
    };
    const a = (I) => I ? I.getComponent() : null;
    function l(I) {
      return I && typeof I == "object" && !Array.isArray(I);
    }
    const u = (I) => Array.isArray(I) ? I.slice() : I !== null && typeof I == "object" ? Object.assign({}, I) : I, c = (I) => I && (I.p != null || I.r !== void 0), h = (I) => I && (I.d != null || I.i !== void 0);
    function d(I, x) {
      return o(I != null), typeof x == "number" ? (o(Array.isArray(I), "Invalid key - child is not an array"), (I = I.slice()).splice(x, 1)) : (o(l(I), "Invalid key - child is not an object"), delete (I = Object.assign({}, I))[x]), I;
    }
    function f(I, x, Y) {
      return typeof x == "number" ? (o(I != null, "Container is missing for key"), o(Array.isArray(I), "Cannot use numerical key for object container"), o(I.length >= x, "Cannot insert into out of bounds index"), I.splice(x, 0, Y)) : (o(l(I), "Cannot insert into missing item"), o(I[x] === void 0, "Trying to overwrite value at key. Your op needs to remove it first"), I[x] = Y), Y;
    }
    e.removeOp = (I, x = true) => s.writeCursor().writeAtPath(I, "r", x).get(), e.moveOp = (I, x) => s.writeCursor().writeMove(I, x).get(), e.insertOp = (I, x) => s.writeCursor().writeAtPath(I, "i", x).get(), e.replaceOp = (I, x, Y) => s.writeCursor().at(I, (z) => {
      z.write("r", x), z.write("i", Y);
    }).get(), e.editOp = (I, x, Y, z = false) => s.writeCursor().at(I, (B) => C(B, x, Y, z)).get();
    const g = (I, x) => I != null && (typeof x == "number" ? Array.isArray(I) : typeof I == "object"), _ = (I, x) => g(I, x) ? I[x] : void 0, R = {};
    function b(I) {
      let x = I.type ? I.type : I;
      x.name && (R[x.name] = x), x.uri && (R[x.uri] = x);
    }
    const H = (I) => {
      const x = R[I];
      if (x) return x;
      throw Error("Missing type: " + I);
    };
    b(ug());
    const P = (I, x) => I + x;
    b({
      name: "number",
      apply: P,
      compose: P,
      invert: (I) => -I,
      transform: (I) => I
    });
    const W = (I) => I == null ? null : I.et ? H(I.et) : I.es ? R["text-unicode"] : I.ena != null ? R.number : null, w = (I) => I.es ? I.es : I.ena != null ? I.ena : I.e, C = (I, x, Y, z = false) => {
      const [B, j] = typeof x == "string" ? [H(x), x] : [x, x.name];
      !z && B.isNoop && B.isNoop(Y) || (j === "number" ? I.write("ena", Y) : j === "text-unicode" ? I.write("es", Y) : (I.write("et", j), I.write("e", Y)));
    };
    function v(I) {
      o(typeof I == "number"), o(I >= 0), o(I === (0 | I));
    }
    function y(I) {
      typeof I == "number" ? v(I) : o(typeof I == "string");
    }
    function F2(I) {
      if (I === null) return;
      const x = /* @__PURE__ */ new Set(), Y = /* @__PURE__ */ new Set(), z = (j) => {
        let Q = true, ee = false;
        for (let U in j) {
          const G = j[U];
          if (Q = false, o(U === "p" || U === "r" || U === "d" || U === "i" || U === "e" || U === "es" || U === "ena" || U === "et", "Invalid component item '" + U + "'"), U === "p") v(G), o(!x.has(G)), x.add(G), o(j.r === void 0);
          else if (U === "d") v(G), o(!Y.has(G)), Y.add(G), o(j.i === void 0);
          else if (U === "e" || U === "es" || U === "ena") {
            o(!ee), ee = true;
            const X = W(j);
            o(X, "Missing type in edit"), X.checkValidOp && X.checkValidOp(w(j));
          }
        }
        o(!Q);
      }, B = (j, Q, ee) => {
        if (!Array.isArray(j)) throw Error("Op must be null or a list");
        if (j.length === 0) throw Error("Empty descent");
        Q || y(j[0]);
        let U = 1, G = 0, X = 0;
        for (let ne = 0; ne < j.length; ne++) {
          const de = j[ne];
          if (o(de != null), Array.isArray(de)) {
            const _e = B(de, false);
            if (G) {
              const K = typeof X, ce = typeof _e;
              K === ce ? o(X < _e, "descent keys are not in order") : o(K === "number" && ce === "string");
            }
            X = _e, G++, U = 3;
          } else typeof de == "object" ? (o(U === 1, `Prev not scalar - instead ${U}`), z(de), U = 2) : (o(U !== 3), y(de), o(s.isValidPathItem(de), "Invalid path key"), U = 1);
        }
        return o(G !== 1, "Operation makes multiple descents. Remove some []"), o(U === 2 || U === 3), j[0];
      };
      B(I, true), o(x.size === Y.size, "Mismatched picks and drops in op");
      for (let j = 0; j < x.size; j++) o(x.has(j)), o(Y.has(j));
    }
    function $(I) {
      let x = 0, Y = [];
      const z = s.writeCursor();
      return z.mergeTree(I, (B, j) => {
        const Q = W(B);
        if (Q) {
          const U = w(B);
          C(j, Q, Q.normalize ? Q.normalize(U) : U);
        }
        for (const U of ["r", "p", "i", "d"]) if (B[U] !== void 0) {
          const G = U === "p" || U === "d" ? (ee = B[U], Y[ee] == null && (Y[ee] = x++), Y[ee]) : B[U];
          j.write(U, G);
        }
        var ee;
      }), z.get();
    }
    function m(I, x) {
      if (F2(x), x === null) return I;
      const Y = [];
      return function z(B, j) {
        let Q = B, ee = 0, U = {
          root: B
        }, G = 0, X = U, ne = "root";
        function de() {
          for (; G < ee; G++) {
            let _e = j[G];
            typeof _e != "object" && (o(g(X, ne)), X = X[ne] = u(X[ne]), ne = _e);
          }
        }
        for (; ee < j.length; ee++) {
          const _e = j[ee];
          if (Array.isArray(_e)) {
            const K = z(Q, _e);
            K !== Q && K !== void 0 && (de(), Q = X[ne] = K);
          } else if (typeof _e == "object") {
            _e.d != null ? (de(), Q = f(X, ne, Y[_e.d])) : _e.i !== void 0 && (de(), Q = f(X, ne, _e.i));
            const K = W(_e);
            if (K) de(), Q = X[ne] = K.apply(Q, w(_e));
            else if (_e.e !== void 0) throw Error("Subtype " + _e.et + " undefined");
          } else Q = _(Q, _e);
        }
        return U.root;
      }(I = function z(B, j) {
        const Q = [];
        let ee = 0;
        for (; ee < j.length; ee++) {
          const ne = j[ee];
          if (Array.isArray(ne)) break;
          typeof ne != "object" && (Q.push(B), B = _(B, ne));
        }
        for (let ne = j.length - 1; ne >= ee; ne--) B = z(B, j[ne]);
        for (--ee; ee >= 0; ee--) {
          const ne = j[ee];
          if (typeof ne != "object") {
            const de = Q.pop();
            B = B === _(de, ne) ? de : B === void 0 ? d(de, ne) : (G = ne, X = B, (U = u(U = de))[G] = X, U);
          } else c(ne) && (o(B !== void 0, "Cannot pick up or remove undefined"), ne.p != null && (Y[ne.p] = B), B = void 0);
        }
        var U, G, X;
        return B;
      }(I, x), x);
    }
    function D2(I, x) {
      I = I.slice(), F2(x);
      const Y = s.readCursor(x);
      let z, B, j = false;
      const Q = [];
      for (let U = 0; ; U++) {
        const G = I[U], X = Y.getComponent();
        if (X && (X.r !== void 0 ? j = true : X.p != null && (j = false, z = X.p, B = U)), U >= I.length) break;
        let ne = 0;
        const de = s.advancer(Y, void 0, (K, ce) => {
          c(ce) && ne++;
        });
        Q.unshift(de);
        const _e = de(G);
        if (typeof G == "number" && (I[U] -= ne), !_e) break;
      }
      if (Q.forEach((U) => U.end()), j) return null;
      const ee = () => {
        let U = 0;
        if (z != null) {
          const G = Y.getPath();
          U = G.length, I = G.concat(I.slice(B));
        }
        for (; U < I.length; U++) {
          const G = I[U], X = a(Y), ne = W(X);
          if (ne) {
            const K = w(X);
            ne.transformPosition && (I[U] = ne.transformPosition(I[U], K));
            break;
          }
          let de = 0;
          const _e = s.advancer(Y, (K, ce) => h(ce) ? ~(K - de) : K - de, (K, ce) => {
            h(ce) && de++;
          })(G);
          if (typeof G == "number" && (I[U] += de), !_e) break;
        }
      };
      return z != null ? Y.eachDrop(null, (U) => {
        U === z && ee();
      }) : ee(), I;
    }
    function S(I, x) {
      if (F2(I), F2(x), I == null) return x;
      if (x == null) return I;
      let Y = 0;
      const z = s.readCursor(I), B = s.readCursor(x), j = s.writeCursor(), Q = [], ee = [], U = [], G = [], X = [], ne = [], de = /* @__PURE__ */ new Set();
      z.traverse(null, (K) => {
        K.p != null && (U[K.p] = z.clone());
      }), B.traverse(null, (K) => {
        K.d != null && (G[K.d] = B.clone());
      });
      const _e = s.writeCursor();
      return function K(ce, Me, Ae, Re, Pe, $t, Qe, Ge) {
        o(Me || Ae);
        const Fe = a(Me), dt = a(Ae), It = !!dt && dt.r !== void 0, rn = !!Fe && Fe.i !== void 0, ft = Fe ? Fe.d : null, at = dt ? dt.p : null, Ht = ($t || It) && at == null;
        if (at != null) Re = G[at], Qe = ee[at] = new s.WriteCursor();
        else if (dt && dt.r !== void 0) Re = null;
        else {
          const se = a(Re);
          se && se.d != null && (Re = null);
        }
        const ve = a(Re);
        if (ft != null) if (ce = U[ft], Ge = Q[ft] = new s.WriteCursor(), Ht) $t && !It && Ge.write("r", true);
        else {
          const se = X[ft] = Y++;
          Qe.write("d", se);
        }
        else if (Fe && Fe.i !== void 0) ce = null;
        else {
          const se = a(ce);
          se && se.p != null && (ce = null);
        }
        let ae;
        rn ? (o(Pe === void 0), ae = Fe.i) : ae = Pe;
        const Ee = (at == null ? !rn || $t || It : ae === void 0) ? null : Qe.getComponent();
        if (at != null) {
          if (!(Pe !== void 0 || rn)) {
            const se = ft != null ? X[ft] : Y++;
            ne[at] = se, Ge.write("p", se);
          }
        } else It && (rn || Pe !== void 0 || (dt.r, Ge.write("r", dt.r)));
        const ue = Ht ? null : W(Fe), re = W(ve);
        if ((ue || re) && (ue && ue.name, re && re.name), ue && re) {
          o(ue === re);
          const se = w(Fe), Ce = w(ve), ze = ue.compose(se, Ce);
          C(Qe, ue, ze), de.add(ve);
        } else ue ? C(Qe, ue, w(Fe)) : re && (C(Qe, re, w(ve)), de.add(ve));
        const he = typeof ae == "object" && ae != null;
        let Oe = false, Se = 0, be = 0, Ye = 0, Be = 0, $e = 0;
        const Ze = s.advancer(Re, (se, Ce) => h(Ce) ? Be - se - 1 : se - Be, (se, Ce) => {
          h(Ce) && Be++;
        }), Ie = s.advancer(ce, (se, Ce) => c(Ce) ? Se - se - 1 : se - Se, (se, Ce) => {
          c(Ce) && Se++;
        });
        if (s.eachChildOf(Me, Ae, (se, Ce, ze) => {
          let nt, Bt, sn = se, wt = se, Xn = se;
          if (typeof se == "number") {
            let Ke = se + Ye;
            Bt = Ze(Ke), wt = Ke + Be;
            let He = se + be;
            nt = Ie(He), h(a(Bt)) && (nt = null), sn = He + Se, Xn = se + $e, o(sn >= 0, "p1PickKey is negative"), o(wt >= 0, "p2DropKey is negative");
            const St = h(a(Ce)), jt = c(a(ze));
            (St || jt && !Ht) && $e--, St && be--, jt && Ye--;
          } else nt = Ie(se), Bt = Ze(se);
          Ge.descend(sn), Qe.descend(wt);
          const Rn = he && !h(a(Ce)) ? ae[Xn] : void 0, Tt = K(nt, Ce, ze, Bt, Rn, Ht, Qe, Ge);
          var Mt, fe, De;
          he && !Ht ? Rn !== Tt && (Oe || (ae = Array.isArray(ae) ? ae.slice() : Object.assign({}, ae), Oe = true), Mt = ae, De = Tt, typeof (fe = Xn) == "number" ? (o(Array.isArray(Mt)), o(fe < Mt.length)) : (o(!Array.isArray(Mt)), o(Mt[fe] !== void 0)), De === void 0 ? typeof fe == "number" ? Mt.splice(fe, 1) : delete Mt[fe] : Mt[fe] = De) : o(Tt === void 0), Qe.ascend(), Ge.ascend();
        }), Ie.end(), Ze.end(), Ee != null) Ee.i = ae;
        else if (!$t && !It && at == null) return ae;
      }(z, z.clone(), B, B.clone(), void 0, false, j, _e), j.reset(), j.mergeTree(_e.get()), j.reset(), j.get(), Q.map((K) => K.get()), ee.map((K) => K.get()), z.traverse(j, (K, ce) => {
        const Me = K.p;
        if (Me != null) {
          const Ae = X[Me];
          Ae != null && ce.write("p", Ae);
          const Re = Q[Me];
          Re && Re.get(), Re && ce.mergeTree(Re.get());
        } else K.r !== void 0 && ce.write("r", K.r);
      }), j.reset(), j.get(), B.traverse(j, (K, ce) => {
        const Me = K.d;
        if (Me != null) {
          const Re = ne[Me];
          Re != null && ce.write("d", Re);
          const Pe = ee[Me];
          Pe && ce.mergeTree(Pe.get());
        } else K.i !== void 0 && ce.write("i", K.i);
        const Ae = W(K);
        Ae && !de.has(K) && C(ce, Ae, w(K));
      }), j.get();
    }
    function T(I) {
      if (I == null) return null;
      const x = new s.ReadCursor(I), Y = new s.WriteCursor();
      let z;
      const B = [], j = [];
      return function Q(ee, U, G) {
        const X = ee.getComponent();
        let ne, de = false;
        if (X) {
          X.p != null && (U.write("d", X.p), B[X.p] = ee.clone()), X.r !== void 0 && U.write("i", X.r), X.d != null && (U.write("p", X.d), G = void 0), X.i !== void 0 && (G = ne = X.i);
          const K = W(X);
          K && (G === void 0 ? (z || (z = /* @__PURE__ */ new Set()), z.add(X)) : (w(X), G = K.apply(G, w(X)), de = true));
        }
        let _e = 0;
        for (const K of ee) {
          U.descend(K);
          const ce = typeof K == "number" ? K - _e : K, Me = _(G, ce);
          h(ee.getComponent()) && _e++;
          const Ae = Q(ee, U, Me);
          if (G !== void 0 && Ae !== void 0) {
            if (de || (de = true, G = u(G)), !g(G, ce)) throw Error("Cannot modify child - invalid operation");
            G[ce] = Ae;
          }
          U.ascend();
        }
        if (ne === void 0) return de ? G : void 0;
        U.write("r", G);
      }(x, Y, void 0), z && (Y.reset(), function Q(ee, U, G) {
        const X = U.getComponent();
        if (X) {
          const K = X.d;
          if (K != null && (ee = B[K], G = j[K] = s.writeCursor()), z.has(X)) {
            const ce = W(X);
            if (!ce.invert) throw Error(`Cannot invert subtype ${ce.name}`);
            C(G, ce, ce.invert(w(X)));
          }
        }
        let ne = 0, de = 0;
        const _e = s.advancer(ee, (K, ce) => c(ce) ? ne - K - 1 : K - ne, (K, ce) => {
          c(ce) && ne++;
        });
        for (const K of U) if (typeof K == "number") {
          const ce = K - de, Me = _e(ce), Ae = ce + ne;
          G.descend(Ae), Q(Me, U, G), h(U.getComponent()) && de++, G.ascend();
        } else G.descend(K), Q(_e(K), U, G), G.ascend();
        _e.end();
      }(x.clone(), x, Y), j.length && (Y.reset(), x.traverse(Y, (Q, ee) => {
        const U = Q.p;
        if (U != null) {
          const G = j[U];
          G && G.get(), G && ee.mergeTree(G.get());
        }
      }))), Y.get();
    }
    const A = (I, x) => I.some((Y) => typeof Y == "object" && (Array.isArray(Y) ? A(Y, x) : x(Y)));
    function O(I, x) {
      if (I == null || !A(I, (U) => {
        var G;
        return U.r !== void 0 || ((G = W(U)) === null || G === void 0 ? void 0 : G.makeInvertible) != null;
      })) return I;
      const Y = new s.ReadCursor(I), z = new s.WriteCursor();
      let B = false;
      const j = [], Q = [], ee = (U, G, X) => {
        const ne = U.getComponent();
        let de = false;
        if (ne) {
          ne.d != null && G.write("d", ne.d), ne.i !== void 0 && G.write("i", ne.i);
          const K = ne.p;
          if (K != null && (j[K] = U.clone(), o(X !== void 0, "Operation picks up at an invalid key"), Q[K] = X, G.write("p", ne.p)), ne.r !== void 0 && X === void 0) throw Error("Invalid doc / op in makeInvertible: removed item missing from doc");
          const ce = W(ne);
          ce && (ce.makeInvertible ? B = true : C(G, ce, w(ne), true));
        }
        let _e = 0;
        for (const K of U) {
          G.descend(K);
          const ce = typeof K == "number" ? K - _e : K, Me = _(X, ce), Ae = ee(U, G, Me);
          Me !== Ae && (de || (de = true, X = u(X)), Ae === void 0 ? (X = d(X, ce), typeof K == "number" && _e++) : X[ce] = Ae), G.ascend();
        }
        return ne && (ne.r !== void 0 ? (G.write("r", r.default(X)), X = void 0) : ne.p != null && (X = void 0)), X;
      };
      return ee(Y, z, x), z.get(), B && (z.reset(), function U(G, X, ne, de, _e) {
        const K = X.getComponent();
        if (K) {
          K.i !== void 0 ? (de = K.i, _e = true) : K.d != null && (de = Q[K.d], G = j[K.d], _e = false, K.d);
          let Re = W(K);
          if (Re && Re.makeInvertible) {
            const Pe = w(K);
            C(ne, Re, Re.makeInvertible(Pe, de), true);
          }
        }
        let ce = 0, Me = 0;
        const Ae = s.advancer(G, (Re, Pe) => c(Pe) ? ce - Re - 1 : Re - ce, (Re, Pe) => {
          c(Pe) && ce++;
        });
        for (const Re of X) if (typeof Re == "number") {
          const Pe = Re - Me, $t = Ae(Pe), Qe = Pe + ce, Ge = _(de, _e ? Pe : Qe);
          ne.descend(Re), U($t, X, ne, Ge, _e), h(X.getComponent()) && Me++, ne.ascend();
        } else {
          const Pe = _(de, Re);
          ne.descend(Re), U(Ae(Re), X, ne, Pe, _e), ne.ascend();
        }
        Ae.end();
      }(Y.clone(), Y, z, x, false)), z.get();
    }
    function N(I, x) {
      return T(O(I, x));
    }
    const M = (I) => {
      if (I == null) return null;
      const x = I.slice();
      for (let Y = 0; Y < I.length; Y++) {
        const z = x[Y];
        Array.isArray(z) && (x[Y] = M(z));
      }
      return x;
    };
    function L(I, x, Y) {
      o(Y === "left" || Y === "right", "Direction must be left or right");
      const z = Y === "left" ? 0 : 1;
      if (x == null) return {
        ok: true,
        result: I
      };
      F2(I), F2(x);
      let B = null;
      const j = [], Q = [], ee = [], U = [], G = [], X = [], ne = [], de = [], _e = [], K = [], ce = [], Me = [], Ae = [], Re = [], Pe = [];
      let $t = 0;
      const Qe = s.readCursor(I), Ge = s.readCursor(x), Fe = s.writeCursor();
      if (function ve(ae, Ee = null, ue) {
        const re = a(Ee);
        re && (re.r !== void 0 ? ue = Ee.clone() : re.p != null && (ue = null, X[re.p] = ae.clone()));
        const he = ae.getComponent();
        let Oe;
        he && (Oe = he.p) != null && (G[Oe] = Ee ? Ee.clone() : null, ee[Oe] = ae.clone(), ue && (K[Oe] = true, _e[Oe] = ue), re && re.p != null && (Re[Oe] = re.p));
        const Se = s.advancer(Ee);
        for (const be of ae) ve(ae, Se(be), ue);
        Se.end();
      }(Ge, Qe, null), function ve(ae, Ee, ue, re, he) {
        const Oe = ue.getComponent();
        let Se, be = false;
        Oe && ((Se = Oe.d) != null ? (U[Se] = ue.clone(), re != null && (Pe[re] == null && (Pe[re] = []), Pe[re].push(Se)), K[Se], ae = G[Se] || null, Ee = ee[Se] || null, K[Se] ? (he && (ce[Se] = true), he = _e[Se] || null) : !he || z !== 1 && Re[Se] != null || B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.moveOp(Ee.getPath(), ue.getPath())
        }), be = true) : Oe.i !== void 0 && (ae = Ee = null, be = true, he && B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.insertOp(ue.getPath(), Oe.i)
        })));
        const Ye = a(ae);
        Ye && (Ye.r !== void 0 ? he = ae.clone() : Ye.p != null && (Ye.p, re = Ye.p, he = null));
        const Be = W(Oe);
        Be && he && B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.editOp(ue.getPath(), Be, w(Oe), true)
        });
        let $e = 0, Ze = 0;
        const Ie = s.advancer(Ee, (Ce, ze) => c(ze) ? $e - Ce - 1 : Ce - $e, (Ce, ze) => {
          c(ze) && $e++;
        }), se = s.advancer(ae);
        for (const Ce of ue) if (typeof Ce == "number") {
          const ze = Ce - Ze, nt = Ie(ze);
          Ze += +ve(se(ze + $e), nt, ue, re, he);
        } else {
          const ze = Ie(Ce);
          ve(se(Ce), ze, ue, re, he);
        }
        return Ie.end(), se.end(), be;
      }(Qe, Ge, Ge.clone(), null, null), U.map((ve) => ve && ve.get()), B) return {
        ok: false,
        conflict: B
      };
      ce.map((ve) => !!ve);
      const dt = [];
      let It = null;
      (function ve(ae, Ee, ue, re, he) {
        let Oe = false;
        const Se = a(Ee);
        if (c(Se)) {
          const Ie = Se.p;
          Ie != null ? (ue = U[Ie], re = Me[Ie] = s.writeCursor(), Oe = true, he = null) : (ue = null, he = Ee.clone());
        } else h(a(ue)) && (ue = null);
        const be = ae.getComponent();
        if (be) {
          const Ie = be.p;
          Ie != null ? (he && (de[Ie] = he), dt[Ie] = he || z === 1 && Oe ? null : re.getComponent(), j[Ie] = ae.clone(), ue && (ne[Ie] = ue.clone())) : be.r !== void 0 && (he || re.write("r", true), (he || Oe) && (It == null && (It = /* @__PURE__ */ new Set()), It.add(be)));
        }
        let Ye = 0, Be = 0;
        const $e = s.advancer(Ee, void 0, (Ie, se) => {
          c(se) && Ye++;
        }), Ze = s.advancer(ue, (Ie, se) => h(se) ? ~(Ie - Be) : Ie - Be, (Ie, se) => {
          h(se) && Be++;
        });
        if (ae) for (const Ie of ae) if (typeof Ie == "string") {
          const se = $e(Ie), Ce = Ze(Ie);
          re.descend(Ie), ve(ae, se, Ce, re, he), re.ascend();
        } else {
          const se = $e(Ie), Ce = Ie - Ye, ze = c(a(se)) ? null : Ze(Ce), nt = Ce + Be;
          o(nt >= 0), re.descend(nt), ve(ae, se, ze, re, he), re.ascend();
        }
        $e.end(), Ze.end();
      })(Qe, Ge, Ge.clone(), Fe, null), Fe.reset();
      let rn = [];
      if (function ve(ae, Ee, ue, re, he, Oe) {
        o(Ee);
        const Se = Ee.getComponent();
        let be = a(re), Ye = false;
        const Be = (fe, De, Ke) => fe ? e.moveOp(fe.getPath(), De.getPath()) : e.insertOp(De.getPath(), Ke.i);
        if (h(Se)) {
          const fe = Se.d;
          fe != null && (Q[fe] = Ee.clone());
          const De = fe != null ? dt[fe] : null;
          let Ke = false;
          if (Se.i !== void 0 || fe != null && De) {
            let He;
            be && (be.i !== void 0 || (He = be.d) != null && !K[He]) && (Ke = He != null ? fe != null && fe === Re[He] : n.default(be.i, Se.i), Ke || He != null && z !== 1 && Re[He] != null || B == null && (B = {
              type: i.ConflictType.DROP_COLLISION,
              op1: Be(fe != null ? j[fe] : null, Ee, Se),
              op2: Be(He != null ? ee[He] : null, re, be)
            })), Ke || (Oe ? B == null && (B = {
              type: i.ConflictType.RM_UNEXPECTED_CONTENT,
              op1: Be(fe != null ? j[fe] : null, Ee, Se),
              op2: e.removeOp(Oe.getPath())
            }) : (fe != null ? (rn[$t] = fe, he.write("d", De.p = $t++)) : he.write("i", r.default(Se.i)), Ye = true));
          } else if (fe != null && !De) {
            const He = de[fe];
            He && (Oe = He.clone());
          }
          fe != null ? (ae = j[fe], ue = X[fe], re = ne[fe]) : Se.i !== void 0 && (ae = ue = null, Ke || (re = null));
        } else c(a(ae)) && (ae = ue = re = null);
        const $e = a(ae), Ze = a(ue);
        if (c(Ze)) {
          const fe = Ze.p;
          Ze.r !== void 0 && (!$e || $e.r === void 0) || K[fe] ? (re = null, Oe = ue.clone()) : fe != null && (re = U[fe], z !== 1 && Re[fe] != null || ((he = Ae[fe]) || (he = Ae[fe] = s.writeCursor()), he.reset(), Oe = null));
        } else !h(Se) && h(be) && (re = null);
        be = re != null ? re.getComponent() : null;
        const Ie = W(Se);
        if (Ie) {
          const fe = w(Se);
          if (Oe) B == null && (B = {
            type: i.ConflictType.RM_UNEXPECTED_CONTENT,
            op1: e.editOp(Ee.getPath(), Ie, fe, true),
            op2: e.removeOp(Oe.getPath())
          });
          else {
            const De = W(be);
            let Ke;
            if (De) {
              if (Ie !== De) throw Error("Transforming incompatible types");
              const He = w(be);
              Ke = Ie.transform(fe, He, Y);
            } else Ke = r.default(fe);
            C(he, Ie, Ke);
          }
        }
        let se = 0, Ce = 0, ze = 0, nt = 0, Bt = 0, sn = 0, wt = ae != null && ae.descendFirst(), Xn = wt;
        const Rn = s.advancer(ue, void 0, (fe, De) => {
          c(De) && ze++;
        });
        let Tt = re != null && re.descendFirst(), Mt = Tt;
        for (const fe of Ee) if (typeof fe == "number") {
          let De;
          const Ke = h(Ee.getComponent()), He = fe - Ce;
          {
            let Gt;
            for (; wt && typeof (Gt = ae.getKey()) == "number"; ) {
              Gt += se;
              const Ot = ae.getComponent(), In = c(Ot);
              if (Gt > He || Gt === He && (!In || z === 0 && Ke)) break;
              if (In) {
                se--;
                const on = Ot.p;
                Re.includes(on), Ot.d, a(Ae[Ot.d]), c(a(Ae[Ot.d])), (Ot.r === void 0 || It && It.has(Ot)) && (on == null || !dt[on] || z !== 1 && Re.includes(on)) || Bt--;
              }
              wt = ae.nextSibling();
            }
            De = wt && Gt === He ? ae : null;
          }
          const St = He - se;
          let jt = Rn(St);
          const js = St - ze;
          let Tr = null;
          {
            let Gt, Ot;
            for (; Tt && typeof (Gt = re.getKey()) == "number"; ) {
              Ot = Gt - nt;
              const In = re.getComponent(), on = h(In);
              if (Ot > js) break;
              if (Ot === js) {
                if (!on) {
                  Tr = re;
                  break;
                }
                {
                  if (z === 0 && Ke) {
                    Tr = re;
                    break;
                  }
                  const Kt = jt && c(jt.getComponent());
                  if (z === 0 && Kt) break;
                }
              }
              if (on) {
                const Kt = In.d;
                K[Kt], Re[Kt], In.i === void 0 && (K[Kt] || Re[Kt] != null && z !== 1) ? (K[Kt] || Re[Kt] != null && z === 0) && (nt++, sn--) : nt++;
              }
              Tt = re.nextSibling();
            }
          }
          const ta = js + nt + Bt + sn;
          o(ta >= 0, "trying to descend to a negative index"), he.descend(ta), Ke && (De = jt = Tr = null, Ce++), ve(De, Ee, jt, Tr, he, Oe) && sn++, he.ascend();
        } else {
          let De;
          for (; wt && (De = ae.getKey(), typeof De != "string" || !(De > fe || De === fe)); ) wt = ae.nextSibling();
          const Ke = wt && De === fe ? ae : null, He = Rn(fe);
          let St;
          for (; Tt && (St = re.getKey(), typeof St != "string" || !(St > fe || St === fe)); ) Tt = re.nextSibling();
          const jt = Tt && St === fe ? re : null;
          he.descend(fe), ve(Ke, Ee, He, jt, he, Oe), he.ascend();
        }
        return Rn.end(), Xn && ae.ascend(), Mt && re.ascend(), Ye;
      }(Qe, Qe.clone(), Ge, Ge.clone(), Fe, null), B) return {
        ok: false,
        conflict: B
      };
      Fe.reset();
      const ft = (ve, ae, Ee) => ve.traverse(ae, (ue, re) => {
        ue.d != null && Ee(ue.d, ve, re);
      });
      (K.length || Me.length) && (ft(Ge, Fe, (ve, ae, Ee) => {
        K[ve] && !ce[ve] && Ee.write("r", true), Me[ve] && Ee.mergeTree(Me[ve].get());
      }), Fe.reset());
      const at = [], Ht = [];
      if ((Ae.length || K.length) && !B) {
        const ve = s.readCursor(M(Fe.get()));
        if (ft(ve, null, (ae, Ee) => {
          at[ae] = Ee.clone();
        }), Ae.forEach((ae) => {
          ae && ft(s.readCursor(ae.get()), null, (Ee, ue) => {
            at[Ee] = ue.clone();
          });
        }), function ae(Ee, ue, re, he, Oe, Se) {
          const be = a(ue);
          if (be && c(be)) if (be.p != null) {
            const se = be.p;
            at[se].getPath(), re = at[se], he = Ht[se] = s.writeCursor();
          } else be.r !== void 0 && (re = null);
          else h(a(re)) && (re = null);
          const Ye = Ee.getComponent();
          if (Ye) {
            let se;
            if ((se = Ye.d) != null) {
              const Ce = Ae[se];
              Ce && (Ce.get(), he.mergeTree(Ce.get()), re = s.readCursor(Ce.get()));
            }
          }
          let Be = 0, $e = 0;
          const Ze = s.advancer(ue, void 0, (se, Ce) => {
            c(Ce) && Be--;
          }), Ie = s.advancer(re, (se, Ce) => h(Ce) ? -(se - $e) - 1 : se - $e, (se, Ce) => {
            h(Ce) && $e++;
          });
          for (const se of Ee) if (typeof se == "number") {
            const Ce = Ze(se), ze = se + Be, nt = Ie(ze), Bt = ze + $e;
            he.descend(Bt), ae(Ee, Ce, nt, he), he.ascend();
          } else he.descend(se), ae(Ee, Ze(se), Ie(se), he), he.ascend();
          Ze.end(), Ie.end();
        }(Ge, ve, ve.clone(), Fe), Fe.reset(), B) return {
          ok: false,
          conflict: B
        };
        if (Fe.get(), Ht.length) {
          const ae = Ht.map((ue) => ue ? ue.get() : null), Ee = s.readCursor(M(Fe.get()));
          if (ft(Ee, Fe, (ue, re, he) => {
            const Oe = ae[ue];
            Oe && (he.mergeTree(Oe), ae[ue] = null);
          }), ae.find((ue) => ue)) {
            const ue = s.writeCursor(), re = s.writeCursor();
            let he = 0, Oe = 0;
            ae.forEach((Se) => {
              Se != null && ft(s.readCursor(Se), null, (be) => {
                const Ye = rn[be];
                ue.writeMove(j[Ye].getPath(), Q[Ye].getPath(), he++);
                const Be = Pe[Ye];
                Be && Be.forEach(($e) => {
                  K[$e] || z !== 1 && Re[$e] != null || re.writeMove(ee[$e].getPath(), U[$e].getPath(), Oe++);
                });
              });
            }), B = {
              type: i.ConflictType.BLACKHOLE,
              op1: ue.get(),
              op2: re.get()
            };
          }
        }
      }
      return B ? {
        ok: false,
        conflict: B
      } : {
        ok: true,
        result: Fe.get()
      };
    }
    const k = (I) => {
      const x = new Error("Transform detected write conflict");
      throw x.conflict = I, x.type = x.name = "writeConflict", x;
    };
    function q(I, x, Y) {
      const z = L(I, x, Y);
      if (z.ok) return z.result;
      k(z.conflict);
    }
    const V = (I) => {
      const x = s.writeCursor();
      return s.readCursor(I).traverse(x, (Y, z) => {
        (h(Y) || W(Y)) && z.write("r", true);
      }), x.get();
    }, oe = (I, x) => {
      const { type: Y, op1: z, op2: B } = I;
      switch (Y) {
        case i.ConflictType.DROP_COLLISION:
          return x === "left" ? [null, V(B)] : [V(z), null];
        case i.ConflictType.RM_UNEXPECTED_CONTENT:
          let j = false;
          return s.readCursor(z).traverse(null, (Q) => {
            Q.r !== void 0 && (j = true);
          }), j ? [null, V(B)] : [V(z), null];
        case i.ConflictType.BLACKHOLE:
          return [V(z), V(B)];
        default:
          throw Error("Unrecognised conflict: " + Y);
      }
    };
    function le(I, x, Y, z) {
      let B = null;
      for (; ; ) {
        const j = L(x, Y, z);
        if (j.ok) return S(B, j.result);
        {
          const { conflict: Q } = j;
          I(Q) || k(Q);
          const [ee, U] = oe(Q, z);
          x = S($(x), ee), Y = S($(Y), U), B = S(B, U);
        }
      }
    }
  }(Zn)), Zn;
}
var Ma;
function hg() {
  return Ma || (Ma = 1, function(e) {
    var t = an && an.__createBinding || (Object.create ? function(i, o, a, l) {
      l === void 0 && (l = a), Object.defineProperty(i, l, { enumerable: true, get: function() {
        return o[a];
      } });
    } : function(i, o, a, l) {
      l === void 0 && (l = a), i[l] = o[a];
    }), n = an && an.__exportStar || function(i, o) {
      for (var a in i) a !== "default" && !o.hasOwnProperty(a) && t(o, i, a);
    };
    Object.defineProperty(e, "__esModule", { value: true }), n(cg(), e);
    var r = hu();
    Object.defineProperty(e, "ReadCursor", { enumerable: true, get: function() {
      return r.ReadCursor;
    } }), Object.defineProperty(e, "WriteCursor", { enumerable: true, get: function() {
      return r.WriteCursor;
    } });
    var s = du();
    Object.defineProperty(e, "ConflictType", { enumerable: true, get: function() {
      return s.ConflictType;
    } });
  }(an)), an;
}
var it = hg();
var dg = Rt(it);
var p1 = Tc({
  __proto__: null,
  default: dg
}, [it]);
var pe = ((e) => (e[e.COVER = 0] = "COVER", e[e.REPLACE = 1] = "REPLACE", e))(pe || {});
var Z = ((e) => (e.RETAIN = "r", e.INSERT = "i", e.DELETE = "d", e))(Z || {});
var Nr = createIdentifier("univer.context-service");
var fg = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_contextChanged$", new Subject());
    p(this, "contextChanged$", this._contextChanged$.asObservable());
    p(this, "_contextMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._contextChanged$.complete(), this._contextMap.clear();
  }
  getContextValue(n) {
    var r;
    return (r = this._contextMap.get(n)) != null ? r : false;
  }
  setContextValue(n, r) {
    this._contextMap.set(n, r), this._contextChanged$.next({ [n]: r });
  }
  subscribeContextValue$(n) {
    return new Observable((r) => {
      const s = this._contextChanged$.pipe(filter((i) => typeof i[n] < "u")).subscribe((i) => r.next(i[n]));
      return this._contextMap.has(n) && r.next(this._contextMap.get(n)), () => s.unsubscribe();
    });
  }
};
var mg = ((e) => (e[e.SILENT = 0] = "SILENT", e[e.ERROR = 1] = "ERROR", e[e.WARN = 2] = "WARN", e[e.INFO = 3] = "INFO", e[e.VERBOSE = 4] = "VERBOSE", e))(mg || {});
var yt = createIdentifier("univer.log");
var gg = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_logLevel", 3);
    p(this, "_deduction", /* @__PURE__ */ new Set());
  }
  dispose() {
    super.dispose(), this._logLevel = 3, this._deduction.clear();
  }
  debug(...n) {
    this._logLevel >= 4 && this._log(console.debug, ...n);
  }
  log(...n) {
    this._logLevel >= 3 && this._log(console.log, ...n);
  }
  warn(...n) {
    this._logLevel >= 2 && this._log(console.warn, ...n);
  }
  error(...n) {
    this._logLevel >= 1 && this._log(console.error, ...n);
  }
  deprecate(...n) {
    this._logLevel >= 2 && this._logWithDeduplication(console.error, ...n);
  }
  setLogLevel(n) {
    this._logLevel = n;
  }
  _log(n, ...r) {
    const s = r[0];
    /^\[(.*?)\]/g.test(s) ? n(`\x1B[97;104m${s}\x1B[0m`, ...r.slice(1)) : n(...r);
  }
  _logWithDeduplication(n, ...r) {
    const s = _g(...r);
    this._deduction.has(s) || (this._deduction.add(s), this._log(n, ...r));
  }
};
function _g(...e) {
  return e.map((t) => JSON.stringify(t)).join("");
}
var pg = Object.getOwnPropertyDescriptor;
var Eg = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? pg(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var La = (e, t) => (n, r) => t(n, r, e);
var Ms = ((e) => (e[e.COMMAND = 0] = "COMMAND", e[e.OPERATION = 1] = "OPERATION", e[e.MUTATION = 2] = "MUTATION", e))(Ms || {});
var Ls = createIdentifier("univer.core.command-service");
var Cg = class {
  constructor() {
    p(this, "_commands", /* @__PURE__ */ new Map());
    p(this, "_commandTypes", /* @__PURE__ */ new Map());
  }
  registerCommand(t) {
    if (this._commands.has(t.id))
      throw new Error(`[CommandRegistry]: command "${t.id}" has been registered before.`);
    return this._commands.set(t.id, t), this._commandTypes.set(t.id, t.type), We(() => {
      this.unregisterCommand(t.id);
    });
  }
  unregisterCommand(t) {
    this._commands.delete(t), this._commandTypes.delete(t);
  }
  hasCommand(t) {
    return this._commands.has(t);
  }
  getCommand(t) {
    return this._commands.has(t) ? [this._commands.get(t)] : null;
  }
  getCommandType(t) {
    return this._commandTypes.get(t);
  }
};
var Rg = {
  id: "nil",
  type: 0,
  handler: () => true
};
var vi = class extends Ve {
  constructor(t, n) {
    super();
    p(this, "_commandRegistry");
    p(this, "_beforeCommandExecutionListeners", []);
    p(this, "_commandExecutedListeners", []);
    p(this, "_multiCommandDisposables", /* @__PURE__ */ new Map());
    p(this, "_commandExecutingLevel", 0);
    p(this, "_commandExecutionStack", []);
    this._injector = t, this._logService = n, this._commandRegistry = new Cg(), this.registerCommand(Rg);
  }
  dispose() {
    super.dispose(), this._commandExecutedListeners.length = 0, this._beforeCommandExecutionListeners.length = 0;
  }
  hasCommand(t) {
    return this._commandRegistry.hasCommand(t);
  }
  registerCommand(t) {
    return this._commandRegistry.registerCommand(t);
  }
  unregisterCommand(t) {
    var n;
    this._commandRegistry.unregisterCommand(t), (n = this._multiCommandDisposables.get(t)) == null || n.dispose();
  }
  registerMultipleCommand(t) {
    return this._registerMultiCommand(t);
  }
  beforeCommandExecuted(t) {
    if (this._beforeCommandExecutionListeners.indexOf(t) === -1)
      return this._beforeCommandExecutionListeners.push(t), We(() => {
        const n = this._beforeCommandExecutionListeners.indexOf(t);
        this._beforeCommandExecutionListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  onCommandExecuted(t) {
    if (this._commandExecutedListeners.indexOf(t) === -1)
      return this._commandExecutedListeners.push(t), We(() => {
        const n = this._commandExecutedListeners.indexOf(t);
        this._commandExecutedListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  async executeCommand(t, n, r) {
    try {
      const s = this._commandRegistry.getCommand(t);
      if (s) {
        const [i] = s, o = {
          id: i.id,
          type: i.type,
          params: n
        }, a = this._pushCommandExecutionStack(o), l = r != null ? r : {};
        this._beforeCommandExecutionListeners.forEach((c) => c(o, l));
        const u = await this._execute(i, n, l);
        return this._commandExecutedListeners.forEach((c) => c(o, l)), a.dispose(), u;
      }
      throw new Error(`[CommandService]: command "${t}" is not registered.`);
    } catch (s) {
      if (s instanceof _i)
        return false;
      throw s;
    }
  }
  syncExecuteCommand(t, n, r) {
    var s;
    try {
      const i = this._commandRegistry.getCommand(t);
      if (i) {
        const [o] = i, a = {
          id: o.id,
          type: o.type,
          params: n
        };
        if (o.type === 2) {
          const h = Uc(
            this._commandExecutionStack,
            (d) => d.type === 0
            /* COMMAND */
          );
          h && (a.params = (s = a.params) != null ? s : {}, a.params.trigger = h.id);
        }
        const l = this._pushCommandExecutionStack(a), u = r != null ? r : {};
        this._beforeCommandExecutionListeners.forEach((h) => h(a, u));
        const c = this._syncExecute(o, n, u);
        return this._commandExecutedListeners.forEach((h) => h(a, u)), l.dispose(), c;
      }
      throw new Error(`[CommandService]: command "${t}" is not registered.`);
    } catch (i) {
      if (i instanceof _i)
        return false;
      throw i;
    }
  }
  _pushCommandExecutionStack(t) {
    return this._commandExecutionStack.push(t), We(() => Os(this._commandExecutionStack, t));
  }
  _registerMultiCommand(t) {
    const n = this._commandRegistry.getCommand(t.id);
    let r;
    if (n) {
      if (n[0].multi !== true)
        throw new Error("Command has registered as a single command.");
      r = n[0];
    } else {
      r = new Ig(t.id);
      const i = new ao();
      i.add(this._commandRegistry.registerCommand(r)), i.add(
        We(() => {
          this._multiCommandDisposables.delete(t.id);
        })
      ), this._multiCommandDisposables.set(t.id, i);
    }
    const s = r.registerImplementation(t);
    return We(() => {
      var i;
      s.dispose(), r.hasImplementations() || (i = this._multiCommandDisposables.get(t.id)) == null || i.dispose();
    });
  }
  async _execute(t, n, r) {
    this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(this._commandExecutingLevel, 0))}executing command "${t.id}"`
    ), this._commandExecutingLevel++;
    let s;
    try {
      s = await this._injector.invoke(t.handler, n, r), this._commandExecutingLevel--;
    } catch (i) {
      throw s = false, this._commandExecutingLevel = 0, i;
    }
    return s;
  }
  _syncExecute(t, n, r) {
    this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(0, this._commandExecutingLevel))}executing command "${t.id}".`
    ), this._commandExecutingLevel++;
    let s;
    try {
      if (s = this._injector.invoke(t.handler, n, r), s instanceof Promise)
        throw new TypeError("[CommandService]: Command handler should not return a promise.");
      this._commandExecutingLevel--;
    } catch (i) {
      throw s = false, this._commandExecutingLevel = 0, i;
    }
    return s;
  }
};
vi = Eg([
  La(0, Inject(Injector)),
  La(1, yt)
], vi);
var Ig = class {
  constructor(t) {
    p(this, "name");
    p(this, "multi", true);
    p(this, "type", 0);
    p(this, "priority", 0);
    p(this, "_implementations", []);
    p(this, "handler", async (t2, n) => {
      if (!this._implementations.length)
        return false;
      const r = t2.get(yt), s = t2.get(Nr), i = t2.get(Injector);
      for (const o of this._implementations) {
        const a = o.command.preconditions;
        if ((!a || a && a(s)) && (r.debug("[MultiCommand]", `executing implementation "${o.command.name}".`), await i.invoke(o.command.handler, n)))
          return true;
      }
      return false;
    });
    this.id = t, this.name = t;
  }
  registerImplementation(t) {
    const n = { command: t };
    return this._implementations.push(n), this._implementations.sort((r, s) => s.command.priority - r.command.priority), We(() => {
      const r = this._implementations.indexOf(n);
      this._implementations.splice(r, 1);
    });
  }
  hasImplementations() {
    return this._implementations.length > 0;
  }
};
function fo(e, t, n) {
  const r = e.map((s) => () => t.syncExecuteCommand(s.id, s.params, n));
  return em(r);
}
function E1(e, t, n) {
  const r = e.map((s) => () => t.executeCommand(s.id, s.params, n));
  return Qf(r);
}
function wg(e) {
  return new Observable((t) => {
    const n = e((...r) => t.next(r));
    return () => n == null ? void 0 : n.dispose();
  });
}
function xa(e) {
  return function(n) {
    return new Observable((r) => (n.subscribe({
      next: (s) => {
        r.next(s), e(s) && r.complete();
      },
      complete: () => r.complete(),
      error: (s) => r.error(s)
    }), () => r.unsubscribe()));
  };
}
function C1(e = 0) {
  return (t) => {
    let n = [];
    return t.pipe(
      tap((r) => n.push(r)),
      debounceTime(e),
      map(() => n),
      tap(() => n = [])
    );
  };
}
function R1(e) {
  const t = new ReplaySubject(1);
  return setTimeout(() => t.next(), e), t.pipe(take(1));
}
function I1(e, t) {
  const n = new BehaviorSubject(t);
  return e.subscribe(n), n;
}
var w1 = (e) => new Promise((t) => {
  merge(
    wg(e.onCommandExecuted.bind(e)).pipe(filter(([n]) => n.type === Ms.MUTATION)),
    timer(300)
  ).pipe(debounceTime(16), first()).subscribe(() => {
    t();
  });
});
function Sg(e, t) {
  let n = 0, r = e.length - 1;
  if (t < e[0]) return 0;
  if (t >= e[e.length - 1]) return e.length - 1;
  for (; n <= r; ) {
    if (e[n] === t) {
      for (; n < e.length && e[n] === t; )
        n++;
      return n;
    }
    if (t > e[n] && t < e[n + 1])
      return n + 1;
    if (e[r] === t) {
      for (; r < e.length && e[r] === t; )
        r++;
      return r;
    }
    if (t > e[r - 1] && t < e[r])
      return r;
    n++, r--;
  }
  return -1;
}
function S1(e, t) {
  let n = 0, r = e.length - 1;
  for (; n <= r; ) {
    const s = Math.floor((r + n) / 2);
    if (t < e[s] && (s === 0 || t >= e[s - 1]))
      return s;
    if (t >= e[s])
      n = s + 1;
    else if (t < e[s])
      r = s - 1;
    else
      return -1;
  }
  return -1;
}
function Og(e, t) {
  let n = 0, r = e.length;
  for (; n < r; ) {
    const s = Math.floor((n + r) / 2);
    e[s] <= t ? n = s + 1 : r = s;
  }
  return n < e.length ? n : e.length - 1;
}
function Pr(e, t, n = false) {
  let r = e.length - 1;
  if (t < 0 || t < e[0])
    return 0;
  if (e.length < 40 || t <= e[20] || t >= e[r - 20] ? r = Sg(e, t) : r = Og(e, t), n) {
    const s = e[r];
    return e.indexOf(s);
  }
  return r;
}
function O1(e) {
  const t = new Blob([e], { type: "text/javascript" });
  return window.URL.createObjectURL(t);
}
var Fr = 2;
var vg = 1;
function v1(e, t) {
  if (t == null || e == null)
    return true;
  const { left: n = 0, top: r = 0, height: s = 0, width: i = 0, angle: o = 0 } = t, { left: a = 0, top: l = 0, height: u = 0, width: c = 0, angle: h = 0 } = e, d = c, f = u, g = i, _ = s;
  return Math.abs(a - n) > Fr || Math.abs(l - r) > Fr || Math.abs(d - g) > Fr || Math.abs(f - _) > Fr || Math.abs(h - o) > vg;
}
function Qs(e, t, n) {
  const { dataStream: r, textRuns: s = [] } = e;
  let i = t;
  const o = [];
  for (const a of s) {
    const { st: l, ed: u } = a;
    J.hasIntersectionBetweenTwoRanges(t, n, l, u) && (l > i ? (o.push(r.slice(i, l)), o.push(Da(r, {
      ...a,
      ed: Math.min(u, n)
    }))) : o.push(Da(r, {
      ...a,
      st: i,
      ed: Math.min(u, n)
    }))), i = Math.max(t, Math.min(u, n));
  }
  return i !== n && o.push(r.slice(i, n)), o.join("");
}
function b1(e, t = true) {
  var n;
  if (t && ((n = e.paragraphs) != null && n.length)) {
    const { dataStream: r, paragraphs: s = [] } = e;
    let i = "", o = -1;
    for (const a of s) {
      const { startIndex: l, paragraphStyle: u = {} } = a, { spaceAbove: c, spaceBelow: h, lineSpacing: d } = u, f = [];
      c != null && (typeof c == "number" ? f.push(`margin-top: ${c}px`) : f.push(`margin-top: ${c.v}px`)), h != null && (typeof h == "number" ? f.push(`margin-bottom: ${h}px`) : f.push(`margin-bottom: ${h.v}px`)), d != null && f.push(`line-height: ${d}`), l > o + 1 ? i += `<p class="UniverNormal" ${f.length ? `style="${f.join("; ")};"` : ""}>${Qs(e, o + 1, l)}</p>` : i += `<p class="UniverNormal" ${f.length ? `style="${f.join("; ")};"` : ""}></p>`, o = l;
    }
    return o !== r.length && (i += Qs(e, o, r.length)), i;
  } else
    return Qs(e, 0, e.dataStream.length);
}
function Da(e, t) {
  const { st: n, ed: r, ts: s = {} } = t, { ff: i, fs: o, it: a, bl: l, ul: u, st: c, ol: h, bg: d, cl: f, va: g } = s;
  let _ = e.slice(n, r);
  const R = [];
  return a === ie.TRUE && (_ = `<i>${_}</i>`), g === Zt.SUPERSCRIPT ? _ = `<sup>${_}</sup>` : g === Zt.SUBSCRIPT && (_ = `<sub>${_}</sub>`), (u == null ? void 0 : u.s) === ie.TRUE && (_ = `<u>${_}</u>`), (c == null ? void 0 : c.s) === ie.TRUE && (_ = `<s>${_}</s>`), l === ie.TRUE && (_ = `<strong>${_}</strong>`), i && R.push(`font-family: ${i}`), f && R.push(`color: ${f.rgb}`), o && R.push(`font-size: ${o}pt`), h && R.push("text-decoration: overline"), d && R.push(`background: ${d.rgb}`), R.length ? `<span style="${R.join("; ")};">${_}</span>` : _;
}
var bg = {
  [co.OFFICE]: {
    [st.ACCENT1]: "#4472C4",
    [st.ACCENT2]: "#ED7D31",
    [st.ACCENT3]: "#A5A5A5",
    [st.ACCENT4]: "#70AD47",
    [st.ACCENT5]: "#5B9BD5",
    [st.ACCENT6]: "#70AD47",
    [st.DARK1]: "#000000",
    [st.DARK2]: "#44546A",
    [st.LIGHT1]: "#FFFFFF",
    [st.LIGHT2]: "#E7E6E6",
    [st.HYPERLINK]: "#0563C1",
    [st.FOLLOWED_HYPERLINK]: "#954F72"
  }
};
var mo = class {
  constructor() {
    p(this, "_themeValue", st.LIGHT1);
    p(this, "_themeColors");
    p(this, "_themeTint");
    p(this, "_rgbValue", "");
    p(this, "_colorType");
    this._colorType = At.UNSUPPORTED, this._themeColors = co.OFFICE, this._themeTint = 0;
  }
  asRgbColor() {
    return new bi(this._rgbValue, this);
  }
  asThemeColor() {
    return new Ai(this._themeValue, this._themeTint, this._themeColors, this);
  }
  build() {
    switch (this._colorType) {
      case At.THEME:
        return this.asThemeColor();
      case At.RGB:
        return this.asRgbColor();
      case At.UNSUPPORTED:
        throw new Error("unsupported color type");
    }
  }
  setRgbColor(t) {
    return this._colorType = At.RGB, this._rgbValue = t, this;
  }
  setThemeColors(t) {
    this._colorType = At.THEME, this._themeColors = t;
  }
  setThemeTint(t) {
    this._colorType = At.THEME, this._themeTint = t;
  }
  setThemeColor(t) {
    return this._colorType = At.THEME, this._themeValue = t, this;
  }
  getColorType() {
    return this._colorType;
  }
};
var jn = class _jn {
  constructor(t) {
    p(this, "_builder");
    this._builder = t;
  }
  static rgbColorToHexValue(t) {
    return `#${((1 << 24) + (t.getRed() << 16) + (t.getGreen() << 8) + t.getBlue()).toString(16).slice(1)}`;
  }
  static hexValueToRgbColor(t) {
    t ? t.indexOf("#") > -1 && (t = t.substring(1)) : t = "#000000";
    const n = +`0x${t[0]}${t[1]}`, r = +`0x${t[2]}${t[3]}`, s = +`0x${t[4]}${t[5]}`;
    return new mo().setRgbColor(`rgb(${n},${r},${s})`).asRgbColor();
  }
  static hexToRgbString(t) {
    const n = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    t = t.replace(n, (i, o, a, l) => o + o + a + a + l + l);
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    let s = null;
    if (r) {
      const i = Number.parseInt(r[1], 16), o = Number.parseInt(r[2], 16), a = Number.parseInt(r[3], 16);
      s = `rgba(${i},${o},${a})`;
    }
    return s;
  }
  asRgbColor() {
    return this._builder.asRgbColor();
  }
  asThemeColor() {
    return this._builder.asThemeColor();
  }
  getColorType() {
    return this._builder.getColorType();
  }
  clone() {
    return new _jn(this._builder);
  }
  equals(t) {
    return false;
  }
};
var Ag = class {
  constructor(t) {
    p(this, "_saturation", 0);
    p(this, "_hue", 0);
    p(this, "_lightness", 0);
    p(this, "_alpha", 0);
    const n = t.getRed() / 255, r = t.getGreen() / 255, s = t.getBlue() / 255, i = t.getAlpha() / 255, o = Math.min(n, Math.min(r, s)), a = Math.max(n, Math.max(r, s)), l = a - o;
    if (a === o) {
      this._hue = 0, this._saturation = 0, this._lightness = a;
      return;
    }
    this._lightness = (o + a) / 2, this._lightness < 0.5 ? this._saturation = l / (a + o) : this._saturation = l / (2 - a - o), n === a && (this._hue = (r - s) / l), r === a && (this._hue = 2 + (s - n) / l), s === a && (this._hue = 4 + (n - r) / l), this._hue *= 60, this._hue < 0 && (this._hue += 360), this._alpha = i;
  }
  asRgbColor() {
    const t = new mo();
    if (this._saturation === 0)
      return t.setRgbColor(
        `rgba(${this._lightness * 255},${this._lightness * 255},${this._lightness * 255},${this._alpha * 255})`
      ), t.asRgbColor();
    let n;
    this._lightness < 0.5 ? n = this._lightness * (1 + this._saturation) : n = this._lightness + this._saturation - this._lightness * this._saturation;
    const r = 2 * this._lightness - n, s = this._hue / 360, i = s + 1 / 3, o = this.setColor(n, r, i), a = this.setColor(n, r, s), l = s - 1 / 3, u = this.setColor(n, r, l);
    return t.setRgbColor(
      `rgba(${Math.round(o * 255)},${Math.round(a * 255)},${Math.round(u * 255)},${this._alpha * 255})`
    ), t.asRgbColor();
  }
  getLightness() {
    return this._lightness;
  }
  getHue() {
    return this._hue;
  }
  getSaturation() {
    return this._saturation;
  }
  getAlpha() {
    return this._alpha;
  }
  setColor(t, n, r) {
    r < 0 && (r += 1), r > 1 && (r -= 1);
    let s;
    return 6 * r < 1 ? s = n + (t - n) * 6 * r : 2 * r < 1 ? s = t : 3 * r < 2 ? s = n + (t - n) * (2 / 3 - r) * 6 : s = n, s;
  }
  setLightness(t) {
    this._lightness = t;
  }
};
var _t = class _t2 extends jn {
  constructor(n, r) {
    super(r);
    p(this, "_cssString");
    p(this, "_red");
    p(this, "_green");
    p(this, "_blue");
    p(this, "_alpha");
    let s = n.match(_t2.RGBA_EXTRACT);
    if (s) {
      const i = +s[1], o = +s[2], a = +s[3], l = +s[4];
      this._cssString = n, this._red = i, this._green = o, this._blue = a, this._alpha = l;
      return;
    }
    if (s = n.match(_t2.RGB_EXTRACT), s) {
      const i = +s[1], o = +s[2], a = +s[3];
      this._cssString = n, this._red = i, this._green = o, this._blue = a, this._alpha = 1;
      return;
    }
    throw new Error("Invalid rgba or rgb color");
  }
  asHexString() {
    return jn.rgbColorToHexValue(this);
  }
  getRed() {
    let n = this._red + _t2.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getGreen() {
    let n = this._green + _t2.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getBlue() {
    let n = this._blue + _t2.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getAlpha() {
    return this._alpha;
  }
  getColorType() {
    return At.RGB;
  }
  clone() {
    return new _t2(this._cssString, this._builder);
  }
  asThemeColor() {
    throw new Error("rgb color not support to themeColor");
  }
  equals(n) {
    return n instanceof _t2 ? n._red === this._red && n._blue === this._blue && n._green === this._green && n._alpha === this._alpha : false;
  }
  getCssString() {
    return this._cssString;
  }
};
p(_t, "RGB_COLOR_AMT", 0), p(_t, "RGBA_EXTRACT", new RegExp(
  "\\s*rgba\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d.\\d|\\d\\s*)\\)\\s*"
)), p(_t, "RGB_EXTRACT", new RegExp("\\s*rgb\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*)\\)\\s*"));
var bi = _t;
var qt = class qt2 extends jn {
  constructor(n, r, s, i) {
    super(i);
    p(this, "_themeColorType");
    p(this, "_themeTint");
    p(this, "_themeColors");
    this._themeColorType = n, this._themeTint = r, this._themeColors = s;
  }
  lumValue(n, r) {
    if (n == null)
      return r;
    let s;
    return n < 0 ? s = r * (1 + n) : s = r * (1 - n) + (255 - 255 * (1 - n)), s;
  }
  asRgbColor() {
    const n = bg[this._themeColors];
    if (n == null)
      throw new Error("not find themeColors type");
    const r = n[this._themeColorType];
    if (r == null)
      throw new Error("not find themeColors value");
    let s;
    if (qt2._cacheThemeColor.has(this._themeColors)) {
      if (s = qt2._cacheThemeColor.get(this._themeColors), s.has(this._themeColorType))
        return s.get(this._themeColorType);
    } else
      s = /* @__PURE__ */ new Map(), qt2._cacheThemeColor.set(this._themeColors, s);
    const i = new Ag(jn.hexValueToRgbColor(r));
    i.setLightness(this.lumValue(this._themeTint, i.getLightness() * 255) / 255);
    const o = i.asRgbColor();
    return s.set(this._themeColorType, o), o;
  }
  clone() {
    return new qt2(this._themeColorType, this._themeTint, this._themeColors, this._builder);
  }
  equals(n) {
    return n instanceof qt2 ? n._themeColorType === this._themeColorType : false;
  }
  getColorType() {
    return At.THEME;
  }
  getThemeColorType() {
    return this._themeColorType;
  }
};
p(qt, "_cacheThemeColor", /* @__PURE__ */ new Map());
var Ai = qt;
var A1 = "rgb(";
var y1 = "rgba(";
var Ua = {
  aliceBlue: [240, 248, 255],
  antiqueWhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blancheAlmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueViolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlyWood: [222, 184, 135],
  cadetBlue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornFlowerBlue: [100, 149, 237],
  cornSilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkBlue: [0, 0, 139],
  darkCyan: [0, 139, 139],
  darkGoldenrod: [184, 132, 11],
  darkGray: [169, 169, 169],
  darkGreen: [0, 100, 0],
  darkGrey: [169, 169, 169],
  darkKhaki: [189, 183, 107],
  darkMagenta: [139, 0, 139],
  darkOliveGreen: [85, 107, 47],
  darkOrange: [255, 140, 0],
  darkOrchid: [153, 50, 204],
  darkRed: [139, 0, 0],
  darkSalmon: [233, 150, 122],
  darkSeaGreen: [143, 188, 143],
  darkSlateBlue: [72, 61, 139],
  darkSlateGray: [47, 79, 79],
  darkSlateGrey: [47, 79, 79],
  darkTurquoise: [0, 206, 209],
  darkViolet: [148, 0, 211],
  darkYellow: [139, 128, 0],
  deepPink: [255, 20, 147],
  deepSkyBlue: [0, 191, 255],
  dimGray: [105, 105, 105],
  dimGrey: [105, 105, 105],
  dodgerBlue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralWhite: [255, 255, 240],
  forestGreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostWhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenYellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotPink: [255, 105, 180],
  indianRed: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderBlush: [255, 240, 245],
  lawnGreen: [124, 252, 0],
  lemonChiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightCoral: [240, 128, 128],
  lightCyan: [224, 255, 255],
  lightGoldenrodYellow: [250, 250, 210],
  lightGray: [211, 211, 211],
  lightGreen: [144, 238, 144],
  lightGrey: [211, 211, 211],
  lightPink: [255, 182, 193],
  lightSalmon: [255, 160, 122],
  lightSeaGreen: [32, 178, 170],
  lightSkyBlue: [135, 206, 250],
  lightSlateGray: [119, 136, 153],
  lightSlateGrey: [119, 136, 153],
  lightSteelBlue: [176, 196, 222],
  lightYellow: [255, 255, 224],
  lime: [0, 255, 0],
  limeGreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumAquamarine: [102, 205, 170],
  mediumBlue: [0, 0, 205],
  mediumOrchid: [186, 85, 211],
  mediumPurple: [147, 112, 219],
  mediumSeaGreen: [60, 179, 113],
  mediumSlateBlue: [123, 104, 238],
  mediumSpringGreen: [0, 250, 154],
  mediumTurquoise: [72, 209, 204],
  mediumVioletRed: [199, 21, 133],
  midBightBlue: [25, 25, 112],
  mintCream: [245, 255, 250],
  mistyRose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajoWhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldLace: [253, 245, 230],
  olive: [128, 128, 0],
  oliveDrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangeRed: [255, 69, 0],
  orchid: [218, 112, 214],
  paleGoldenrod: [238, 232, 170],
  paleGreen: [152, 251, 152],
  paleTurquoise: [175, 238, 238],
  paleVioletRed: [219, 112, 147],
  papayaWhip: [255, 239, 213],
  peachPuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderBlue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccaPurple: [102, 51, 153],
  red: [255, 0, 0],
  rosyBrown: [188, 143, 143],
  royalBlue: [65, 105, 225],
  saddleBrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandyBrown: [244, 164, 96],
  seaGreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyBlue: [135, 206, 235],
  slateBlue: [106, 90, 205],
  slateGray: [119, 128, 144],
  slateGrey: [119, 128, 144],
  snow: [255, 255, 250],
  springGreen: [0, 255, 127],
  steelBlue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  transparent: [255, 255, 255, 0],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whiteSmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowGreen: [154, 205, 5]
};
var bt = class _bt {
  constructor(t) {
    p(this, "_color");
    p(this, "_rgbColor");
    p(this, "_isValid", false);
    if (t == null) {
      this._setNullColor();
      return;
    }
    if (t instanceof _bt) {
      this._color = { ...t._color }, this._rgbColor = { ...t._rgbColor };
      return;
    }
    const n = fu(t);
    if (n == null) {
      this._setNullColor();
      return;
    }
    this._color = n;
    const r = Lg(this._color);
    if (r == null) {
      this._setNullColor();
      return;
    }
    this._rgbColor = r, this._isValid = true;
  }
  static mix(t, n, r) {
    var u, c;
    r = Math.min(1, Math.max(0, r));
    const s = new _bt(t).toRgb(), i = new _bt(n).toRgb(), o = (u = s.a) != null ? u : 1, a = (c = i.a) != null ? c : 1, l = {
      r: (i.r - s.r) * r + s.r,
      g: (i.g - s.g) * r + s.g,
      b: (i.b - s.b) * r + s.b,
      a: (a - o) * r + o
    };
    return new _bt(l);
  }
  static getContrastRatio(t, n) {
    const r = new _bt(t).getLuminance(), s = new _bt(n).getLuminance();
    return (Math.max(r, s) + 0.05) / (Math.min(r, s) + 0.05);
  }
  get isValid() {
    return this._isValid;
  }
  toRgb() {
    return this._rgbColor;
  }
  toRgbString() {
    const { r: t, g: n, b: r, a: s = 1 } = this.toRgb(), i = s < 1;
    return `rgb${i ? "a" : ""}(${t},${n},${r}${i ? `,${s}` : ""})`;
  }
  toString() {
    return this.toRgbString();
  }
  toHexString(t) {
    const { r: n, g: r, b: s, a: i = 1 } = this.toRgb(), o = i < 1, a = [
      $r(Math.round(n).toString(16)),
      $r(Math.round(r).toString(16)),
      $r(Math.round(s).toString(16)),
      $r(Math.round(i * 255).toString(16))
    ];
    return t && a[0][0] === a[0][1] && a[1][0] === a[1][1] && a[2][0] === a[2][1] && a[3][0] === a[3][1] ? o ? `#${a[0][0]}${a[1][0]}${a[2][0]}${a[3][0]}` : `#${a[0][0]}${a[1][0]}${a[2][0]}` : o ? `#${a[0]}${a[1]}${a[2]}${a[3]}` : `#${a[0]}${a[1]}${a[2]}`;
  }
  toHsv() {
    return kg(this.toRgb());
  }
  toHsl() {
    return Ug(this.toRgb());
  }
  lighten(t = 10) {
    const n = this.toHsl();
    return n.l += t, n.l = Math.min(Math.max(n.l, 0), 100), new _bt(n);
  }
  darken(t = 10) {
    const n = this.toHsl();
    return n.l -= t, n.l = Math.min(Math.max(n.l, 0), 100), new _bt(n);
  }
  setAlpha(t) {
    return new _bt({ ...this._rgbColor, a: t });
  }
  getLuminance() {
    let { r: t, g: n, b: r } = this.toRgb();
    return t = ei(t), n = ei(n), r = ei(r), Number((0.2126 * t + 0.7152 * n + 0.0722 * r).toFixed(3));
  }
  getBrightness() {
    const { r: t, g: n, b: r } = this.toRgb();
    return (t * 299 + n * 587 + r * 114) / 1e3;
  }
  getAlpha() {
    var t;
    return (t = this._color.a) != null ? t : 1;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  _setNullColor() {
    this._isValid = false, this._color = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    }, this._rgbColor = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    };
  }
};
var $r = (e) => e.length === 1 ? `0${e}` : e;
var ei = (e) => (e /= 255, e <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4);
var fu = (e) => {
  if (Fg(e)) {
    if ("r" in e) {
      const r = {
        r: Math.round(e.r),
        g: Math.round(e.g),
        b: Math.round(e.b)
      };
      return e.a !== void 0 && (r.a = e.a), r;
    }
    if ("l" in e) {
      const r = {
        h: Math.round(e.h),
        s: e.s,
        l: e.l
      };
      return e.a !== void 0 && (r.a = e.a), r;
    }
    const n = {
      h: Math.round(e.h),
      s: e.s,
      v: e.v
    };
    return e.a !== void 0 && (n.a = e.a), n;
  }
  const t = e.trim();
  if (Ua[t]) {
    const n = Ua[t], r = {
      r: Math.round(n[0]),
      g: Math.round(n[1]),
      b: Math.round(n[2])
    };
    return r.a = n[3] || 1, r;
  }
  if (t.startsWith("#"))
    return yg(t);
  if (t.startsWith("rgb"))
    return Ng(t);
  if (t.startsWith("hsl"))
    return Tg(t);
  if (t.startsWith("hsv"))
    return Mg(t);
};
var yg = (e) => {
  const t = e.substring(1), n = new RegExp(`.{1,${t.length >= 6 ? 2 : 1}}`, "g");
  let r = t.match(n);
  if (!r || r.length < 3)
    throw new Error(`The color '${e}' is illegal hex color`);
  r[0].length === 1 && (r = r.map((i) => i + i));
  const s = {
    r: Number.parseInt(r[0], 16),
    g: Number.parseInt(r[1], 16),
    b: Number.parseInt(r[2], 16)
  };
  return r.length > 3 && (s.a = Number.parseInt(r[3], 16) / 255), s;
};
var Ng = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal rgb color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal rgb color`);
  const r = {
    r: Number.parseInt(n[0], 10),
    g: Number.parseInt(n[1], 10),
    b: Number.parseInt(n[2], 10)
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
};
var Tg = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal hsl color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal hsl color`);
  const r = {
    h: Number.parseInt(n[0], 10),
    s: Number.parseFloat(n[1]),
    l: Number.parseFloat(n[2])
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
};
var Mg = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal hsv color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal hsv color`);
  const r = {
    h: Number.parseInt(n[0], 10),
    s: Number.parseFloat(n[1]),
    v: Number.parseFloat(n[2])
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
};
var Lg = (e) => {
  const t = fu(e);
  if (t != null)
    return "r" in t ? t : "l" in t ? xg(t) : Dg(t);
};
var ti = (e, t, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e);
var xg = (e) => {
  let { h: t, s: n, l: r } = e;
  t /= 360, n /= 100, r /= 100;
  let s = 0, i = 0, o = 0;
  if (n === 0)
    s = i = o = r;
  else {
    const l = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - l;
    s = ti(u, l, t + 1 / 3), i = ti(u, l, t), o = ti(u, l, t - 1 / 3);
  }
  const a = {
    r: Math.round(s * 255),
    g: Math.round(i * 255),
    b: Math.round(o * 255)
  };
  return e.a !== void 0 && (a.a = e.a), a;
};
var Dg = (e) => {
  let { h: t, s: n, v: r } = e;
  t = t / 360 * 6, n /= 100, r /= 100;
  const s = Math.floor(t), i = t - s, o = r * (1 - n), a = r * (1 - i * n), l = r * (1 - (1 - i) * n), u = s % 6, c = [r, a, o, o, l, r][u], h = [l, r, r, a, o, o][u], d = [o, o, l, r, r, a][u], f = {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
  return e.a !== void 0 && (f.a = e.a), f;
};
var Ug = (e) => {
  let { r: t, g: n, b: r } = e;
  t /= 255, n /= 255, r /= 255;
  const s = Math.max(t, n, r), i = Math.min(t, n, r), o = (s + i) / 2;
  let a, l;
  if (s === i)
    a = l = 0;
  else {
    const c = s - i;
    switch (l = o > 0.5 ? c / (2 - s - i) : c / (s + i), s) {
      case t:
        a = (n - r) / c + (n < r ? 6 : 0);
        break;
      case n:
        a = (r - t) / c + 2;
        break;
      default:
        a = (t - n) / c + 4;
        break;
    }
    a /= 6;
  }
  const u = {
    h: Math.round(a * 360),
    s: Math.round(l * 100),
    l: Math.round(o * 100)
  };
  return e.a !== void 0 && (u.a = e.a), u;
};
var kg = (e) => {
  let { r: t, g: n, b: r } = e;
  t /= 255, n /= 255, r /= 255;
  const s = Math.max(t, n, r), i = Math.min(t, n, r);
  let o;
  const a = s, l = s - i, u = s === 0 ? 0 : l / s;
  if (s === i)
    o = 0;
  else {
    switch (s) {
      case t:
        o = (n - r) / l + (n < r ? 6 : 0);
        break;
      case n:
        o = (r - t) / l + 2;
        break;
      default:
        o = (t - n) / l + 4;
        break;
    }
    o /= 6;
  }
  const c = {
    h: Math.round(o * 360),
    s: Math.round(u * 100),
    v: Math.round(a * 100)
  };
  return e.a !== void 0 && (c.a = e.a), c;
};
var Pg = (e) => e == null;
var Fg = (e) => !Pg(e) && typeof e == "object";
function N1(e) {
  const t = /^#(?:[0]{3}|[0]{6})\b/, n = /^rgb\s*\(\s*0+\s*,\s*0+\s*,\s*0+\s*\)$/, r = /^rgba\s*\(\s*0+\s*,\s*0+\s*,\s*0+\s*,\s*(1|1\.0*|0?\.\d+)\)$/, s = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*0%*\s*\)$/, i = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*0%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
  return !!(t.test(e) || n.test(e) || r.test(e) || s.test(e) || i.test(e));
}
function T1(e) {
  const t = /^#(?:[Ff]{3}|[Ff]{6})\b/, n = /^rgb\s*\(\s*255\s*,\s*255\s*,\s*255\s*\)$/, r = /^rgba\s*\(\s*255\s*,\s*255\s*,\s*255\s*,\s*(1|1\.0*|0?\.\d+)\)$/, s = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*\)$/, i = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
  return !!(t.test(e) || n.test(e) || r.test(e) || s.test(e) || i.test(e));
}
function $g(e) {
  return e && (e.s !== void 0 || e.p !== void 0 || e.v !== void 0 || e.t !== void 0 || e.f !== void 0 || e.si !== void 0 || e.custom !== void 0);
}
function M1(e) {
  if (e.t !== void 0)
    return e.t;
  if (typeof e.v == "string")
    return fn.STRING;
  if (typeof e.v == "number")
    return fn.NUMBER;
  if (typeof e.v == "boolean")
    return fn.BOOLEAN;
}
function L1(e) {
  if (e == null)
    return true;
  const { v: t, f: n, si: r, p: s, custom: i } = e;
  return !(!(t == null || typeof t == "string" && t.length === 0) || n != null && n.length > 0 || r != null && r.length > 0 || s != null || i != null);
}
function Hg(e) {
  return e != null && (typeof e == "string" || typeof e == "number" || typeof e == "boolean");
}
var ge = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL", e))(ge || {});
var ye = ((e) => (e[e.NONE = 0] = "NONE", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL", e))(ye || {});
function x1(e) {
  return [e.startRow, e.startColumn, e.endRow, e.endColumn];
}
var Bg = ((e) => (e.NONE = "none", e.BACKWARD = "backward", e.FORWARD = "forward", e))(Bg || {});
var jg = ((e) => (e.RECT = "RECT", e.TEXT = "TEXT", e))(jg || {});
function D1(e, t, n) {
  let r = false, s = false, i = e, o = t, a = e, l = t;
  if (n == null)
    return {
      actualRow: e,
      actualColumn: t,
      isMergedMainCell: s,
      isMerged: r,
      endRow: i,
      endColumn: o,
      startRow: a,
      startColumn: l
    };
  for (let u = 0; u < n.length; u++) {
    const {
      startRow: c,
      endRow: h,
      startColumn: d,
      endColumn: f
    } = n[u];
    if (e === c && t === d) {
      i = h, o = f, a = c, l = d, s = true;
      break;
    }
    if (e >= c && e <= h && t >= d && t <= f) {
      i = h, o = f, a = c, l = d, r = true;
      break;
    }
  }
  return {
    actualRow: e,
    actualColumn: t,
    isMergedMainCell: s,
    isMerged: r,
    endRow: i,
    endColumn: o,
    startRow: a,
    startColumn: l
  };
}
var or = ((e) => (e.Raw = "raw", e.Intercepted = "intercepted", e.Both = "both", e))(or || {});
function U1(e, t) {
  const n = {};
  for (const r in e) {
    const s = Number(r), i = e[s];
    for (const o in i) {
      const a = Number(o), l = i[a], u = t(s, a, l);
      u !== void 0 && (n[s] ? n[s][a] = u : n[s] = {
        [a]: u
      });
    }
  }
  return n;
}
function mn(e) {
  let t = 0;
  const n = Object.keys(e);
  for (const r of n) {
    const s = Number(r);
    t = Math.max(t, s);
  }
  return t + 1;
}
function k1(e, t, n) {
  const r = mn(n), s = n;
  for (let i = r - 1; i >= e; i--)
    s[i + 1] = s[i];
  s[e] = t;
}
function ka(e, t, n) {
  const r = Object.keys(n).reduce((s, i) => Math.max(s, Number.parseInt(i)), 0) + 1;
  for (let s = e; s < r; s++)
    s < e + t ? delete n[s] : n[s] !== void 0 && (n[s - t] = n[s], delete n[s]);
}
function P1(e, t) {
  const n = e, r = Object.keys(n), s = r.length, i = t, o = Object.keys(i), a = o.length, l = {};
  let u = 0;
  for (let c = 0; c < s; c++, u++) {
    const h = r[c];
    l[u] = n[h];
  }
  for (let c = 0; c < a; c++, u++) {
    const h = o[c];
    l[u] = i[h];
  }
  return l;
}
function F1(e, t, n) {
  const r = n;
  if (mn(n) > 0) {
    const i = {};
    let o = 0;
    for (let a = e; a <= t; a++)
      r[a] && (i[o] = r[a], o++);
    return i;
  }
  return {};
}
function Pa(e, t, n, r) {
  const s = e > n;
  if (!s && e + t > n)
    throw new Error("Invalid move operation");
  s ? Wg(e, t, n, r) : Yg(e, t, n, r);
}
function Wg(e, t, n, r) {
  const s = r, i = [];
  for (let o = e; o < e + t; o++)
    i.push(s[o]);
  for (let o = e - 1; o >= n; o--) {
    const a = s[o];
    s[o + t] = a, a === void 0 && delete s[o + t];
  }
  i.forEach((o, a) => {
    s[n + a] = o, o === void 0 && delete s[n + a];
  });
}
function Yg(e, t, n, r) {
  const s = r, i = [];
  for (let o = e; o < e + t; o++)
    i.push(s[o]);
  for (let o = e + t; o < n; o++) {
    const a = s[o];
    s[o - t] = a, a === void 0 && delete s[o - t];
  }
  i.forEach((o, a) => {
    s[n + a - t] = o, o === void 0 && delete s[n + a - t];
  });
}
var pt = class _pt {
  constructor(t = {}) {
    p(this, "_matrix");
    this._setOriginValue(t);
  }
  static MakeObjectMatrixSize(t) {
    return new _pt({
      [t - 1]: {}
    });
  }
  getMatrix() {
    return this._matrix;
  }
  forEach(t) {
    const n = this._matrix, r = Object.keys(n);
    for (const s of r) {
      const i = Number(s), o = n[i];
      if (t(i, o) === false)
        return this;
    }
    return this;
  }
  forRow(t) {
    const n = this._matrix, r = Object.keys(n);
    for (const s of r) {
      const i = Number(s), o = n[i];
      if (t(
        i,
        Object.keys(o).map((l) => Number(l))
      ) === false)
        return this;
    }
    return this;
  }
  /**
   * Iterate the object matrix with row priority, which means it scan the whole range row by row.
   */
  forValue(t) {
    const n = this._matrix;
    for (const r in n) {
      const s = Number(r), i = n[s];
      if (i)
        for (const o in i) {
          const a = Number(o), l = i[a];
          if (t(s, a, l) === false)
            return this;
        }
    }
    return this;
  }
  swapRow(t, n) {
    const r = this._matrix[t], s = this._matrix[n];
    this._matrix[t] = s, this._matrix[n] = r;
  }
  getRow(t) {
    return this._matrix[t];
  }
  getRowOrCreate(t) {
    let n = this.getRow(t);
    return n == null && (n = {}, this._matrix[t] = n), n;
  }
  reset() {
    this._setOriginValue({});
  }
  hasValue() {
    const t = this._matrix, n = Object.keys(t);
    if (n.length === 0)
      return false;
    for (const r of n) {
      const s = Number(r), i = t[s];
      if (Object.keys(i).length > 0)
        return true;
    }
    return false;
  }
  getValue(t, n) {
    var r, s;
    return (s = (r = this._matrix) == null ? void 0 : r[t]) == null ? void 0 : s[n];
  }
  setValue(t, n, r) {
    const s = this.getRowOrCreate(t);
    s[n] = r;
  }
  /**
   * 
   * Please +1 , who fell into this pit.
   * @deprecated use `realDelete` or `splice`
   */
  deleteValue(t, n) {
    var r, s;
    (s = (r = this._matrix) == null ? void 0 : r[t]) == null || delete s[n];
  }
  realDeleteValue(t, n) {
    var r, s, i;
    if ((s = (r = this._matrix) == null ? void 0 : r[t]) == null || delete s[n], this.getRow(t)) {
      const o = this.getRow(t);
      if (o == null)
        return;
      Object.keys(o).length === 0 && ((i = this._matrix) == null || delete i[t]);
    }
  }
  setRow(t, n) {
    this._matrix[t] = n;
  }
  moveRows(t, n, r) {
    Pa(t, n, r, this._matrix);
  }
  moveColumns(t, n, r) {
    this.forEach((s, i) => {
      Pa(t, n, r, i);
    });
  }
  insertRows(t, n) {
    const r = Object.keys(this._matrix);
    for (let s = r.length - 1; s >= 0; s--) {
      const i = Number(r[s]);
      if (i >= t) {
        const o = this._matrix[i];
        delete this._matrix[i], this._matrix[i + n] = o;
      }
    }
  }
  insertColumns(t, n) {
    const r = Object.keys(this._matrix);
    for (let s = 0; s < r.length; s++) {
      const i = Number(r[s]), o = this._matrix[i], a = Object.keys(o);
      for (let l = a.length - 1; l >= 0; l--) {
        const u = Number(a[l]);
        if (u >= t) {
          const c = o[u];
          delete o[u], o[u + n] = c;
        }
      }
    }
  }
  removeRows(t, n) {
    ka(t, n, this._matrix);
  }
  removeColumns(t, n) {
    this.forEach((r, s) => {
      s && ka(t, n, s);
    });
  }
  /**
   * Return a fragment of the original data matrix. Note that the returned matrix's row matrix would start from
   * 0 not `startRow`. Neither does its column matrix. If you want to get the original matrix, use `getSlice`.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getFragment(t, n, r, s) {
    const i = new _pt();
    let o = 0;
    for (let a = t; a <= n; a++) {
      const l = {};
      let u = 0;
      for (let c = r; c <= s; c++) {
        const h = this.getValue(a, c);
        l[u] = h, u++;
      }
      i.setRow(o, l), o++;
    }
    return i;
  }
  /**
   * Return a slice of the original data matrix. Note that the returned matrix's row matrix would start from
   * `startRow` not 0, and the same does its column index. You may be looking for `getFragment` if you want
   * both of the indexes start from 0.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getSlice(t, n, r, s) {
    const i = new _pt();
    for (let o = t; o <= n; o++)
      for (let a = r; a <= s; a++) {
        const l = this.getValue(o, a);
        l && i.setValue(o, a, J.deepClone(l));
      }
    return i;
  }
  getSizeOf() {
    return Object.keys(this._matrix).length;
  }
  getLength() {
    return mn(this._matrix);
  }
  getRange() {
    const r = this.getLength() - 1;
    let s = 0;
    const i = this.getLength();
    for (let o = 0; o < i; o++) {
      const a = this.getRow(o);
      if (a) {
        const l = mn(a) - 1;
        s = l > s ? l : s;
      }
    }
    return {
      startRow: 0,
      startColumn: 0,
      endRow: r,
      endColumn: s
    };
  }
  toNativeArray() {
    const t = new Array();
    return this.forValue((n, r, s) => {
      t.push(s);
    }), t;
  }
  toArray() {
    const t = [];
    return this.forRow((n, r) => {
      t[n] == null && (t[n] = []), r.forEach((s) => {
        t[n][s] = this.getValue(n, s);
      });
    }), t;
  }
  toFullArray() {
    const t = this.getRange(), { endColumn: n, endRow: r } = t, s = [];
    for (let i = 0; i <= r; i++) {
      const o = new Array(n + 1).fill(void 0);
      s.push(o);
    }
    return this.forValue((i, o, a) => {
      s[i][o] = a;
    }), s;
  }
  /**
   * @deprecated Use getMatrix as a substitute.
   */
  toJSON() {
    return this._matrix;
  }
  clone() {
    const t = JSON.stringify(this._matrix);
    return JSON.parse(t);
  }
  /**
   * @deprecated Use clone as a substitute.
   */
  getData() {
    const t = JSON.stringify(this._matrix);
    return JSON.parse(t);
  }
  getArrayData() {
    let t = 0, n = 0, r = false, s = false;
    const i = new _pt();
    return this.forEach((o, a) => {
      r || (r = true, t = o), Object.keys(a).forEach((l) => {
        const u = Number(l);
        s ? u < n && (n = u) : (s = true, n = u);
        const c = this.getValue(o, u);
        i.setValue(o - t, u - n, c);
      });
    }), i.getData();
  }
  /**
   * the function can only be used in all the row and column are positive integer
   * @description the positive integer in V8 Object is stored in a fast memory space and it is sorted  when we get the keys
   * @returns {IRange} the start and end scope of the matrix
   */
  getStartEndScope() {
    let t = 1 / 0, n = -1 / 0, r = 1 / 0, s = -1 / 0;
    const i = Object.keys(this._matrix);
    i.length > 0 && (t = +i[0], n = +i[i.length - 1]);
    for (const o of i) {
      const a = Object.keys(this._matrix[o]);
      a.length > 0 && (r = Math.min(r, +a[0]), s = Math.max(s, +a[a.length - 1]));
    }
    return { startRow: t, endRow: n, startColumn: r, endColumn: s };
  }
  getDataRange() {
    let t = 0, n = 0, r = 0, s = -1, i = false, o = false;
    return this.forEach((a, l) => {
      if (i || (i = true, t = a), l == null)
        return;
      const u = mn(l) - 1;
      u > r && (r = u), Object.keys(l).forEach((c) => {
        const h = Number(c);
        o ? h < n && (n = h) : (o = true, n = h);
      }), a > s && (s = a);
    }), {
      startRow: t,
      startColumn: n,
      endRow: s,
      endColumn: r
    };
  }
  getDiscreteRanges() {
    const t = [];
    return this.forEach((n, r) => {
      Object.keys(r).forEach((s) => {
        const i = Number(s);
        let o = false;
        for (const a of t)
          if (n >= a.startRow && n <= a.endRow + 1 && i >= a.startColumn && i <= a.endColumn + 1) {
            a.endRow = Math.max(n, a.endRow), a.endColumn = Math.max(i, a.endColumn), o = true;
            break;
          }
        o || t.push({
          startRow: n,
          endRow: n,
          startColumn: i,
          endColumn: i
        });
      });
    }), t;
  }
  merge(t) {
    this.forValue((n, r) => {
      const s = t.getValue(n, r);
      s != null && this.setValue(n, r, s);
    });
  }
  _setOriginValue(t = {}) {
    this._matrix = t;
  }
};
function zg(e) {
  const { actualRow: t, actualColumn: n, isMerged: r, isMergedMainCell: s, mergeInfo: i } = e;
  let { startY: o, endY: a, startX: l, endX: u } = e, c = t, h = n, d = t, f = n;
  if (r && i) {
    const {
      startRow: g,
      startColumn: _,
      endRow: R,
      endColumn: b,
      startY: H,
      endY: P,
      startX: W,
      endX: w
    } = i;
    c = g, h = _, d = R, f = b, o = H, a = P, l = W, u = w;
  }
  return s && (o = i.startY, a = i.endY, l = i.startX, u = i.endX, d = i.endRow, f = i.endColumn), {
    startRow: c,
    startColumn: h,
    endRow: d,
    endColumn: f,
    startY: o,
    endY: a,
    startX: l,
    endX: u
  };
}
var $1 = zg;
function H1(e) {
  if (!e)
    return;
  const {
    actualRow: t,
    actualColumn: n,
    isMerged: r,
    isMergedMainCell: s,
    startRow: i,
    startColumn: o,
    endRow: a,
    endColumn: l
  } = e;
  let u = t, c = n, h = t, d = n;
  return (r || s) && (u = i, c = o, h = a, d = l), {
    startRow: u,
    startColumn: c,
    endRow: h,
    endColumn: d
  };
}
function Vg(e) {
  var n;
  return !e || (((n = e == null ? void 0 : e.v) == null ? void 0 : n.toString()) || "").length === 0 && !e.p;
}
function Fa(e) {
  return Vg(e) && (e == null ? void 0 : e.coverable) !== false;
}
function Wt(e) {
  if (e) {
    if (e.rgb)
      return new bt(e.rgb).toHexString();
    if (e.th)
      return new mo().setThemeColor(e.th).asThemeColor().asRgbColor().getCssString();
  }
  return null;
}
function Gg(e) {
  return J.isString(e) && e.substring(0, 1) === "=" && e.length > 1;
}
function B1(e) {
  return J.isString(e) && e.length > 0;
}
function j1(e, t = false) {
  var i;
  let n = "";
  const r = /* @__PURE__ */ new Map([
    [
      "ff",
      () => {
        e.ff && (n += `font-family: ${e.ff}; `);
      }
    ],
    [
      "fs",
      () => {
        if (e.fs) {
          let o = e.fs;
          e.va && (o /= 2), n += `font-size: ${o}pt; `;
        }
      }
    ],
    [
      "it",
      () => {
        e.it && (n += "font-style: italic; ");
      }
    ],
    [
      "bl",
      () => {
        e.bl && (n += "font-weight: bold; ");
      }
    ],
    [
      "ul",
      () => {
        var o;
        (o = e.ul) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} underline`) : n += "text-decoration: underline; ", e.ul.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Wt(e.ul.cl)}; `), e.ul.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.ul.t} `));
      }
    ],
    [
      "st",
      () => {
        var o;
        (o = e.st) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} line-through`) : n += "text-decoration-line: line-through; ", e.st.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Wt(e.st.cl)}; `), e.st.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.st.t} `));
      }
    ],
    [
      "ol",
      () => {
        var o;
        (o = e.ol) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} overline`) : n += "text-decoration-line: overline; ", e.ol.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Wt(e.ol.cl)}; `), e.ol.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.ol.t} `));
      }
    ],
    [
      "bg",
      () => {
        e.bg && (n += `background: ${Wt(e.bg)}; `);
      }
    ],
    [
      "bd",
      () => {
        var o, a, l, u, c, h, d, f, g, _, R, b;
        (o = e.bd) != null && o.b && (n += `border-bottom: ${Hr((a = e.bd) == null ? void 0 : a.b.s)} ${(l = Wt(e.bd.b.cl)) != null ? l : ""}; `), (u = e.bd) != null && u.t && (n += `border-top: ${Hr((c = e.bd) == null ? void 0 : c.t.s)} ${(h = Wt(e.bd.t.cl)) != null ? h : ""}; `), (d = e.bd) != null && d.r && (n += `border-right: ${Hr((f = e.bd) == null ? void 0 : f.r.s)} ${(g = Wt(e.bd.r.cl)) != null ? g : ""}; `), (_ = e.bd) != null && _.l && (n += `border-left: ${Hr((R = e.bd) == null ? void 0 : R.l.s)} ${(b = Wt(e.bd.l.cl)) != null ? b : ""}; `);
      }
    ],
    [
      "cl",
      () => {
        e.cl && (n += `color: ${Wt(e.cl)}; `);
      }
    ],
    [
      "va",
      () => {
        e.va === Zt.SUBSCRIPT ? n += "vertical-align: sub; " : e.va === Zt.SUPERSCRIPT && (n += "vertical-align: super; ");
      }
    ],
    [
      "td",
      () => {
        e.td === ms.LEFT_TO_RIGHT ? n += "direction: ltr; " : e.td === ms.RIGHT_TO_LEFT && (n += "direction: rtl; ");
      }
    ],
    [
      "tr",
      () => {
        var o, a, l;
        e.tr && (n += `--data-rotate: (${(o = e.tr) == null ? void 0 : o.a}deg${(a = e.tr) != null && a.v ? ` ,${(l = e.tr) == null ? void 0 : l.v}` : ""});`);
      }
    ],
    [
      "ht",
      () => {
        e.ht === Ut.LEFT ? n += "text-align: left; " : e.ht === Ut.RIGHT ? n += "text-align: right; " : e.ht === Ut.CENTER ? n += "text-align: center; " : e.ht === Ut.JUSTIFIED && (n += "text-align: justify; ");
      }
    ],
    [
      "vt",
      () => {
        e.vt === xn.BOTTOM ? n += "vertical-align: bottom; " : e.vt === xn.TOP ? n += "vertical-align: top; " : e.vt === xn.MIDDLE && (n += "vertical-align: middle; ");
      }
    ],
    [
      "tb",
      () => {
        e.tb === Bn.CLIP ? n += "white-space: nowrap; overflow-x: hidden; " : e.tb === Bn.WRAP && (n += "white-space: normal;");
      }
    ],
    [
      "pd",
      () => {
        var c, h, d, f, g, _, R, b;
        const o = `${(c = e.pd) == null ? void 0 : c.b}pt`, a = `${(h = e.pd) == null ? void 0 : h.t}pt`, l = `${(d = e.pd) == null ? void 0 : d.l}pt`, u = `${(f = e.pd) == null ? void 0 : f.r}pt`;
        (g = e.pd) != null && g.b && (n += `padding-bottom: ${o}; `), (_ = e.pd) != null && _.t && (n += `padding-top: ${a}; `), (R = e.pd) != null && R.l && (n += `padding-left: ${l}; `), (b = e.pd) != null && b.r && (n += `padding-right: ${u}; `);
      }
    ]
  ]), s = ["bd", "tr", "tb"];
  for (const o in e)
    t && s.includes(o) || (i = r.get(o)) == null || i();
  return n;
}
function Hr(e) {
  let t = "";
  return e === Le.NONE ? t = "none" : e === Le.THIN ? t = "0.5pt solid" : e === Le.HAIR ? t = "0.5pt double" : e === Le.DOTTED ? t = "0.5pt dotted" : e === Le.DASHED || e === Le.DASH_DOT ? t = "0.5pt dashed" : e === Le.DASH_DOT_DOT ? t = "0.5pt dotted" : e === Le.DOUBLE ? t = "0.5pt double" : e === Le.MEDIUM ? t = "1pt solid" : e === Le.MEDIUM_DASHED || e === Le.MEDIUM_DASH_DOT ? t = "1pt dashed" : e === Le.MEDIUM_DASH_DOT_DOT ? t = "1pt dotted" : e === Le.SLANT_DASH_DOT ? t = "0.5pt dashed" : e === Le.THICK && (t = "1.5pt solid"), t;
}
function W1(e) {
  let t = 0;
  if (e = e.trim(), e === "none")
    t = Le.NONE;
  else if (e === "0.5pt solid")
    t = Le.THIN;
  else if (e === "0.5pt double")
    t = Le.HAIR;
  else if (e === "0.5pt dotted")
    t = Le.DOTTED;
  else if (e === "0.5pt dashed")
    t = Le.DASHED;
  else if (e === "1pt solid")
    t = Le.MEDIUM;
  else if (e === "1pt dashed")
    t = Le.MEDIUM_DASHED;
  else if (e === "1pt dotted")
    t = Le.MEDIUM_DASH_DOT_DOT;
  else if (e === "1.5pt solid")
    t = Le.THICK;
  else if (!e.includes("none"))
    t = Le.THIN;
  else
    return Le.NONE;
  return t;
}
function Y1(e, t) {
  let n = e.body;
  if (t) {
    const { headers: r, footers: s } = e;
    r != null && r[t] ? n = r[t].body : s != null && s[t] && (n = s[t].body);
  }
  return n;
}
function z1(e, t) {
  const { startRow: n, endRow: r, startColumn: s, endColumn: i, rangeType: o } = e;
  if (n < 0 || s < 0 || r < 0 || i < 0 || !(Number.isNaN(n) && Number.isNaN(r)) && o === ge.COLUMN || !(Number.isNaN(s) && Number.isNaN(i)) && o === ge.ROW || o !== ge.ROW && o !== ge.COLUMN && (Number.isNaN(s) || Number.isNaN(n) || Number.isNaN(i) || Number.isNaN(r)))
    return false;
  if (t) {
    const a = t.getRowCount(), l = t.getColumnCount();
    if (r >= a || i >= l)
      return false;
  }
  return true;
}
function V1(e, t) {
  return { startRow: e, endRow: e, startColumn: t, endColumn: t };
}
function $a(e) {
  return Gg(e) ? {
    f: e,
    v: null,
    p: null
  } : Hg(e) ? {
    v: e,
    p: null,
    f: null
  } : ($g(e), e);
}
function G1(e, t) {
  const n = new pt(), { startRow: r, startColumn: s, endRow: i, endColumn: o } = t;
  if (J.isArray(e))
    for (let a = 0; a <= i - r; a++)
      for (let l = 0; l <= o - s; l++)
        n.setValue(a + r, l + s, $a(e[a][l]));
  else
    new pt(e).forValue((l, u, c) => {
      n.setValue(l, u, $a(c));
    });
  return n.getMatrix();
}
function mu(e, t) {
  return Object.prototype.toString.call(e) === Object.prototype.toString.call(t) ? Object.prototype.toString.call(e) === "[object Object]" || Object.prototype.toString.call(e) === "[object Array]" ? Object.keys(e).length !== Object.keys(t).length ? false : Object.keys(e).every((n) => mu(e[n], t[n])) : e === t : false;
}
function Kg(e, t) {
  const n = e.ts || {}, r = t.ts || {};
  return e.sId !== t.sId ? false : mu(n, r);
}
function K1(e, t) {
  return t.some((n) => e.indexOf(n) > -1);
}
var es = { exports: {} };
var Xg = es.exports;
var Ha;
function qg() {
  return Ha || (Ha = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(Xg, function() {
      var n = 1e3, r = 6e4, s = 36e5, i = "millisecond", o = "second", a = "minute", l = "hour", u = "day", c = "week", h = "month", d = "quarter", f = "year", g = "date", _ = "Invalid Date", R = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, H = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(T) {
        var A = ["th", "st", "nd", "rd"], O = T % 100;
        return "[" + T + (A[(O - 20) % 10] || A[O] || A[0]) + "]";
      } }, P = function(T, A, O) {
        var N = String(T);
        return !N || N.length >= A ? T : "" + Array(A + 1 - N.length).join(O) + T;
      }, W = { s: P, z: function(T) {
        var A = -T.utcOffset(), O = Math.abs(A), N = Math.floor(O / 60), M = O % 60;
        return (A <= 0 ? "+" : "-") + P(N, 2, "0") + ":" + P(M, 2, "0");
      }, m: function T(A, O) {
        if (A.date() < O.date()) return -T(O, A);
        var N = 12 * (O.year() - A.year()) + (O.month() - A.month()), M = A.clone().add(N, h), L = O - M < 0, k = A.clone().add(N + (L ? -1 : 1), h);
        return +(-(N + (O - M) / (L ? M - k : k - M)) || 0);
      }, a: function(T) {
        return T < 0 ? Math.ceil(T) || 0 : Math.floor(T);
      }, p: function(T) {
        return { M: h, y: f, w: c, d: u, D: g, h: l, m: a, s: o, ms: i, Q: d }[T] || String(T || "").toLowerCase().replace(/s$/, "");
      }, u: function(T) {
        return T === void 0;
      } }, w = "en", C = {};
      C[w] = H;
      var v = "$isDayjsObject", y = function(T) {
        return T instanceof D2 || !(!T || !T[v]);
      }, F2 = function T(A, O, N) {
        var M;
        if (!A) return w;
        if (typeof A == "string") {
          var L = A.toLowerCase();
          C[L] && (M = L), O && (C[L] = O, M = L);
          var k = A.split("-");
          if (!M && k.length > 1) return T(k[0]);
        } else {
          var q = A.name;
          C[q] = A, M = q;
        }
        return !N && M && (w = M), M || !N && w;
      }, $ = function(T, A) {
        if (y(T)) return T.clone();
        var O = typeof A == "object" ? A : {};
        return O.date = T, O.args = arguments, new D2(O);
      }, m = W;
      m.l = F2, m.i = y, m.w = function(T, A) {
        return $(T, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
      };
      var D2 = function() {
        function T(O) {
          this.$L = F2(O.locale, null, true), this.parse(O), this.$x = this.$x || O.x || {}, this[v] = true;
        }
        var A = T.prototype;
        return A.parse = function(O) {
          this.$d = function(N) {
            var M = N.date, L = N.utc;
            if (M === null) return /* @__PURE__ */ new Date(NaN);
            if (m.u(M)) return /* @__PURE__ */ new Date();
            if (M instanceof Date) return new Date(M);
            if (typeof M == "string" && !/Z$/i.test(M)) {
              var k = M.match(R);
              if (k) {
                var q = k[2] - 1 || 0, V = (k[7] || "0").substring(0, 3);
                return L ? new Date(Date.UTC(k[1], q, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, V)) : new Date(k[1], q, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, V);
              }
            }
            return new Date(M);
          }(O), this.init();
        }, A.init = function() {
          var O = this.$d;
          this.$y = O.getFullYear(), this.$M = O.getMonth(), this.$D = O.getDate(), this.$W = O.getDay(), this.$H = O.getHours(), this.$m = O.getMinutes(), this.$s = O.getSeconds(), this.$ms = O.getMilliseconds();
        }, A.$utils = function() {
          return m;
        }, A.isValid = function() {
          return this.$d.toString() !== _;
        }, A.isSame = function(O, N) {
          var M = $(O);
          return this.startOf(N) <= M && M <= this.endOf(N);
        }, A.isAfter = function(O, N) {
          return $(O) < this.startOf(N);
        }, A.isBefore = function(O, N) {
          return this.endOf(N) < $(O);
        }, A.$g = function(O, N, M) {
          return m.u(O) ? this[N] : this.set(M, O);
        }, A.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, A.valueOf = function() {
          return this.$d.getTime();
        }, A.startOf = function(O, N) {
          var M = this, L = !!m.u(N) || N, k = m.p(O), q = function(B, j) {
            var Q = m.w(M.$u ? Date.UTC(M.$y, j, B) : new Date(M.$y, j, B), M);
            return L ? Q : Q.endOf(u);
          }, V = function(B, j) {
            return m.w(M.toDate()[B].apply(M.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(j)), M);
          }, oe = this.$W, le = this.$M, I = this.$D, x = "set" + (this.$u ? "UTC" : "");
          switch (k) {
            case f:
              return L ? q(1, 0) : q(31, 11);
            case h:
              return L ? q(1, le) : q(0, le + 1);
            case c:
              var Y = this.$locale().weekStart || 0, z = (oe < Y ? oe + 7 : oe) - Y;
              return q(L ? I - z : I + (6 - z), le);
            case u:
            case g:
              return V(x + "Hours", 0);
            case l:
              return V(x + "Minutes", 1);
            case a:
              return V(x + "Seconds", 2);
            case o:
              return V(x + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, A.endOf = function(O) {
          return this.startOf(O, false);
        }, A.$set = function(O, N) {
          var M, L = m.p(O), k = "set" + (this.$u ? "UTC" : ""), q = (M = {}, M[u] = k + "Date", M[g] = k + "Date", M[h] = k + "Month", M[f] = k + "FullYear", M[l] = k + "Hours", M[a] = k + "Minutes", M[o] = k + "Seconds", M[i] = k + "Milliseconds", M)[L], V = L === u ? this.$D + (N - this.$W) : N;
          if (L === h || L === f) {
            var oe = this.clone().set(g, 1);
            oe.$d[q](V), oe.init(), this.$d = oe.set(g, Math.min(this.$D, oe.daysInMonth())).$d;
          } else q && this.$d[q](V);
          return this.init(), this;
        }, A.set = function(O, N) {
          return this.clone().$set(O, N);
        }, A.get = function(O) {
          return this[m.p(O)]();
        }, A.add = function(O, N) {
          var M, L = this;
          O = Number(O);
          var k = m.p(N), q = function(le) {
            var I = $(L);
            return m.w(I.date(I.date() + Math.round(le * O)), L);
          };
          if (k === h) return this.set(h, this.$M + O);
          if (k === f) return this.set(f, this.$y + O);
          if (k === u) return q(1);
          if (k === c) return q(7);
          var V = (M = {}, M[a] = r, M[l] = s, M[o] = n, M)[k] || 1, oe = this.$d.getTime() + O * V;
          return m.w(oe, this);
        }, A.subtract = function(O, N) {
          return this.add(-1 * O, N);
        }, A.format = function(O) {
          var N = this, M = this.$locale();
          if (!this.isValid()) return M.invalidDate || _;
          var L = O || "YYYY-MM-DDTHH:mm:ssZ", k = m.z(this), q = this.$H, V = this.$m, oe = this.$M, le = M.weekdays, I = M.months, x = M.meridiem, Y = function(j, Q, ee, U) {
            return j && (j[Q] || j(N, L)) || ee[Q].slice(0, U);
          }, z = function(j) {
            return m.s(q % 12 || 12, j, "0");
          }, B = x || function(j, Q, ee) {
            var U = j < 12 ? "AM" : "PM";
            return ee ? U.toLowerCase() : U;
          };
          return L.replace(b, function(j, Q) {
            return Q || function(ee) {
              switch (ee) {
                case "YY":
                  return String(N.$y).slice(-2);
                case "YYYY":
                  return m.s(N.$y, 4, "0");
                case "M":
                  return oe + 1;
                case "MM":
                  return m.s(oe + 1, 2, "0");
                case "MMM":
                  return Y(M.monthsShort, oe, I, 3);
                case "MMMM":
                  return Y(I, oe);
                case "D":
                  return N.$D;
                case "DD":
                  return m.s(N.$D, 2, "0");
                case "d":
                  return String(N.$W);
                case "dd":
                  return Y(M.weekdaysMin, N.$W, le, 2);
                case "ddd":
                  return Y(M.weekdaysShort, N.$W, le, 3);
                case "dddd":
                  return le[N.$W];
                case "H":
                  return String(q);
                case "HH":
                  return m.s(q, 2, "0");
                case "h":
                  return z(1);
                case "hh":
                  return z(2);
                case "a":
                  return B(q, V, true);
                case "A":
                  return B(q, V, false);
                case "m":
                  return String(V);
                case "mm":
                  return m.s(V, 2, "0");
                case "s":
                  return String(N.$s);
                case "ss":
                  return m.s(N.$s, 2, "0");
                case "SSS":
                  return m.s(N.$ms, 3, "0");
                case "Z":
                  return k;
              }
              return null;
            }(j) || k.replace(":", "");
          });
        }, A.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, A.diff = function(O, N, M) {
          var L, k = this, q = m.p(N), V = $(O), oe = (V.utcOffset() - this.utcOffset()) * r, le = this - V, I = function() {
            return m.m(k, V);
          };
          switch (q) {
            case f:
              L = I() / 12;
              break;
            case h:
              L = I();
              break;
            case d:
              L = I() / 3;
              break;
            case c:
              L = (le - oe) / 6048e5;
              break;
            case u:
              L = (le - oe) / 864e5;
              break;
            case l:
              L = le / s;
              break;
            case a:
              L = le / r;
              break;
            case o:
              L = le / n;
              break;
            default:
              L = le;
          }
          return M ? L : m.a(L);
        }, A.daysInMonth = function() {
          return this.endOf(h).$D;
        }, A.$locale = function() {
          return C[this.$L];
        }, A.locale = function(O, N) {
          if (!O) return this.$L;
          var M = this.clone(), L = F2(O, N, true);
          return L && (M.$L = L), M;
        }, A.clone = function() {
          return m.w(this.$d, this);
        }, A.toDate = function() {
          return new Date(this.valueOf());
        }, A.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, A.toISOString = function() {
          return this.$d.toISOString();
        }, A.toString = function() {
          return this.$d.toUTCString();
        }, T;
      }(), S = D2.prototype;
      return $.prototype = S, [["$ms", i], ["$s", o], ["$m", a], ["$H", l], ["$W", u], ["$M", h], ["$y", f], ["$D", g]].forEach(function(T) {
        S[T[1]] = function(A) {
          return this.$g(A, T[0], T[1]);
        };
      }), $.extend = function(T, A) {
        return T.$i || (T(A, D2, $), T.$i = true), $;
      }, $.locale = F2, $.isDayjs = y, $.unix = function(T) {
        return $(1e3 * T);
      }, $.en = C[w], $.Ls = C, $.p = {}, $;
    });
  }(es)), es.exports;
}
var Zg = qg();
var tn = Rt(Zg);
var ts = { exports: {} };
var Jg = ts.exports;
var Ba;
function Qg() {
  return Ba || (Ba = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(Jg, function() {
      return function(n, r) {
        var s = r.prototype, i = s.format;
        s.format = function(o) {
          var a = this, l = this.$locale();
          if (!this.isValid()) return i.bind(this)(o);
          var u = this.$utils(), c = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(h) {
            switch (h) {
              case "Q":
                return Math.ceil((a.$M + 1) / 3);
              case "Do":
                return l.ordinal(a.$D);
              case "gggg":
                return a.weekYear();
              case "GGGG":
                return a.isoWeekYear();
              case "wo":
                return l.ordinal(a.week(), "W");
              case "w":
              case "ww":
                return u.s(a.week(), h === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return u.s(a.isoWeek(), h === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return u.s(String(a.$H === 0 ? 24 : a.$H), h === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(a.$d.getTime() / 1e3);
              case "x":
                return a.$d.getTime();
              case "z":
                return "[" + a.offsetName() + "]";
              case "zzz":
                return "[" + a.offsetName("long") + "]";
              default:
                return h;
            }
          });
          return i.bind(this)(c);
        };
      };
    });
  }(ts)), ts.exports;
}
var e_ = Qg();
var t_ = Rt(e_);
var ns = { exports: {} };
var n_ = ns.exports;
var ja;
function r_() {
  return ja || (ja = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(n_, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, s = /\d/, i = /\d\d/, o = /\d\d?/, a = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(R) {
        return (R = +R) + (R > 68 ? 1900 : 2e3);
      }, c = function(R) {
        return function(b) {
          this[R] = +b;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(R) {
        (this.zone || (this.zone = {})).offset = function(b) {
          if (!b || b === "Z") return 0;
          var H = b.match(/([+-]|\d\d)/g), P = 60 * H[1] + (+H[2] || 0);
          return P === 0 ? 0 : H[0] === "+" ? -P : P;
        }(R);
      }], d = function(R) {
        var b = l[R];
        return b && (b.indexOf ? b : b.s.concat(b.f));
      }, f = function(R, b) {
        var H, P = l.meridiem;
        if (P) {
          for (var W = 1; W <= 24; W += 1) if (R.indexOf(P(W, 0, b)) > -1) {
            H = W > 12;
            break;
          }
        } else H = R === (b ? "pm" : "PM");
        return H;
      }, g = { A: [a, function(R) {
        this.afternoon = f(R, false);
      }], a: [a, function(R) {
        this.afternoon = f(R, true);
      }], Q: [s, function(R) {
        this.month = 3 * (R - 1) + 1;
      }], S: [s, function(R) {
        this.milliseconds = 100 * +R;
      }], SS: [i, function(R) {
        this.milliseconds = 10 * +R;
      }], SSS: [/\d{3}/, function(R) {
        this.milliseconds = +R;
      }], s: [o, c("seconds")], ss: [o, c("seconds")], m: [o, c("minutes")], mm: [o, c("minutes")], H: [o, c("hours")], h: [o, c("hours")], HH: [o, c("hours")], hh: [o, c("hours")], D: [o, c("day")], DD: [i, c("day")], Do: [a, function(R) {
        var b = l.ordinal, H = R.match(/\d+/);
        if (this.day = H[0], b) for (var P = 1; P <= 31; P += 1) b(P).replace(/\[|\]/g, "") === R && (this.day = P);
      }], w: [o, c("week")], ww: [i, c("week")], M: [o, c("month")], MM: [i, c("month")], MMM: [a, function(R) {
        var b = d("months"), H = (d("monthsShort") || b.map(function(P) {
          return P.slice(0, 3);
        })).indexOf(R) + 1;
        if (H < 1) throw new Error();
        this.month = H % 12 || H;
      }], MMMM: [a, function(R) {
        var b = d("months").indexOf(R) + 1;
        if (b < 1) throw new Error();
        this.month = b % 12 || b;
      }], Y: [/[+-]?\d+/, c("year")], YY: [i, function(R) {
        this.year = u(R);
      }], YYYY: [/\d{4}/, c("year")], Z: h, ZZ: h };
      function _(R) {
        var b, H;
        b = R, H = l && l.formats;
        for (var P = (R = b.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function($, m, D2) {
          var S = D2 && D2.toUpperCase();
          return m || H[D2] || n[D2] || H[S].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(T, A, O) {
            return A || O.slice(1);
          });
        })).match(r), W = P.length, w = 0; w < W; w += 1) {
          var C = P[w], v = g[C], y = v && v[0], F2 = v && v[1];
          P[w] = F2 ? { regex: y, parser: F2 } : C.replace(/^\[|\]$/g, "");
        }
        return function($) {
          for (var m = {}, D2 = 0, S = 0; D2 < W; D2 += 1) {
            var T = P[D2];
            if (typeof T == "string") S += T.length;
            else {
              var A = T.regex, O = T.parser, N = $.slice(S), M = A.exec(N)[0];
              O.call(m, M), $ = $.replace(M, "");
            }
          }
          return function(L) {
            var k = L.afternoon;
            if (k !== void 0) {
              var q = L.hours;
              k ? q < 12 && (L.hours += 12) : q === 12 && (L.hours = 0), delete L.afternoon;
            }
          }(m), m;
        };
      }
      return function(R, b, H) {
        H.p.customParseFormat = true, R && R.parseTwoDigitYear && (u = R.parseTwoDigitYear);
        var P = b.prototype, W = P.parse;
        P.parse = function(w) {
          var C = w.date, v = w.utc, y = w.args;
          this.$u = v;
          var F2 = y[1];
          if (typeof F2 == "string") {
            var $ = y[2] === true, m = y[3] === true, D2 = $ || m, S = y[2];
            m && (S = y[2]), l = this.$locale(), !$ && S && (l = H.Ls[S]), this.$d = function(N, M, L, k) {
              try {
                if (["x", "X"].indexOf(M) > -1) return new Date((M === "X" ? 1e3 : 1) * N);
                var q = _(M)(N), V = q.year, oe = q.month, le = q.day, I = q.hours, x = q.minutes, Y = q.seconds, z = q.milliseconds, B = q.zone, j = q.week, Q = /* @__PURE__ */ new Date(), ee = le || (V || oe ? 1 : Q.getDate()), U = V || Q.getFullYear(), G = 0;
                V && !oe || (G = oe > 0 ? oe - 1 : Q.getMonth());
                var X, ne = I || 0, de = x || 0, _e = Y || 0, K = z || 0;
                return B ? new Date(Date.UTC(U, G, ee, ne, de, _e, K + 60 * B.offset * 1e3)) : L ? new Date(Date.UTC(U, G, ee, ne, de, _e, K)) : (X = new Date(U, G, ee, ne, de, _e, K), j && (X = k(X).week(j).toDate()), X);
              } catch {
                return /* @__PURE__ */ new Date("");
              }
            }(C, F2, v, H), this.init(), S && S !== true && (this.$L = this.locale(S).$L), D2 && C != this.format(F2) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
          } else if (F2 instanceof Array) for (var T = F2.length, A = 1; A <= T; A += 1) {
            y[1] = F2[A - 1];
            var O = H.apply(this, y);
            if (O.isValid()) {
              this.$d = O.$d, this.$L = O.$L, this.init();
              break;
            }
            A === T && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else W.call(this, w);
        };
      };
    });
  }(ns)), ns.exports;
}
var s_ = r_();
var i_ = Rt(s_);
var rs = { exports: {} };
var o_ = rs.exports;
var Wa;
function a_() {
  return Wa || (Wa = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(o_, function() {
      return function(n, r, s) {
        var i = r.prototype, o = function(h) {
          return h && (h.indexOf ? h : h.s);
        }, a = function(h, d, f, g, _) {
          var R = h.name ? h : h.$locale(), b = o(R[d]), H = o(R[f]), P = b || H.map(function(w) {
            return w.slice(0, g);
          });
          if (!_) return P;
          var W = R.weekStart;
          return P.map(function(w, C) {
            return P[(C + (W || 0)) % 7];
          });
        }, l = function() {
          return s.Ls[s.locale()];
        }, u = function(h, d) {
          return h.formats[d] || function(f) {
            return f.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(g, _, R) {
              return _ || R.slice(1);
            });
          }(h.formats[d.toUpperCase()]);
        }, c = function() {
          var h = this;
          return { months: function(d) {
            return d ? d.format("MMMM") : a(h, "months");
          }, monthsShort: function(d) {
            return d ? d.format("MMM") : a(h, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return h.$locale().weekStart || 0;
          }, weekdays: function(d) {
            return d ? d.format("dddd") : a(h, "weekdays");
          }, weekdaysMin: function(d) {
            return d ? d.format("dd") : a(h, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(d) {
            return d ? d.format("ddd") : a(h, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(d) {
            return u(h.$locale(), d);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        i.localeData = function() {
          return c.bind(this)();
        }, s.localeData = function() {
          var h = l();
          return { firstDayOfWeek: function() {
            return h.weekStart || 0;
          }, weekdays: function() {
            return s.weekdays();
          }, weekdaysShort: function() {
            return s.weekdaysShort();
          }, weekdaysMin: function() {
            return s.weekdaysMin();
          }, months: function() {
            return s.months();
          }, monthsShort: function() {
            return s.monthsShort();
          }, longDateFormat: function(d) {
            return u(h, d);
          }, meridiem: h.meridiem, ordinal: h.ordinal };
        }, s.months = function() {
          return a(l(), "months");
        }, s.monthsShort = function() {
          return a(l(), "monthsShort", "months", 3);
        }, s.weekdays = function(h) {
          return a(l(), "weekdays", null, null, h);
        }, s.weekdaysShort = function(h) {
          return a(l(), "weekdaysShort", "weekdays", 3, h);
        }, s.weekdaysMin = function(h) {
          return a(l(), "weekdaysMin", "weekdays", 2, h);
        };
      };
    });
  }(rs)), rs.exports;
}
var l_ = a_();
var u_ = Rt(l_);
var ss = { exports: {} };
var c_ = ss.exports;
var Ya;
function h_() {
  return Ya || (Ya = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(c_, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(r, s, i) {
        var o = s.prototype, a = o.format;
        i.en.formats = n, o.format = function(l) {
          l === void 0 && (l = "YYYY-MM-DDTHH:mm:ssZ");
          var u = this.$locale().formats, c = function(h, d) {
            return h.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(f, g, _) {
              var R = _ && _.toUpperCase();
              return g || d[_] || n[_] || d[R].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(b, H, P) {
                return H || P.slice(1);
              });
            });
          }(l, u === void 0 ? {} : u);
          return a.call(this, c);
        };
      };
    });
  }(ss)), ss.exports;
}
var d_ = h_();
var f_ = Rt(d_);
var is = { exports: {} };
var m_ = is.exports;
var za;
function g_() {
  return za || (za = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(m_, function() {
      var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, s = /([+-]|\d\d)/g;
      return function(i, o, a) {
        var l = o.prototype;
        a.utc = function(_) {
          var R = { date: _, utc: true, args: arguments };
          return new o(R);
        }, l.utc = function(_) {
          var R = a(this.toDate(), { locale: this.$L, utc: true });
          return _ ? R.add(this.utcOffset(), n) : R;
        }, l.local = function() {
          return a(this.toDate(), { locale: this.$L, utc: false });
        };
        var u = l.parse;
        l.parse = function(_) {
          _.utc && (this.$u = true), this.$utils().u(_.$offset) || (this.$offset = _.$offset), u.call(this, _);
        };
        var c = l.init;
        l.init = function() {
          if (this.$u) {
            var _ = this.$d;
            this.$y = _.getUTCFullYear(), this.$M = _.getUTCMonth(), this.$D = _.getUTCDate(), this.$W = _.getUTCDay(), this.$H = _.getUTCHours(), this.$m = _.getUTCMinutes(), this.$s = _.getUTCSeconds(), this.$ms = _.getUTCMilliseconds();
          } else c.call(this);
        };
        var h = l.utcOffset;
        l.utcOffset = function(_, R) {
          var b = this.$utils().u;
          if (b(_)) return this.$u ? 0 : b(this.$offset) ? h.call(this) : this.$offset;
          if (typeof _ == "string" && (_ = function(w) {
            w === void 0 && (w = "");
            var C = w.match(r);
            if (!C) return null;
            var v = ("" + C[0]).match(s) || ["-", 0, 0], y = v[0], F2 = 60 * +v[1] + +v[2];
            return F2 === 0 ? 0 : y === "+" ? F2 : -F2;
          }(_), _ === null)) return this;
          var H = Math.abs(_) <= 16 ? 60 * _ : _;
          if (H === 0) return this.utc(R);
          var P = this.clone();
          if (R) return P.$offset = H, P.$u = false, P;
          var W = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          return (P = this.local().add(H + W, n)).$offset = H, P.$x.$localOffset = W, P;
        };
        var d = l.format;
        l.format = function(_) {
          var R = _ || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return d.call(this, R);
        }, l.valueOf = function() {
          var _ = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * _;
        }, l.isUTC = function() {
          return !!this.$u;
        }, l.toISOString = function() {
          return this.toDate().toISOString();
        }, l.toString = function() {
          return this.toDate().toUTCString();
        };
        var f = l.toDate;
        l.toDate = function(_) {
          return _ === "s" && this.$offset ? a(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : f.call(this);
        };
        var g = l.diff;
        l.diff = function(_, R, b) {
          if (_ && this.$u === _.$u) return g.call(this, _, R, b);
          var H = this.local(), P = a(_).local();
          return g.call(H, P, R, b);
        };
      };
    });
  }(is)), is.exports;
}
var __ = g_();
var p_ = Rt(__);
var os = { exports: {} };
var E_ = os.exports;
var Va;
function C_() {
  return Va || (Va = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(E_, function() {
      return function(n, r) {
        r.prototype.weekday = function(s) {
          var i = this.$locale().weekStart || 0, o = this.$W, a = (o < i ? o + 7 : o) - i;
          return this.$utils().u(s) ? a : this.subtract(a, "day").add(s, "day");
        };
      };
    });
  }(os)), os.exports;
}
var R_ = C_();
var I_ = Rt(R_);
var as = { exports: {} };
var w_ = as.exports;
var Ga;
function S_() {
  return Ga || (Ga = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(w_, function() {
      var n = "week", r = "year";
      return function(s, i, o) {
        var a = i.prototype;
        a.week = function(l) {
          if (l === void 0 && (l = null), l !== null) return this.add(7 * (l - this.week()), "day");
          var u = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var c = o(this).startOf(r).add(1, r).date(u), h = o(this).endOf(n);
            if (c.isBefore(h)) return 1;
          }
          var d = o(this).startOf(r).date(u).startOf(n).subtract(1, "millisecond"), f = this.diff(d, n, true);
          return f < 0 ? o(this).startOf("week").week() : Math.ceil(f);
        }, a.weeks = function(l) {
          return l === void 0 && (l = null), this.week(l);
        };
      };
    });
  }(as)), as.exports;
}
var O_ = S_();
var v_ = Rt(O_);
var ls = { exports: {} };
var b_ = ls.exports;
var Ka;
function A_() {
  return Ka || (Ka = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(b_, function() {
      return function(n, r) {
        r.prototype.weekYear = function() {
          var s = this.month(), i = this.week(), o = this.year();
          return i === 1 && s === 11 ? o + 1 : s === 0 && i >= 52 ? o - 1 : o;
        };
      };
    });
  }(ls)), ls.exports;
}
var y_ = A_();
var N_ = Rt(y_);
tn.extend(i_);
tn.extend(t_);
tn.extend(I_);
tn.extend(u_);
tn.extend(v_);
tn.extend(N_);
tn.extend(p_);
tn.extend(f_);
function go(e, t, n, r) {
  if (e > t)
    throw new Error("a1 should be less than a2");
  if (n > r)
    throw new Error("b1 should be less than b2");
  if (t < n || r < e)
    return [e, t];
  if (n <= e && r >= t)
    return [];
  const s = r - n + 1;
  return e < n && t > r ? [e, t - s] : n <= e && r < t ? [r + 1 - s, t - s] : n > e && r >= t ? [e, n - 1] : [e, t];
}
function X1(e) {
  if (e == null)
    return false;
  const t = e.bullet;
  return (t == null ? void 0 : t.listId) != null;
}
function q1(e) {
  if (e == null)
    return false;
  const t = e.paragraphStyle;
  return T_(t);
}
function T_(e) {
  var t;
  return !(e == null || (e.indentStart == null || e.indentStart.v === 0) && e.hanging == null || ((t = e.hanging) == null ? void 0 : t.v) === 0);
}
function M_(e, t, n) {
  return e.slice(0, t) + n + e.slice(t);
}
function L_(e, t, n) {
  return t > n ? e : e.slice(0, t) + e.slice(n);
}
function Z1(e) {
  if (e == null || typeof e == "boolean")
    return false;
  if (typeof e == "number")
    return !isNaN(e);
  if (typeof e == "string") {
    const t = e.trim();
    return t === "" ? false : !isNaN(Number(t));
  }
  return false;
}
function J1(e) {
  let t = 0;
  for (let n = 0; n < e.length; n++)
    t = e.charCodeAt(n) + (t << 6) + (t << 16) - t;
  return t >>> 0;
}
function Q1(...e) {
  let t;
  return e.length === 1 && Array.isArray(e[0]) ? t = e[0] : t = e, oo({}, ...t);
}
var Te = Symbol("newer");
var Xe = Symbol("older");
var x_ = class {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: false, value: t.key }) : { done: true, value: void 0 };
  }
};
var D_ = class {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: false, value: t.value }) : { done: true, value: void 0 };
  }
};
var U_ = class {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: false, value: [t.key, t.value] }) : { done: true, value: void 0 };
  }
};
var Tl;
var Ml;
Ml = Te, Tl = Xe;
var Xa = class {
  constructor(t, n) {
    p(this, "key");
    p(this, "value");
    p(this, Ml);
    p(this, Tl);
    this.key = t, this.value = n, this[Te] = void 0, this[Xe] = void 0;
  }
  toJSON() {
    return {
      key: this.key,
      value: this.value
    };
  }
};
var gs = class {
  constructor(...t) {
    p(this, "_keymap");
    p(this, "size", 0);
    p(this, "limit");
    p(this, "oldest");
    p(this, "newest");
    p(this, "_onShiftListeners", []);
    if (Br.hasLength(t, 1)) {
      if (Br.isNumber(t[0])) {
        const n = t[0];
        this._initialize(n, void 0);
        return;
      }
      if (Br.isIterable(t[0])) {
        const n = t[0];
        this._initialize(0, n);
        return;
      }
      return;
    }
    if (Br.hasLength(t, 2)) {
      const n = t[0], r = t[1];
      this._initialize(n, r);
    }
  }
  onShift(t) {
    if (this._onShiftListeners.indexOf(t) === -1)
      return this._onShiftListeners.push(t), We(() => Os(this._onShiftListeners, t));
    throw new Error("[LRUMap]: the listener has been registered!");
  }
  _initialize(t, n) {
    this.oldest = void 0, this.newest = void 0, this.size = 0, this.limit = t, this._keymap = /* @__PURE__ */ new Map(), n && (this.assign(n), t < 1 && (this.limit = this.size));
  }
  _markEntryAsUsed(t) {
    t !== this.newest && (t[Te] && (t === this.oldest && (this.oldest = t[Te]), t[Te][Xe] = t[Xe]), t[Xe] && (t[Xe][Te] = t[Te]), t[Te] = void 0, t[Xe] = this.newest, this.newest && (this.newest[Te] = t), this.newest = t);
  }
  assign(t) {
    let n, r = this.limit || Number.MAX_VALUE;
    this._keymap.clear();
    const s = t[Symbol.iterator]();
    for (let i = s.next(); !i.done; i = s.next()) {
      const o = new Xa(i.value[0], i.value[1]);
      if (this._keymap.set(o.key, o), n ? (n[Te] = o, o[Xe] = n) : this.oldest = o, n = o, r-- === 0)
        throw new Error("overflow");
    }
    this.newest = n, this.size = this._keymap.size;
  }
  set(t, n) {
    let r = this._keymap.get(t);
    return r ? (r.value = n, this._markEntryAsUsed(r), this) : (this._keymap.set(t, r = new Xa(t, n)), this.newest ? (this.newest[Te] = r, r[Xe] = this.newest) : this.oldest = r, this.newest = r, ++this.size, this.size > this.limit && this.shift(), this);
  }
  shift() {
    const t = this.oldest;
    if (t)
      return this.oldest && this.oldest[Te] ? (this.oldest = this.oldest[Te], this.oldest[Xe] = void 0) : (this.oldest = void 0, this.newest = void 0), t[Te] = t[Xe] = void 0, this._keymap.delete(t.key), --this.size, this._onShiftListeners.forEach((n) => n(t)), [t.key, t.value];
  }
  get(t) {
    const n = this._keymap.get(t);
    if (n)
      return this._markEntryAsUsed(n), n.value;
  }
  has(t) {
    return this._keymap.has(t);
  }
  find(t) {
    const n = this._keymap.get(t);
    return n ? n.value : void 0;
  }
  delete(t) {
    const n = this._keymap.get(t);
    if (n)
      return this._keymap.delete(n.key), n[Te] && n[Xe] ? (n[Xe][Te] = n[Te], n[Te][Xe] = n[Xe]) : n[Te] ? (n[Te][Xe] = void 0, this.oldest = n[Te]) : n[Xe] ? (n[Xe][Te] = void 0, this.newest = n[Xe]) : this.oldest = this.newest = void 0, this.size--, n.value;
  }
  clear() {
    this.oldest = void 0, this.newest = void 0, this.size = 0, this._keymap.clear();
  }
  keys() {
    return new x_(this.oldest);
  }
  values() {
    return new D_(this.oldest);
  }
  entries() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new U_(this.oldest);
  }
  forEach(t, n) {
    typeof n != "object" && (n = this);
    let r = this.oldest;
    for (; r; )
      t.call(n, r.value, r.key, this), r = r[Te];
  }
  toJSON() {
    const t = new Array(this.size);
    let n = 0, r = this.oldest;
    for (; r; )
      t[n++] = { key: r.key, value: r.value }, r = r[Te];
    return t;
  }
  toString() {
    let t = "", n = this.oldest;
    for (; n; )
      t += `${String(n.key)}:${n.value}`, n = n[Te], n && (t += " < ");
    return t;
  }
};
var Br = class {
  static hasLength(t, n) {
    return t.length === n;
  }
  static getValueType(t) {
    return Object.prototype.toString.apply(t);
  }
  static isObject(t) {
    return this.getValueType(t) === "[object Object]";
  }
  static isIterable(t) {
    return t[Symbol.iterator] != null;
  }
  static isNumber(t) {
    return this.getValueType(t) === "[object Number]";
  }
};
var ar = 2;
var lr = 2 ** 2;
var us = 2 ** 3;
var ur = 2 ** 4;
var cr = 2 ** 5;
var hr = 2 ** 6;
var yi = 2 ** 7;
var Ni = 2 ** 8;
var Ti = 2 ** 9;
var k_ = 0;
var P_ = 2958466;
var F_ = -694324;
var $_ = 35830291;
var H_ = -1;
var qa = 1;
var Un = 6;
var _o = "general";
var po = "hash";
var kn = "zero";
var Eo = "qmark";
var Co = "slash";
var wr = "group";
var _s = "scale";
var Ro = "comma";
var Io = "break";
var xs = "text";
var wo = "plus";
var So = "minus";
var ps = "point";
var Oo = "space";
var vo = "percent";
var Ds = "digit";
var bo = "calendar";
var Sr = "error";
var Ao = "datetime";
var yo = "duration";
var No = "condition";
var To = "dbnum";
var Mo = "natnum";
var Lo = "locale";
var xo = "color";
var gu = "modifier";
var Do = "ampm";
var Uo = "escaped";
var ko = "string";
var Po = "skip";
var Fo = "exp";
var $o = "fill";
var Ho = "paren";
var Us = "char";
var B_ = [
  "#000",
  "#FFF",
  "#F00",
  "#0F0",
  "#00F",
  "#FF0",
  "#F0F",
  "#0FF",
  "#000",
  "#FFF",
  "#F00",
  "#0F0",
  "#00F",
  "#FF0",
  "#F0F",
  "#0FF",
  "#800",
  "#080",
  "#008",
  "#880",
  "#808",
  "#088",
  "#CCC",
  "#888",
  "#99F",
  "#936",
  "#FFC",
  "#CFF",
  "#606",
  "#F88",
  "#06C",
  "#CCF",
  "#008",
  "#F0F",
  "#FF0",
  "#0FF",
  "#808",
  "#800",
  "#088",
  "#00F",
  "#0CF",
  "#CFF",
  "#CFC",
  "#FF9",
  "#9CF",
  "#F9C",
  "#C9F",
  "#FC9",
  "#36F",
  "#3CC",
  "#9C0",
  "#FC0"
];
var Mi = [
  "",
  "$",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var Li = new RegExp("[" + Mi.join("") + "]");
var ni = Object.freeze({
  1078: "af",
  // Afrikaans
  1052: "sq",
  // Albanian
  1118: "am",
  // Amharic
  5121: "ar_DZ",
  // Arabic - Algeria
  15361: "ar_BH",
  // Arabic - Bahrain
  3073: "ar_EG",
  // Arabic - Egypt
  2049: "ar_IQ",
  // Arabic - Iraq
  11265: "ar_JO",
  // Arabic - Jordan
  13313: "ar_KW",
  // Arabic - Kuwait
  12289: "ar_LB",
  // Arabic - Lebanon
  4097: "ar_LY",
  // Arabic - Libya
  6145: "ar_MA",
  // Arabic - Morocco
  8193: "ar_OM",
  // Arabic - Oman
  16385: "ar_QA",
  // Arabic - Qatar
  1025: "ar_SA",
  // Arabic - Saudi Arabia
  10241: "ar_SY",
  // Arabic - Syria
  7169: "ar_TN",
  // Arabic - Tunisia
  14337: "ar_AE",
  // Arabic - United Arab Emirates
  9217: "ar_YE",
  // Arabic - Yemen
  1067: "hy",
  // Armenian
  1101: "as",
  // Assamese
  2092: "az_AZ",
  // Azeri - Cyrillic
  1068: "az_AZ",
  // Azeri - Latin
  1069: "eu",
  // Basque
  1059: "be",
  // Belarusian
  2117: "bn",
  // Bengali - Bangladesh
  1093: "bn_IN",
  // Bengali - India
  5146: "bs",
  // Bosnian
  1026: "bg",
  // Bulgarian
  1109: "my",
  // Burmese
  1027: "ca",
  // Catalan
  2052: "zh_CN",
  // Chinese - China
  3076: "zh_HK",
  // Chinese - Hong Kong SAR
  5124: "zh_MO",
  // Chinese - Macau SAR
  4100: "zh_SG",
  // Chinese - Singapore
  1028: "zh_TW",
  // Chinese - Taiwan
  1050: "hr",
  // Croatian
  1029: "cs",
  // Czech
  1030: "da",
  // Danish
  1125: "dv",
  // Divehi; Dhivehi; Maldivian
  2067: "nl_BE",
  // Dutch - Belgium
  1043: "nl_NL",
  // Dutch - Netherlands
  1126: "bin",
  // Edo
  3081: "en_AU",
  // English - Australia
  10249: "en_BZ",
  // English - Belize
  4105: "en_CA",
  // English - Canada
  9225: "en_CB",
  // English - Caribbean
  2057: "en_GB",
  // English - Great Britain
  16393: "en_IN",
  // English - India
  6153: "en_IE",
  // English - Ireland
  8201: "en_JM",
  // English - Jamaica
  5129: "en_NZ",
  // English - New Zealand
  13321: "en_PH",
  // English - Phillippines
  7177: "en_ZA",
  // English - Southern Africa
  11273: "en_TT",
  // English - Trinidad
  1033: "en_US",
  // English - United States
  12297: "en_ZW",
  // English - Zimbabwe
  1061: "et",
  // Estonian
  1071: "mk",
  // FYRO Macedonia
  1080: "fo",
  // Faroese
  1065: "fa",
  // Farsi - Persian
  1124: "fil",
  // Filipino
  1035: "fi",
  // Finnish
  2060: "fr_BE",
  // French - Belgium
  11276: "fr_CM",
  // French - Cameroon
  3084: "fr_CA",
  // French - Canada
  9228: "fr_CG",
  // French - Congo
  12300: "fr_CI",
  // French - Cote d'Ivoire
  1036: "fr_FR",
  // French - France
  5132: "fr_LU",
  // French - Luxembourg
  13324: "fr_ML",
  // French - Mali
  6156: "fr_MC",
  // French - Monaco
  14348: "fr_MA",
  // French - Morocco
  10252: "fr_SN",
  // French - Senegal
  4108: "fr_CH",
  // French - Switzerland
  7180: "fr",
  // French - West Indies
  1122: "fy_NL",
  // Frisian - Netherlands
  2108: "gd_IE",
  // Gaelic - Ireland
  1084: "gd",
  // Gaelic - Scotland
  1110: "gl",
  // Galician
  1079: "ka",
  // Georgian
  3079: "de_AT",
  // German - Austria
  1031: "de_DE",
  // German - Germany
  5127: "de_LI",
  // German - Liechtenstein
  4103: "de_LU",
  // German - Luxembourg
  2055: "de_CH",
  // German - Switzerland
  1032: "el",
  // Greek
  1140: "gn",
  // Guarani - Paraguay
  1095: "gu",
  // Gujarati
  1279: "en",
  // HID (Human Interface Device)
  1037: "he",
  // Hebrew
  1081: "hi",
  // Hindi
  1038: "hu",
  // Hungarian
  1039: "is",
  // Icelandic
  1136: "ig_NG",
  // Igbo - Nigeria
  1057: "id",
  // Indonesian
  1040: "it_IT",
  // Italian - Italy
  2064: "it_CH",
  // Italian - Switzerland
  1041: "ja",
  // Japanese
  1099: "kn",
  // Kannada
  1120: "ks",
  // Kashmiri
  1087: "kk",
  // Kazakh
  1107: "km",
  // Khmer
  1111: "kok",
  // Konkani
  1042: "ko",
  // Korean
  1088: "ky",
  // Kyrgyz - Cyrillic
  1108: "lo",
  // Lao
  1142: "la",
  // Latin
  1062: "lv",
  // Latvian
  1063: "lt",
  // Lithuanian
  2110: "ms_BN",
  // Malay - Brunei
  1086: "ms_MY",
  // Malay - Malaysia
  1100: "ml",
  // Malayalam
  1082: "mt",
  // Maltese
  1112: "mni",
  // Manipuri
  1153: "mi",
  // Maori
  1102: "mr",
  // Marathi
  1104: "mn",
  // Mongolian
  2128: "mn",
  // Mongolian
  1121: "ne",
  // Nepali
  1044: "no_NO",
  // Norwegian - Bokml
  2068: "no_NO",
  // Norwegian - Nynorsk
  1096: "or",
  // Oriya
  1045: "pl",
  // Polish
  1046: "pt_BR",
  // Portuguese - Brazil
  2070: "pt_PT",
  // Portuguese - Portugal
  1094: "pa",
  // Punjabi
  1047: "rm",
  // Raeto-Romance
  2072: "ro_MO",
  // Romanian - Moldova
  1048: "ro_RO",
  // Romanian - Romania
  1049: "ru",
  // Russian
  2073: "ru_MO",
  // Russian - Moldova
  1083: "se",
  // Sami Lappish
  1103: "sa",
  // Sanskrit
  3098: "sr_SP",
  // Serbian - Cyrillic
  2074: "sr_SP",
  // Serbian - Latin
  1072: "st",
  // Sesotho (Sutu)
  1074: "tn",
  // Setsuana
  1113: "sd",
  // Sindhi
  1115: "si",
  // Sinhala; Sinhalese
  1051: "sk",
  // Slovak
  1060: "sl",
  // Slovenian
  1143: "so",
  // Somali
  1070: "sb",
  // Sorbian
  11274: "es_AR",
  // Spanish - Argentina
  16394: "es_BO",
  // Spanish - Bolivia
  13322: "es_CL",
  // Spanish - Chile
  9226: "es_CO",
  // Spanish - Colombia
  5130: "es_CR",
  // Spanish - Costa Rica
  7178: "es_DO",
  // Spanish - Dominican Republic
  12298: "es_EC",
  // Spanish - Ecuador
  17418: "es_SV",
  // Spanish - El Salvador
  4106: "es_GT",
  // Spanish - Guatemala
  18442: "es_HN",
  // Spanish - Honduras
  2058: "es_MX",
  // Spanish - Mexico
  19466: "es_NI",
  // Spanish - Nicaragua
  6154: "es_PA",
  // Spanish - Panama
  15370: "es_PY",
  // Spanish - Paraguay
  10250: "es_PE",
  // Spanish - Peru
  20490: "es_PR",
  // Spanish - Puerto Rico
  1034: "es_ES",
  // Spanish - Spain (Traditional)
  14346: "es_UY",
  // Spanish - Uruguay
  8202: "es_VE",
  // Spanish - Venezuela
  1089: "sw",
  // Swahili
  2077: "sv_FI",
  // Swedish - Finland
  1053: "sv_SE",
  // Swedish - Sweden
  1114: "syc",
  // Syriac
  1064: "tg",
  // Tajik
  1097: "ta",
  // Tamil
  1092: "tt",
  // Tatar
  1098: "te",
  // Telugu
  1054: "th",
  // Thai
  1105: "bo",
  // Tibetan
  1073: "ts",
  // Tsonga
  1055: "tr",
  // Turkish
  1090: "tk",
  // Turkmen
  1058: "uk",
  // Ukrainian
  1056: "ur",
  // Urdu
  2115: "uz_UZ",
  // Uzbek - Cyrillic
  1091: "uz_UZ",
  // Uzbek - Latin
  1075: "ve",
  // Venda
  1066: "vi",
  // Vietnamese
  1106: "cy",
  // Welsh
  1076: "xh",
  // Xhosa
  1085: "yi",
  // Yiddish
  1077: "zu"
  // Zulu
});
var _u = /^([a-z\d]+)(?:[_-]([a-z\d]+))?(?:\.([a-z\d]+))?(?:@([a-z\d]+))?$/i;
var Nn = {};
var E = (e, t = "") => e.replace(/~/g, t).split(";");
var xe = (e, t = 0, n = 0) => (e.mmm || (e.mmm = t < 1 ? e.mmmm.concat() : e.mmmm.map((r) => {
  const s = r.slice(0, t % 10);
  return s + (t < 10 || r === s ? "" : ".");
})), e.ddd || (e.ddd = n < 1 ? e.dddd.concat() : e.dddd.map((r) => {
  const s = r.slice(0, n % 10);
  return s + (n < 10 || r === s ? "" : ".");
})), !e.mmm6 && e.mmmm6 && (e.mmm6 = e.mmmm6), e);
var j_ = {
  group: "",
  decimal: ".",
  positive: "+",
  negative: "-",
  percent: "%",
  exponent: "E",
  nan: "NaN",
  infinity: "",
  ampm: E("AM;PM"),
  mmmm6: E("Muharram;Safar;Rabi I;Rabi II;Jumada I;Jumada II;Rajab;Shaban;Ramadan;Shawwal;Dhul-Qidah;Dhul-Hijjah"),
  mmm6: E("Muh.;Saf.;Rab. I;Rab. II;Jum. I;Jum. II;Raj.;Sha.;Ram.;Shaw.;Dhul-Q.;Dhul-H."),
  mmmm: E("January;February;March;April;May;June;July;August;September;October;November;December"),
  mmm: E("Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec"),
  dddd: E("Sunday;Monday;Tuesday;Wednesday;Thursday;Friday;Saturday"),
  ddd: E("Sun;Mon;Tue;Wed;Thu;Fri;Sat"),
  bool: E("TRUE;FALSE"),
  preferMDY: false
};
function Bo(e) {
  const t = _u.exec(e);
  if (!t)
    throw new SyntaxError(`Malformed locale: ${e}`);
  return {
    lang: t[1] + (t[2] ? "_" + t[2] : ""),
    language: t[1],
    territory: t[2] || ""
  };
}
function jo(e) {
  if (typeof e == "number")
    return ni[e & 65535] || null;
  const t = parseInt(e, 16);
  return isFinite(t) && ni[t & 65535] ? ni[t & 65535] || null : _u.test(e) ? e : null;
}
function Kn(e) {
  const t = jo(e);
  let n = null;
  if (t) {
    const r = Bo(t);
    n = Nn[r.lang] || Nn[r.language] || null;
  }
  return n;
}
function xi(e) {
  return Object.assign({}, j_, e);
}
function te(e, t) {
  const n = typeof t == "object" ? t : Bo(t);
  return Nn[n.lang] = xi(e), n.language !== n.lang && !Nn[n.language] && (Nn[n.language] = xi(e)), Nn[n.lang];
}
var Jt = xi({ group: ",", preferMDY: true });
Jt.isDefault = true;
te({
  group: ",",
  ampm: E(";"),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "zh_CN");
var Wo = {
  group: ",",
  ampm: E(";"),
  mmmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
};
te({
  ...Wo,
  nan: "",
  dddd: E("~;~;~;~;~;~;~", "")
}, "zh_TW");
te({
  ...Wo,
  dddd: E("~;~;~;~;~;~;~", "")
}, "zh_HK");
te({
  ...Wo,
  ampm: E(";"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "ja");
te({
  group: ",",
  ampm: E(";"),
  mmmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "ko");
te({
  group: ",",
  ampm: E(";"),
  mmmm: E("~;;~;;~;;~;~;;~;;~", ""),
  mmm: E("..;..;..;..;..;..;..;..;..;..;..;.."),
  dddd: E(";;;;;;"),
  ddd: E(".;.;.;.;.;.;.")
}, "th");
te(xe({
  decimal: ",",
  ampm: E("dop.;odp."),
  mmmm: E("ledna;nora;bezna;dubna;kvtna;ervna;ervence;srpna;z;jna;listopadu;prosince"),
  mmm: E("I;II;III;IV;V;VI;VII;VIII;IX;X;XI;XII"),
  dddd: E("nedle;pondl;ter;steda;tvrtek;ptek;sobota"),
  bool: E("PRAVDA;NEPRAVDA")
}, -1, 2), "cs");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("januar;februar;marts;april;maj;juni;juli;august;september;oktober;november;december"),
  dddd: E("sn~;man~;tirs~;ons~;tors~;fre~;lr~", "dag"),
  bool: E("SAND;FALSK")
}, 13, 13), "da");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("januari;februari;maart;april;mei;juni;juli;augustus;september;oktober;november;december"),
  mmm: E("jan.;feb.;mrt.;apr.;mei;jun.;jul.;aug.;sep.;okt.;nov.;dec."),
  dddd: E("zondag;maandag;dinsdag;woensdag;donderdag;vrijdag;zaterdag"),
  bool: E("WAAR;ONWAAR")
}, -1, 2), "nl");
te({ group: ",", preferMDY: true }, "en");
te({ group: ",", preferMDY: true }, "en_US");
te({ group: "," }, "en_AU");
te({ group: "," }, "en_CA");
te({ group: "," }, "en_GB");
te({ group: ",", mmm: E("Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sept;Oct;Nov;Dec") }, "en_IE");
te(xe({
  decimal: ",",
  nan: "epluku",
  ampm: E("ap.;ip."),
  mmmm: E("tammi~;helmi~;maalis~;huhti~;touko~;kes~;hein~;elo~;syys~;loka~;marras~;joulu~", "kuuta"),
  mmm: E("tammik.;helmik.;maalisk.;huhtik.;toukok.;kesk.;heink.;elok.;syysk.;lokak.;marrask.;jouluk."),
  dddd: E("sunnun~;maanan~;tiis~;keskiviikkona;tors~;perjan~;lauan~", "taina"),
  bool: E("TOSI;EPTOSI")
}, -1, 2), "fi");
var Yo = xe({
  group: "",
  decimal: ",",
  mmmm: E("janvier;fvrier;mars;avril;mai;juin;juillet;aot;septembre;octobre;novembre;dcembre"),
  mmm: E("janv.;fvr.;mars;avr.;mai;juin;juil.;aot;sept.;oct.;nov.;dc."),
  dddd: E("~manche;lun~;mar~;mercre~;jeu~;vendre~;same~", "di"),
  bool: E("VRAI;FAUX")
}, -1, 13);
te({ ...Yo }, "fr");
te({ ...Yo, mmm: E("janv.;fvr.;mars;avr.;mai;juin;juill.;aot;sept.;oct.;nov.;dc.") }, "fr_CA");
te({ group: "'", decimal: ".", ...Yo }, "fr_CH");
var pu = xe({
  mmmm: E("Januar;Februar;Mrz;April;Mai;Juni;Juli;August;September;Oktober;November;Dezember"),
  mmm: E("Jan.;Feb.;Mrz;Apr.;Mai;Juni;Juli;Aug.;Sept.;Okt.;Nov.;Dez."),
  dddd: E("Sonn~;Mon~;Diens~;Mittwoch;Donners~;Frei~;Sams~", "tag"),
  bool: E("WAHR;FALSCH")
}, -1, 12);
te({ group: ".", decimal: ",", ...pu }, "de");
te({ group: "'", decimal: ".", ...pu }, "de_CH");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E("..;.."),
  mmmm: E("~;~;~;~;;~;~;;~;~;~;~", ""),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, -1, 3), "el");
te({
  decimal: ",",
  ampm: E("de.;du."),
  mmmm: E("janur;februr;mrcius;prilis;mjus;jnius;jlius;augusztus;szeptember;oktber;november;december"),
  mmm: E("jan.;febr.;mrc.;pr.;mj.;jn.;jl.;aug.;szept.;okt.;nov.;dec."),
  dddd: E("vasrnap;htf;kedd;szerda;cstrtk;pntek;szombat"),
  ddd: E("V;H;K;Sze;Cs;P;Szo"),
  bool: E("IGAZ;HAMIS")
}, "hu");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E("f.h.;e.h."),
  mmmm: E("janar;febrar;mars;aprl;ma;jn;jl;gst;september;oktber;nvember;desember"),
  dddd: E("sunnu~;mnu~;riju~;miviku~;fimmtu~;fstu~;laugar~", "dagur")
}, 13, 13), "is");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("Januari;Februari;Maret;April;Mei;Juni;Juli;Agustus;September;Oktober;November;Desember"),
  dddd: E("Minggu;Senin;Selasa;Rabu;Kamis;Jumat;Sabtu")
}, 3, 3), "id");
var Eu = xe({
  mmmm: E("gennaio;febbraio;marzo;aprile;maggio;giugno;luglio;agosto;settembre;ottobre;novembre;dicembre"),
  dddd: E("domenica;luned;marted;mercoled;gioved;venerd;sabato"),
  bool: E("VERO;FALSO")
}, 3, 3);
te({ group: ".", decimal: ",", ...Eu }, "it");
te({ group: "'", decimal: ".", ...Eu }, "it_CH");
var Cu = {
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("januar;februar;mars;april;mai;juni;juli;august;september;oktober;november;desember"),
  mmm: E("jan.;feb.;mar.;apr.;mai;jun.;jul.;aug.;sep.;okt.;nov.;des."),
  dddd: E("sn~;man~;tirs~;ons~;tors~;fre~;lr~", "dag"),
  bool: E("SANN;USANN")
};
te(xe({ ...Cu }, -1, 13), "nb");
te(xe({ ...Cu }, -1, 13), "no");
te(xe({
  decimal: ",",
  mmmm: E("stycznia;lutego;marca;kwietnia;maja;czerwca;lipca;sierpnia;wrzenia;padziernika;listopada;grudnia"),
  dddd: E("niedziela;poniedziaek;wtorek;roda;czwartek;pitek;sobota"),
  ddd: E("niedz.;pon.;wt.;r.;czw.;pt.;sob."),
  bool: E("PRAWDA;FASZ")
}, 3, -1), "pl");
var Ru = {
  group: ".",
  decimal: ",",
  mmmm: E("janeiro;fevereiro;maro;abril;maio;junho;julho;agosto;setembro;outubro;novembro;dezembro"),
  dddd: E("domingo;segunda-feira;tera-feira;quarta-feira;quinta-feira;sexta-feira;sbado"),
  bool: E("VERDADEIRO;FALSO")
};
te(xe(Ru, 13, 13), "pt");
te(xe(Ru, 13, 13), "pt_BR");
te({
  decimal: ",",
  nan: "",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;;.;.;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  mmmm6: E(";;-;-;;--;--;--;--;;;"),
  mmm6: E(".;.;-.;-.;.;. I;. II;. I;. II;.;.;."),
  bool: E(";")
}, "ru");
te(xe({
  decimal: ",",
  mmmm: E("janura;februra;marca;aprla;mja;jna;jla;augusta;septembra;oktbra;novembra;decembra"),
  dddd: E("nedea;pondelok;utorok;streda;tvrtok;piatok;sobota")
}, 3, 2), "sk");
var Ft = {
  group: ".",
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("enero;febrero;marzo;abril;mayo;junio;julio;agosto;septiem~;octu~;noviem~;diciem~", "bre"),
  mmm: E("ene;feb;mar;abr;may;jun;jul;ago;sept;oct;nov;dic"),
  dddd: E("domingo;lunes;martes;mircoles;jueves;viernes;sbado"),
  ddd: E("dom;lun;mar;mi;jue;vie;sb"),
  bool: E("VERDADERO;FALSO")
};
var W_ = E("ene;feb;mar;abr;may;jun;jul;ago;sep;oct;nov;dic");
var zo = E("ene.;feb.;mar.;abr.;may.;jun.;jul.;ago.;sept.;oct.;nov.;dic.");
te({ ...Ft }, "es");
te({ ...Ft }, "es_AR");
te({ ...Ft }, "es_BO");
te({ ...Ft }, "es_CL");
te({ ...Ft }, "es_CO");
te({ ...Ft }, "es_EC");
te({ ...Ft, mmm: W_, ampm: E("a.m.;p.m.") }, "es_MX");
te({ ...Ft, mmm: zo }, "es_PY");
te({ ...Ft, mmm: zo }, "es_UY");
te({ ...Ft, mmm: zo, mmmm: E("enero;febrero;marzo;abril;mayo;junio;julio;agosto;setiembre;octubre;noviembre;diciembre") }, "es_VE");
te({
  decimal: ",",
  ampm: E("fm;em"),
  mmmm: E("januari;februari;mars;april;maj;juni;juli;augusti;september;oktober;november;december"),
  mmm: E("jan.;feb.;mars;apr.;maj;juni;juli;aug.;sep.;okt.;nov.;dec."),
  dddd: E("sn~;mn~;tis~;ons~;tors~;fre~;lr~", "dag"),
  ddd: E("sn;mn;tis;ons;tors;fre;lr")
}, "sv");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E(";S"),
  mmmm: E("Ocak;ubat;Mart;Nisan;Mays;Haziran;Temmuz;Austos;Eyll;Ekim;Kasm;Aralk"),
  mmm: E("Oca;ub;Mar;Nis;May;Haz;Tem;Au;Eyl;Eki;Kas;Ara"),
  dddd: E("Pazar;Pazartesi;Sal;aramba;Perembe;Cuma;Cumartesi"),
  ddd: E("Paz;Pzt;Sal;ar;Per;Cum;Cmt"),
  bool: E("DORU;YANLI")
}, 3, -1), "tr");
te({
  group: ",",
  ampm: E("yb;yh"),
  mmmm: E("Ionawr;Chwefror;Mawrth;Ebrill;Mai;Mehefin;Gorffennaf;Awst;Medi;Hydref;Tachwedd;Rhagfyr"),
  mmm: E("Ion;Chwef;Maw;Ebr;Mai;Meh;Gorff;Awst;Medi;Hyd;Tach;Rhag"),
  dddd: E("Dydd Sul;Dydd Llun;Dydd Mawrth;Dydd Mercher;Dydd Iau;Dydd Gwener;Dydd Sadwrn"),
  ddd: E("Sul;Llun;Maw;Mer;Iau;Gwen;Sad")
}, "cy");
te({
  group: ".",
  decimal: ",",
  mmmm: E("yanvar;fevral;mart;aprel;may;iyun;iyul;avqust;sentyabr;oktyabr;noyabr;dekabr"),
  mmm: E("yan;fev;mar;apr;may;iyn;iyl;avq;sen;okt;noy;dek"),
  dddd: E("bazar;bazar ertsi;rnb axam;rnb;cm axam;cm;nb"),
  ddd: E("B.;B.e.;.a.;.;C.a.;C.;.")
}, "az");
te(xe({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, 3, -1), "be");
te({
  decimal: ",",
  ampm: E("..;.."),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  bool: E(";")
}, "bg");
te({
  group: ".",
  decimal: ",",
  mmmm: E("de gener;de febrer;de mar;dabril;de maig;de juny;de juliol;dagost;de setembre;doctubre;de novembre;de desembre"),
  mmm: E("de gen.;de febr.;de mar;dabr.;de maig;de juny;de jul.;dag.;de set.;doct.;de nov.;de des."),
  dddd: E("diumenge;dilluns;dimarts;dimecres;dijous;divendres;dissabte"),
  ddd: E("dg.;dl.;dt.;dc.;dj.;dv.;ds."),
  ampm: E("a.m.;p.m.")
}, "ca");
te(xe({
  group: ",",
  decimal: ".",
  mmmm: E("Enero;Pebrero;Marso;Abril;Mayo;Hunyo;Hulyo;Agosto;Setyembre;Oktubre;Nobyembre;Disyembre"),
  dddd: E("Linggo;Lunes;Martes;Miyerkules;Huwebes;Biyernes;Sabado")
}, 3, 3), "fil");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "gu");
te({
  group: ",",
  decimal: ".",
  ampm: E(";"),
  dddd: E("~;~;~;~;~;~;~", " "),
  ddd: E("~;~;~;~;~;~;", " "),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  mmmm6: E(";; ; ;; ; ; ; ;;;"),
  mmm6: E(";; ; ;; ; ; ; ;;;")
}, "he");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("sijenja;veljae;oujka;travnja;svibnja;lipnja;srpnja;kolovoza;rujna;listopada;studenoga;prosinca"),
  mmm: E("sij;velj;ou;tra;svi;lip;srp;kol;ruj;lis;stu;pro"),
  dddd: E("nedjelja;ponedjeljak;utorak;srijeda;etvrtak;petak;subota")
}, -1, 3), "hr");
te({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "hy");
te(xe({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, 3, 3), "ka");
te(xe({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, 13, -1), "kk");
te({
  group: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;"),
  ampm: E(";")
}, "kn");
te({
  decimal: ",",
  mmmm: E("sausio;vasario;kovo;balandio;gegus;birelio;liepos;rugpjio;rugsjo;spalio;lapkriio;gruodio"),
  mmm: E("saus.;vas.;kov.;bal.;geg.;bir.;liep.;rugp.;rugs.;spal.;lapkr.;gruod."),
  dddd: E("sekmadienis;pirmadienis;antradienis;treiadienis;ketvirtadienis;penktadienis;etadienis"),
  ddd: E("sk;pr;an;tr;kt;pn;t"),
  ampm: E("priepiet;popiet")
}, "lt");
te({
  decimal: ",",
  mmmm: E("janvris;februris;marts;aprlis;maijs;jnijs;jlijs;augusts;septembris;oktobris;novembris;decembris"),
  mmm: E("janv.;febr.;marts;apr.;maijs;jn.;jl.;aug.;sept.;okt.;nov.;dec."),
  dddd: E("svtdiena;pirmdiena;otrdiena;trediena;ceturtdiena;piektdiena;sestdiena"),
  ddd: E("svtd.;pirmd.;otrd.;tred.;ceturtd.;piektd.;sestd."),
  ampm: E("priekpusdien;pcpusdien")
}, "lv");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "ml");
te({
  group: ",",
  decimal: ".",
  mmmm: E("~;~;~;~;~;~;~;~;~;~; ~; ~", " "),
  mmm: E("1~;2~;3~;4~;5~;6~;7~;8~;9~;10~;11~;12~", "- "),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("..;..")
}, "mn");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "mr");
te(xe({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ampm: E(";")
}, -1, 0), "my");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("..;..")
}, "pa");
te({
  group: ".",
  decimal: ",",
  mmmm: E("ianuarie;februarie;martie;aprilie;mai;iunie;iulie;august;septem~;octom~;noiem~;decem~", "brie"),
  mmm: E("ian.;feb.;mar.;apr.;mai;iun.;iul.;aug.;sept.;oct.;nov.;dec."),
  dddd: E("duminic;luni;mari;miercuri;joi;vineri;smbt"),
  ddd: E("dum.;lun.;mar.;mie.;joi;vin.;sm."),
  ampm: E("a.m.;p.m.")
}, "ro");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("januar;februar;marec;april;maj;junij;julij;avgust;september;oktober;november;december"),
  mmm: E("jan.;feb.;mar.;apr.;maj;jun.;jul.;avg.;sep.;okt.;nov.;dec."),
  dddd: E("nedelja;ponedeljek;torek;sreda;etrtek;petek;sobota"),
  ampm: E("dop.;pop.")
}, -1, 13), "sl");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, 3, 3), "sr");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;;;;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(".;.;.;.;.;.;")
}, "ta");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "te");
te({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;.;.;.;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E(";")
}, "uk");
te({
  group: ".",
  decimal: ",",
  mmmm: E("~1;~2;~3;~4;~5;~6;~7;~8;~9;~10;~11;~12", "thng "),
  mmm: E("~1;~2;~3;~4;~5;~6;~7;~8;~9;~10;~11;~12", "thg "),
  dddd: E("Ch Nht;Th Hai;Th Ba;Th T;Th Nm;Th Su;Th By"),
  ddd: E("CN;Th 2;Th 3;Th 4;Th 5;Th 6;Th 7"),
  ampm: E("SA;CH")
}, "vi");
te(xe({
  group: "",
  decimal: "",
  ampm: E(";"),
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  mmmm6: E(";; ; ;; ; ; ; ;;;")
}, 0, 0), "ar");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "bn");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("am;pm")
}, "hi");
var Iu = {
  // Overflow error string
  overflow: "######",
  // dateErrorThrow needs to be off! [prev in locale]
  // Should it throw when there is an overflow error?
  dateErrorThrows: false,
  // Should it emit a number when date has an overflow error? (Sheets does this)
  dateErrorNumber: true,
  // dateErrorThrow needs to be off!
  // Should it emit a number when bigint has an is an overflow error?
  bigintErrorNumber: false,
  // Sheets mode (see #3)
  dateSpanLarge: true,
  // Simulate the Lotus 1-2-3 leap year bug
  leap1900: true,
  // Emit regular vs. non-breaking spaces
  nbsp: false,
  // Robust/throw mode
  throws: true,
  // What is emitted when robust mode fails to parse (###### currently)
  invalid: "######",
  // Locale
  locale: "",
  // Don't adjust dates to UTC when converting them to serial time
  ignoreTimezone: false,
  // Integer digit grouping
  grouping: [3, 3],
  // resolve indexed colors to hex
  indexColors: true,
  // Skip-next signifier character
  skipChar: "",
  // Repear-next signifier character
  repeatChar: ""
};
function Et(e, t = 0) {
  if (typeof e != "number")
    return e;
  if (e < 0)
    return -Et(-e, t);
  if (t) {
    const n = 10 ** t || 1;
    return Et(e * n, 0) / n;
  }
  return Math.round(e);
}
var Y_ = 1e-13;
function wu(e, t = 2, n = 2) {
  const r = e < 0 ? -1 : 1, s = 10 ** (t || 2), i = 10 ** (n || 2);
  let o = Math.abs(e), a = 0, l = 0, u = 0, c = 1, h, d;
  if (e = o, e % 1 === 0)
    d = [e * r, 1];
  else if (e < 1e-19)
    d = [r, 1e19];
  else if (e > 1e19)
    d = [1e19 * r, 1];
  else {
    do
      if (o = 1 / (o - Math.floor(o)), h = c, c = c * Math.floor(o) + a, a = h, l = u, u = Math.floor(e * c + 0.5), u >= s || c >= i)
        return [r * l, a];
    while (Math.abs(e - u / c) >= Y_ && o !== Math.floor(o));
    d = [r * u, c];
  }
  return d;
}
var ut = Math.floor;
function Su(e, t = true) {
  if (t && e >= 0) {
    if (e === 0)
      return [1900, 1, 0];
    if (e === 60)
      return [1900, 2, 29];
    if (e < 60)
      return [1900, e < 32 ? 1 : 2, (e - 1) % 31 + 1];
  }
  let n = e + 68569 + 2415019;
  const r = ut(4 * n / 146097);
  n = n - ut((146097 * r + 3) / 4);
  const s = ut(4e3 * (n + 1) / 1461001);
  n = n - ut(1461 * s / 4) + 31;
  const i = ut(80 * n / 2447), o = n - ut(2447 * i / 80);
  n = ut(i / 11);
  const a = i + 2 - 12 * n;
  return [100 * (r - 49) + s + n | 0, a | 0, o | 0];
}
function z_(e) {
  return Su(e + 1462);
}
function V_(e) {
  if (e === 60)
    throw new Error("#VALUE!");
  if (e <= 1)
    return [1317, 8, 29];
  if (e < 60)
    return [1317, e < 32 ? 9 : 10, 1 + (e - 2) % 30];
  const t = 10631 / 30, n = 8.01 / 60;
  let r = e + 466935;
  const s = ut(r / 10631);
  r = r - 10631 * s;
  const i = ut((r - n) / t);
  r = r - ut(i * t + n);
  const o = ut((r + 28.5001) / 29.5);
  return o === 13 ? [30 * s + i, 12, 30] : [30 * s + i, o, r - ut(29.5001 * o - 29)];
}
function Ou(e, t = 0, n = true) {
  const r = ut(e);
  return t === Un ? V_(r) : t === H_ ? z_(r) : Su(r, n);
}
var jr = Math.floor;
var ri = 86400;
function Vo(e, t) {
  let n = null;
  if (Array.isArray(e)) {
    const [r, s, i, o, a, l] = e;
    n = Date.UTC(r, s == null ? 0 : s - 1, i != null ? i : 1, o || 0, a || 0, l || 0);
  } else if (e instanceof Date && (n = e * 1, !t || !t.ignoreTimezone)) {
    const r = /* @__PURE__ */ new Date();
    r.setUTCFullYear(
      e.getFullYear(),
      e.getMonth(),
      e.getDate()
    ), r.setUTCHours(
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    ), n = r * 1;
  }
  if (n != null && isFinite(n)) {
    const r = n / 864e5;
    return r - (r <= -25509 ? -25568 : -25569);
  }
  return null;
}
function G_(e, t) {
  let n = e | 0;
  const r = ri * (e - n);
  let s = jr(r);
  r - s > 0.9999 && (s += 1, s === ri && (s = 0, n += 1));
  const i = s < 0 ? ri + s : s, [o, a, l] = Ou(e, 0, t && t.leap1900), u = jr(i / 60 / 60) % 60, c = jr(i / 60) % 60, h = jr(i) % 60;
  return [o, a, l, u, c, h];
}
var K_ = [
  // day-month-year
  "!d-m-y",
  "!d-m-Y",
  "!j-m-y",
  "!j-m-Y",
  "!d-n-y",
  "!d-n-Y",
  "!j-n-y",
  "!j-n-Y",
  // month-day-year
  "?m-d-y",
  "?m-d-Y",
  "?m-j-y",
  "?m-j-Y",
  "?n-d-y",
  "?n-d-Y",
  "?n-j-y",
  "?n-j-Y",
  // unab
  "d-M-y",
  "d-M-Y",
  "j-M-y",
  "j-M-Y",
  "M-d-y",
  "M-d-Y",
  "M-j-y",
  "M-j-Y",
  "d-F-y",
  "d-F-Y",
  "F-d-y",
  "F-d-Y",
  "F-j-y",
  "F-j-Y",
  "j-F-y",
  "j-F-Y",
  "y-F-d",
  "y-F-j",
  "y-M-d",
  "y-M-j",
  "Y-F-d",
  "Y-F-j",
  "Y-M-d",
  "Y-m-d",
  "Y-M-j",
  "Y-m-j",
  "Y-n-d",
  "Y-n-j",
  "j-F",
  // 2-April
  "j-M",
  // 2-Apr
  "d-F",
  // 02-April
  "d-M",
  // 02-Apr
  "n-d",
  // 4-02
  "n-j",
  // 4-2
  "n-Y",
  // 4-1908
  "m-d",
  // 04-02
  "m-j",
  // 04-2
  "m-Y",
  // 04-1908
  "M-Y",
  // Apr-1908
  "M-y",
  // Apr-08
  "F-y",
  // April-08
  "F-Y",
  // April-1908
  "Y-M",
  // 1908-Apr
  "Y-n",
  // 1908-4
  "Y-m",
  // 1908-04
  "Y-F",
  // 1908-April
  "Y-M"
  // 1908-Apr
];
var X_ = { j: "d", d: "d", D: "ddd", l: "dddd", n: "m", m: "m", M: "mmm", F: "mmmm", y: "yy", Y: "yyyy" };
var q_ = { j: "dd", d: "dd", D: "ddd", l: "dddd", n: "mm", m: "mm", M: "mmm", F: "mmmm", y: "yy", Y: "yyyy" };
var vu = {};
var bu = {};
function lt(e, t, n = 1) {
  if (e) {
    const r = e[0], s = e.slice(1);
    r === "!" ? lt(s, t, 4) : r === "?" ? lt(s, t, 2) : (t[r] = t[r] || {}, lt(s, t[r], n));
  } else
    t.$ = n;
}
function Za(e, t) {
  lt(e, t), lt(e + " x", t), lt(e + " l", t), lt(e + " l x", t), lt("l " + e, t), lt("l " + e + " x", t), lt(e + " D", t), lt(e + " D x", t), lt("D " + e, t), lt("D " + e + " x", t);
}
K_.forEach((e) => {
  e[0] !== "?" && Za(e, vu), e[0] !== "!" && Za(e, bu);
});
var Z_ = (/* @__PURE__ */ new Date()).getUTCFullYear();
var Ja = ".";
var J_ = ",";
var si = " ";
var pr = "";
var Er = "";
var cs = "'";
var hs = "";
var Q_ = {
  ".": [J_, pr, Er, cs, hs],
  ",": [Ja, pr, Er, cs, hs],
  "": [Ja, pr, Er, cs, hs]
};
var ii = (e) => e && e.length === 1 && e >= "0" && e <= "9";
function Go(e, t = {}) {
  const n = Kn(t.locale || "") || Jt, r = n.decimal, s = [...Q_[r] || [cs, hs]];
  !s.includes(n.group) && n.group !== si && n.group !== r && s.push(n.group);
  let i = "", o = "", a = 1, l = "", u = false, c = false, h = false, d = false, f = false, g = null, _ = false, R = 0;
  const b = [si, pr, Er, "+", "%", "(", "-"].concat(Mi);
  for (; b.includes(e[R]); ) {
    const v = e[R];
    if (v === "-") {
      if (u || c)
        return null;
      u = true, a = -1;
    } else if (Li.test(v)) {
      if (f)
        return null;
      f = true, g = v;
    } else if (v === "(") {
      if (c || u)
        return null;
      c = true, a = -1;
    } else if (v === "%") {
      if (d)
        return null;
      d = true;
    }
    R++;
  }
  let H = false, P;
  if (e[R] === r || ii(e[R]))
    for (; R < e.length; ) {
      const v = e[R];
      if (!P && s.includes(v))
        P = v;
      else if (!(P && P === v)) if (v === r) {
        if (H)
          break;
        i += ".", H = true;
      } else if (ii(v))
        i += v;
      else
        break;
      R++;
    }
  if (e[R] === "e" || e[R] === "E") {
    o += e[R], R++, (e[R] === "+" || e[R] === "-") && (o += e[R], R++);
    const v = R;
    for (; ii(e[R]); )
      o += e[R], R++;
    if (v === R)
      return null;
  }
  const W = [si, pr, Er, "%", "$", ")"].concat(Mi);
  for (; W.includes(e[R]); ) {
    const v = e[R];
    if (Li.test(v)) {
      if (f)
        return null;
      f = true, g = v, _ = true;
    } else if (v === ")") {
      if (h || !c)
        return null;
      h = true;
    } else if (v === "%") {
      if (d)
        return null;
      d = true;
    }
    R++;
  }
  if (R !== e.length)
    return null;
  let w = parseFloat(i + o);
  if (!isFinite(w))
    return null;
  if (o) {
    if (d || f)
      return null;
    l = "0.00E+00";
  } else if (d) {
    if (f)
      return null;
    l = i.includes(".") ? "0.00%" : "0%", w *= 0.01;
  } else if (f) {
    const v = i.includes(".") ? "#,##0.00" : "#,##0";
    _ ? l = v + g : l = g + v;
  } else P && (l = i.includes(".") ? "#,##0.00" : "#,##0");
  const C = { v: w * a };
  return l && (C.z = l), C;
}
function ep(e, t, n) {
  if (n < 1 || t < 1 || t > 12)
    return false;
  if (t === 2) {
    const s = e % 4 === 0 && e % 100 !== 0 || e % 400 === 0 || e === 1900 ? 29 : 28;
    if (n > s)
      return false;
  } else if ((t === 4 || t === 6 || t === 9 || t === 11) && n > 30 || (t === 1 || t === 3 || t === 5 || t === 7 || t === 8 || t === 10 || t === 12) && n > 31)
    return false;
  return true;
}
var Qa = (e, t, n = false) => {
  for (const r of t)
    if (e.startsWith(r[0])) {
      let s = r[0].length;
      return n && (r[2] === "D" || r[2] === "M") && e[s] === "." && s++, [e.slice(0, s), r];
    }
  return ["", null];
};
var Lt = (e, t, n, r) => {
  const s = n.path || "", i = Object.keys(t);
  for (let o = 0; o < i.length; o++) {
    let a;
    const l = i[o];
    if (t[l]) {
      if (l === "$" || l === "")
        e || (a = n);
      else if (l === "-") {
        const u = /^(\s*([./-]|,\s)\s*|\s+)/.exec(e);
        if (u) {
          const c = u[1] === "-" || u[1] === "/" || u[1] === "." ? u[1] : " ";
          if (!n.sep || n.sep === c) {
            const h = u[0].replace(/\s+/g, " ");
            a = Lt(e.slice(u[0].length), t[l], { ...n, sep: c, path: s + h }, r);
          }
        }
      } else if (l === " ") {
        const u = /^[,.]?\s+/.exec(e);
        if (u) {
          const c = u[0].replace(/\s+/g, " ");
          a = Lt(e.slice(u[0].length), t[l], { ...n, path: s + c }, r);
        }
      } else if (l === "j" || l === "d") {
        const u = /^(0?[1-9]|1\d|2\d|3[01])\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], { ...n, day: u[0], path: s + l }, r));
      } else if (l === "n" || l === "m") {
        const u = /^(0?[1-9]|1[012])\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], { ...n, month: +u[0], _mon: u[0], path: s + l }, r));
      } else if (l === "F" || l === "M") {
        const [u, c] = Qa(e, r.mon, r.mp);
        c && c[2] === l && (a = Lt(
          e.slice(u.length),
          t[l],
          { ...n, month: c[1], _mon: u, path: s + l },
          r
        ));
      } else if (l === "l" || l === "D") {
        const [u, c] = Qa(e, r.day, r.dp);
        c && c[2] === l && (a = Lt(e.slice(u.length), t[l], { ...n, path: s + l }, r));
      } else if (l === "y") {
        const u = /^\d\d\b/.exec(e);
        if (u) {
          const c = +u[0] >= 30 ? +u[0] + 1900 : +u[0] + 2e3;
          a = Lt(e.slice(u[0].length), t[l], { ...n, year: c, path: s + l }, r);
        }
      } else if (l === "Y") {
        const u = /^\d\d\d\d\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], { ...n, year: +u[0], path: s + l }, r));
      } else if (l === "x") {
        const u = ks(e, { locale: r.locale });
        u && (a = Lt("", t[l], { ...n, time: u.v, tf: u.z, path: s + l }, r));
      } else
        throw new Error(`Unknown date token "${l}"`);
      if (a && ep(n.year || 1916, n.month || 1, n.day ? +n.day : 1))
        return a;
    }
  }
};
var Au = (e) => e.replace(/\s+/g, " ").trim().replace(//, "'").replace(/\.$/, "").toLowerCase();
var Wr = (e, t) => {
  const n = e.map((r, s) => [Au(r), s + 1, t]);
  return n.sort((r, s) => s[0].length - r[0].length), n;
};
function Ko(e, t = {}) {
  var i;
  const n = Kn(t.locale || "") || Jt, r = {
    mon: Wr(n.mmmm, "F").concat(Wr(n.mmm, "M")),
    mp: n.mmm[0].at(-1) === ".",
    day: Wr(n.dddd, "l").concat(Wr(n.ddd, "D")),
    dp: n.ddd[0].at(-1) === ".",
    locale: t.locale
  }, s = Lt(
    Au(e),
    n.preferMDY ? bu : vu,
    { path: "" },
    r
  );
  if (s) {
    if (s.sep === "." && s.path.length === 3)
      return null;
    const o = +((i = s.year) != null ? i : Z_);
    s.day || (s.day = 1);
    let a = -1 / 0;
    if (o < 1900)
      return null;
    o <= 1900 && s.month <= 2 ? a = 25568 : o < 1e4 && (a = 25569);
    const l = Date.UTC(o, s.month - 1, s.day) / 864e5 + a + (s.time || 0);
    if (l >= 0 && l <= 2958465) {
      const u = (
        // either has a leading zero
        s._mon[0] === "0" || s.day[0] === "0" || // both are 2-digits long
        s._mon.length === 2 && s.day.length === 2
      ), c = s.path.replace(/[jdlDnmMFyYx]/g, (h) => h === "x" ? s.tf || "" : (u ? q_[h] : X_[h]) || h);
      return { v: l, z: c };
    }
  }
  return null;
}
var oi = (e) => e.replace(/\s+/g, "").trim().replace(/\./g, "").toLowerCase();
function ks(e, t = {}) {
  const n = Kn(t.locale || "") || Jt, r = /^\s*([10]?\d|2[0-4])(?::([0-5]\d|\d))?(?::([0-5]\d|\d))?(\.\d{1,10})?(?=\s*[^\s\d]|$)/.exec(e);
  let s = "";
  if (r) {
    const i = oi(e.slice(r[0].length));
    if (i === oi(n.ampm[0]) || i === "a" || i === "am")
      s = "a";
    else if (i === oi(n.ampm[1]) || i === "p" || i === "pm")
      s = "p";
    else if (i)
      return null;
  }
  if (r) {
    const [, i, o, a, l] = r;
    if (l && !a || !s && !o && !a)
      return null;
    let u = +(i || 0) * 1;
    if (s) {
      if (u >= 13)
        return null;
      s === "p" && (u += 12);
    }
    const c = +(o || 0) * 1, h = +(a || 0) * 1, d = +(l || 0) * 1;
    return {
      v: (u * 60 * 60 + c * 60 + h + d) / (3600 * 24),
      z: (i.length === 2 ? "hh" : "h") + ":mm" + (a ? ":ss" : "") + (s ? " AM/PM" : "")
    };
  }
  return null;
}
function yu(e, t = {}) {
  const n = Kn(t.locale || "") || Jt, r = e.trim().toLowerCase(), s = n.bool[0].toLowerCase();
  if (r === "true" || r === s)
    return { v: true };
  const i = n.bool[1].toLowerCase();
  return r === "false" || r === i ? { v: false } : null;
}
function tp(e, t) {
  var n, r, s;
  return (s = (r = (n = Go(e, t)) != null ? n : Ko(e, t)) != null ? r : ks(e, t)) != null ? s : yu(e, t);
}
function un(e, t, n) {
  return t[n + "_max"] = e.length, t[n + "_min"] = e.replace(/#/g, "").length, t;
}
function je(e, t) {
  typeof e == "string" ? t.push({ type: "string", value: e }) : t.push(e);
}
function el(e, t) {
  const n = e && e.type;
  return n === po || n === kn || n === Eo || n === Ds && t === "den";
}
function dr(e) {
  var P, W, w;
  const t = [], n = {
    scale: 1,
    percent: false,
    text: false,
    date: 0,
    date_eval: false,
    date_system: qa,
    sec_decimals: 0,
    general: false,
    clock: 24,
    int_pattern: [],
    frac_pattern: [],
    man_pattern: [],
    den_pattern: [],
    num_pattern: [],
    tokens: t
  };
  let r = "int", s = null;
  const i = [];
  let o, a = false, l = -1, u = false, c = "", h = false;
  for (; ++l < e.length && !u; ) {
    const C = e[l], v = C.type || Sr;
    if (c += C.raw, v === _o)
      n.general = true, je(C, t);
    else if (el(C, r)) {
      const y = n[r + "_pattern"];
      el(o, r) || (o == null ? void 0 : o.type) === wr ? (y.push((y.pop() || "") + C.value), s.num += C.value) : (y.push(C.value), s = { type: r, num: C.value }, je(s, t));
    } else if (v === Ho)
      C.value === "(" && (n.parens = true), je(C.value, t);
    else if (v === Ds)
      je(C.value, t);
    else if (v === Co)
      if (h = true, n[r + "_pattern"].length) {
        if (!s)
          throw new SyntaxError("Format pattern is missing a numerator");
        n.fractions = true, n.num_pattern.push(n[r + "_pattern"].pop()), s.type = "num", r = "den", je({ type: "div" }, t);
      } else
        je(C.value, t);
    else if (v === Ro)
      je(",", t);
    else if (v === _s)
      n.scale = 1e-3 ** C.raw.length;
    else if (v === wr) {
      if (r === "int" && (n.grouping = true), r === "den")
        throw new SyntaxError("Cannot group denominator digits");
    } else if (v === Oo)
      je(C, t);
    else if (v === Io) {
      u = true;
      break;
    } else if (v === xs)
      n.text = true, je(C, t);
    else if (v === wo || v === So)
      je(C, t);
    else if (v === yo) {
      const y = C.value.toLowerCase(), F2 = y[0], $ = { type: "", size: 0, date: 1, pad: y.length };
      F2 === "h" ? ($.size = ur, $.type = "hour-elap") : F2 === "m" ? ($.size = cr, $.type = "min-elap") : ($.size = hr, $.type = "sec-elap"), n.date = n.date | $.size, i.push($), je($, t);
    } else if (n.date && v === ps && ((P = e[l + 1]) == null ? void 0 : P.type) === kn) {
      let y = 1;
      l++;
      let F2 = "0";
      ((W = e[l + 1]) == null ? void 0 : W.type) === kn && (F2 += "0", y = 2, l++), ((w = e[l + 1]) == null ? void 0 : w.type) === kn && (F2 += "0", y = 3, l++), c += F2;
      const $ = [hr, yi, Ni, Ti][y];
      n.date = n.date | $, n.date_eval = true, n.sec_decimals = Math.max(n.sec_decimals, y), je({
        type: "subsec",
        size: $,
        decimals: y,
        date: 1
      }, t);
    } else if (v === bo)
      a || (C.value === "B2" || C.value === "b2" ? n.date_system = Un : n.date_system = qa);
    else if (v === Ao) {
      const y = { type: "", size: 0, date: 1 }, F2 = C.value.toLowerCase(), $ = F2[0];
      if (F2 === "y" || F2 === "yy")
        y.size = ar, y.type = "year-short";
      else if ($ === "y" || $ === "e")
        y.size = ar, y.type = "year";
      else if (F2 === "b" || F2 === "bb")
        y.size = ar, y.type = "b-year-short";
      else if ($ === "b")
        y.size = ar, y.type = "b-year";
      else if (F2 === "d" || F2 === "dd")
        y.size = us, y.type = "day", y.pad = /dd/.test(F2);
      else if (F2 === "ddd" || F2 === "aaa")
        y.size = us, y.type = "weekday-short";
      else if ($ === "d" || $ === "a")
        y.size = us, y.type = "weekday";
      else if ($ === "h")
        y.size = ur, y.type = "hour", y.pad = /hh/i.test(F2);
      else if ($ === "m") {
        F2.length === 3 ? (y.size = lr, y.type = "monthname-short") : F2.length === 5 ? (y.size = lr, y.type = "monthname-single") : F2.length >= 4 && (y.size = lr, y.type = "monthname");
        const m = i[i.length - 1];
        !y.type && m && !m.used && m.size & (ur | hr) && (m.used = true, y.size = cr, y.type = "min", y.pad = /mm/.test(F2)), y.type || (y.size = lr, y.type = "month", y.pad = /mm/.test(F2), y.indeterminate = true);
      } else if ($ === "s") {
        y.size = hr, y.type = "sec", y.pad = /ss/.test(F2);
        const m = i[i.length - 1];
        m && m.size & cr ? y.used = true : m && m.indeterminate && (delete m.indeterminate, m.size = cr, m.type = "min", y.used = true);
      }
      n.date = n.date | y.size, n.date_eval = true, i.push(y), je(y, t);
    } else if (v === Do)
      n.clock = 12, n.date = n.date | ur, n.date_eval = true, C.short = C.value === "A/P", je(C, t);
    else if (v === ko || v === Uo || v === Us)
      je(C.value, t);
    else if (v === No)
      n.condition = [
        C.value[0],
        // operator
        parseFloat(C.value[1])
        // operand
      ];
    else if (v === Lo) {
      const y = C.value.split("-"), F2 = y.length < 2 ? "" : y.slice(1).join("-"), $ = y[0];
      $ && je($, t);
      const m = jo(F2);
      m && (n.locale = m);
      const D2 = parseInt(F2, 16);
      isFinite(D2) && D2 & 16711680 && (D2 >> 16 & 255) === 6 && (n.date_system = Un), a = true;
    } else if (v === xo) {
      let y, F2 = C.value.toLowerCase();
      (y = /^color\s*(\d+)$/i.exec(F2)) && (F2 = parseInt(y[1], 10)), n.color = F2;
    } else if (v === vo)
      n.scale = 100, n.percent = true, je("%", t);
    else if (v === ps)
      je(C, t), n.date || (n.dec_fractions = true, r = "frac");
    else if (v === Fo)
      n.exponential = true, n.exp_plus = C.value.includes("+"), r = "man", je({ type: "exp", plus: n.exp_plus }, t);
    else if (v === Po)
      je(C, t);
    else if (v === $o)
      je(C, t);
    else if (!(v === To || v === Mo)) throw v === Sr ? new SyntaxError(`Illegal character: ${c}`) : new SyntaxError(`Unknown token ${v} in ${c}`);
    o = C;
  }
  if (n.tokensUsed = l, n.pattern = c, /^((?:\[[^\]]+\])+)(;|$)/.test(n.pattern) && !/^\[(?:h+|m+|s+)\]/.test(n.pattern) && je({ type: "text" }, t), n.fractions && n.dec_fractions || n.grouping && !n.int_pattern.length || n.fractions && n.exponential || n.fractions && n.den_pattern.length * n.num_pattern.length === 0 || h && !n.fractions && !n.date || n.exponential && (n.int_pattern.length || n.frac_pattern.length) * n.man_pattern.length === 0)
    throw new SyntaxError(`Invalid pattern: ${c}`);
  const d = n.int_pattern.join(""), f = n.man_pattern.join(""), g = n.frac_pattern.join("");
  un(d, n, "int");
  let _ = 0;
  for (let C = 0; C < d.length; C++) {
    const v = d[d.length - 1 - C];
    /^[0-9?]/.test(v) && (_ = C + 1);
  }
  n.int_min = _, un(g, n, "frac"), un(f, n, "man");
  let R = n.num_pattern.join(""), b = n.den_pattern[0] || "";
  if (b.includes("?") || R.includes("?") ? (b = b.replace(/\d/g, "?"), b = b.replace(/#$/g, "?"), un(R, n, "num"), un(b, n, "den"), R = R.replace(/#$/g, "?")) : (un(R, n, "num"), un(b, n, "den")), n.int_p = d, n.man_p = f, n.num_p = R, n.den_p = b, n.den_pattern.length && (n.denominator = parseInt(n.den_pattern.join("").replace(/\D/g, ""), 10)), n.integer = !!d.length, !n.integer && !n.exponential && g.length) {
    const C = n.tokens.findIndex((v) => v.type === "point");
    n.tokens.splice(C, 0, { type: "int", value: "#" }), n.integer = true, n.int_pattern = ["#"], n.int_p = "#";
  }
  if (n.fractions)
    for (let C = 0; C < t.length - 1; C++) {
      const v = t[C];
      if (v.type !== "string" && v.type !== "space")
        continue;
      const y = t[C + 1].type;
      y === "num" ? v.rule = "num+int" : y === "div" ? v.rule = "num" : y === "den" && (v.rule = "den");
    }
  return n.grouping && n.int_pattern.length > 1 && (n.grouping = false), n;
}
function np(e) {
  if (e === 0)
    return e;
  const t = Math.ceil(Math.log10(e < 0 ? -e : e)), n = 10 ** (16 - Math.floor(t));
  return isFinite(n) ? Math.round(e * n) / n : 0;
}
function Nu(e, t = 0) {
  const n = Math.floor(Math.log10(e));
  return t > 1 ? Math.floor(n / t) * t : n;
}
function Tu(e, t = 1) {
  return t < -300 ? parseFloat(e.toExponential().split("e")[0]) : e * 10 ** -t;
}
var rp = {
  total: 1,
  sign: 0,
  period: 0,
  int: 1,
  frac: 0
};
function sp(e, t = true) {
  const n = Math.abs(e);
  if (!n)
    return rp;
  const r = t && e < 0 ? 1 : 0, s = Math.floor(n), i = Math.floor(Math.log10(n) + 1);
  let o = 0, a = 0;
  if (s !== n) {
    o = 1;
    const l = String(
      Et(n * 10 ** -i, 15)
    );
    let u = l.length, c = true, h = 0;
    for (; h <= l.length; ) {
      if (l[h] === ".") {
        u--;
        break;
      } else l[h] === "0" && c ? u-- : c = false;
      h++;
    }
    a = u - i, a < 0 && (a = 0, o = 0);
  }
  return {
    total: r + Math.max(i, 1) + o + a,
    digits: Math.max(i, 0) + a,
    sign: r,
    period: o,
    int: Math.max(i, 1),
    frac: a
  };
}
var bn = (e, t) => e.replace(/\./, t.decimal);
var tl = (e, t, n) => {
  const r = Math.abs(t);
  let s;
  return e === 1 ? s = e : s = Et(e, 5), [
    bn(s + "", n),
    n.exponent,
    t < 0 ? n.negative : n.positive,
    r < 10 ? "0" : "",
    r
  ];
};
function nl(e, t, n, r) {
  const s = n | 0;
  if (typeof n == "string")
    e.push(n);
  else if (n === s)
    e.push(Math.abs(s));
  else {
    const i = Math.abs(n);
    let o = Nu(i), a = Tu(i, o);
    a === 10 && (a = 1, o++);
    const l = sp(i);
    if (o >= -4 && o <= -1) {
      const u = i.toPrecision(10 + o).replace(/\.?0+$/, "");
      e.push(bn(u, r));
    } else if (o === 10) {
      const u = i.toFixed(10).slice(0, 12).replace(/\.$/, "");
      e.push(bn(u, r));
    } else if (Math.abs(o) <= 9)
      if (l.total <= 11) {
        const u = Et(i, 9).toFixed(l.frac);
        e.push(bn(u, r));
      } else o === 9 ? e.push(Math.floor(i)) : o >= 0 && o < 9 ? e.push(bn(String(Et(i, 9 - o)), r)) : e.push(...tl(a, o, r));
    else l.total >= 12 ? e.push(...tl(a, o, r)) : e.push(bn(Et(i, 9).toFixed(l.frac), r));
  }
  return e;
}
function cn(e, t = false) {
  return e === "0" ? "0" : e === "?" ? t ? "" : " " : "";
}
var Jn = 86400;
var ip = (e, t, n) => n ? e < F_ || t >= $_ : e < k_ || t >= P_;
function rl(e, t, n, r) {
  var A, O;
  let s = "", i = "", o = "", a = "", l = "", u = "", c = 0, h = 0;
  if (typeof e == "bigint") {
    if (e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER)
      e = Number(e);
    else
      return n.bigintErrorNumber ? String(e) : n.overflow;
    h = e;
  } else
    h = Math.trunc(e);
  let d = 0, f = 0, g = 1, _ = 0, R = 0, b = 0, H = 0, P = 0, W = 0;
  const w = r || Jt;
  if (!t.text && isFinite(t.scale) && t.scale !== 1 && (e = np(e * t.scale)), t.exponential) {
    let N = Math.abs(e);
    N && (c = Nu(N, t.int_max)), e && !t.integer && c++, N = Tu(N, c), t.int_max === 1 && Et(N, t.frac_max) === 10 && (N = 1, c++), e = e < 0 ? -N : N, s += Math.abs(c);
  }
  if (t.integer) {
    const N = Math.abs(Et(e, t.fractions ? 1 : t.frac_max));
    u += N < 1 ? "" : Math.floor(N);
  }
  const C = (A = n.grouping[0]) != null ? A : 3, v = (O = n.grouping[1]) != null ? O : C;
  t.dec_fractions && (l = String(Et(e, t.frac_max)).split(".")[1] || "");
  const y = !t.error && (t.num_p.includes("0") || t.den_p.includes("0"));
  let F2 = y;
  if (t.fractions) {
    F2 = y || !!(e % 1);
    const N = Math.abs(t.integer ? e % 1 : e);
    if (N)
      if (F2 = true, t.denominator && isFinite(t.denominator))
        a += t.denominator, o += Et(N * t.denominator), o === "0" && (o = "", a = "", F2 = y);
      else {
        const M = wu(N, 1 / 0, t.den_max);
        o += M[0], a += M[1], t.integer && o === "0" && (o = "", a = "", F2 = y);
      }
    else !e && !t.integer && (F2 = true, o = "0", a = "1");
    t.integer && !F2 && !Math.trunc(e) && (u = "0");
  }
  if (t.date) {
    h = Math.trunc(e);
    const N = Jn * (e - h);
    if (d = Math.floor(N), W = N - d, Math.abs(W) < 1e-6 ? W = 0 : W > 0.9999 && (W = 0, d += 1, d === Jn && (d = 0, h += 1)), W) {
      const M = t.date & Ti || t.date & Ni || t.date & yi;
      (M === Ti && W > 0.9995 || M === Ni && W > 0.995 || M === yi && W > 0.95 || !M && W >= 0.5) && (d++, W = 0);
    }
    if (h || t.date_system) {
      const M = Ou(e, t.date_system, n.leap1900);
      f = M[0], g = M[1], _ = M[2];
    }
    if (d) {
      const M = d < 0 ? Jn + d : d;
      P = Math.floor(M) % 60, H = Math.floor(M / 60) % 60, b = Math.floor(M / 60 / 60) % 60;
    }
    if (R = (6 + h) % 7, t.date_eval && ip(e, h + d / Jn, n.dateSpanLarge)) {
      if (n.dateErrorThrows)
        throw new Error("Date out of bounds");
      if (n.dateErrorNumber) {
        const M = e < 0 ? [w.negative] : [];
        return nl(M, {}, e, w).join("");
      }
      return n.overflow;
    }
  }
  const $ = cn("?", n.nbsp);
  c < 0 ? i = "-" : t.exp_plus && (i = "+");
  const m = [], D2 = (N, M, L, k) => {
    const q = !k && N.length > M.length ? L.length + N.length - M.length : L.length;
    N.length < M.length && (k += N.length - M.length);
    for (let V = 0; V < q; V++)
      m.push(N[V + k] || cn(L[V], n.nbsp));
    return q;
  };
  let S = false;
  const T = { int: 0, frac: 0, man: 0, num: 0, den: 0 };
  for (let N = 0, M = t.tokens.length; N < M; N++) {
    const L = t.tokens[N], k = L.type, q = L.num ? L.num.length : 0;
    if (k === "string")
      L.rule ? L.rule === "num" ? F2 ? m.push(L.value.replace(/ /g, $)) : (t.num_min > 0 || t.den_min > 0) && m.push(L.value.replace(/./g, $)) : L.rule === "num+int" ? F2 && u ? m.push(L.value.replace(/ /g, $)) : t.den_min > 0 && (u || t.num_min) && m.push(L.value.replace(/./g, $)) : L.rule === "den" && (F2 ? m.push(L.value.replace(/ /g, $)) : (t.den_min > 0 || t.den_min > 0) && m.push(L.value.replace(/./g, $))) : m.push(L.value.replace(/ /g, $));
    else if (k === "space")
      L.rule === "num+int" ? (F2 || t.num_min || t.den_min) && (u || t.num_min) && m.push($) : m.push($);
    else if (k === "error")
      m.push(n.invalid);
    else if (k === "point")
      m.push(t.date ? L.value : w.decimal);
    else if (k === "general")
      nl(m, t, e, w);
    else if (k === "exp")
      m.push(w.exponent);
    else if (k === "minus")
      L.volatile && t.date || L.volatile && (e >= 0 || typeof e != "number") || (L.volatile && !t.fractions && (t.integer || t.dec_fractions) ? (e < 0 && u && u !== "0" || l) && m.push(w.negative) : m.push(w.negative));
    else if (k === "plus")
      m.push(w.positive);
    else if (k === "text")
      m.push(e);
    else if (k === "fill")
      n.fillChar && m.push(n.fillChar, L.value);
    else if (k === "skip")
      n.skipChar ? m.push(n.skipChar, L.value) : m.push(n.nbsp ? "" : " ");
    else if (k === "div")
      F2 ? m.push("/") : t.num_min > 0 || t.den_min > 0 ? m.push($) : m.push(cn("#", n.nbsp));
    else if (k === "int")
      if (t.int_pattern.length === 1) {
        const V = t.int_p, oe = Math.max(t.int_min, u.length);
        let le = "";
        for (let I = oe; I > 0; I--) {
          const x = u.charAt(u.length - I), Y = x ? "" : V.charAt(V.length - I) || V[0];
          let z = "";
          if (t.grouping) {
            const B = I - 1 - C;
            B >= 0 && !(B % v) && (z = x || Y === "0" ? w.group : cn("?", n.nbsp));
          }
          le += (x || cn(Y, n.nbsp)) + z;
        }
        m.push(le);
      } else
        T.int += D2(u, t.int_p, L.num, T.int);
    else if (k === "frac") {
      const V = T.frac;
      for (let oe = 0; oe < q; oe++)
        m.push(l[oe + V] || cn(L.num[oe], n.nbsp));
      T.frac += q;
    } else if (k === "man")
      !T[k] && !T.man && m.push(i), T.man += D2(s, t.man_p, L.num, T.man);
    else if (k === "num")
      T.num += D2(o, t.num_p, L.num, T.num);
    else if (k === "den") {
      const V = T.den;
      for (let oe = 0; oe < q; oe++) {
        let le = a[oe + V];
        if (!le) {
          const I = L.num[oe];
          "123456789".includes(I) || S && I === "0" ? (S = true, le = n.nbsp ? "" : " ") : !S && oe === q - 1 && I === "0" && !a ? le = "1" : le = cn(I, n.nbsp);
        }
        m.push(le);
      }
      T.den += q;
    } else if (k === "year")
      f < 0 && m.push(w.negative), m.push(String(Math.abs(f)).padStart(4, "0"));
    else if (k === "year-short") {
      const V = f % 100;
      m.push(V < 10 ? "0" : "", V);
    } else if (k === "month")
      m.push(L.pad && g < 10 ? "0" : "", g);
    else if (k === "monthname-single")
      t.date_system === Un ? m.push(w.mmmm6[g - 1].charAt(0)) : m.push(w.mmmm[g - 1].charAt(0));
    else if (k === "monthname-short")
      t.date_system === Un ? m.push(w.mmm6[g - 1]) : m.push(w.mmm[g - 1]);
    else if (k === "monthname")
      t.date_system === Un ? m.push(w.mmmm6[g - 1]) : m.push(w.mmmm[g - 1]);
    else if (L.type === "weekday-short")
      m.push(w.ddd[R]);
    else if (k === "weekday")
      m.push(w.dddd[R]);
    else if (k === "day")
      m.push(L.pad && _ < 10 ? "0" : "", _);
    else if (k === "hour") {
      const V = b % t.clock || (t.clock < 24 ? t.clock : 0);
      m.push(L.pad && V < 10 ? "0" : "", V);
    } else if (k === "min")
      m.push(L.pad && H < 10 ? "0" : "", H);
    else if (k === "sec")
      m.push(L.pad && P < 10 ? "0" : "", P);
    else if (k === "subsec") {
      m.push(w.decimal);
      const V = W.toFixed(t.sec_decimals);
      m.push(V.slice(2, 2 + L.decimals));
    } else if (k === "ampm") {
      const V = b < 12 ? 0 : 1;
      L.short && !r ? m.push("AP"[V]) : m.push(w.ampm[V]);
    } else if (k === "hour-elap") {
      e < 0 && m.push(w.negative);
      const V = h * 24 + Math.floor(Math.abs(d) / 3600);
      m.push(String(Math.abs(V)).padStart(L.pad, "0"));
    } else if (k === "min-elap") {
      e < 0 && m.push(w.negative);
      const V = h * 1440 + Math.floor(Math.abs(d) / 60);
      m.push(String(Math.abs(V)).padStart(L.pad, "0"));
    } else if (k === "sec-elap") {
      e < 0 && m.push(w.negative);
      const V = h * Jn + Math.abs(d);
      m.push(String(Math.abs(V)).padStart(L.pad, "0"));
    } else if (k === "b-year")
      m.push(f + 543);
    else if (k === "b-year-short") {
      const V = (f + 543) % 100;
      m.push(V < 10 ? "0" : "", V);
    }
  }
  return m.join("");
}
var op = dr([
  { type: xs, value: "@", raw: "@" }
]);
function Mu(e, t) {
  for (let n = 0; n < 3; n++) {
    const r = t[n];
    if (r) {
      let s;
      if (r.condition) {
        const i = r.condition[0], o = r.condition[1];
        i === "=" ? s = e === o : i === ">" ? s = e > o : i === "<" ? s = e < o : i === ">=" ? s = e >= o : i === "<=" ? s = e <= o : i === "<>" && (s = e !== o);
      } else
        s = true;
      if (s)
        return r;
    }
  }
}
function ap(e, t, n) {
  const r = t.partitions;
  let s = r[3], i = null;
  return (typeof e == "number" || typeof e == "bigint") && isFinite(e) && (s = Mu(e, r)), s && s.color && (i = s.color), i && typeof i == "number" && n.indexColors && (i = B_[i - 1] || "#000"), i;
}
function lp(e, t, n) {
  const r = t.partitions, s = Kn(t.locale || n.locale), i = r[3] ? r[3] : op;
  if (typeof e == "boolean" && (e = (s || Jt).bool[e ? 0 : 1]), e == null)
    return "";
  const o = typeof e == "bigint";
  if (typeof e != "number" && !o)
    return rl(e, i, n, s);
  if (!o && !isFinite(e)) {
    const l = s || Jt;
    return isNaN(e) ? l.nan : (e < 0 ? l.negative : "") + l.infinity;
  }
  const a = Mu(e, r);
  return a ? rl(e, a, n, s) : n.overflow;
}
function Lu(e) {
  return !!(e[0] && e[0].percent || e[1] && e[1].percent || e[2] && e[2].percent || e[3] && e[3].percent);
}
function xu(e) {
  return !!(e[0] && e[0].date || e[1] && e[1].date || e[2] && e[2].date || e[3] && e[3].date);
}
function Du(e) {
  const [t, n, r, s] = e;
  return !!((!t || t.generated) && (!n || n.generated) && (!r || r.generated) && s && s.text && !s.generated);
}
var up = {
  text: 15,
  datetime: 10.8,
  date: 10.8,
  time: 10.8,
  percent: 10.6,
  currency: 10.4,
  grouped: 10.2,
  scientific: 6,
  number: 4,
  fraction: 2,
  general: 0,
  error: 0
};
var cp = [
  ["DMY", 1],
  ["DM", 2],
  ["MY", 3],
  ["MDY", 4],
  ["MD", 5],
  ["hmsa", 6],
  ["hma", 7],
  ["hms", 8],
  ["hm", 9]
];
function hp(e, t = null) {
  var h;
  const [n, r] = e, s = n.frac_max, i = {
    type: "general",
    isDate: xu(e),
    isText: Du(e),
    isPercent: Lu(e),
    maxDecimals: n.general ? 9 : s,
    scale: (h = n.scale) != null ? h : 1,
    color: 0,
    parentheses: 0,
    grouped: n.grouping ? 1 : 0
  }, o = !i.isDate && !i.isText && !n.error && n.tokens.some((d) => d.type === "string" && (t ? d.value === t : Li.test(d.value)));
  let a = "G", l = s >= 0 ? Math.min(15, s) : "", u = "", c = "";
  if (r && r.color && (c = "-", i.color = 1), n.parens && (u = "()", i.parentheses = 1), o)
    a = "C", i.type = "currency";
  else if (n.error)
    i.type = "error", i.maxDecimals = 0;
  else if (i.isDate) {
    let d = 0, f = 0, g = "";
    n.tokens.forEach((R) => {
      const b = R.type;
      /^(b-)?year/.test(b) ? (g += "Y", f++) : b.startsWith("month") ? (g += "M", f++) : /^(week)?day/.test(b) ? (g += "D", f++) : (b === "hour" || b === "min" || b === "sec" || b === "ampm") && (g += b[0], d++);
    }), i.type = "date", f && d ? i.type = "datetime" : !f && d && (i.type = "time");
    const _ = cp.find((R) => g.startsWith(R[0]));
    a = _ ? "D" : "G", l = _ ? _[1] : "";
  } else i.isText ? (a = "G", i.type = "text", l = "", i.maxDecimals = 0) : n.general ? (a = "G", i.type = "general", l = "") : n.fractions ? (a = "G", i.type = "fraction", l = "") : n.exponential ? (a = "S", i.type = "scientific") : i.isPercent ? (a = "P", i.type = "percent") : n.grouping ? (a = ",", i.type = "grouped") : (n.int_max || s) && (a = "F", i.type = "number");
  return i.code = a + l + c + u, i.level = up[i.type], Object.freeze(i);
}
function dp(e) {
  const [t] = e;
  return {
    year: !!(t.date & ar),
    month: !!(t.date & lr),
    day: !!(t.date & us),
    hours: !!(t.date & ur),
    minutes: !!(t.date & cr),
    seconds: !!(t.date & hr),
    clockType: t.clock === 12 ? 12 : 24
  };
}
var fp = [
  [_o, /^General/i, 0],
  [po, /^#/, 0],
  [kn, /^0/, 0],
  [Eo, /^\?/, 0],
  [Co, /^\//, 0],
  // Commas are dealt with as a special case in the tokenizer but will end up
  // as one of these:
  // [ TOKEN_GROUP, /^(,),*/, 1 ],
  // [ TOKEN_SCALE, /^(,),*/, 1 ],
  // [ TOKEN_COMMA, /^(,),*/, 1 ],
  [Io, /^;/, 0],
  [xs, /^@/, 0],
  [wo, /^\+/, 0],
  [So, /^-/, 0],
  [ps, /^\./, 0],
  [Oo, /^ /, 0],
  [vo, /^%/, 0],
  [Ds, /^[1-9]/, 0],
  [bo, /^(?:B[12])/i, 0],
  [Sr, /^B$/, 0],
  // pattern must not end in a "B"
  [Ao, /^(?:[hH]+|[mM]+|[sS]+|[yY]+|[bB]+|[dD]+|[gG]+|[aA]{3,}|e+)/, 0],
  [yo, /^(?:\[(h+|m+|s+)\])/i, 1],
  [No, /^\[(<[=>]?|>=?|=)\s*(-?[.\d]+)\]/, [1, 2]],
  [To, /^\[(DBNum[0-4]?\d)\]/i, 1],
  [Mo, /^\[(NatNum[0-4]?\d)\]/i, 1],
  [Lo, /^\[\$([^\]]+)\]/, 1],
  [xo, /^\[(black|blue|cyan|green|magenta|red|white|yellow|color\s*\d+)\]/i, 1],
  // conditionally allow these open ended directions?
  [gu, /^\[([^\]]+)\]/, 1],
  [Do, /^(?:AM\/PM|am\/pm|A\/P)/, 0],
  [Uo, /^\\(.)/, 1],
  [ko, /^"([^"]*?)"/, 1],
  [Po, /^_(\\.|.)/, 1],
  // Google Sheets and Excel diverge on "e": Excel only accepts E.
  [Fo, /^[Ee]([+-])/, 1],
  [$o, /^\*(\\.|.)/, 1],
  [Ho, /^[()]/, 0],
  [Sr, /^[ENn["*/\\_]/, 0],
  [Us, /^./, 0]
];
var mp = 63;
var gp = 35;
var _p = 48;
var pp = 57;
var ai = (e) => {
  const t = (e || "\0").charCodeAt(0);
  return t === mp || t === gp || t >= _p && t <= pp;
};
function Tn(e) {
  let t = 0;
  const n = [], r = [];
  for (; t < e.length; ) {
    const s = e.slice(t);
    let i = 0;
    const o = /^(,+)(.)?/.exec(s);
    if (o) {
      const a = o[1];
      i = a.length;
      const l = e[t - 1] || "";
      let u = false, c = false;
      ai(l) ? (u = true, c = true) : l === "." && (c = true);
      const h = o[2] || "";
      if (u && (!h || h === ";") && (u = false), c && ai(h) && (c = false), u && !c)
        n.push({ type: wr, value: ",", raw: a });
      else if (!u && c)
        n.push({ type: _s, value: ",", raw: a });
      else if (u && c) {
        const d = { type: _s, value: ",", raw: a };
        n.push(d), r.push(d);
      } else
        n.push({ type: Ro, value: ",", raw: a });
    } else {
      let a;
      for (const [l, u, c] of fp) {
        const h = u.exec(s);
        if (h) {
          const d = Array.isArray(c) ? c.map((f) => h[f]) : h[c || 0];
          a = { type: l, value: d, raw: h[0] }, n.push(a), i = h[0].length;
          break;
        }
      }
      r.length && a.raw === ";" && (r.length = 0), r.length && ai(a.raw) && (r.forEach((l) => l.type = wr), r.length = 0);
    }
    if (!i) {
      const a = s[0];
      i = 1, n.push({ type: Us, value: a, raw: a });
    }
    t += i;
  }
  return n;
}
var li = (e) => {
  const t = e.condition;
  t && t[1] < 0 && (t[0] === "<" || t[0] === "<=" || t[0] === "=") || e.tokens.unshift({
    type: "minus",
    volatile: true
  });
};
var sl = (e, t = null) => {
  const n = {};
  for (const r in e)
    Array.isArray(e[r]) ? n[r] = [...e[r]] : n[r] = e[r];
  return t && n.tokens.unshift(t), n.generated = true, n;
};
function Ep(e) {
  var h;
  const t = [];
  let n = false, r, s = null, i = 0, o = false, a = 0, l = 0, u = Tn(e);
  do {
    if (o = dr(u), (o.date || o.general) && (o.int_pattern.length || o.frac_pattern.length || o.scale !== 1 || o.text))
      throw new Error("Illegal format");
    if (o.condition && (l++, n = true), o.text) {
      if (s)
        throw new Error("Unexpected partition");
      s = o;
    }
    o.locale && (r = jo(o.locale)), t.push(o), i = ((h = u[o.tokensUsed]) == null ? void 0 : h.type) === "break" ? 1 : 0, u = u.slice(o.tokensUsed + i), a++;
  } while (i && a < 4 && l < 3);
  if (i)
    throw new Error("Unexpected partition");
  if (l > 2)
    throw new Error("Unexpected condition");
  const c = t[3];
  if (c && (c.int_pattern.length || c.frac_pattern.length || c.date))
    throw new Error("Unexpected partition");
  if (n) {
    const d = t.length;
    if (d === 1 && (t[1] = dr(Tn("General")), t[1].generated = true), d < 3) {
      const f = t[0], g = t[1];
      if (li(f), g.condition)
        li(g);
      else {
        const _ = f.condition;
        (_[0] === "=" || _[1] >= 0 && (_[0] === ">" || _[0] === ">=")) && g.tokens.unshift({
          type: "minus",
          volatile: true
        });
      }
    } else
      t.forEach(li);
  } else {
    if (t.length < 4 && s)
      for (let d = 0, f = t.length; d < f; d++)
        t[d] === s && t.splice(d, 1);
    if (t.length < 1 && s && (t[0] = dr(Tn("General")), t[0].generated = true), t.length < 2) {
      const d = { type: "minus", volatile: true };
      t.push(sl(t[0], d));
    }
    if (t.length < 3 && t.push(sl(t[0])), t.length < 4)
      if (s)
        t.push(s);
      else {
        const d = dr(Tn("@"));
        d.generated = true, t.push(d);
      }
    t[0].condition = [">", 0], t[1].condition = ["<", 0], t[2].condition = null;
  }
  return {
    pattern: e,
    partitions: t,
    locale: r
  };
}
var il = /* @__PURE__ */ Object.create({});
function nn(e, t = false) {
  e || (e = "General");
  let n = il[e];
  if (!n)
    try {
      n = Ep(e), il[e] = n;
    } catch (r) {
      if (t)
        throw r;
      const s = {
        tokens: [{ type: "error" }],
        error: r.message
      };
      n = {
        pattern: e,
        partitions: [s, s, s, s],
        error: r.message,
        locale: null
      };
    }
  return n;
}
function Uu(e, t, n = {}) {
  var o;
  const r = Object.assign({}, Iu, n), s = nn(e, r.throws), i = (o = Vo(t, r)) != null ? o : t;
  return lp(i, s, r);
}
function Cp(e, t, n) {
  var o;
  const r = Object.assign({}, Iu, n), s = nn(e, r.throws), i = (o = Vo(t, r)) != null ? o : t;
  return ap(i, s, r);
}
function Rp(e) {
  const t = nn(e, false);
  return xu(t.partitions);
}
function Ip(e) {
  const t = nn(e, false);
  return Lu(t.partitions);
}
function wp(e) {
  const t = nn(e, false);
  return Du(t.partitions);
}
function Sp(e) {
  try {
    return nn(e, true), true;
  } catch {
    return false;
  }
}
function Op(e, t = {}) {
  const n = nn(e, false);
  return n.info || (n.info = hp(n.partitions, t == null ? void 0 : t.currency)), n.info;
}
function vp(e) {
  const t = nn(e, false);
  return t.dateInfo || (t.dateInfo = dp(t.partitions)), t.dateInfo;
}
var An = Object.freeze({
  AMPM: Do,
  BREAK: Io,
  CALENDAR: bo,
  CHAR: Us,
  COLOR: xo,
  COMMA: Ro,
  CONDITION: No,
  DATETIME: Ao,
  DBNUM: To,
  DIGIT: Ds,
  DURATION: yo,
  ERROR: Sr,
  ESCAPED: Uo,
  EXP: Fo,
  FILL: $o,
  GENERAL: _o,
  GROUP: wr,
  HASH: po,
  LOCALE: Lo,
  MINUS: So,
  MODIFIER: gu,
  NATNUM: Mo,
  PAREN: Ho,
  PERCENT: vo,
  PLUS: wo,
  POINT: ps,
  QMARK: Eo,
  SCALE: _s,
  SKIP: Po,
  SLASH: Co,
  SPACE: Oo,
  STRING: ko,
  TEXT: xs,
  ZERO: kn
});
var eR = Object.freeze(Object.defineProperty({
  __proto__: null,
  addLocale: te,
  dateFromSerial: G_,
  dateToSerial: Vo,
  dec2frac: wu,
  format: Uu,
  formatColor: Cp,
  getFormatDateInfo: vp,
  getFormatInfo: Op,
  getLocale: Kn,
  isDateFormat: Rp,
  isPercentFormat: Ip,
  isTextFormat: wp,
  isValidFormat: Sp,
  parseBool: yu,
  parseDate: Ko,
  parseLocale: Bo,
  parseNumber: Go,
  parseTime: ks,
  parseValue: tp,
  round: Et,
  tokenTypes: An,
  tokenize: Tn
}, Symbol.toStringTag, { value: "Module" }));
var bp = "@@@";
var Ap = "@";
var yp = "General";
function tR(e) {
  return e === bp || e === Ap;
}
function nR(e) {
  return e == null || e === yp;
}
var rR = (e, t) => {
  if (e && !t || !e && t)
    return false;
  const n = (i) => {
    const o = Tn(i);
    let a = "", l = false, u = false;
    for (const c of o) {
      if (c.type === An.POINT) {
        l = true;
        continue;
      }
      if (!(u && c.type === An.MINUS) && c.type !== An.SKIP) {
        if (c.type === An.COLOR) {
          u = true;
          continue;
        } else
          u = false;
        l && c.type === An.ZERO || (l = false, l || (a += c.value || ""));
      }
    }
    return a;
  }, r = n(e), s = n(t);
  return r === s;
};
var Np = /* @__PURE__ */ new Set(["m d"]);
var Tp = /* @__PURE__ */ new Set(["h:mm AM/PM", "hh:mm AM/PM"]);
var sR = (e) => {
  var s, i;
  const t = (i = (s = Ko(e)) != null ? s : ks(e)) != null ? i : Go(e);
  if (!t) return null;
  const { v: n, z: r } = t;
  return r && (Np.has(r) || Tp.has(r) && !/\s(A|AM|P|PM)$/i.test(e) || r.includes("#,##0") && Uu(r, n) !== e) ? null : t;
};
var iR = {
  sheetId: "",
  range: {
    startRow: -1,
    endRow: -1,
    startColumn: -1,
    endColumn: -1
  }
};
var oR = {
  startRow: -1,
  startColumn: -1,
  endRow: -1,
  endColumn: -1
};
var aR = {
  startRow: 0,
  startColumn: 0,
  endRow: 0,
  endColumn: 0
};
var lR = {
  row: 0,
  column: 0
};
var rt = {
  /**
   * fontFamily
   */
  ff: "Arial",
  /**
   * fontSize
   */
  fs: 11,
  /**
   * italic
   * 0: false
   * 1: true
   */
  it: ie.FALSE,
  /**
   * bold
   * 0: false
   * 1: true
   */
  bl: ie.FALSE,
  /**
   * underline
   */
  ul: {
    s: ie.FALSE
  },
  /**
   * strikethrough
   */
  st: {
    s: ie.FALSE
  },
  /**
   * overline
   */
  ol: {
    s: ie.FALSE
  },
  /**
   * textRotation
   */
  tr: {
    a: 0,
    /**
     * true : 1
     * false : 0
     */
    v: ie.FALSE
  },
  /**
   * textDirection
   */
  td: ms.UNSPECIFIED,
  /**
   * color
   */
  cl: {
    rgb: "#000000"
  },
  /**
   * background
   */
  bg: {
    rgb: "#fff"
  },
  /**
   * horizontalAlignment
   */
  ht: Ut.UNSPECIFIED,
  /**
   * verticalAlignment
   */
  vt: xn.UNSPECIFIED,
  /**
   * wrapStrategy
   */
  tb: Bn.UNSPECIFIED,
  /**
   * padding
   */
  pd: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  n: null,
  /**
   * border
   */
  bd: {
    b: null,
    l: null,
    r: null,
    t: null
  }
};
var Mp = {
  id: "default_slide",
  title: "defaultSlide",
  pageSize: {
    width: 300,
    height: 300
  }
};
var uR = [Dl, Hc, Ul];
var cR = {
  [qe.HEADING_1]: { fs: 20, bl: 1 },
  // Heading 1: 20pt, bold
  [qe.HEADING_2]: { fs: 18, bl: 1 },
  // Heading 2: 18pt, bold
  [qe.HEADING_3]: { fs: 16, bl: 1 },
  // Heading 3: 16pt, bold
  [qe.HEADING_4]: { fs: 14, bl: 1 },
  // Heading 4: 14pt, bold
  [qe.HEADING_5]: { fs: 12, bl: 1 },
  // Heading 5: 12pt, bold
  [qe.NORMAL_TEXT]: null,
  // Normal text: using global font size
  [qe.TITLE]: { fs: 26, bl: 1 },
  // Title: 26pt, bold
  [qe.SUBTITLE]: { fs: 15, cl: { rgb: "#999999" } },
  // Subtitle: 15pt
  [qe.NAMED_STYLE_TYPE_UNSPECIFIED]: null
};
var wn = 4;
var hR = {
  [qe.HEADING_1]: {
    spaceAbove: {
      v: 20
    },
    spaceBelow: {
      v: 6 + wn
    }
  },
  [qe.HEADING_2]: {
    spaceAbove: {
      v: 18
    },
    spaceBelow: {
      v: 6 + wn
    }
  },
  [qe.HEADING_3]: {
    spaceAbove: {
      v: 16
    },
    spaceBelow: {
      v: 6 + wn
    }
  },
  [qe.HEADING_4]: {
    spaceAbove: {
      v: 14
    },
    spaceBelow: {
      v: 4 + wn
    }
  },
  [qe.HEADING_5]: {
    spaceAbove: {
      v: 12
    },
    spaceBelow: {
      v: 4 + wn
    }
  },
  [qe.NORMAL_TEXT]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 0
    }
  },
  [qe.TITLE]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 3 + wn
    }
  },
  [qe.SUBTITLE]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 16
    }
  },
  [qe.NAMED_STYLE_TYPE_UNSPECIFIED]: null
};
var dR = "univer-sheets-chart-print-chart";
var fR = "univer-docs-drawing-printing";
var Lp = ((e) => (e.ARRAY_CONVERTOR = "ARRAY_CONVERTOR", e.MATRIX_CONVERTOR = "MATRIX_CONVERTOR", e))(Lp || {});
var mR = {
  [gt.A3]: {
    width: 1123,
    height: 1587
  },
  [gt.A4]: {
    width: 794,
    height: 1124
  },
  [gt.A5]: {
    width: 559,
    height: 794
  },
  [gt.B4]: {
    width: 944,
    height: 1344
  },
  [gt.B5]: {
    width: 665,
    height: 944
  },
  [gt.Executive]: {
    width: 696,
    height: 1008
  },
  [gt.Folio]: {
    width: 816,
    height: 1248
  },
  [gt.Legal]: {
    width: 816,
    height: 1344
  },
  [gt.Letter]: {
    width: 816,
    height: 1056
  },
  [gt.Statement]: {
    width: 528,
    height: 816
  },
  [gt.Tabloid]: {
    width: 1056,
    height: 1632
  }
};
function Yr(e, t) {
  const { textRuns: n = [] } = t;
  let r = 0;
  for (const i of n) {
    const { ts: o = {}, st: a, ed: l } = i;
    if (o[e] == null)
      return ie.FALSE;
    switch (e) {
      case "bl":
      case "it": {
        if (o[e] === ie.FALSE)
          return ie.FALSE;
        break;
      }
      case "ul":
      case "st": {
        if (o[e].s === ie.FALSE)
          return ie.FALSE;
        break;
      }
      default:
        throw new Error(`unknown style key: ${e} in IStyleBase`);
    }
    r += l - a;
  }
  return t.dataStream.indexOf(`\r
`) === r ? ie.TRUE : ie.FALSE;
}
var Cr = class Cr2 {
  constructor(t, n, r) {
    p(this, "_range");
    p(this, "_worksheet");
    this._deps = r, this._range = n, this._worksheet = t;
  }
  static foreach(t, n) {
    const { startRow: r, startColumn: s, endRow: i, endColumn: o } = t;
    for (let a = r; a <= i; a++)
      for (let l = s; l <= o; l++)
        n(a, l);
  }
  /**
   * get current range data
   *
   * @returns current range
   */
  getRangeData() {
    return this._range;
  }
  /**
   * Returns the value of the top-left cell in the range. The value may be of type Number, Boolean, Date, or String
   * depending on the value of the cell. Empty cells return an empty string.
   * @returns  The value in this cell
   */
  getValue() {
    return this.getValues()[0][0];
  }
  /**
   * Returns the rectangular grid of values for this range.
   *
   * Returns a two-dimensional array of values, indexed by row, then by column. The values may be of type Number,
   * Boolean, Date, or String, depending on the value of the cell. Empty cells are represented by an empty string
   * in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
   *
   * In web apps, a Date value isn't a legal parameter. getValues() fails to return data to a web app if the range
   * contains a cell with a Date value. Instead, transform all the values retrieved from the sheet to a supported
   * JavaScript primitive like a Number, Boolean, or String.
   *
   * @returns  A two-dimensional array of values.
   */
  getValues() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = [];
    for (let o = t; o <= n; o++) {
      const a = [];
      for (let l = r; l <= s; l++)
        a.push(this.getMatrix().getValue(o, l) || null);
      i.push(a);
    }
    return i;
  }
  /**
   * get range matrix
   *
   * @returns range matrix
   */
  getMatrix() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = this._worksheet.getCellMatrix(), o = new pt();
    for (let a = t; a <= n; a++)
      for (let l = r; l <= s; l++)
        o.setValue(a, l, i.getValue(a, l) || null);
    return o;
  }
  /**
   * get range matrix object
   *
   * @returns range matrix object
   */
  getMatrixObject() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = this._worksheet.getCellMatrix(), o = new pt();
    for (let a = t; a <= n; a++)
      for (let l = r; l <= s; l++)
        o.setValue(a - t, l - r, i.getValue(a, l) || {});
    return o;
  }
  /**
   * Returns a string description of the range, in A1 notation.
   *
   * @returns The string description of the range in A1 notation.
   */
  getA1Notation() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range;
    let i, o;
    return r < s ? (i = J.numToWord(r + 1) + (t + 1), o = J.numToWord(s + 1) + (n + 1)) : (i = J.numToWord(s + 1) + (n + 1), o = J.numToWord(r + 1) + (t + 1)), i === o ? `${i}` : `${i}:${o}`;
  }
  /**
   * Returns the background color of the top-left cell in the range (for example, '#ffffff').
   *
   * @returns  The color code of the background.
   */
  getBackground() {
    return this.getBackgrounds()[0][0];
  }
  /**
   * Returns the background colors of the cells in the range (for example, '#ffffff').
   *
   * @returns   A two-dimensional array of color codes of the backgrounds.
   */
  getBackgrounds() {
    const t = this._deps.getStyles();
    return this.getValues().map(
      (n) => n.map((r) => {
        var i;
        const s = t.getStyleByCell(r);
        return ((i = s == null ? void 0 : s.bg) == null ? void 0 : i.rgb) || rt.bg.rgb;
      })
    );
  }
  /**
   * Returns a given cell within a range.
   *
   * The row and column here are relative to the range
   * e.g. "B2:D4", getCell(0,0) in this code returns the cell at B2
   * @returns   A range containing a single cell at the specified coordinates.
   */
  getCell(t, n) {
    const { startRow: r, startColumn: s } = this._range, i = {
      startRow: r + t,
      endRow: r + t,
      startColumn: s + n,
      endColumn: s + n
    };
    return new Cr2(this._worksheet, i, this._deps);
  }
  /**
   * Returns the starting column position for this range
   *
   * @returns   The range's starting column position in the spreadsheet.
   */
  getColumn() {
    return this._range.startColumn;
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   */
  getObjectValue(t = {}) {
    return this.getObjectValues(t)[0][0];
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   *
   * @param options set whether to include style
   * @returns Returns a value in object format
   */
  getObjectValues(t = {}) {
    var a;
    const { startRow: n, endRow: r, startColumn: s, endColumn: i } = this._range, o = this._worksheet.getCellMatrix().getFragment(n, r, s, i).getData();
    if (t.isIncludeStyle) {
      const l = this._deps.getStyles();
      for (let u = 0; u <= r - n; u++)
        for (let c = 0; c <= i - s; c++) {
          if (o == null || ((a = o == null ? void 0 : o[u]) == null ? void 0 : a[c]) == null)
            continue;
          const h = o[u][c].s;
          h && (o[u][c].s = l.get(h));
        }
    }
    return o;
  }
  /**
   * Returns the font color of the cell in the top-left corner of the range, in CSS notation
   */
  getFontColor() {
    return this.getFontColors()[0][0];
  }
  /**
   * Returns the font colors of the cells in the range in CSS notation (such as '#ffffff' or 'white').
   */
  getFontColors() {
    const t = this._deps.getStyles();
    return this.getValues().map(
      (n) => n.map((r) => {
        var i;
        const s = t.getStyleByCell(r);
        return ((i = s == null ? void 0 : s.cl) == null ? void 0 : i.rgb) || rt.cl.rgb;
      })
    );
  }
  /**
   * Returns the font families of the cells in the range.
   */
  getFontFamilies() {
    return this._getStyles("ff");
  }
  /**
   * Returns the font family of the cell in the top-left corner of the range.
   */
  getFontFamily() {
    return this.getFontFamilies()[0][0];
  }
  /**
   * Returns the underlines of the cells in the range.
   */
  getUnderlines() {
    return this._getStyles("ul");
  }
  /**
   * Returns the underline of the cells in the range.
   */
  getUnderline() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("ul", t.body) === ie.TRUE ? {
      s: ie.TRUE
    } : {
      s: ie.FALSE
    } : this.getUnderlines()[0][0];
  }
  /**
   * Returns the overlines of the cells in the range.
   */
  getOverlines() {
    return this._getStyles("ol");
  }
  /**
   * Returns the overline of the cells in the range.
   */
  getOverline() {
    return this.getOverlines()[0][0];
  }
  /**
   * Returns the strikeThrough of the cells in the range.
   */
  getStrikeThrough() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("st", t.body) === ie.TRUE ? {
      s: ie.TRUE
    } : {
      s: ie.FALSE
    } : this.getStrikeThroughs()[0][0];
  }
  /**
   * Returns the strikeThroughs of the cells in the range.
   */
  getStrikeThroughs() {
    return this._getStyles("st");
  }
  /**
   * Returns the font size in point size of the cell in the top-left corner of the range.
   */
  getFontSize() {
    var n, r;
    const t = ((n = this.getValue()) == null ? void 0 : n.p) || {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? t.body.textRuns.some((s) => {
      var i;
      return ((i = s == null ? void 0 : s.ts) == null ? void 0 : i.fs) != null;
    }) ? Math.max(...t.body.textRuns.map((s) => {
      var i;
      return ((i = s == null ? void 0 : s.ts) == null ? void 0 : i.fs) || 0;
    })) : this.getFontSizes()[0][0] : this.getFontSizes()[0][0];
  }
  /**
   * Returns the font sizes of the cells in the range.
   */
  getFontSizes() {
    return this._getStyles("fs");
  }
  /**
   * Returns the border info of the cells in the range.
   */
  getBorder() {
    return this.getBorders()[0][0];
  }
  getBorders() {
    return this._getStyles("bd");
  }
  /**
   * Returns the font style ('italic' or 'normal') of the cell in the top-left corner of the range.
   */
  getFontStyle() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("it", t.body) === ie.TRUE ? wi.ITALIC : wi.NORMAL : this._getFontStyles()[0][0];
  }
  /**
   * Returns the font styles of the cells in the range.
   */
  _getFontStyles() {
    return this._getStyles("it");
  }
  /**
   * Returns the font weight (normal/bold) of the cell in the top-left corner of the range.
   * If the cell has rich text, the return value according to the textRuns of the rich text,
   * when all styles of textRuns are bold, it will return FontWeight.BOLD,
   * otherwise return FontWeight.NORMAL.
   */
  getFontWeight() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("bl", t.body) === ie.TRUE ? Si.BOLD : Si.NORMAL : this._getFontWeights()[0][0];
  }
  /**
   * Returns the font weights of the cells in the range.
   */
  _getFontWeights() {
    return this._getStyles("bl");
  }
  /**
   * Returns the grid ID of the range's parent sheet.
   */
  getGridId() {
    return this._worksheet.getSheetId();
  }
  /**
   * Returns the height of the range.
   */
  getHeight() {
    const { _range: t, _worksheet: n } = this, { startRow: r, endRow: s } = t;
    let i = 0;
    for (let o = 0; o <= s - r; o++) {
      const a = n.getRowHeight(o);
      i += a;
    }
    return i;
  }
  /**
   *     Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left corner of the range.
   */
  getHorizontalAlignment() {
    return this.getHorizontalAlignments()[0][0];
  }
  /**
   *Returns the horizontal alignments of the cells in the range.
   */
  getHorizontalAlignments() {
    return this._getStyles("ht");
  }
  /**
   * Returns the end column position.
   */
  getLastColumn() {
    return this._range.endColumn;
  }
  /**
   *     Returns the end row position.
   */
  getLastRow() {
    return this._range.endRow;
  }
  /**
   * Returns the number of columns in this range.
   */
  getNumColumns() {
    const { startColumn: t, endColumn: n } = this._range;
    return n - t + 1;
  }
  /**
   * Returns the number of rows in this range.
   */
  getNumRows() {
    const { startRow: t, endRow: n } = this._range;
    return n - t + 1;
  }
  /**
   * Returns the Rich Text value for the top left cell of the range, or null if the cell value is not text.
   */
  getRichTextValue() {
    return this.getRichTextValues()[0][0];
  }
  /**
   * Returns the Rich Text values for the cells in the range.
   */
  getRichTextValues() {
    return this.getValues().map((t) => t.map((n) => (n == null ? void 0 : n.p) || ""));
  }
  /**
   * Returns the row position for this range.
   */
  getRowIndex() {
    return this._range.startRow;
  }
  /**
   * Returns the sheet this range belongs to.
   */
  getSheet() {
    return this._worksheet;
  }
  /**
   * Returns the text direction for the top left cell of the range.
   */
  getTextDirection() {
    return this.getTextDirections()[0][0];
  }
  /**
   * Returns the text directions for the cells in the range.
   */
  getTextDirections() {
    return this._getStyles("td");
  }
  /**
   * Returns the text rotation settings for the top left cell of the range.
   */
  // getTextRotation(): number {
  getTextRotation() {
    return this.getTextRotations()[0][0];
  }
  /**
   * Returns the text rotation settings for the cells in the range.
   */
  // getTextRotations(): number[][] {
  getTextRotations() {
    return this._getStyles("tr");
  }
  /**
   *     Returns the text style for the top left cell of the range.
   */
  getTextStyle() {
    return this.getTextStyles()[0][0];
  }
  /**
   * Returns the text styles for the cells in the range.
   */
  getTextStyles() {
    const t = this._deps.getStyles();
    return this.getValues().map((n) => n.map((r) => t.getStyleByCell(r)));
  }
  /**
   * Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner of the range.
   */
  getVerticalAlignment() {
    return this.getVerticalAlignments()[0][0];
  }
  /**
   * Returns the vertical alignments of the cells in the range.
   */
  getVerticalAlignments() {
    return this._getStyles("vt");
  }
  /**
   * Returns the width of the range in columns.
   */
  getWidth() {
    const { _range: t, _worksheet: n } = this, { startColumn: r, endColumn: s } = t;
    let i = 0;
    for (let o = 0; o <= s - r; o++)
      i += n.getColumnWidth(o);
    return i;
  }
  /**
   * Returns whether the text in the cell wraps.
   */
  getWrap() {
    return this.getWrapStrategy() === Bn.WRAP ? ie.TRUE : ie.FALSE;
  }
  /**
   * Returns the text wrapping strategies for the cells in the range.
   */
  getWrapStrategies() {
    return this._getStyles("tb");
  }
  /**
   * Returns the text wrapping strategy for the top left cell of the range.
   */
  getWrapStrategy() {
    return this.getWrapStrategies()[0][0];
  }
  forEach(t) {
    Cr2.foreach(this._range, t);
  }
  /**
   *
   * @param arg Shorthand for the style that gets
   * @returns style value
   */
  _getStyles(t) {
    const n = this._deps.getStyles();
    return this.getValues().map(
      (r) => r.map((s) => {
        const i = n && n.getStyleByCell(s);
        return i && i[t] || rt[t];
      })
    );
  }
};
p(Cr, "transformRange", (t, n) => {
  const r = n.getMaxColumns() - 1, s = n.getMaxRows() - 1;
  return t.rangeType === ge.ALL ? {
    startColumn: 0,
    startRow: 0,
    endColumn: r,
    endRow: s
  } : t.rangeType === ge.COLUMN ? {
    startRow: 0,
    endRow: s,
    startColumn: t.startColumn,
    endColumn: t.endColumn
  } : t.rangeType === ge.ROW ? {
    startColumn: 0,
    endColumn: r,
    startRow: t.startRow,
    endRow: t.endRow
  } : {
    startColumn: t.startColumn,
    endColumn: Math.min(t.endColumn, r),
    startRow: t.startRow,
    endRow: Math.min(t.endRow, s)
  };
});
var Or = Cr;
function ku(e, t, n = 0, r = e.length - 1, s = xp) {
  for (; r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, u = t - n + 1, c = Math.log(l), h = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * h * (l - h) / l) * (u - l / 2 < 0 ? -1 : 1), f = Math.max(n, Math.floor(t - u * h / l + d)), g = Math.min(r, Math.floor(t + (l - u) * h / l + d));
      ku(e, t, f, g, s);
    }
    const i = e[t];
    let o = n, a = r;
    for (Qn(e, n, t), s(e[r], i) > 0 && Qn(e, n, r); o < a; ) {
      for (Qn(e, o, a), o++, a--; s(e[o], i) < 0; ) o++;
      for (; s(e[a], i) > 0; ) a--;
    }
    s(e[n], i) === 0 ? Qn(e, n, a) : (a++, Qn(e, a, r)), a <= t && (n = a + 1), t <= a && (r = a - 1);
  }
}
function Qn(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function xp(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
var Di = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const r = [];
    if (!Vr(t, n)) return r;
    const s = this.toBBox, i = [];
    for (; n; ) {
      for (let o = 0; o < n.children.length; o++) {
        const a = n.children[o], l = n.leaf ? s(a) : a;
        Vr(t, l) && (n.leaf ? r.push(a) : ci(t, l) ? this._all(a, r) : i.push(a));
      }
      n = i.pop();
    }
    return r;
  }
  collides(t) {
    let n = this.data;
    if (!Vr(t, n)) return false;
    const r = [];
    for (; n; ) {
      for (let s = 0; s < n.children.length; s++) {
        const i = n.children[s], o = n.leaf ? this.toBBox(i) : i;
        if (Vr(t, o)) {
          if (n.leaf || ci(t, o)) return true;
          r.push(i);
        }
      }
      n = r.pop();
    }
    return false;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let r = 0; r < t.length; r++)
        this.insert(t[r]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const r = this.data;
        this.data = n, n = r;
      }
      this._insert(n, this.data.height - n.height - 1, true);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = yn([]), this;
  }
  remove(t, n) {
    if (!t) return this;
    let r = this.data;
    const s = this.toBBox(t), i = [], o = [];
    let a, l, u;
    for (; r || i.length; ) {
      if (r || (r = i.pop(), l = i[i.length - 1], a = o.pop(), u = true), r.leaf) {
        const c = Dp(t, r.children, n);
        if (c !== -1)
          return r.children.splice(c, 1), i.push(r), this._condense(i), this;
      }
      !u && !r.leaf && ci(r, s) ? (i.push(r), o.push(a), a = 0, l = r, r = r.children[0]) : l ? (a++, r = l.children[a], u = false) : r = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const r = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : r.push(...t.children), t = r.pop();
    return n;
  }
  _build(t, n, r, s) {
    const i = r - n + 1;
    let o = this._maxEntries, a;
    if (i <= o)
      return a = yn(t.slice(n, r + 1)), Sn(a, this.toBBox), a;
    s || (s = Math.ceil(Math.log(i) / Math.log(o)), o = Math.ceil(i / Math.pow(o, s - 1))), a = yn([]), a.leaf = false, a.height = s;
    const l = Math.ceil(i / o), u = l * Math.ceil(Math.sqrt(o));
    ol(t, n, r, u, this.compareMinX);
    for (let c = n; c <= r; c += u) {
      const h = Math.min(c + u - 1, r);
      ol(t, c, h, l, this.compareMinY);
      for (let d = c; d <= h; d += l) {
        const f = Math.min(d + l - 1, h);
        a.children.push(this._build(t, d, f, s - 1));
      }
    }
    return Sn(a, this.toBBox), a;
  }
  _chooseSubtree(t, n, r, s) {
    for (; s.push(n), !(n.leaf || s.length - 1 === r); ) {
      let i = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < n.children.length; l++) {
        const u = n.children[l], c = ui(u), h = Pp(t, u) - c;
        h < o ? (o = h, i = c < i ? c : i, a = u) : h === o && c < i && (i = c, a = u);
      }
      n = a || n.children[0];
    }
    return n;
  }
  _insert(t, n, r) {
    const s = r ? t : this.toBBox(t), i = [], o = this._chooseSubtree(s, this.data, n, i);
    for (o.children.push(t), mr(o, s); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(s, i, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const r = t[n], s = r.children.length, i = this._minEntries;
    this._chooseSplitAxis(r, i, s);
    const o = this._chooseSplitIndex(r, i, s), a = yn(r.children.splice(o, r.children.length - o));
    a.height = r.height, a.leaf = r.leaf, Sn(r, this.toBBox), Sn(a, this.toBBox), n ? t[n - 1].children.push(a) : this._splitRoot(r, a);
  }
  _splitRoot(t, n) {
    this.data = yn([t, n]), this.data.height = t.height + 1, this.data.leaf = false, Sn(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, r) {
    let s, i = 1 / 0, o = 1 / 0;
    for (let a = n; a <= r - n; a++) {
      const l = fr(t, 0, a, this.toBBox), u = fr(t, a, r, this.toBBox), c = Fp(l, u), h = ui(l) + ui(u);
      c < i ? (i = c, s = a, o = h < o ? h : o) : c === i && h < o && (o = h, s = a);
    }
    return s || r - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, r) {
    const s = t.leaf ? this.compareMinX : Up, i = t.leaf ? this.compareMinY : kp, o = this._allDistMargin(t, n, r, s), a = this._allDistMargin(t, n, r, i);
    o < a && t.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, r, s) {
    t.children.sort(s);
    const i = this.toBBox, o = fr(t, 0, n, i), a = fr(t, r - n, r, i);
    let l = zr(o) + zr(a);
    for (let u = n; u < r - n; u++) {
      const c = t.children[u];
      mr(o, t.leaf ? i(c) : c), l += zr(o);
    }
    for (let u = r - n - 1; u >= n; u--) {
      const c = t.children[u];
      mr(a, t.leaf ? i(c) : c), l += zr(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, n, r) {
    for (let s = r; s >= 0; s--)
      mr(n[s], t);
  }
  _condense(t) {
    for (let n = t.length - 1, r; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (r = t[n - 1].children, r.splice(r.indexOf(t[n]), 1)) : this.clear() : Sn(t[n], this.toBBox);
  }
};
function Dp(e, t, n) {
  if (!n) return t.indexOf(e);
  for (let r = 0; r < t.length; r++)
    if (n(e, t[r])) return r;
  return -1;
}
function Sn(e, t) {
  fr(e, 0, e.children.length, t, e);
}
function fr(e, t, n, r, s) {
  s || (s = yn(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let i = t; i < n; i++) {
    const o = e.children[i];
    mr(s, e.leaf ? r(o) : o);
  }
  return s;
}
function mr(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function Up(e, t) {
  return e.minX - t.minX;
}
function kp(e, t) {
  return e.minY - t.minY;
}
function ui(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function zr(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Pp(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function Fp(e, t) {
  const n = Math.max(e.minX, t.minX), r = Math.max(e.minY, t.minY), s = Math.min(e.maxX, t.maxX), i = Math.min(e.maxY, t.maxY);
  return Math.max(0, s - n) * Math.max(0, i - r);
}
function ci(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function Vr(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function yn(e) {
  return {
    children: e,
    height: 1,
    leaf: true,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function ol(e, t, n, r, s) {
  const i = [t, n];
  for (; i.length; ) {
    if (n = i.pop(), t = i.pop(), n - t <= r) continue;
    const o = t + Math.ceil((n - t) / r / 2) * r;
    ku(e, o, t, n, s), i.push(t, o, o, n);
  }
}
function gR(e, t, n, r = false) {
  if (t === 0 && n === 0)
    return e;
  let s = { ...e };
  const i = s.startAbsoluteRefType || ye.NONE, o = s.endAbsoluteRefType || ye.NONE, a = s.rangeType || ge.NORMAL;
  if (!r && i === ye.ALL && o === ye.ALL)
    return s;
  const l = al(s.startRow, n, s.startColumn, t, a), u = al(s.endRow, n, s.endColumn, t, a);
  return r || i === ye.NONE && o === ye.NONE ? s = {
    ...s,
    startRow: l.row,
    startColumn: l.column,
    endRow: u.row,
    endColumn: u.column
  } : (i === ye.NONE ? s = { ...s, startRow: l.row, startColumn: l.column } : i === ye.COLUMN ? s = { ...s, startRow: l.row } : i === ye.ROW && (s = { ...s, startColumn: l.column }), o === ye.NONE ? s = { ...s, endRow: u.row, endColumn: u.column } : o === ye.COLUMN ? s = { ...s, endRow: u.row } : o === ye.ROW && (s = { ...s, endColumn: u.column }), s);
}
function al(e, t, n, r, s) {
  return s === ge.NORMAL ? { row: e + t, column: n + r } : s === ge.ROW ? { row: e + t, column: n } : s === ge.COLUMN ? { row: e, column: n + r } : { row: e, column: n };
}
function Pu(e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (const o of e)
    t.add(o.startColumn), t.add(o.endColumn + 1), n.add(o.startRow), n.add(o.endRow + 1);
  const r = Array.from(t).sort((o, a) => o - a), s = Array.from(n).sort((o, a) => o - a);
  e.sort((o, a) => o.startRow - a.startRow || o.startColumn - a.startColumn);
  const i = [];
  for (let o = 0; o < s.length - 1; o++)
    for (let a = 0; a < r.length - 1; a++) {
      const l = r[a], u = r[a + 1] - 1, c = s[o], h = s[o + 1] - 1;
      for (const d of e) {
        if (d.startRow > h)
          break;
        if (d.startRow <= c && d.endRow >= h && d.startColumn <= l && d.endColumn >= u) {
          i.push({
            startColumn: l,
            endColumn: u,
            startRow: c,
            endRow: h
          });
          break;
        }
      }
    }
  return i;
}
function $p(e) {
  e.sort((r, s) => r.startRow - s.startRow || r.startColumn - s.startColumn);
  const t = {};
  for (const r of e)
    t[r.startRow] || (t[r.startRow] = []), t[r.startRow].push(r);
  const n = [];
  for (const r in t) {
    const s = t[+r];
    s.sort((o, a) => o.startColumn - a.startColumn);
    let i = s[0];
    for (let o = 1; o < s.length; o++) {
      const a = s[o];
      a.startColumn <= i.endColumn + 1 && a.startRow === i.startRow && a.endRow === i.endRow ? i.endColumn = Math.max(i.endColumn, a.endColumn) : (n.push(i), i = a);
    }
    n.push(i);
  }
  return n;
}
function Hp(e) {
  e.sort((r, s) => r.startColumn - s.startColumn || r.startRow - s.startRow);
  const t = {};
  for (const r of e)
    t[r.startColumn] || (t[r.startColumn] = []), t[r.startColumn].push(r);
  const n = [];
  for (const r in t) {
    const s = t[+r];
    s.sort((o, a) => o.startRow - a.startRow);
    let i = s[0];
    for (let o = 1; o < s.length; o++) {
      const a = s[o];
      a.startRow <= i.endRow + 1 && a.startColumn === i.startColumn && a.endColumn === i.endColumn ? i.endRow = Math.max(i.endRow, a.endRow) : (n.push(i), i = a);
    }
    n.push(i);
  }
  return n;
}
function Bp(e) {
  const t = Pu(e), n = $p(t);
  return Hp(n);
}
function jp(e, t) {
  const n = [];
  return e.forEach((r) => {
    n.push(...En.subtract(r, t));
  }), En.mergeRanges(n);
}
function Wp(e, t) {
  const n = ll(
    e.startRow,
    e.endRow,
    t.startRow,
    t.endRow
  ), r = ll(
    e.startColumn,
    e.endColumn,
    t.startColumn,
    t.endColumn
  );
  if (!n || !r)
    return null;
  const [s, i] = n, [o, a] = r, l = Yp(
    e.rangeType,
    t.rangeType,
    s,
    i,
    o,
    a
  );
  return {
    startRow: s,
    endRow: i,
    startColumn: o,
    endColumn: a,
    rangeType: l
  };
}
function ll(e, t, n, r) {
  const s = isNaN(e) ? -1 / 0 : e, i = isNaN(t) ? 1 / 0 : t, o = isNaN(n) ? -1 / 0 : n, a = isNaN(r) ? 1 / 0 : r, l = Math.max(s, o), u = Math.min(i, a);
  if (l <= u) {
    const c = l === -1 / 0 ? Number.NaN : l, h = u === 1 / 0 ? Number.NaN : u;
    return [c, h];
  } else
    return null;
}
function Yp(e, t, n, r, s, i) {
  const o = e !== void 0 ? e : ul(n, r, s, i), a = t !== void 0 ? t : ul(n, r, s, i);
  return o === ge.ALL || a === ge.ALL ? o === a ? o : o === ge.ALL ? a : o : o === a ? o : (o === ge.NORMAL || a === ge.NORMAL, ge.NORMAL);
}
function ul(e, t, n, r) {
  const s = !isNaN(e) && !isNaN(t), i = !isNaN(n) && !isNaN(r);
  return s && i ? ge.NORMAL : s ? ge.ROW : i ? ge.COLUMN : ge.ALL;
}
var Yt = class Yt2 {
  /**
   * Creates a deep copy of an IRange object
   * @param src
   * @example
   * ```typescript
   * const original = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const copy = Rectangle.clone(original);
   * // copy = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ```
   */
  static clone(t) {
    return t.rangeType !== void 0 ? {
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn,
      rangeType: t.rangeType
    } : {
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn
    };
  }
  /**
   * Checks if two ranges are equal by comparing their properties
   * @param src
   * @param target
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const areEqual = Rectangle.equals(range1, range2); // true
   * ```
   */
  static equals(t, n) {
    return t == null || n == null ? false : t.endRow === n.endRow && t.endColumn === n.endColumn && t.startRow === n.startRow && t.startColumn === n.startColumn && (t.rangeType === n.rangeType || t.rangeType === void 0 && n.rangeType === ge.NORMAL || n.rangeType === void 0 && t.rangeType === ge.NORMAL);
  }
  /**
   * Quickly checks if two normal ranges intersect. For specialized range types,
   * use the intersects() method instead.
   * @param rangeA
   * @param rangeB
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const doIntersect = Rectangle.simpleRangesIntersect(range1, range2); // true
   * ```
   */
  static simpleRangesIntersect(t, n) {
    const { startRow: r, endRow: s, startColumn: i, endColumn: o } = t, { startRow: a, endRow: l, startColumn: u, endColumn: c } = n, h = r <= l && s >= a, d = i <= c && o >= u;
    return h && d;
  }
  /**
   * Checks if two ranges intersect, handling special range types (ROW, COLUMN)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   startColumn: NaN, endColumn: NaN,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const colRange = {
   *   startRow: NaN, endRow: NaN,
   *   startColumn: 0, endColumn: 2,
   *   rangeType: RANGE_TYPE.COLUMN
   * };
   * const doIntersect = Rectangle.intersects(rowRange, colRange); // true
   * ```
   */
  static intersects(t, n) {
    if (t.rangeType === ge.ROW && n.rangeType === ge.COLUMN || t.rangeType === ge.COLUMN && n.rangeType === ge.ROW)
      return true;
    if (t.rangeType === ge.ROW && n.rangeType === ge.ROW)
      return t.startRow <= n.endRow && t.endRow >= n.startRow;
    if (t.rangeType === ge.COLUMN && n.rangeType === ge.COLUMN)
      return t.startColumn <= n.endColumn && t.endColumn >= n.startColumn;
    const r = Math.floor(Number.MAX_SAFE_INTEGER / 10), s = Number.isNaN(t.startRow) ? 0 : t.startRow, i = Number.isNaN(t.endRow) ? r : t.endRow, o = Number.isNaN(t.startColumn) ? 0 : t.startColumn, a = Number.isNaN(t.endColumn) ? r : t.endColumn, l = Number.isNaN(n.startRow) ? 0 : n.startRow, u = Number.isNaN(n.endRow) ? r : n.endRow, c = Number.isNaN(n.startColumn) ? 0 : n.startColumn, h = Number.isNaN(n.endColumn) ? r : n.endColumn, d = Math.abs(o + a - c - h), f = Math.abs(o - a) + Math.abs(c - h), g = Math.abs(s + i - l - u), _ = Math.abs(s - i) + Math.abs(l - u);
    return d <= f && g <= _;
  }
  /**
   * Checks if any of the ranges in the target array intersect with any of the ranges in the source array.
   * Attention! Please make sure there is no NaN in the ranges.
   * @param src
   * @param target
   * @example
   * ```typescript
   * const ranges1 = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 3, startColumn: 3, endRow: 5, endColumn: 5 }
   * ];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 4, endColumn: 4 },
   *   { startRow: 6, startColumn: 6, endRow: 8, endColumn: 8 }
   * ];
   * const doIntersect = Rectangle.doAnyRangesIntersect(ranges1, ranges2); // true
   * ```
   */
  static doAnyRangesIntersect(t, n) {
    const r = new Di();
    return r.load(t.map((s) => ({ minX: s.startColumn, minY: s.startRow, maxX: s.endColumn, maxY: s.endRow }))), n.some((s) => r.search({ minX: s.startColumn, minY: s.startRow, maxX: s.endColumn, maxY: s.endRow }).length > 0);
  }
  /**
   * Gets the intersection range between two ranges
   * @param src
   * @param target
   * @deprecated use `getIntersectRange` instead
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const intersection = Rectangle.getIntersects(range1, range2);
   * // intersection = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ```
   */
  static getIntersects(t, n) {
    const r = t.startRow, s = t.endRow, i = t.startColumn, o = t.endColumn, a = n.startRow, l = n.endRow, u = n.startColumn, c = n.endColumn;
    let h, d, f, g;
    if (a <= s)
      a >= r ? d = a : d = r;
    else
      return null;
    if (l >= r)
      l >= s ? g = s : g = l;
    else
      return null;
    if (u <= o)
      u > i ? h = u : h = i;
    else
      return null;
    if (c >= i)
      c >= o ? f = o : f = c;
    else
      return null;
    return {
      startRow: d,
      endRow: g,
      startColumn: h,
      endColumn: f,
      rangeType: ge.NORMAL
      // TODO: this may not be accurate
    };
  }
  /**
   * Checks if one range completely contains another range
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const inner = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const contains = Rectangle.contains(outer, inner); // true
   * ```
   */
  static contains(t, n) {
    return t.startRow <= n.startRow && t.endRow >= n.endRow && t.startColumn <= n.startColumn && t.endColumn >= n.endColumn;
  }
  /**
   * Checks if one range strictly contains another range (not equal)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const same = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const realContains = Rectangle.realContain(outer, same); // false
   * ```
   */
  static realContain(t, n) {
    return Yt2.contains(t, n) && (t.startRow < n.startRow || t.endRow > n.endRow || t.startColumn < n.startColumn || t.endColumn > n.endColumn);
  }
  /**
   * Creates a union range that encompasses all input ranges
   * @param {...any} ranges
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 };
   * const union = Rectangle.union(range1, range2);
   * // union = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }
   * ```
   */
  static union(...t) {
    return t.reduce(
      (n, r) => ({
        startRow: Math.min(n.startRow, r.startRow),
        startColumn: Math.min(n.startColumn, r.startColumn),
        endRow: Math.max(n.endRow, r.endRow),
        endColumn: Math.max(n.endColumn, r.endColumn),
        rangeType: ge.NORMAL
      }),
      t[0]
    );
  }
  /**
   * Creates a union range considering special range types (ROW, COLUMN)
   * @param {...any} ranges
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const normalRange = {
   *   startRow: 1, startColumn: 1,
   *   endRow: 3, endColumn: 3
   * };
   * const union = Rectangle.realUnion(rowRange, normalRange);
   * // Result will have NaN for columns due to ROW type
   * ```
   */
  static realUnion(...t) {
    const n = t.some((i) => i.rangeType === ge.COLUMN), r = t.some((i) => i.rangeType === ge.ROW), s = Yt2.union(...t);
    return {
      startColumn: r ? Number.NaN : s.startColumn,
      endColumn: r ? Number.NaN : s.endColumn,
      startRow: n ? Number.NaN : s.startRow,
      endRow: n ? Number.NaN : s.endRow,
      rangeType: r ? ge.ROW : n ? ge.COLUMN : ge.NORMAL
    };
  }
  /**
   * Subtracts one range from another, returning the remaining areas as separate ranges
   * @param range1
   * @param range2
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const result = Rectangle.subtract(range1, range2);
   * // Results in up to 4 ranges representing the non-overlapping areas
   * ```
   */
  static subtract(t, n) {
    if (n.startRow > t.endRow || n.endRow < t.startRow || n.startColumn > t.endColumn || n.endColumn < t.startColumn)
      return [t];
    const r = [];
    n.startRow >= t.startRow && r.push({
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: n.startRow - 1,
      endColumn: t.endColumn
    }), n.endRow <= t.endRow && r.push({
      startRow: n.endRow + 1,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn
    });
    const s = Math.max(t.startRow, n.startRow), i = Math.min(t.endRow, n.endRow);
    return n.startColumn >= t.startColumn && r.push({
      startRow: s,
      startColumn: t.startColumn,
      endRow: i,
      endColumn: n.startColumn - 1
    }), n.endColumn <= t.endColumn && r.push({
      startRow: s,
      startColumn: n.endColumn + 1,
      endRow: i,
      endColumn: t.endColumn
    }), r.filter((a) => a.startRow <= a.endRow && a.startColumn <= a.endColumn);
  }
  /**
   * Merges overlapping or adjacent ranges into larger ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 },
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ];
   * const merged = Rectangle.mergeRanges(ranges);
   * // Combines overlapping ranges into larger ones
   * ```
   */
  static mergeRanges(t) {
    return Bp(t);
  }
  /**
   * Splits overlapping ranges into a grid of non-overlapping ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 }
   * ];
   * const grid = Rectangle.splitIntoGrid(ranges);
   * // Splits into non-overlapping grid sections
   * ```
   */
  static splitIntoGrid(t) {
    return Pu(t);
  }
  /**
   * Subtracts multiple ranges from multiple ranges
   * @param ranges1
   * @param ranges2
   * @example
   * ```typescript
   * const ranges1 = [{ startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 },
   *   { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 }
   * ];
   * const result = Rectangle.subtractMulti(ranges1, ranges2);
   * // Returns remaining non-overlapping areas
   * ```
   */
  static subtractMulti(t, n) {
    if (!n.length)
      return t;
    let r = t;
    return n.forEach((s) => {
      r = jp(r, s);
    }), r;
  }
  /**
   * Checks if two rectangles defined by left, top, right, bottom coordinates intersect
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersects = Rectangle.hasIntersectionBetweenTwoRect(rect1, rect2); // true
   * ```
   */
  static hasIntersectionBetweenTwoRect(t, n) {
    return !(t.left > n.right || // rect1  rect2 
    t.right < n.left || // rect1  rect2 
    t.top > n.bottom || // rect1  rect2 
    t.bottom < n.top);
  }
  /**
   * Gets the intersection area between two rectangles defined by LTRB coordinates
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersection = Rectangle.getIntersectionBetweenTwoRect(rect1, rect2);
   * // Returns { left: 5, top: 5, right: 10, bottom: 10, width: 5, height: 5 }
   * ```
   */
  static getIntersectionBetweenTwoRect(t, n) {
    const r = Math.max(t.left, n.left), s = Math.min(t.right, n.right), i = Math.max(t.top, n.top), o = Math.min(t.bottom, n.bottom);
    return s <= r || o <= i ? null : {
      left: r,
      right: s,
      top: i,
      bottom: o,
      width: s - r,
      height: o - i
    };
  }
  /**
   * Sorts an array of ranges by startRow, then by startColumn
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 1, startColumn: 0, endRow: 2, endColumn: 1 },
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ];
   * const sorted = Rectangle.sort(ranges);
   * // Ranges will be sorted by startRow first, then startColumn
   * ```
   */
  static sort(t) {
    return t.sort((n, r) => n.startRow - r.startRow || n.startColumn - r.startColumn);
  }
};
p(Yt, "getRelativeRange", (t, n) => ({
  startRow: t.startRow - n.startRow,
  endRow: t.endRow - t.startRow,
  startColumn: t.startColumn - n.startColumn,
  endColumn: t.endColumn - t.startColumn
})), /**
* Converts a relative range back to an absolute range based on origin
* @param relativeRange
* @param originRange
* @param absoluteRange
* @example
* ```typescript
* const relative = { startRow: 2, startColumn: 2, endRow: 2, endColumn: 2 };
* const origin = { startRow: 3, startColumn: 3, endRow: 8, endColumn: 8 };
* const absolute = Rectangle.getPositionRange(relative, origin);
* // absolute = { startRow: 5, startColumn: 5, endRow: 7, endColumn: 7 }
* ```
*/
p(Yt, "getPositionRange", (t, n, r) => ({
  ...r || {},
  startRow: r && [ye.ROW, ye.ALL].includes(r.startAbsoluteRefType || 0) ? r.startRow : t.startRow + n.startRow,
  endRow: r && [ye.ROW, ye.ALL].includes(r.endAbsoluteRefType || 0) ? r.endRow : t.endRow + t.startRow + n.startRow,
  startColumn: r && [ye.COLUMN, ye.ALL].includes(r.startAbsoluteRefType || 0) ? r.startColumn : t.startColumn + n.startColumn,
  endColumn: r && [ye.COLUMN, ye.ALL].includes(r.endAbsoluteRefType || 0) ? r.endColumn : t.endColumn + t.startColumn + n.startColumn
})), /**
* Moves a range horizontally by a specified step and optionally extends it
* @param range
* @param step
* @param length
* @example
* ```typescript
* const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
* const moved = Rectangle.moveHorizontal(range, 2, 1);
* // moved = { startRow: 0, startColumn: 2, endRow: 1, endColumn: 4 }
* ```
*/
p(Yt, "moveHorizontal", (t, n = 0, r = 0) => ({
  ...t,
  startColumn: t.startColumn + n,
  endColumn: t.endColumn + n + r
})), /**
* Moves a range vertically by a specified step and optionally extends it
* @param range
* @param step
* @param length
* @example
* ```typescript
* const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
* const moved = Rectangle.moveVertical(range, 2, 1);
* // moved = { startRow: 2, startColumn: 0, endRow: 4, endColumn: 1 }
* ```
*/
p(Yt, "moveVertical", (t, n = 0, r = 0) => ({
  ...t,
  startRow: t.startRow + n,
  endRow: t.endRow + n + r
})), /**
* Moves a range by specified offsets in both directions
* @param range
* @param offsetX
* @param offsetY
* @example
* ```typescript
* const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
* const moved = Rectangle.moveOffset(range, 2, 3);
* // moved = { startRow: 3, startColumn: 2, endRow: 4, endColumn: 3 }
* ```
*/
p(Yt, "moveOffset", (t, n, r) => {
  const s = { ...t };
  switch (t.startAbsoluteRefType) {
    case ye.ROW:
      s.startColumn += n;
      break;
    case ye.COLUMN:
      s.startRow += r;
      break;
    case ye.ALL:
      break;
    case ye.NONE:
    default:
      s.startRow += r, s.startColumn += n;
      break;
  }
  switch (t.endAbsoluteRefType) {
    case ye.ROW:
      s.endColumn += n;
      break;
    case ye.COLUMN:
      s.endRow += r;
      break;
    case ye.ALL:
      break;
    case ye.NONE:
    default:
      s.endRow += r, s.endColumn += n;
      break;
  }
  return s;
});
var En = Yt;
function zp(e, t) {
  if (e.length === 0 || e[0].length === 0) return null;
  const n = new Array(e[0].length).fill(0);
  let r = 0, s = null;
  for (let i = 0; i < e.length; i++) {
    for (let a = 0; a < e[0].length; a++)
      n[a] = t(e[i][a]) ? n[a] + 1 : 0;
    const o = Vp(n);
    o.area > r && (r = o.area, s = {
      startColumn: o.start,
      startRow: i - o.height + 1,
      endColumn: o.end,
      endRow: i
    });
  }
  return s;
}
function Vp(e) {
  const t = [];
  let n = 0, r = { area: 0, height: 0, start: 0, end: 0 }, s = 0;
  for (; s < e.length; )
    if (t.length === 0 || e[s] >= e[t[t.length - 1]])
      t.push(s++);
    else {
      const i = e[t.pop()], o = t.length === 0 ? s : s - t[t.length - 1] - 1;
      i * o > n && (n = i * o, r = { area: n, height: i, start: t.length === 0 ? 0 : t[t.length - 1] + 1, end: s - 1 });
    }
  for (; t.length > 0; ) {
    const i = e[t.pop()], o = t.length === 0 ? s : s - t[t.length - 1] - 1;
    i * o > n && (n = i * o, r = { area: n, height: i, start: t.length === 0 ? 0 : t[t.length - 1] + 1, end: s - 1 });
  }
  return r;
}
function Gp(e, t) {
  Or.foreach(t, (n, r) => {
    e[n][r] = void 0;
  });
}
function _R(e, t) {
  const n = e.toFullArray(), r = [];
  for (; ; ) {
    const s = zp(n, t);
    if (!s)
      break;
    r.push(s), Gp(n, s);
  }
  return r;
}
var pR = class {
  constructor(t, n) {
    p(this, "_values", []);
    p(this, "_keys", []);
    p(this, "_keyMaps", /* @__PURE__ */ new Map());
    this._values = t, this._keys = n, t.forEach((r) => {
      this._initKeyMap(r);
    });
  }
  _initKeyMap(t) {
    this._keys.forEach((n) => {
      const r = t[n], s = this._keyMaps.get(n) || /* @__PURE__ */ new Map();
      s.set(r, t), this._keyMaps.set(n, s);
    });
  }
  /**
   * If a key group is specified, the order of values is determined by the key group, otherwise it depends on the keys at initialization
   * @param {string} key
   * @param {K[]} [keyGroup]
   * @return {*}
   * @memberof RefAlias
   */
  getValue(t, n) {
    const r = n || this._keys;
    for (let s = 0; s < r.length; s++) {
      const i = this._keyMaps.get(r[s]);
      if (i != null && i.has(t))
        return i.get(t);
    }
    return null;
  }
  hasValue(t) {
    for (let n = 0; n < this._keys.length; n++) {
      const r = this._keyMaps.get(this._keys[n]);
      if (r != null && r.has(t))
        return true;
    }
    return false;
  }
  addValue(t) {
    this._values.push(t), this._initKeyMap(t);
  }
  setValue(t, n, r) {
    const s = this.getValue(t);
    s && Object.keys(s).includes(n) && (s[n] = r);
  }
  deleteValue(t, n) {
    const r = this.getValue(t, n);
    if (r) {
      this._keys.forEach((i) => {
        const o = this._keyMaps.get(i), a = r[i];
        o == null || o.delete(a);
      });
      const s = this._values.findIndex((i) => i === r);
      this._values.splice(s, 1);
    }
  }
  getValues() {
    return this._values;
  }
  getKeyMap(t) {
    var n;
    return [...((n = this._keyMaps.get(t)) == null ? void 0 : n.keys()) || []];
  }
  clear() {
    this._values = [], this._keys = [], this._keyMaps.clear();
  }
};
function cl(e, t, n, r) {
  return {
    forEach(s) {
      for (let i = e; i <= t; i++)
        for (let o = n; o <= r; o++)
          s(i, o);
    }
  };
}
function ER(e) {
  if (e == null || e.length === 0)
    return Number.NaN;
  const t = e.toLowerCase().split(""), n = t.length, r = (o) => o.charCodeAt(0) - 96;
  let s = 0, i = 0;
  for (let o = 0; o < n; o++)
    i = r(t[o]), s += i * 26 ** (n - o - 1);
  return s === 0 ? Number.NaN : s - 1;
}
var Es = 65;
var Fu = 90;
var Kp = 97;
function CR(e) {
  const t = Fu - Es + 1;
  let n = "";
  for (; e >= 0; )
    n = String.fromCharCode(e % t + Es) + n, e = Math.floor(e / t) - 1;
  return n;
}
function Xp(e, t) {
  let n = "";
  for (; t > 0; )
    n += e, t--;
  return n;
}
function RR(e, t = false) {
  const n = Fu - Es + 1;
  let r = Kp;
  t && (r = Es);
  const s = String.fromCharCode(e % n + r), i = Math.floor(e / n) + 1;
  return Xp(s, i);
}
function IR(e, t) {
  return e.zIndex > t.zIndex ? 1 : e.zIndex === t.zIndex ? 0 : -1;
}
function wR(e, t) {
  return e.zIndex > t.zIndex ? -1 : e.zIndex === t.zIndex ? 0 : 1;
}
function Ps(e = "index", t = 1) {
  return (n, r) => n[e] > r[e] ? t : n[e] === r[e] ? 0 : -t;
}
function Fs(e, t = false) {
  const n = [];
  for (const r of e) {
    const { st: s, ed: i, ts: o } = r;
    if (r.sId === void 0 && delete r.sId, s === i || !t && J.isEmptyObject(o) && r.sId == null)
      continue;
    if (n.length === 0) {
      n.push(r);
      continue;
    }
    const a = n.pop();
    Kg(r, a) && J.hasIntersectionBetweenTwoRanges(a.st, a.ed, r.st, r.ed) ? n.push({
      ...r,
      st: a.st,
      ed: i
    }) : n.push(a, r);
  }
  return n;
}
function $u(e, t, n, r) {
  var u;
  const { textRuns: s } = e;
  if (s == null)
    return;
  const i = [], o = s.length;
  let a = false;
  const l = (u = t.textRuns) != null ? u : [];
  if (l.length)
    for (const c of l)
      c.st += r, c.ed += r;
  for (let c = 0; c < o; c++) {
    const h = s[c], { st: d, ed: f } = h;
    if (f <= r)
      i.push(h);
    else if (r > d && r < f) {
      a = true;
      const g = {
        ...h,
        ed: r
      };
      i.push(g), l.length && i.push(...l);
      const _ = {
        ...h,
        st: r + n,
        ed: f + n
      };
      i.push(_);
    } else
      h.st += n, h.ed += n, a || (a = true, i.push(...l)), i.push(h);
  }
  a || (a = true, i.push(...l)), e.textRuns = Fs(i);
}
function Hu(e, t, n, r) {
  const { paragraphs: s } = e;
  if (s == null)
    return;
  const { paragraphs: i } = t, o = [];
  for (let l = 0, u = s.length; l < u; l++) {
    const c = s[l], { startIndex: h } = c;
    h >= r && (c.startIndex += n), o.push(c.startIndex);
  }
  let a = -1;
  if (i) {
    for (let l = 0, u = i.length; l < u; l++) {
      const c = i[l];
      c.startIndex += r;
      const h = c.startIndex;
      a = o.indexOf(h);
    }
    a !== -1 && s.splice(a, 1), s.push(...i), s.sort(Ps("startIndex"));
  }
}
function Bu(e, t, n, r) {
  const { sectionBreaks: s } = e;
  if (s == null)
    return;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n);
  }
  const i = t.sectionBreaks;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r;
    }
    s.push(...i), s.sort(Ps("startIndex"));
  }
}
function ju(e, t, n, r) {
  const { customBlocks: s = [] } = e;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n);
  }
  const i = t.customBlocks;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r;
    }
    s.push(...i), s.sort(Ps("startIndex"));
  }
  s.length && !e.customBlocks && (e.customBlocks = s);
}
function Wu(e, t, n, r) {
  const { tables: s } = e;
  if (s == null)
    return;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u, endIndex: c } = l;
    u > r ? (l.startIndex += n, l.endIndex += n) : c > r && (l.endIndex += n);
  }
  const i = t.tables;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r, l.endIndex += r;
    }
    s.push(...i), s.sort(Ps("startIndex"));
  }
}
var Yu = "$";
var hl = (e) => e.split(Yu)[0];
function Xo(e) {
  if (e.length <= 1) return e;
  e.sort((s, i) => s.startIndex - i.startIndex);
  const t = [];
  let n = { ...e[0] };
  n.rangeId = hl(n.rangeId);
  for (let s = 1; s < e.length; s++) {
    const i = e[s];
    i.rangeId = hl(i.rangeId), i.rangeId === n.rangeId && Vc(n.properties, i.properties) && n.endIndex + 1 >= i.startIndex ? n.endIndex = i.endIndex : (t.push(n), n = { ...i });
  }
  t.push(n);
  const r = /* @__PURE__ */ Object.create(null);
  for (let s = 0, i = t.length; s < i; s++) {
    const o = t[s], a = o.rangeId;
    r[a] ? (o.rangeId = `${a}${Yu}${r[a]}`, r[a] = r[a] + 1) : r[a] = 1;
  }
  return t;
}
function Ui(e, t) {
  const n = e.findIndex((s) => s.startIndex < t && s.endIndex >= t), r = e[n];
  r && e.splice(n, 1, {
    rangeId: r.rangeId,
    rangeType: r.rangeType,
    startIndex: r.startIndex,
    endIndex: t - 1,
    properties: { ...r.properties }
  }, {
    rangeId: r.rangeId,
    rangeType: r.rangeType,
    startIndex: t,
    endIndex: r.endIndex,
    properties: { ...r.properties }
  });
}
function zu(e) {
  if (e.length <= 1) return e;
  e.sort((r, s) => r.startIndex - s.startIndex);
  const t = [];
  let n = { ...e[0] };
  for (let r = 1; r < e.length; r++) {
    const s = e[r];
    s.id === n.id && n.endIndex + 1 >= s.startIndex ? n.endIndex = s.endIndex : (t.push(n), n = { ...s });
  }
  return t.push(n), t;
}
function ki(e, t) {
  e.filter((r) => r.startIndex < t && r.endIndex >= t).forEach((r) => {
    const s = e.indexOf(r);
    e.splice(s, 1, {
      id: r.id,
      type: r.type,
      startIndex: r.startIndex,
      endIndex: t - 1
    }, {
      id: r.id,
      type: r.type,
      startIndex: t,
      endIndex: r.endIndex
    });
  });
}
function qp(e, t, n, r) {
  e.customRanges || (e.customRanges = []);
  const { customRanges: s } = e;
  Ui(s, r);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n, l.endIndex += n);
  }
  const i = [];
  if (t.customRanges) {
    for (let o = 0, a = t.customRanges.length; o < a; o++) {
      const l = t.customRanges[o];
      l.startIndex += r, l.endIndex += r, i.push(l);
    }
    s.push(...i);
  }
  e.customRanges = Xo(s);
}
function Zp(e, t, n, r) {
  e.customDecorations || (e.customDecorations = []);
  const { customDecorations: s } = e;
  ki(s, r);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n, l.endIndex += n);
  }
  const i = [];
  if (t.customDecorations) {
    for (let o = 0, a = t.customDecorations.length; o < a; o++) {
      const l = t.customDecorations[o];
      l.startIndex += r, l.endIndex += r, i.push(l);
    }
    s.push(...i);
  }
  e.customDecorations = zu(s);
}
function Vu(e, t, n) {
  const { textRuns: r } = e, s = n, i = n + t, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { st: h, ed: d } = c;
      if (s <= h && i >= d) {
        o.push({
          ...c,
          st: h - s,
          ed: d - s
        });
        continue;
      } else h <= s && d >= i ? (o.push({
        ...c,
        st: s - s,
        ed: i - s
      }), c.ed -= t) : s >= h && s < d ? (o.push({
        ...c,
        st: s - s,
        ed: d - s
      }), c.ed = s) : i > h && i <= d ? (o.push({
        ...c,
        st: h - s,
        ed: i - s
      }), c.st = i - t, c.ed -= t) : h >= i && (c.st -= t, c.ed -= t);
      a.push(c);
    }
    e.textRuns = a;
  }
  return o.length === 0 && o.push({
    st: 0,
    ed: t,
    ts: {}
  }), o;
}
function Gu(e, t, n) {
  const { paragraphs: r } = e, s = n, i = n + t, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h < i) {
        o.push({
          ...c,
          startIndex: h - n
        });
        continue;
      } else h >= i && (c.startIndex -= t);
      a.push(c);
    }
    e.paragraphs = a;
  }
  return o;
}
function Ku(e, t, n) {
  const { sectionBreaks: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h <= i) {
        o.push({
          ...c,
          startIndex: h - n
        });
        continue;
      } else h > i && (c.startIndex -= t);
      a.push(c);
    }
    e.sectionBreaks = a;
  }
  return o;
}
function Xu(e, t, n) {
  const { customBlocks: r = [] } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h <= i) {
        o.push({
          ...c,
          startIndex: h - n
        });
        continue;
      } else h > i && (c.startIndex -= t);
      a.push(c);
    }
    e.customBlocks = a;
  }
  return r.length && !e.customBlocks && (e.customBlocks = r), o;
}
function qu(e, t, n) {
  const { tables: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h, endIndex: d } = c;
      if (s <= h && i >= d) {
        o.push({
          ...c,
          startIndex: h - n,
          endIndex: d - n
        });
        continue;
      } else if (h <= s && d >= i) {
        const f = go(h, d, s, i);
        if (f.length === 0 || (c.startIndex = f[0], c.endIndex = f[1], c.startIndex === c.endIndex))
          continue;
      } else i < h && (c.startIndex -= t, c.endIndex -= t);
      a.push(c);
    }
    e.tables = a;
  }
  return o;
}
function Jp(e, t, n) {
  const { customRanges: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h, endIndex: d } = c;
      if (h >= s && d <= i) {
        o.push(c);
        continue;
      } else if (Math.max(s, h) <= Math.min(i, d)) {
        const f = go(h, d, s, i);
        if (f.length === 0)
          continue;
        c.startIndex = f[0], c.endIndex = f[1];
      } else i < h && (c.startIndex -= t, c.endIndex -= t);
      a.push(c);
    }
    e.customRanges = Xo(a);
  }
  return o;
}
function Qp(e, t, n, r = true) {
  const { customDecorations: s } = e, i = n, o = n + t - 1, a = [];
  if (s) {
    const l = [];
    for (let u = 0, c = s.length; u < c; u++) {
      const h = s[u], { startIndex: d, endIndex: f } = h;
      if (d >= i && f <= o) {
        a.push(h);
        continue;
      } else if (Math.max(i, d) <= Math.min(o, f)) {
        const g = go(d, f, i, o);
        if (g.length === 0)
          continue;
        h.startIndex = g[0], h.endIndex = g[1];
      } else o < d && r && (h.startIndex -= t, h.endIndex -= t);
      l.push(h);
    }
    e.customDecorations = l;
  }
  return a;
}
var e0 = ((e) => (e.ORDER_LIST_QUICK_1 = "1.", e.ORDER_LIST_QUICK_2 = "a)", e.ORDER_LIST_QUICK_3 = "a.", e.ORDER_LIST_QUICK_4 = "i.", e.ORDER_LIST_QUICK_5 = "A.", e.ORDER_LIST_QUICK_6 = "I.", e.ORDER_LIST_QUICK_7 = "01.", e.BULLET_LIST = "*", e))(e0 || {});
var zt = ((e) => (e.BULLET_LIST = "BULLET_LIST", e.BULLET_LIST_1 = "BULLET_LIST_1", e.BULLET_LIST_2 = "BULLET_LIST_2", e.BULLET_LIST_3 = "BULLET_LIST_3", e.BULLET_LIST_4 = "BULLET_LIST_4", e.BULLET_LIST_5 = "BULLET_LIST_5", e.ORDER_LIST = "ORDER_LIST", e.ORDER_LIST_1 = "ORDER_LIST_1", e.ORDER_LIST_2 = "ORDER_LIST_2", e.ORDER_LIST_3 = "ORDER_LIST_3", e.ORDER_LIST_4 = "ORDER_LIST_4", e.ORDER_LIST_5 = "ORDER_LIST_5", e.ORDER_LIST_QUICK_2 = "ORDER_LIST_QUICK_2", e.ORDER_LIST_QUICK_3 = "ORDER_LIST_QUICK_3", e.ORDER_LIST_QUICK_4 = "ORDER_LIST_QUICK_4", e.ORDER_LIST_QUICK_5 = "ORDER_LIST_QUICK_5", e.ORDER_LIST_QUICK_6 = "ORDER_LIST_QUICK_6", e.CHECK_LIST = "CHECK_LIST", e.CHECK_LIST_CHECKED = "CHECK_LIST_CHECKED", e))(zt || {});
var Gr = {
  "a)": { glyphFormat: "%1)", glyphType: me.DECIMAL },
  "1.": { glyphType: me.DECIMAL },
  "a.": { glyphFormat: "%1.", glyphType: me.LOWER_LETTER },
  "A.": { glyphType: me.UPPER_LETTER },
  "i.": { glyphFormat: "%1.", glyphType: me.LOWER_ROMAN },
  "I.": { glyphFormat: "%1.", glyphType: me.UPPER_LETTER }
};
var On = (e) => [
  ...e,
  ...e,
  ...e
].map((t, n) => ({
  glyphFormat: ` %${n + 1}`,
  glyphSymbol: t,
  bulletAlignment: Ts.START,
  textStyle: {
    fs: 12
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * n }
  }
}));
var vn = (e) => e.map((t, n) => ({
  ...t,
  bulletAlignment: Ts.START,
  textStyle: {
    fs: 12
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * n }
  }
}));
var dl = (e, t) => new Array(9).fill(0).map((n, r) => ({
  glyphFormat: ` %${r + 1}`,
  glyphSymbol: e,
  bulletAlignment: Ts.START,
  textStyle: {
    fs: 16
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * r },
    textStyle: t
  }
}));
var $s = {
  BULLET_LIST: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_1: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_2: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_3: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_4: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_5: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  ORDER_LIST: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.DECIMAL },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.DECIMAL },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.DECIMAL },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_1: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1)", glyphType: me.DECIMAL },
      { glyphFormat: "%2)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3)", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4)", glyphType: me.DECIMAL },
      { glyphFormat: "%5)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6)", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7)", glyphType: me.DECIMAL },
      { glyphFormat: "%8)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9)", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_2: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      "%1.",
      "%1.%2.",
      "%1.%2.%3.",
      "%1.%2.%3.%4.",
      "%1.%2.%3.%4.%5.",
      "%1.%2.%3.%4.%5.%6.",
      "%1.%2.%3.%4.%5.%6.%7."
    ].map((e) => ({ glyphFormat: e, glyphType: me.DECIMAL })))
  },
  ORDER_LIST_3: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_4: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%2.", glyphType: me.DECIMAL },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%5.", glyphType: me.DECIMAL },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%8.", glyphType: me.DECIMAL },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_5: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  CHECK_LIST: {
    listType: "CHECK_LIST",
    nestingLevel: dl("")
  },
  CHECK_LIST_CHECKED: {
    listType: "CHECK_LIST_CHECKED",
    nestingLevel: dl(
      "",
      {
        st: {
          s: ie.TRUE
        }
      }
    )
  }
};
var Kr = (e) => {
  const { glyphFormat: t, glyphType: n } = e, r = J.deepClone($s.ORDER_LIST);
  return r.nestingLevel[0].glyphFormat = t, r.nestingLevel[0].glyphType = n, r;
};
var t0 = {
  ORDER_LIST_QUICK_2: Kr(Gr[
    "a)"
    /* ORDER_LIST_QUICK_2 */
  ]),
  ORDER_LIST_QUICK_3: Kr(Gr[
    "a."
    /* ORDER_LIST_QUICK_3 */
  ]),
  ORDER_LIST_QUICK_4: Kr(Gr[
    "i."
    /* ORDER_LIST_QUICK_4 */
  ]),
  ORDER_LIST_QUICK_6: Kr(Gr[
    "I."
    /* ORDER_LIST_QUICK_6 */
  ])
};
Object.assign($s, t0);
var SR = {
  "1.": "ORDER_LIST",
  "a)": "ORDER_LIST_QUICK_2",
  "a.": "ORDER_LIST_QUICK_3",
  "i.": "ORDER_LIST_QUICK_4",
  "A.": "ORDER_LIST_3",
  "I.": "ORDER_LIST_QUICK_6",
  "01.": "ORDER_LIST_5",
  "*": "BULLET_LIST"
  /* BULLET_LIST */
};
function n0(e, t, n, r, s) {
  const i = r0(e, t, n, r, s), o = s0(e, t, n, r, s), a = i0(e, t, n, r, s), l = o0(e, t, n, r, s), u = a0(e, t, n, r, s), c = l0(e, t, n, r), h = u0(e, t, n, r, s);
  return {
    dataStream: "",
    textRuns: i,
    paragraphs: o,
    sectionBreaks: a,
    customBlocks: l,
    tables: u,
    customRanges: c,
    customDecorations: h
  };
}
function r0(e, t, n, r, s) {
  const { textRuns: i } = e, { textRuns: o } = t;
  if (i == null || o == null)
    return;
  const a = Vu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = Zu(o, a, s);
    t.textRuns = l;
  }
  return $u(e, t, n, r), a;
}
function Zu(e, t, n) {
  if (t.length === 0)
    return e;
  e = J.deepClone(e), t = J.deepClone(t);
  const r = [], s = e.length, i = t.length;
  let o = 0, a = 0, l = null;
  function u() {
    return l ? (r.push(l), l = null, true) : false;
  }
  for (; o < s && a < i; ) {
    const { st: f, ed: g, ts: _ } = e[o], { st: R, ed: b, ts: H, sId: P } = t[a];
    let W;
    if (n === pe.COVER ? W = { ...H, ..._ } : W = { ..._ }, g < R)
      u() || r.push(e[o]), o++;
    else if (b < f)
      u() || r.push(t[a]), a++;
    else {
      const w = {
        st: Math.min(f, R),
        ed: Math.max(f, R),
        ts: f < R ? { ..._ } : { ...H },
        sId: f < R ? void 0 : P
      };
      w.ed > w.st && r.push(w), r.push({
        st: Math.max(f, R),
        ed: Math.min(g, b),
        ts: W,
        sId: P
      }), g < b ? (o++, t[a].st = g, t[a].st === t[a].ed && a++) : (a++, e[o].st = b, e[o].st === e[o].ed && o++);
      const C = {
        st: Math.min(g, b),
        ed: Math.max(g, b),
        ts: g < b ? { ...H } : { ..._ },
        sId: g < b ? P : void 0
      };
      l = C.ed > C.st ? C : null;
    }
  }
  u();
  const c = r[r.length - 1], h = e[s - 1], d = t[i - 1];
  return c && c.ed !== Math.max(h.ed, d.ed) && (h.ed > d.ed ? r.push(h) : r.push(d)), Fs(r);
}
function s0(e, t, n, r, s) {
  const { paragraphs: i } = e, { paragraphs: o } = t;
  if (i == null || o == null)
    return;
  const a = Gu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const {
        startIndex: c,
        paragraphStyle: h,
        bullet: d
      } = u;
      let f = [];
      for (const g of a) {
        const {
          startIndex: _,
          paragraphStyle: R,
          bullet: b
        } = g;
        let H, P;
        if (s === pe.COVER ? (H = { ...R, ...h }, P = {
          listId: "",
          listType: zt.BULLET_LIST,
          nestingLevel: 0,
          textStyle: {},
          ...b,
          ...d
        }) : (H = { ...h, ...R }, P = {
          listId: "",
          listType: zt.BULLET_LIST,
          nestingLevel: 0,
          textStyle: {},
          ...d,
          ...b
        }), c === _) {
          f.push({
            startIndex: c,
            paragraphStyle: H,
            bullet: P
          });
          break;
        }
      }
      l.push(...f), f = [];
    }
    t.paragraphs = l;
  }
  return Hu(e, t, n, r), a;
}
function i0(e, t, n, r, s) {
  const { sectionBreaks: i } = e, { sectionBreaks: o } = t;
  if (i == null || o == null)
    return;
  const a = Ku(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c } = u;
      let h = [];
      for (const d of a) {
        const { startIndex: f } = d;
        if (c === f) {
          s === pe.COVER ? h.push({
            ...d,
            ...u
          }) : h.push({
            ...u,
            ...d
          });
          break;
        }
      }
      l.push(...h), h = [];
    }
    t.sectionBreaks = l;
  }
  return Bu(e, t, n, r), a;
}
function o0(e, t, n, r, s) {
  const { customBlocks: i = [] } = e, { customBlocks: o } = t;
  if (i == null || o == null)
    return;
  const a = Xu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c } = u;
      let h = [];
      for (const d of a) {
        const { startIndex: f } = d;
        if (c === f) {
          s === pe.COVER ? h.push({
            ...d,
            ...u
          }) : h.push({
            ...u,
            ...d
          });
          break;
        }
      }
      l.push(...h), h = [];
    }
    t.customBlocks = l;
  }
  return ju(e, t, n, r), i.length && !e.customBlocks && (e.customBlocks = i), a;
}
function a0(e, t, n, r, s) {
  const { tables: i } = e, { tables: o } = t;
  if (i == null || o == null)
    return;
  const a = qu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c, endIndex: h } = u;
      let d = [];
      for (const f of a) {
        const { startIndex: g, endIndex: _ } = f;
        if (g >= c && _ <= h) {
          s === pe.COVER ? d.push({
            ...f,
            ...u
          }) : d.push({
            ...u,
            ...f
          });
          break;
        }
      }
      l.push(...d), d = [];
    }
    t.tables = l;
  }
  return Wu(e, t, n, r), a;
}
function l0(e, t, n, r, s) {
  e.customRanges || (e.customRanges = []), Ui(e.customRanges, r), Ui(e.customRanges, r + n);
  const i = r, o = r + n - 1, { customRanges: a } = t, l = [], u = /* @__PURE__ */ new Map();
  e.customRanges.forEach((h) => {
    const { startIndex: d, endIndex: f } = h;
    d >= i && f <= o ? u.set(h.rangeId, h) : l.push(h);
  });
  const c = [];
  return a ? (a.forEach((h) => {
    const { startIndex: d, endIndex: f } = h;
    l.push({
      ...h,
      startIndex: d + r,
      endIndex: f + r
    });
  }), e.customRanges = Xo(l), c) : [];
}
function u0(e, t, n, r, s) {
  e.customDecorations || (e.customDecorations = []), ki(e.customDecorations, r), ki(e.customDecorations, r + n);
  const i = [], { customDecorations: o } = e, { customDecorations: a = [] } = t;
  if (s === pe.REPLACE) {
    for (let l = 0; l < o.length; l++) {
      const u = o[l], { startIndex: c, endIndex: h } = u;
      c >= r && h <= r + n - 1 && i.push(u);
    }
    a.forEach((l) => {
      const { startIndex: u, endIndex: c } = l;
      o.push({
        ...l,
        startIndex: u + r,
        endIndex: c + r
      });
    });
  } else
    for (const l of a) {
      const { id: u } = l;
      if (l.type === Dn.DELETED) {
        const c = o.filter((h) => h.id === u);
        c.length && i.push(...c);
      } else
        o.push({
          ...l,
          startIndex: l.startIndex + r,
          endIndex: l.endIndex + r
        });
    }
  for (const l of i) {
    const { id: u } = l, c = o.findIndex((h) => h.id === u);
    c !== -1 && o.splice(c, 1);
  }
  return e.customDecorations = zu(o), i;
}
var Ju = ((e) => (e[e.copy = 0] = "copy", e[e.cut = 1] = "cut", e))(Ju || {});
function Pi(e, t, n, r = true) {
  const { textRuns: s } = e;
  if (s) {
    const i = [];
    for (const o of s) {
      const a = J.deepClone(o), { st: l, ed: u } = a;
      J.hasIntersectionBetweenTwoRanges(l, u, t, n) && (t >= l && t <= u ? i.push({
        ...a,
        st: t,
        ed: Math.min(n, u)
      }) : n >= l && n <= u ? i.push({
        ...a,
        st: Math.max(t, l),
        ed: n
      }) : i.push(a));
    }
    return Fs(
      i.map((o) => {
        const { st: a, ed: l } = o;
        return {
          ...o,
          st: a - t,
          ed: l - t
        };
      })
    );
  } else if (r)
    return [{
      st: 0,
      ed: n - t,
      ts: {}
    }];
}
function c0(e, t, n) {
  const { tables: r = [] } = e, s = [];
  for (const i of r) {
    const o = J.deepClone(i), { startIndex: a, endIndex: l } = o;
    a >= t && l <= n && s.push({
      ...o,
      startIndex: a - t,
      endIndex: l - t
    });
  }
  return s;
}
function h0(e, t, n) {
  const { paragraphs: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    if (o >= t && o < n) {
      const a = J.deepClone(i);
      s.push(a);
    }
  }
  if (s.length)
    return s.map((i) => ({
      ...i,
      startIndex: i.startIndex - t
    }));
}
function OR(e, t, n) {
  const { sectionBreaks: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    o >= t && o <= n && s.push(J.deepClone(i));
  }
  if (s.length)
    return s.map((i) => ({
      ...i,
      startIndex: i.startIndex - t
    }));
}
function d0(e, t, n) {
  const { customBlocks: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    o >= t && o < n && s.push(J.deepClone(i));
  }
  if (s.length)
    return s.map((i) => ({
      ...i,
      startIndex: i.startIndex - t
    }));
}
function kt(e, t, n, r = true, s = 1) {
  const { dataStream: i } = e, o = {
    dataStream: i.slice(t, n)
  };
  o.textRuns = Pi(e, t, n, r);
  const a = c0(e, t, n);
  if (a.length && (o.tables = a), o.paragraphs = h0(e, t, n), s === 1) {
    const u = m0(e, t, n);
    u ? o.customDecorations = u : r && (o.customDecorations = []);
  }
  const { customRanges: l } = f0(e, t, n);
  return l ? o.customRanges = l : r && (o.customRanges = []), o.customBlocks = d0(e, t, n), o;
}
function vR(e) {
  const { dataStream: t, textRuns: n, paragraphs: r, customRanges: s, customDecorations: i, tables: o } = e;
  let a = 0, l = 0;
  s == null || s.forEach((c) => {
    c.startIndex < 0 && (a = Math.max(a, -c.startIndex)), c.endIndex > t.length - 1 && (l = Math.max(l, c.endIndex - t.length + 1));
  });
  const u = `${t}`;
  return n && (n[0] && (n[0].st = n[0].st - a), n[n.length - 1] && (n[n.length - 1].ed = n[n.length - 1].ed + l)), n == null || n.forEach((c) => {
    c.st += a, c.ed += a;
  }), r == null || r.forEach((c) => {
    c.startIndex += a;
  }), s == null || s.forEach((c) => {
    c.startIndex += a, c.endIndex += a;
  }), i == null || i.forEach((c) => {
    c.startIndex += a, c.endIndex += l;
  }), o == null || o.forEach((c) => {
    c.startIndex += a, c.endIndex += l;
  }), {
    ...e,
    dataStream: u,
    textRuns: n,
    paragraphs: r,
    customRanges: s,
    customDecorations: i,
    tables: o
  };
}
function f0(e, t, n) {
  if (e.customRanges == null)
    return {};
  const { customRanges: r } = e;
  return {
    customRanges: r.filter((a) => Math.max(a.startIndex, t) <= Math.min(a.endIndex, n - 1)).map((a) => ({
      ...a,
      startIndex: Math.max(a.startIndex, t),
      endIndex: Math.min(a.endIndex, n - 1)
    })).map((a) => ({
      ...a,
      startIndex: a.startIndex - t,
      endIndex: a.endIndex - t
    })),
    leftOffset: 0,
    rightOffset: 0
  };
}
function m0(e, t, n) {
  if (e.customDecorations == null)
    return;
  const { customDecorations: r = [] } = e, s = [];
  return r.forEach((i) => {
    if (Math.max(i.startIndex, t) <= Math.min(i.endIndex, n - 1)) {
      const o = J.deepClone(i);
      s.push({
        ...o,
        startIndex: Math.max(o.startIndex - t, 0),
        endIndex: Math.min(o.endIndex, n - 1) - t
      });
    }
  }), s;
}
function g0(e, t, n) {
  return e == null || t == null ? e != null ? e : t : Zu(e, t, n);
}
function _0(e, t, n) {
  if (e == null || t == null)
    return e != null ? e : t;
  if (t.length === 0 || e.length === 0)
    return e;
  if (t.length > 1 || e.length > 1)
    throw new Error("Cannot cover multiple customRanges");
  return n === pe.REPLACE ? [{
    ...e[0]
  }] : [{
    ...t[0],
    ...e[0]
  }];
}
function p0(e, t, n) {
  return t.length === 0 || e.length === 0 || n === pe.REPLACE ? e : [
    ...e,
    ...t.filter((r) => !e.some((s) => r.id === s.id))
  ];
}
function fl(e, t, n = pe.COVER) {
  if (t.dataStream !== "")
    throw new Error("Cannot compose other body with non-empty dataStream");
  const r = {
    dataStream: e.dataStream
  }, {
    textRuns: s,
    paragraphs: i = [],
    customRanges: o,
    customDecorations: a = []
  } = e, {
    textRuns: l,
    paragraphs: u = [],
    customRanges: c,
    customDecorations: h = []
  } = t;
  r.textRuns = g0(l, s, n), r.customRanges = _0(c, o, n);
  const d = p0(h, a, n);
  d.length && (r.customDecorations = d);
  const f = [];
  let g = 0, _ = 0;
  for (; g < i.length && _ < u.length; ) {
    const R = i[g], b = u[_], { startIndex: H } = R, { startIndex: P } = b;
    H === P ? (f.push(J.deepMerge(R, b)), g++, _++) : H < P ? (f.push(J.deepClone(R)), g++) : (f.push(J.deepClone(b)), _++);
  }
  return g < i.length && f.push(...i.slice(g)), _ < u.length && f.push(...u.slice(_)), f.length && (r.paragraphs = f), r;
}
function E0(e) {
  const { body: t } = e;
  if (t == null)
    return true;
  const { textRuns: n, paragraphs: r, customRanges: s, customBlocks: i, customDecorations: o, tables: a } = t;
  return n == null && r == null && s == null && i == null && o == null && a == null;
}
var er = class {
  constructor(t) {
    p(this, "_index", 0);
    p(this, "_offset", 0);
    this._actions = t;
  }
  hasNext() {
    return this.peekLength() < Number.POSITIVE_INFINITY;
  }
  next(t) {
    t || (t = Number.POSITIVE_INFINITY);
    const n = this._actions[this._index];
    if (n) {
      const r = this._offset, s = n.len;
      return t >= s - r ? (t = s - r, this._index += 1, this._offset = 0) : this._offset += t, n.t === Z.DELETE || n.t === Z.RETAIN && n.body == null ? J.deepClone({
        ...n,
        len: t
      }) : J.deepClone({
        ...n,
        len: t,
        body: kt(n.body, r, r + t, false)
      });
    } else
      return {
        t: Z.RETAIN,
        len: Number.POSITIVE_INFINITY
      };
  }
  peek() {
    return this._actions[this._index];
  }
  peekLength() {
    return this._actions[this._index] ? this._actions[this._index].len - this._offset : Number.POSITIVE_INFINITY;
  }
  peekType() {
    const t = this._actions[this._index];
    return t ? t.t : Z.RETAIN;
  }
  rest() {
    if (this.hasNext()) {
      if (this._offset === 0)
        return this._actions.slice(this._index);
      {
        const t = this._offset, n = this._index, r = this.next(), s = this._actions.slice(this._index);
        return this._offset = t, this._index = n, [r].concat(s);
      }
    } else return [];
  }
};
function C0(e, t, n) {
  const { dataStream: r } = e, s = n, i = n + t, o = Vu(e, t, n), a = Gu(e, t, n), l = Ku(e, t, n), u = Xu(e, t, n), c = qu(e, t, n), h = Jp(e, t, n), d = Qp(e, t, n);
  let f = "";
  return r && (e.dataStream = L_(r, s, i), f = r.slice(s, i)), {
    dataStream: f,
    textRuns: o,
    paragraphs: a,
    sectionBreaks: l,
    customBlocks: u,
    tables: c,
    customRanges: h,
    customDecorations: d
  };
}
function R0(e, t, n, r) {
  e.dataStream = M_(e.dataStream, r, t.dataStream), $u(e, t, n, r), Hu(e, t, n, r), Bu(e, t, n, r), ju(e, t, n, r), Wu(e, t, n, r), qp(e, t, n, r), Zp(e, t, n, r);
}
function I0(e, t, n, r, s = pe.COVER) {
  return n0(e, t, n, r, s);
}
function w0(e, t, n) {
  return t <= 0 ? { dataStream: "" } : C0(e, t, n);
}
function S0(e, t, n, r) {
  n !== 0 && R0(e, t, n, r);
}
function O0(e, t) {
  const n = new Gn();
  return n.reset(), t.forEach((r) => {
    const s = J.deepClone(r);
    switch (s.t) {
      case Z.RETAIN: {
        const { coverType: i, body: o, len: a } = s;
        o != null && I0(e, o, a, n.cursor, i), n.moveCursor(a);
        break;
      }
      case Z.INSERT: {
        const { body: i, len: o } = s;
        S0(e, i, o, n.cursor), n.moveCursor(o);
        break;
      }
      case Z.DELETE: {
        const { len: i } = s;
        w0(e, i, n.cursor);
        break;
      }
      default:
        throw new Error(`Unknown action type for action: ${s}.`);
    }
  }), e;
}
function v0(e, t, n, r, s) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return [];
  t = J.deepClone(t), e = J.deepClone(e);
  const i = [], o = t.length, a = e.length;
  let l = 0, u = 0, c = null;
  function h() {
    return c ? (i.push(c), c = null, true) : false;
  }
  for (; l < o && u < a; ) {
    const { st: _, ed: R, ts: b } = t[l], { st: H, ed: P, ts: W, sId: w } = e[u];
    let C = {};
    if (s === 0)
      C = { ...b }, n === pe.COVER && r === pe.REPLACE && W && (C = Object.assign({}, W, C));
    else if (C = { ...b }, n === pe.REPLACE) {
      if (r === pe.REPLACE)
        C = { ...W };
      else if (b && W) {
        const v = Object.keys(b);
        for (const y of v)
          W[y] && delete C[y];
      }
    } else if (r === pe.REPLACE) {
      if (W) {
        const v = Object.keys(W);
        for (const y of v)
          W[y] !== void 0 && (C[y] = W[y]);
      }
    } else if (W) {
      const v = Object.keys(W);
      for (const y of v)
        C[y] !== void 0 && delete C[y];
    }
    if (R < H)
      h() || i.push(t[l]), l++;
    else if (P < _)
      h() || i.push(e[u]), u++;
    else {
      const v = {
        st: Math.min(_, H),
        ed: Math.max(_, H),
        ts: _ < H ? { ...b } : { ...W }
      };
      v.ed > v.st && i.push(), i.push({
        st: Math.max(_, H),
        ed: Math.min(R, P),
        ts: C,
        sId: w
      }), R < P ? (l++, e[u].st = R, e[u].st === e[u].ed && u++) : (u++, t[l].st = P, t[l].st === t[l].ed && l++);
      const y = {
        st: Math.min(R, P),
        ed: Math.max(R, P),
        ts: R < P ? { ...W } : { ...b },
        sId: R < P ? w : void 0
      };
      c = y.ed > y.st ? y : null;
    }
  }
  h();
  const d = i[i.length - 1], f = t[o - 1], g = e[a - 1];
  return d.ed !== Math.max(f.ed, g.ed) && (f.ed > g.ed ? i.push(f) : i.push(g)), Fs(i, true);
}
function b0(e, t, n, r, s) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return [];
  if (e.length > 1 || t.length > 1)
    throw new Error("CustomRanges is only supported transform for length one now.");
  const i = e[0], o = t[0];
  if (n === pe.REPLACE)
    return s === 1 ? [J.deepClone(i)] : [J.deepClone(o)];
  if (r === pe.REPLACE) {
    const a = J.deepClone(o);
    return s === 1 && Object.assign(a, J.deepClone(i)), [a];
  } else {
    const a = J.deepClone(o);
    return s === 1 && Object.assign(a, J.deepClone(i)), [a];
  }
}
function ml(e, t, n, r, s) {
  const i = {
    startIndex: t.startIndex
  };
  if (t.paragraphStyle && (i.paragraphStyle = J.deepClone(t.paragraphStyle), e.paragraphStyle)) {
    if (n === pe.REPLACE)
      if (r === pe.REPLACE)
        s === 1 && (i.paragraphStyle = {
          ...e.paragraphStyle
        });
      else if (s === 1) {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          e.paragraphStyle[a] !== void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      } else {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          i.paragraphStyle[a] === void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      }
    else if (r === pe.REPLACE)
      if (s === 1) {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          e.paragraphStyle[a] !== void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      } else {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          i.paragraphStyle[a] === void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      }
    else if (s === 1) {
      const o = Object.keys(e.paragraphStyle);
      for (const a of o)
        i.paragraphStyle[a] && delete i.paragraphStyle[a];
    }
  }
  return n === pe.REPLACE && r === pe.REPLACE ? i.bullet = s === 1 ? J.deepClone(e.bullet) : J.deepClone(t.bullet) : e.bullet === void 0 ? i.bullet = J.deepClone(t.bullet) : n === pe.REPLACE || r === pe.REPLACE ? i.bullet = s === 0 && t.bullet ? J.deepClone(t.bullet) : J.deepClone(e.bullet) : s === 0 && t.bullet !== void 0 && (i.bullet = J.deepClone(t.bullet)), i;
}
function A0(e, t) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return J.deepClone(t);
  const n = [];
  for (const r of t) {
    const { id: s, type: i } = r;
    let o = false;
    for (const a of e)
      if (a.id === s) {
        (a.type === Dn.DELETED || i === Dn.DELETED) && (o = true, n.push({
          ...r,
          type: Dn.DELETED
        }));
        break;
      }
    o || n.push(r);
  }
  return n;
}
function y0(e, t, n = false) {
  const { body: r, coverType: s = pe.COVER } = e, { body: i, coverType: o = pe.COVER } = t;
  if (r == null || r.dataStream !== "" || i == null || i.dataStream !== "")
    throw new Error("Data stream is not supported in retain transform.");
  const a = {
    dataStream: ""
  }, l = o, {
    textRuns: u,
    paragraphs: c = [],
    customRanges: h,
    customDecorations: d
  } = r, {
    textRuns: f,
    paragraphs: g = [],
    customRanges: _,
    customDecorations: R
  } = i, b = v0(
    u,
    f,
    s,
    o,
    n ? 1 : 0
    /* COVER */
  );
  b && (a.textRuns = b);
  const H = b0(
    h,
    _,
    s,
    o,
    n ? 1 : 0
    /* COVER */
  );
  H && (a.customRanges = H);
  const P = A0(
    d,
    R
  );
  P && (a.customDecorations = P);
  const W = [];
  let w = 0, C = 0;
  for (; w < c.length && C < g.length; ) {
    const v = c[w], y = g[C], { startIndex: F2 } = v, { startIndex: $ } = y;
    if (F2 === $) {
      let m = {
        startIndex: F2
      };
      n ? m = ml(
        v,
        y,
        s,
        o,
        1
        /* COVER_ONLY_NOT_EXISTED */
      ) : m = ml(
        v,
        y,
        s,
        o,
        0
        /* COVER */
      ), W.push(m), w++, C++;
    } else F2 < $ ? w++ : (W.push(J.deepClone(y)), C++);
  }
  return C < g.length && W.push(...g.slice(C)), W.length && (a.paragraphs = W), {
    coverType: l,
    body: a
  };
}
function gl(e) {
  return Object.keys(e).length === 1;
}
var Mn = class Mn2 {
  constructor() {
    p(this, "_actions", []);
  }
  static apply(t, n) {
    return O0(t, n);
  }
  // eslint-disable-next-line complexity
  static compose(t, n) {
    const r = new er(t), s = new er(n), i = new Mn2();
    for (; r.hasNext() || s.hasNext(); )
      if (s.peekType() === Z.INSERT)
        i.push(s.next());
      else if (r.peekType() === Z.DELETE)
        i.push(r.next());
      else {
        const o = Math.min(r.peekLength(), s.peekLength()), a = r.next(o), l = s.next(o);
        if (a.t === Z.INSERT && l.t === Z.RETAIN)
          l.body == null ? i.push(a) : i.push({
            ...a,
            body: fl(a.body, l.body, l.coverType)
          });
        else if (a.t === Z.RETAIN && l.t === Z.RETAIN)
          if (a.body == null && l.body == null)
            i.push(a.len !== Number.POSITIVE_INFINITY ? a : l);
          else if (a.body && l.body) {
            const u = a.coverType === pe.REPLACE || l.coverType === pe.REPLACE ? pe.REPLACE : pe.COVER;
            i.push({
              ...a,
              t: Z.RETAIN,
              coverType: u,
              body: fl(a.body, l.body, l.coverType)
            });
          } else
            i.push(a.body ? a : l);
        else a.t === Z.RETAIN && l.t === Z.DELETE ? i.push(l) : a.t === Z.INSERT && (l.t, Z.DELETE);
      }
    return i.trimEndUselessRetainAction(), i.serialize();
  }
  /**
   * |(this \| other) | **insert** | **retain** | **delete** |
   * | ---------------- | ---------- | ---------- | ---------- |
   * |    **insert**    |   Case 1   |   Case 2   |   Case 2   |
   * |    **retain**    |   Case 1   |   Case 5   |   Case 4   |
   * |    **delete**    |   Case 1   |   Case 3   |   Case 3   |
   *
   * Case 1: When the other action type is an insert operation,
   *         the insert operation is retained regardless of the type of action this action
   * Case 2: When this action type is an insert operation and the other action type is a
   *         non-insert operation, you need to retain the length of this action insert
   * Case 3: When this action is a delete operation, there are two scenarios:
   *      1) When other is a delete operation, since it is a delete operation, this has
   *         already been deleted, so the target does not need to be in delete, and it can
   *         be continued directly
   *      2) When other is the retain operation, although this action delete occurs first,
   *         the delete priority is higher, so the delete operation is retained, and the origin
   *         delete has been applied, so it is directly continued
   * Case 4: other is the delete operation, this is the retain operation, and the target delete operation
   *         is kept
   * Case 5: When both other and this are retain operations
   *      1) If the other body attribute does not exist, directly retain length
   *      2) If the other body property exists, then execute the TransformBody logic to override it
   */
  // priority - if true, this actions takes priority over other, that is, this actions are considered to happen "first".
  // thisActions is the target action.
  static transform(t, n, r = "right") {
    return this._transform(n, t, r === "left" ? "right" : "left");
  }
  // otherActions is the actions to be transformed.
  static _transform(t, n, r = "right") {
    const s = new er(t), i = new er(n), o = new Mn2();
    for (; s.hasNext() || i.hasNext(); )
      if (s.peekType() === Z.INSERT && (r === "left" || i.peekType() !== Z.INSERT)) {
        const a = s.next();
        o.retain(a.len);
      } else if (i.peekType() === Z.INSERT)
        o.push(i.next());
      else {
        const a = Math.min(s.peekLength(), i.peekLength()), l = s.next(a), u = i.next(a);
        if (l.t === Z.DELETE)
          continue;
        if (u.t === Z.DELETE) {
          o.push(u);
          continue;
        }
        if (l.body == null || u.body == null)
          o.push(u);
        else {
          const { coverType: c, body: h } = y0(l, u, r === "left");
          o.push({
            ...u,
            t: Z.RETAIN,
            coverType: c,
            body: h
          });
        }
      }
    return o.trimEndUselessRetainAction(), o.serialize();
  }
  /**
   * Used to transform selection. Why not named transformSelection?
   * Because Univer Doc supports multiple Selections in one document, user need to encapsulate transformSelections at the application layer.
   */
  static transformPosition(t, n, r = false) {
    const s = new er(t);
    let i = 0;
    for (; s.hasNext() && i <= n; ) {
      const o = s.peekLength(), a = s.peekType();
      if (s.next(), a === Z.DELETE) {
        n -= Math.min(o, n - i);
        continue;
      } else a === Z.INSERT && (i < n || !r) && (n += o);
      i += o;
    }
    return n;
  }
  static isNoop(t) {
    return t.length === 0;
  }
  static invert(t) {
    const n = [];
    for (const r of t)
      if (r.t === Z.INSERT)
        n.push({
          t: Z.DELETE,
          len: r.len,
          body: r.body
        });
      else if (r.t === Z.DELETE) {
        if (r.body == null)
          throw new Error("Can not invert DELETE action without body property, makeInvertible must be called first.");
        n.push({
          t: Z.INSERT,
          body: r.body,
          len: r.len
        });
      } else if (r.body != null) {
        if (r.oldBody == null)
          throw new Error("Can not invert RETAIN action without oldBody property, makeInvertible must be called first.");
        n.push({
          t: Z.RETAIN,
          body: r.oldBody,
          oldBody: r.body,
          len: r.len,
          coverType: pe.REPLACE
        });
      } else
        n.push(r);
    return n;
  }
  static makeInvertible(t, n) {
    const r = [];
    let s = 0;
    for (const i of t) {
      if (i.t === Z.DELETE && (i.body == null || i.body && i.body.dataStream.length !== i.len)) {
        const o = kt(n, s, s + i.len, false);
        i.len = o.dataStream.length, i.body = o;
      }
      if (i.t === Z.RETAIN && i.body != null) {
        const o = kt(n, s, s + i.len, true);
        i.oldBody = {
          ...o,
          dataStream: ""
        }, i.len = o.dataStream.length;
      }
      r.push(i), i.t !== Z.INSERT && (s += i.len);
    }
    return r;
  }
  insert(t, n) {
    const r = {
      t: Z.INSERT,
      body: n,
      len: t
    };
    return this.push(r), this;
  }
  retain(t, n, r) {
    const s = {
      t: Z.RETAIN,
      len: t
    };
    return n != null && (s.body = n), r != null && (s.coverType = r), this.push(s), this;
  }
  delete(t) {
    const n = {
      t: Z.DELETE,
      len: t
    };
    return this.push(n), this;
  }
  empty() {
    return this._actions = [], this;
  }
  serialize() {
    return this._actions;
  }
  // eslint-disable-next-line complexity
  push(...t) {
    if (t.length > 1) {
      for (const i of t)
        this.push(i);
      return this;
    }
    let n = this._actions.length, r = this._actions[n - 1];
    const s = J.deepClone(t[0]);
    if (s.t === Z.RETAIN && s.len === 0 && s.body == null)
      return this;
    if (typeof r == "object") {
      if (r.t === Z.DELETE && s.t === Z.DELETE)
        return r.len += s.len, this;
      if (r.t === Z.DELETE && s.t === Z.INSERT && (n -= 1, r = this._actions[n - 1], r == null))
        return this._actions.unshift(s), this;
      if (r.t === Z.RETAIN && s.t === Z.RETAIN && r.body == null && s.body == null)
        return r.len += s.len, this;
      if (r.t === Z.INSERT && gl(r.body) && s.t === Z.INSERT && gl(s.body))
        return r.len += s.len, r.body.dataStream += s.body.dataStream, this;
    }
    return n === this._actions.length ? this._actions.push(s) : this._actions.splice(n, 0, s), this;
  }
  trimEndUselessRetainAction() {
    let t = this._actions[this._actions.length - 1];
    for (; t && t.t === Z.RETAIN && E0(t); )
      this._actions.pop(), t = this._actions[this._actions.length - 1];
    return this;
  }
};
p(Mn, "id", "text-x"), p(Mn, "uri", "https://github.com/dream-num/univer#text-x");
var Ne = Mn;
Object.defineProperty(Ne, "name", {
  value: "text-x"
});
var Ln = class Ln2 {
  static registerSubtype(t) {
    var n;
    t == null || this._subTypes.has(t.name) && ((n = this._subTypes.get(t.name)) == null ? void 0 : n.id) !== Ne.id || (this._subTypes.set(t.name, t), it.type.registerSubtype(t));
  }
  static apply(t, n) {
    if (!it.type.isNoop(n))
      return it.type.apply(t, n);
  }
  static compose(t, n) {
    return it.type.compose(t, n);
  }
  static transform(t, n, r) {
    return it.type.transform(t, n, r);
  }
  // Use to transform cursor position, just call TextXPro.transformPosition.
  static transformPosition(t, n, r = "right") {
    return t && t.length === 2 && t[0] === "body" && t[1].et === Ne.name ? Ne.transformPosition(t[1].e, n, r === "left") : n;
  }
  static invertWithDoc(t, n) {
    return it.type.invertWithDoc(t, n);
  }
  static isNoop(t) {
    return it.type.isNoop(t);
  }
  static getInstance() {
    return this._instance == null && (this._instance = new Ln2()), this._instance;
  }
  // eslint-disable-next-line ts/no-explicit-any
  removeOp(t, n) {
    return it.removeOp(t, n);
  }
  moveOp(t, n) {
    return it.moveOp(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  insertOp(t, n) {
    return it.insertOp(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  replaceOp(t, n, r) {
    return it.replaceOp(t, n, r);
  }
  editOp(t, n = ["body"]) {
    return it.editOp(n, Ne.name, t);
  }
};
p(Ln, "uri", "https://github.com/dream-num/univer#json-x"), p(Ln, "_subTypes", /* @__PURE__ */ new Map()), p(Ln, "_instance", null);
var Qt = Ln;
Qt.registerSubtype(Ne);
var N0 = ((e) => (e.PARAGRAPH = "PARAGRAPH", e.SECTION_BREAK = "SECTION_BREAK", e.TABLE = "TABLE", e.TABLE_ROW = "TABLE_ROW", e.TABLE_CELL = "TABLE_CELL", e.CUSTOM_BLOCK = "CUSTOM_BLOCK", e))(N0 || {});
var ct = ((e) => (e.PARAGRAPH = "\r", e.SECTION_BREAK = `
`, e.TABLE_START = "", e.TABLE_ROW_START = "\x1B", e.TABLE_CELL_START = "", e.TABLE_CELL_END = "", e.TABLE_ROW_END = "", e.TABLE_END = "", e.CUSTOM_RANGE_START = "", e.CUSTOM_RANGE_END = "", e.COLUMN_BREAK = "\v", e.PAGE_BREAK = "\f", e.DOCS_END = "\0", e.TAB = "	", e.CUSTOM_BLOCK = "\b", e.LETTER = "", e.SPACE = " ", e))(ct || {});
function bR(e) {
  return `${e}`;
}
var T0 = [
  // DataStreamTreeTokenType.PARAGRAPH, // 
  // DataStreamTreeTokenType.SECTION_BREAK, // 
  ct.TABLE_START,
  // 
  ct.TABLE_ROW_START,
  // 
  ct.TABLE_CELL_START,
  // 
  ct.TABLE_CELL_END,
  // 
  ct.TABLE_ROW_END,
  // 
  ct.TABLE_END
  // 
  // DataStreamTreeTokenType.COLUMN_BREAK, // 
  // DataStreamTreeTokenType.PAGE_BREAK, // 
  // DataStreamTreeTokenType.DOCS_END, // 
  // DataStreamTreeTokenType.TAB, // 
  // DataStreamTreeTokenType.CUSTOM_BLOCK, //  mention 
];
var qo = (e) => {
  const t = e.endsWith(`\r
`) ? e.slice(0, -2) : e;
  return T0.reduce((n, r) => n.replaceAll(r, ""), t);
};
var M0 = (e) => e ? qo(e).replaceAll("\r", "") === "" : true;
var L0 = (e) => {
  const t = e.replace(/\n/g, "\r"), n = [], r = [];
  let s = 0, i = "";
  const o = (l, u = true) => {
    const c = t.slice(s, l);
    if (J.isLegalUrl(c)) {
      const h = et(), d = `${c}`, f = {
        startIndex: s,
        endIndex: s + d.length - 1,
        rangeId: h,
        rangeType: pn.HYPERLINK,
        properties: {
          url: e
        }
      };
      r.push(f), i += d, s = l + 1, u && (i += "\r", n.push({ startIndex: l }));
    } else
      i += t.slice(s, l + 1), s = l + 1, u && n.push({ startIndex: l });
  };
  let a = 0;
  for (let l = 0; l < t.length; l++)
    t[l] === "\r" && (o(l), a = l);
  return (a !== t.length - 1 || t.length === 1) && o(t.length, false), {
    dataStream: i,
    paragraphs: n,
    customRanges: r
  };
};
var Qu = {
  id: "default_doc",
  documentStyle: {}
};
var x0 = class extends lo {
  constructor(n) {
    var r;
    super();
    p(this, "type", we.UNIVER_DOC);
    p(this, "_name$", new BehaviorSubject(""));
    p(this, "name$", this._name$.asObservable());
    p(this, "snapshot");
    this.snapshot = { ...Qu, ...n }, this._name$.next((r = this.snapshot.title) != null ? r : "No Title");
  }
  getUnitId() {
    throw new Error("Method not implemented.");
  }
  getRev() {
    var n;
    return (n = this.snapshot.rev) != null ? n : 1;
  }
  incrementRev() {
    this.snapshot.rev = this.getRev() + 1;
  }
  setRev(n) {
    this.snapshot.rev = n;
  }
  setName(n) {
    this.snapshot.title = n, this._name$.next(n);
  }
  get drawings() {
    return this.snapshot.drawings;
  }
  get documentStyle() {
    return this.snapshot.documentStyle;
  }
  get lists() {
    return this.snapshot.lists;
  }
  get zoomRatio() {
    var n;
    return ((n = this.snapshot.settings) == null ? void 0 : n.zoomRatio) || 1;
  }
  resetDrawing(n, r) {
    this.snapshot.drawings = n, this.snapshot.drawingsOrder = r;
  }
  getBody() {
    return this.snapshot.body;
  }
  getSnapshot() {
    return this.snapshot;
  }
  getBulletPresetList() {
    var s;
    const n = (s = this.snapshot.lists) != null ? s : {};
    return {
      ...$s,
      ...n
    };
  }
  updateDocumentId(n) {
    this.snapshot.id = n;
  }
  updateDocumentRenderConfig(n) {
    const { documentStyle: r } = this.snapshot;
    r.renderConfig == null ? r.renderConfig = n : r.renderConfig = {
      ...r.renderConfig,
      ...n
    };
  }
  getDocumentStyle() {
    return this.snapshot.documentStyle;
  }
  updateDocumentStyle(n) {
    this.snapshot.documentStyle == null ? this.snapshot.documentStyle = n : this.snapshot.documentStyle = {
      ...this.snapshot.documentStyle,
      ...n
    };
  }
  updateDocumentDataMargin(n) {
    const { t: r, l: s, b: i, r: o } = n, { documentStyle: a } = this.snapshot;
    r != null && (a.marginTop = r), s != null && (a.marginLeft = s), i != null && (a.marginBottom = i), o != null && (a.marginRight = o);
  }
  updateDocumentDataPageSize(n, r) {
    const { documentStyle: s } = this.snapshot;
    if (!s.pageSize) {
      s.pageSize = {
        width: n != null ? n : Number.POSITIVE_INFINITY,
        height: r != null ? r : Number.POSITIVE_INFINITY
      };
      return;
    }
    n !== void 0 && (s.pageSize.width = n), r !== void 0 && (s.pageSize.height = r);
  }
  updateDrawing(n, r) {
    const { drawings: s } = this, { width: i, height: o, left: a, top: l } = r, u = s == null ? void 0 : s[n];
    if (!u)
      return;
    const c = u.docTransform;
    c.size.width = i, c.size.height = o, c.positionH.posOffset = a, c.positionV.posOffset = l;
  }
  setZoomRatio(n = 1) {
    this.snapshot.settings ? this.snapshot.settings.zoomRatio = n : this.snapshot.settings = {
      zoomRatio: n
    };
  }
  setDisabled(n) {
    this.snapshot.disabled = n;
  }
  getDisabled() {
    return this.snapshot.disabled;
  }
  getTitle() {
    return this.snapshot.title;
  }
};
var Pt = class _Pt extends x0 {
  constructor(n) {
    var s, i;
    super(J.isEmptyObject(n) ? ig() : n);
    p(this, "_unitId");
    p(this, "headerModelMap", /* @__PURE__ */ new Map());
    p(this, "footerModelMap", /* @__PURE__ */ new Map());
    p(this, "change$", new BehaviorSubject(0));
    const r = 6;
    this._unitId = (s = this.snapshot.id) != null ? s : et(r), this._initializeHeaderFooterModel(), this._name$.next((i = this.snapshot.title) != null ? i : "");
  }
  dispose() {
    super.dispose(), this.headerModelMap.forEach((n) => {
      n.dispose();
    }), this.footerModelMap.forEach((n) => {
      n.dispose();
    }), this._name$.complete();
  }
  getDrawings() {
    return this.snapshot.drawings;
  }
  getDrawingsOrder() {
    return this.snapshot.drawingsOrder;
  }
  getCustomRanges() {
    var n;
    return (n = this.snapshot.body) == null ? void 0 : n.customRanges;
  }
  getCustomDecorations() {
    var n;
    return (n = this.snapshot.body) == null ? void 0 : n.customDecorations;
  }
  getSettings() {
    return this.snapshot.settings;
  }
  // TODO: @JOCS do not use reset, please use apply to modify the snapshot.
  reset(n) {
    if (n.id && n.id !== this._unitId)
      throw new Error("Cannot reset a document model with a different unit id!");
    this.snapshot = { ...Qu, ...n }, this._initializeHeaderFooterModel(), this.change$.next(this.change$.value + 1);
  }
  getSelfOrHeaderFooterModel(n) {
    if (n != null) {
      if (this.headerModelMap.has(n))
        return this.headerModelMap.get(n);
      if (this.footerModelMap.has(n))
        return this.footerModelMap.get(n);
    }
    return this;
  }
  getUnitId() {
    return this._unitId;
  }
  apply(n) {
    if (!Qt.isNoop(n))
      return this.snapshot = Qt.apply(this.snapshot, n), n != null && n.some((r) => Array.isArray(r) && ((r == null ? void 0 : r[0]) === "headers" || (r == null ? void 0 : r[0]) === "footers")) && (this.headerModelMap.clear(), this.footerModelMap.clear(), this._initializeHeaderFooterModel()), this.change$.next(this.change$.value + 1), this.snapshot;
  }
  sliceBody(n, r, s = Ju.copy) {
    const i = this.getBody();
    if (i != null)
      return kt(i, n, r, false, s);
  }
  _initializeHeaderFooterModel() {
    const { headers: n, footers: r } = this.getSnapshot();
    if (n)
      for (const s in n) {
        const i = n[s];
        this.headerModelMap.set(s, new _Pt(i)), this.headerModelMap.get(s).updateDocumentId(this.getUnitId());
      }
    if (r)
      for (const s in r) {
        const i = r[s];
        this.footerModelMap.set(s, new _Pt(i)), this.footerModelMap.get(s).updateDocumentId(this.getUnitId());
      }
  }
  updateDocumentId(n) {
    super.updateDocumentId(n), this._unitId = n;
  }
  getPlainText() {
    var n, r;
    return qo((r = (n = this.getBody()) == null ? void 0 : n.dataStream) != null ? r : "");
  }
};
function D0(e) {
  const { ranges: t, id: n, type: r } = e, s = new Ne();
  let i = 0;
  for (let o = 0; o < t.length; o++) {
    const a = t[o], { startOffset: l, endOffset: u } = a;
    l > 0 && s.push({
      t: Z.RETAIN,
      len: l - i
    }), s.push({
      t: Z.RETAIN,
      body: {
        dataStream: "",
        customDecorations: [{
          id: n,
          type: r,
          startIndex: 0,
          endIndex: u - l - 1
        }]
      },
      len: u - l
    }), i = u;
  }
  return s;
}
function U0(e) {
  var c, h, d;
  const { id: t, segmentId: n, documentDataModel: r } = e, s = r == null ? void 0 : r.getBody();
  if (!r || !s)
    return false;
  const i = (d = (h = (c = r.getSelfOrHeaderFooterModel(n)) == null ? void 0 : c.getBody()) == null ? void 0 : h.customDecorations) == null ? void 0 : d.find((f) => f.id === t);
  if (!i)
    return false;
  const o = new Ne(), { startIndex: a, endIndex: l } = i, u = l - a + 1;
  return o.push({
    t: Z.RETAIN,
    len: a
  }), o.push({
    t: Z.RETAIN,
    len: u,
    body: {
      dataStream: "",
      customDecorations: [
        {
          startIndex: 0,
          endIndex: u - 1,
          id: t,
          type: Dn.DELETED
        }
      ]
    }
  }), o;
}
function ec(e, t, n, r) {
  return e <= n && t >= n || e >= n && e <= r;
}
function k0(e, t) {
  const n = [];
  for (let r = 0, s = t.length; r < s; r++) {
    const i = t[r];
    e.collapsed ? i.startIndex < e.startOffset && e.startOffset <= i.endIndex && n.push(i) : ec(e.startOffset, e.endOffset - 1, i.startIndex, i.endIndex) && n.push(i);
  }
  return n;
}
function P0(e) {
  return {
    ...J.deepClone(e),
    rangeId: et()
  };
}
function F0(e, t) {
  const n = [];
  let r = e[0];
  for (const s of t)
    s < e[0] || s > e[1] || (r < s && n.push([r, s - 1]), r = s + 1);
  return r <= e[1] && n.push([r, e[1]]), n;
}
function tc(e, t, n, r) {
  const s = [];
  for (let i = 0, o = n.length; i < o; i++) {
    const a = n[i];
    if ((r === void 0 || a.rangeType === r) && Math.max(a.startIndex, e) <= Math.min(a.endIndex, t) && s.push({ ...a }), a.startIndex > t)
      break;
  }
  return s;
}
function $0(e, t) {
  var i, o, a, l, u;
  const n = tc(e.startOffset, e.collapsed ? e.startOffset : e.endOffset - 1, (i = t.customRanges) != null ? i : []), r = Math.min(e.startOffset, (a = (o = n[0]) == null ? void 0 : o.startIndex) != null ? a : 1 / 0), s = Math.max(e.endOffset, ((u = (l = n[n.length - 1]) == null ? void 0 : l.endIndex) != null ? u : -1 / 0) + 1);
  return {
    startOffset: r,
    endOffset: s,
    collapsed: r === s
  };
}
var hi;
var _l;
function H0() {
  if (_l) return hi;
  _l = 1;
  var e = -1, t = 1, n = 0;
  function r(m, D2, S, T, A) {
    if (m === D2)
      return m ? [[n, m]] : [];
    if (S != null) {
      var O = F2(m, D2, S);
      if (O)
        return O;
    }
    var N = a(m, D2), M = m.substring(0, N);
    m = m.substring(N), D2 = D2.substring(N), N = u(m, D2);
    var L = m.substring(m.length - N);
    m = m.substring(0, m.length - N), D2 = D2.substring(0, D2.length - N);
    var k = s(m, D2);
    return M && k.unshift([n, M]), L && k.push([n, L]), H(k, A), T && h(k), k;
  }
  function s(m, D2) {
    var S;
    if (!m)
      return [[t, D2]];
    if (!D2)
      return [[e, m]];
    var T = m.length > D2.length ? m : D2, A = m.length > D2.length ? D2 : m, O = T.indexOf(A);
    if (O !== -1)
      return S = [
        [t, T.substring(0, O)],
        [n, A],
        [t, T.substring(O + A.length)]
      ], m.length > D2.length && (S[0][0] = S[2][0] = e), S;
    if (A.length === 1)
      return [
        [e, m],
        [t, D2]
      ];
    var N = c(m, D2);
    if (N) {
      var M = N[0], L = N[1], k = N[2], q = N[3], V = N[4], oe = r(M, k), le = r(L, q);
      return oe.concat([[n, V]], le);
    }
    return i(m, D2);
  }
  function i(m, D2) {
    for (var S = m.length, T = D2.length, A = Math.ceil((S + T) / 2), O = A, N = 2 * A, M = new Array(N), L = new Array(N), k = 0; k < N; k++)
      M[k] = -1, L[k] = -1;
    M[O + 1] = 0, L[O + 1] = 0;
    for (var q = S - T, V = q % 2 !== 0, oe = 0, le = 0, I = 0, x = 0, Y = 0; Y < A; Y++) {
      for (var z = -Y + oe; z <= Y - le; z += 2) {
        var B = O + z, j;
        z === -Y || z !== Y && M[B - 1] < M[B + 1] ? j = M[B + 1] : j = M[B - 1] + 1;
        for (var Q = j - z; j < S && Q < T && m.charAt(j) === D2.charAt(Q); )
          j++, Q++;
        if (M[B] = j, j > S)
          le += 2;
        else if (Q > T)
          oe += 2;
        else if (V) {
          var ee = O + q - z;
          if (ee >= 0 && ee < N && L[ee] !== -1) {
            var U = S - L[ee];
            if (j >= U)
              return o(m, D2, j, Q);
          }
        }
      }
      for (var G = -Y + I; G <= Y - x; G += 2) {
        var ee = O + G, U;
        G === -Y || G !== Y && L[ee - 1] < L[ee + 1] ? U = L[ee + 1] : U = L[ee - 1] + 1;
        for (var X = U - G; U < S && X < T && m.charAt(S - U - 1) === D2.charAt(T - X - 1); )
          U++, X++;
        if (L[ee] = U, U > S)
          x += 2;
        else if (X > T)
          I += 2;
        else if (!V) {
          var B = O + q - G;
          if (B >= 0 && B < N && M[B] !== -1) {
            var j = M[B], Q = O + j - B;
            if (U = S - U, j >= U)
              return o(m, D2, j, Q);
          }
        }
      }
    }
    return [
      [e, m],
      [t, D2]
    ];
  }
  function o(m, D2, S, T) {
    var A = m.substring(0, S), O = D2.substring(0, T), N = m.substring(S), M = D2.substring(T), L = r(A, O), k = r(N, M);
    return L.concat(k);
  }
  function a(m, D2) {
    if (!m || !D2 || m.charAt(0) !== D2.charAt(0))
      return 0;
    for (var S = 0, T = Math.min(m.length, D2.length), A = T, O = 0; S < A; )
      m.substring(O, A) == D2.substring(O, A) ? (S = A, O = S) : T = A, A = Math.floor((T - S) / 2 + S);
    return P(m.charCodeAt(A - 1)) && A--, A;
  }
  function l(m, D2) {
    var S = m.length, T = D2.length;
    if (S == 0 || T == 0)
      return 0;
    S > T ? m = m.substring(S - T) : S < T && (D2 = D2.substring(0, S));
    var A = Math.min(S, T);
    if (m == D2)
      return A;
    for (var O = 0, N = 1; ; ) {
      var M = m.substring(A - N), L = D2.indexOf(M);
      if (L == -1)
        return O;
      N += L, (L == 0 || m.substring(A - N) == D2.substring(0, N)) && (O = N, N++);
    }
  }
  function u(m, D2) {
    if (!m || !D2 || m.slice(-1) !== D2.slice(-1))
      return 0;
    for (var S = 0, T = Math.min(m.length, D2.length), A = T, O = 0; S < A; )
      m.substring(m.length - A, m.length - O) == D2.substring(D2.length - A, D2.length - O) ? (S = A, O = S) : T = A, A = Math.floor((T - S) / 2 + S);
    return W(m.charCodeAt(m.length - A)) && A--, A;
  }
  function c(m, D2) {
    var S = m.length > D2.length ? m : D2, T = m.length > D2.length ? D2 : m;
    if (S.length < 4 || T.length * 2 < S.length)
      return null;
    function A(le, I, x) {
      for (var Y = le.substring(x, x + Math.floor(le.length / 4)), z = -1, B = "", j, Q, ee, U; (z = I.indexOf(Y, z + 1)) !== -1; ) {
        var G = a(
          le.substring(x),
          I.substring(z)
        ), X = u(
          le.substring(0, x),
          I.substring(0, z)
        );
        B.length < X + G && (B = I.substring(z - X, z) + I.substring(z, z + G), j = le.substring(0, x - X), Q = le.substring(x + G), ee = I.substring(0, z - X), U = I.substring(z + G));
      }
      return B.length * 2 >= le.length ? [
        j,
        Q,
        ee,
        U,
        B
      ] : null;
    }
    var O = A(
      S,
      T,
      Math.ceil(S.length / 4)
    ), N = A(
      S,
      T,
      Math.ceil(S.length / 2)
    ), M;
    if (!O && !N)
      return null;
    N ? O ? M = O[4].length > N[4].length ? O : N : M = N : M = O;
    var L, k, q, V;
    m.length > D2.length ? (L = M[0], k = M[1], q = M[2], V = M[3]) : (q = M[0], V = M[1], L = M[2], k = M[3]);
    var oe = M[4];
    return [L, k, q, V, oe];
  }
  function h(m) {
    for (var D2 = false, S = [], T = 0, A = null, O = 0, N = 0, M = 0, L = 0, k = 0; O < m.length; )
      m[O][0] == n ? (S[T++] = O, N = L, M = k, L = 0, k = 0, A = m[O][1]) : (m[O][0] == t ? L += m[O][1].length : k += m[O][1].length, A && A.length <= Math.max(N, M) && A.length <= Math.max(L, k) && (m.splice(S[T - 1], 0, [
        e,
        A
      ]), m[S[T - 1] + 1][0] = t, T--, T--, O = T > 0 ? S[T - 1] : -1, N = 0, M = 0, L = 0, k = 0, A = null, D2 = true)), O++;
    for (D2 && H(m), b(m), O = 1; O < m.length; ) {
      if (m[O - 1][0] == e && m[O][0] == t) {
        var q = m[O - 1][1], V = m[O][1], oe = l(q, V), le = l(V, q);
        oe >= le ? (oe >= q.length / 2 || oe >= V.length / 2) && (m.splice(O, 0, [
          n,
          V.substring(0, oe)
        ]), m[O - 1][1] = q.substring(
          0,
          q.length - oe
        ), m[O + 1][1] = V.substring(oe), O++) : (le >= q.length / 2 || le >= V.length / 2) && (m.splice(O, 0, [
          n,
          q.substring(0, le)
        ]), m[O - 1][0] = t, m[O - 1][1] = V.substring(
          0,
          V.length - le
        ), m[O + 1][0] = e, m[O + 1][1] = q.substring(le), O++), O++;
      }
      O++;
    }
  }
  var d = /[^a-zA-Z0-9]/, f = /\s/, g = /[\r\n]/, _ = /\n\r?\n$/, R = /^\r?\n\r?\n/;
  function b(m) {
    function D2(le, I) {
      if (!le || !I)
        return 6;
      var x = le.charAt(le.length - 1), Y = I.charAt(0), z = x.match(d), B = Y.match(d), j = z && x.match(f), Q = B && Y.match(f), ee = j && x.match(g), U = Q && Y.match(g), G = ee && le.match(_), X = U && I.match(R);
      return G || X ? 5 : ee || U ? 4 : z && !j && Q ? 3 : j || Q ? 2 : z || B ? 1 : 0;
    }
    for (var S = 1; S < m.length - 1; ) {
      if (m[S - 1][0] == n && m[S + 1][0] == n) {
        var T = m[S - 1][1], A = m[S][1], O = m[S + 1][1], N = u(T, A);
        if (N) {
          var M = A.substring(A.length - N);
          T = T.substring(0, T.length - N), A = M + A.substring(0, A.length - N), O = M + O;
        }
        for (var L = T, k = A, q = O, V = D2(T, A) + D2(A, O); A.charAt(0) === O.charAt(0); ) {
          T += A.charAt(0), A = A.substring(1) + O.charAt(0), O = O.substring(1);
          var oe = D2(T, A) + D2(A, O);
          oe >= V && (V = oe, L = T, k = A, q = O);
        }
        m[S - 1][1] != L && (L ? m[S - 1][1] = L : (m.splice(S - 1, 1), S--), m[S][1] = k, q ? m[S + 1][1] = q : (m.splice(S + 1, 1), S--));
      }
      S++;
    }
  }
  function H(m, D2) {
    m.push([n, ""]);
    for (var S = 0, T = 0, A = 0, O = "", N = "", M; S < m.length; ) {
      if (S < m.length - 1 && !m[S][1]) {
        m.splice(S, 1);
        continue;
      }
      switch (m[S][0]) {
        case t:
          A++, N += m[S][1], S++;
          break;
        case e:
          T++, O += m[S][1], S++;
          break;
        case n:
          var L = S - A - T - 1;
          if (D2) {
            if (L >= 0 && C(m[L][1])) {
              var k = m[L][1].slice(-1);
              if (m[L][1] = m[L][1].slice(
                0,
                -1
              ), O = k + O, N = k + N, !m[L][1]) {
                m.splice(L, 1), S--;
                var q = L - 1;
                m[q] && m[q][0] === t && (A++, N = m[q][1] + N, q--), m[q] && m[q][0] === e && (T++, O = m[q][1] + O, q--), L = q;
              }
            }
            if (w(m[S][1])) {
              var k = m[S][1].charAt(0);
              m[S][1] = m[S][1].slice(1), O += k, N += k;
            }
          }
          if (S < m.length - 1 && !m[S][1]) {
            m.splice(S, 1);
            break;
          }
          if (O.length > 0 || N.length > 0) {
            O.length > 0 && N.length > 0 && (M = a(N, O), M !== 0 && (L >= 0 ? m[L][1] += N.substring(
              0,
              M
            ) : (m.splice(0, 0, [
              n,
              N.substring(0, M)
            ]), S++), N = N.substring(M), O = O.substring(M)), M = u(N, O), M !== 0 && (m[S][1] = N.substring(N.length - M) + m[S][1], N = N.substring(
              0,
              N.length - M
            ), O = O.substring(
              0,
              O.length - M
            )));
            var V = A + T;
            O.length === 0 && N.length === 0 ? (m.splice(S - V, V), S = S - V) : O.length === 0 ? (m.splice(S - V, V, [t, N]), S = S - V + 1) : N.length === 0 ? (m.splice(S - V, V, [e, O]), S = S - V + 1) : (m.splice(
              S - V,
              V,
              [e, O],
              [t, N]
            ), S = S - V + 2);
          }
          S !== 0 && m[S - 1][0] === n ? (m[S - 1][1] += m[S][1], m.splice(S, 1)) : S++, A = 0, T = 0, O = "", N = "";
          break;
      }
    }
    m[m.length - 1][1] === "" && m.pop();
    var oe = false;
    for (S = 1; S < m.length - 1; )
      m[S - 1][0] === n && m[S + 1][0] === n && (m[S][1].substring(
        m[S][1].length - m[S - 1][1].length
      ) === m[S - 1][1] ? (m[S][1] = m[S - 1][1] + m[S][1].substring(
        0,
        m[S][1].length - m[S - 1][1].length
      ), m[S + 1][1] = m[S - 1][1] + m[S + 1][1], m.splice(S - 1, 1), oe = true) : m[S][1].substring(0, m[S + 1][1].length) == m[S + 1][1] && (m[S - 1][1] += m[S + 1][1], m[S][1] = m[S][1].substring(m[S + 1][1].length) + m[S + 1][1], m.splice(S + 1, 1), oe = true)), S++;
    oe && H(m, D2);
  }
  function P(m) {
    return m >= 55296 && m <= 56319;
  }
  function W(m) {
    return m >= 56320 && m <= 57343;
  }
  function w(m) {
    return W(m.charCodeAt(0));
  }
  function C(m) {
    return P(m.charCodeAt(m.length - 1));
  }
  function v(m) {
    for (var D2 = [], S = 0; S < m.length; S++)
      m[S][1].length > 0 && D2.push(m[S]);
    return D2;
  }
  function y(m, D2, S, T) {
    return C(m) || w(T) ? null : v([
      [n, m],
      [e, D2],
      [t, S],
      [n, T]
    ]);
  }
  function F2(m, D2, S) {
    var T = typeof S == "number" ? { index: S, length: 0 } : S.oldRange, A = typeof S == "number" ? null : S.newRange, O = m.length, N = D2.length;
    if (T.length === 0 && (A === null || A.length === 0)) {
      var M = T.index, L = m.slice(0, M), k = m.slice(M), q = A ? A.index : null;
      e: {
        var V = M + N - O;
        if (q !== null && q !== V || V < 0 || V > N)
          break e;
        var oe = D2.slice(0, V), le = D2.slice(V);
        if (le !== k)
          break e;
        var I = Math.min(M, V), x = L.slice(0, I), Y = oe.slice(0, I);
        if (x !== Y)
          break e;
        var z = L.slice(I), B = oe.slice(I);
        return y(x, z, B, k);
      }
      e: {
        if (q !== null && q !== M)
          break e;
        var j = M, oe = D2.slice(0, j), le = D2.slice(j);
        if (oe !== L)
          break e;
        var Q = Math.min(O - j, N - j), ee = k.slice(k.length - Q), U = le.slice(le.length - Q);
        if (ee !== U)
          break e;
        var z = k.slice(0, k.length - Q), B = le.slice(0, le.length - Q);
        return y(L, z, B, ee);
      }
    }
    if (T.length > 0 && A && A.length === 0)
      e: {
        var x = m.slice(0, T.index), ee = m.slice(T.index + T.length), I = x.length, Q = ee.length;
        if (N < I + Q)
          break e;
        var Y = D2.slice(0, I), U = D2.slice(N - Q);
        if (x !== Y || ee !== U)
          break e;
        var z = m.slice(I, O - Q), B = D2.slice(I, N - Q);
        return y(x, z, B, ee);
      }
    return null;
  }
  function $(m, D2, S, T) {
    return r(m, D2, S, T, true);
  }
  return $.INSERT = t, $.DELETE = e, $.EQUAL = n, hi = $, hi;
}
var B0 = H0();
var nc = Rt(B0);
function j0(e) {
  var h, d, f;
  const { rangeId: t, segmentId: n, documentDataModel: r, insert: s } = e, i = (d = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.customRanges) == null ? void 0 : d.find((g) => g.rangeId === t);
  if (!i)
    return false;
  const { startIndex: o, endIndex: a } = i, l = new Ne(), u = a - o + 1;
  l.push({
    t: Z.RETAIN,
    len: o
  }), l.push({
    t: Z.RETAIN,
    len: u,
    body: {
      dataStream: "",
      customRanges: []
    }
  }), s && l.push({
    t: Z.INSERT,
    body: s,
    len: s.dataStream.length
  });
  const c = a + 1 + ((f = s == null ? void 0 : s.dataStream.length) != null ? f : 0);
  return l.selections = [{
    startOffset: c,
    endOffset: c,
    collapsed: true
  }], l;
}
function W0(e) {
  const { ranges: t, rangeId: n, rangeType: r, wholeEntity: s, properties: i, body: o } = e;
  let a = 0;
  const l = new Ne();
  let u = false;
  return t.forEach((c) => {
    var P, W, w;
    const h = $0(c, o);
    if (!h || !o)
      return false;
    const { startOffset: d, endOffset: f } = h, g = (P = o.customRanges) != null ? P : [], _ = (C, v, y) => {
      var S, T, A, O;
      const F2 = tc(C, v, g, r), $ = Math.min((T = (S = F2[0]) == null ? void 0 : S.startIndex) != null ? T : 1 / 0, C), m = Math.max((O = (A = F2[F2.length - 1]) == null ? void 0 : A.endIndex) != null ? O : -1 / 0, v), D2 = {
        rangeId: y ? `${n}$${y}` : n,
        rangeType: r,
        startIndex: 0,
        endIndex: m - $,
        wholeEntity: s,
        properties: {
          ...i
        }
      };
      l.push({
        t: Z.RETAIN,
        len: $ - a
      }), l.push({
        t: Z.RETAIN,
        len: m - $ + 1,
        body: {
          dataStream: "",
          customRanges: [D2]
        },
        coverType: pe.COVER
      }), a = m + 1;
    }, R = ((W = o.paragraphs) != null ? W : []).filter((C) => C.startIndex < f && C.startIndex > d), b = ((w = o.customBlocks) != null ? w : []).filter((C) => C.startIndex < f && C.startIndex > d);
    F0([d, f - 1], [...R.map((C) => C.startIndex), ...b.map((C) => C.startIndex)]).forEach(([C, v], y) => _(C, v, y)), u = true, l.selections = [{
      startOffset: h.endOffset,
      endOffset: h.endOffset,
      collapsed: true
    }];
  }), u ? l : false;
}
function rc(e, t, n = 0, r = null, s = true) {
  e.sort((u, c) => u.startOffset - c.startOffset);
  const i = [], { paragraphs: o = [] } = t, a = o == null ? void 0 : o.find(
    (u) => u.startIndex >= e[0].startOffset && u.startIndex < e[0].endOffset
  );
  let l = n;
  if (e.forEach((u) => {
    const { startOffset: c, endOffset: h } = u;
    c > l && (i.push({
      t: Z.RETAIN,
      len: c - l
    }), l = c), l < h && (i.push({
      t: Z.DELETE,
      len: h - l
    }), l = h);
  }), r && i.push({
    t: Z.INSERT,
    body: r,
    len: r.dataStream.length
  }), a && s) {
    const u = o.find((c) => c.startIndex - n >= e[e.length - 1].endOffset - 1);
    u && (u.startIndex > l && (i.push({
      t: Z.RETAIN,
      len: u.startIndex - l
    }), l = u.startIndex), i.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...u,
            startIndex: 0,
            bullet: a == null ? void 0 : a.bullet
          }
        ]
      },
      coverType: pe.REPLACE
    }));
  }
  return i;
}
function Y0(e, t, n = 0) {
  const r = [];
  let s = n;
  return e.forEach((i) => {
    const { startOffset: o, endOffset: a } = i;
    o > s && (r.push({
      t: Z.RETAIN,
      len: o - s
    }), s = o), a > s && (r.push({
      t: Z.RETAIN,
      len: a - s,
      body: {
        ...J.deepClone(t),
        dataStream: ""
      }
    }), s = a);
  }), r;
}
var z0 = (e) => {
  var h;
  const { selection: t, body: n, doc: r } = e, s = t.segmentId, i = (h = r.getSelfOrHeaderFooterModel(s)) == null ? void 0 : h.getBody();
  if (!i) return false;
  const o = t.collapsed ? null : kt(i, t.startOffset, t.endOffset), a = nc(o ? o.dataStream : "", n.dataStream);
  let l = 0;
  const u = a.map(([d, f]) => {
    switch (d) {
      case 0: {
        const g = {
          t: Z.RETAIN,
          body: {
            ...kt(n, l, l + f.length, false),
            dataStream: ""
          },
          len: f.length
        };
        return l += f.length, g;
      }
      case 1: {
        const g = {
          t: Z.INSERT,
          body: kt(n, l, l + f.length),
          len: f.length
        };
        return l += f.length, g;
      }
      default:
        return {
          t: Z.DELETE,
          len: f.length
        };
    }
  }), c = new Ne();
  return c.push({
    t: Z.RETAIN,
    len: t.startOffset
  }), c.push(...u), c;
};
function V0(e, t) {
  return !!((e == null ? void 0 : e.length) === (t == null ? void 0 : t.length) && (e != null && e.every((n, r) => JSON.stringify(n) === JSON.stringify(t == null ? void 0 : t[r]))));
}
var G0 = (e) => {
  var d;
  const { selection: t, body: n, doc: r, themeService: s } = e, i = t.segmentId, o = (d = r.getSelfOrHeaderFooterModel(i)) == null ? void 0 : d.getBody();
  if (!o) return false;
  const a = t.collapsed ? null : kt(o, t.startOffset, t.endOffset), l = nc(a ? a.dataStream : "", n.dataStream);
  let u = 0;
  const c = l.map(([f, g]) => {
    switch (f) {
      case 0: {
        const _ = Pi(n, u, u + g.length, false), R = Pi(a, u, u + g.length, false), b = {
          t: Z.RETAIN,
          body: V0(_, R) ? void 0 : {
            textRuns: _ == null ? void 0 : _.map((H) => {
              var P, W, w, C, v, y, F2;
              return {
                ...H,
                ts: {
                  ...H.ts,
                  cl: (w = (W = (P = H.ts) == null ? void 0 : P.cl) == null ? void 0 : W.rgb) != null && w.includes(".") ? { rgb: s.getColorFromTheme((y = (v = (C = H.ts) == null ? void 0 : C.cl) == null ? void 0 : v.rgb) != null ? y : "") } : (F2 = H.ts) == null ? void 0 : F2.cl
                }
              };
            }),
            dataStream: ""
          },
          len: g.length
        };
        return u += g.length, b;
      }
      case 1: {
        const _ = {
          t: Z.INSERT,
          body: kt(n, u, u + g.length),
          len: g.length
        };
        return u += g.length, _;
      }
      default:
        return {
          t: Z.DELETE,
          len: g.length
        };
    }
  });
  if (c.every((f) => f.t === Z.RETAIN && !f.body))
    return false;
  const h = new Ne();
  return h.push({
    t: Z.RETAIN,
    len: t.startOffset
  }), h.push(...c), h;
};
function K0(e, t) {
  const n = [], { customBlocks: r = [] } = e;
  for (const s of t) {
    const { startOffset: i, endOffset: o } = s;
    if (!(i == null || o == null))
      for (const a of r) {
        const { startIndex: l } = a;
        l >= i && l < o && n.push(a.blockId);
      }
  }
  return n;
}
function X0(e, t = "") {
  if (!t)
    return ["body"];
  const { headers: n, footers: r } = e.getSnapshot();
  if (n == null && r == null)
    throw new Error("Document data model must have headers or footers when update by segment id");
  if ((n == null ? void 0 : n[t]) != null)
    return ["headers", t, "body"];
  if ((r == null ? void 0 : r[t]) != null)
    return ["footers", t, "body"];
  throw new Error("Segment id not found in headers or footers");
}
var q0 = (e) => {
  var _, R, b, H;
  const { selection: t, documentDataModel: n, drawings: r } = e, { collapsed: s, startOffset: i, segmentId: o } = t, a = new Ne(), l = Qt.getInstance(), u = [], c = n.getSelfOrHeaderFooterModel(o).getBody();
  if (!c)
    return false;
  const h = (R = (_ = n.getSnapshot().drawingsOrder) == null ? void 0 : _.length) != null ? R : 0;
  let d = 0;
  if (s)
    i > 0 && a.push({
      t: Z.RETAIN,
      len: i
    });
  else {
    const P = rc([t], c, 0, null, false);
    a.push(...P);
    const W = K0(c, [t]), w = (b = n.getDrawings()) != null ? b : {}, C = (H = n.getDrawingsOrder()) != null ? H : [], v = W.sort((y, F2) => C.indexOf(y) > C.indexOf(F2) ? -1 : C.indexOf(y) < C.indexOf(F2) ? 1 : 0);
    if (v.length > 0)
      for (const y of v) {
        const F2 = w[y], $ = C.indexOf(y);
        if (F2 == null || $ < 0)
          continue;
        const m = l.removeOp(["drawings", y], F2), D2 = l.removeOp(["drawingsOrder", $], y);
        u.push(m), u.push(D2), d++;
      }
  }
  a.push({
    t: Z.INSERT,
    body: {
      dataStream: "\b".repeat(r.length),
      customBlocks: r.map((P, W) => ({
        startIndex: W,
        blockId: P.drawingId
      }))
    },
    len: r.length
  });
  const f = X0(n, o), g = l.editOp(a.serialize(), f);
  u.push(g);
  for (const P of r) {
    const { drawingId: W } = P, w = l.insertOp(["drawings", W], P), C = l.insertOp(["drawingsOrder", h - d], W);
    u.push(w), u.push(C);
  }
  return u.reduce((P, W) => Qt.compose(P, W), null);
};
function Z0(e, t) {
  if (typeof t > "u")
    return { startOffset: e, endOffset: e, collapsed: true };
  if (t < e)
    throw new Error(`Cannot make a doc selection when endOffset ${t} is less than startOffset ${e}.`);
  return { startOffset: e, endOffset: t, collapsed: e === t };
}
function J0(e) {
  const { startOffset: t, endOffset: n, collapsed: r } = e, s = Math.min(t, n), i = Math.max(t, n);
  return {
    startOffset: s,
    endOffset: i,
    collapsed: r
  };
}
function Q0(e, t, n, r) {
  return Math.max(e, n) <= Math.min(t, r);
}
function Fi(e, t, n, r) {
  const { startOffset: s, endOffset: i } = e, o = r != null ? r : Zo(t, n), a = [];
  let l = -1;
  for (let u = 0; u < o.length; u++) {
    const c = o[u], { startIndex: h } = c;
    (s > l && s <= h || i > l && i <= h || h >= s && h <= i) && a.push(c), l = h;
  }
  return a;
}
function $i(e, t, n) {
  const r = [], s = Zo(t, n);
  for (const i of e) {
    const o = Fi(i, t, n, s);
    r.push(...o);
  }
  return r;
}
var eE = [
  ct.PARAGRAPH,
  ct.TABLE_START,
  ct.TABLE_END,
  ct.TABLE_ROW_START,
  ct.TABLE_CELL_START,
  ct.TABLE_CELL_END
];
function Zo(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r], { startIndex: i } = s;
    let o = i - 1;
    for (; !eE.includes(t[o]) && o >= 0; )
      o--;
    n.push({
      ...s,
      paragraphStart: o + 1,
      paragraphEnd: s.startIndex
    });
  }
  return n;
}
var tE = (e) => {
  var h, d, f;
  const { paragraphs: t, segmentId: n, document: r } = e;
  let s = e.listType;
  const i = (d = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.paragraphs) != null ? d : [], o = t.every((g) => {
    var _;
    return ((_ = g.bullet) == null ? void 0 : _.listType.indexOf(s)) === 0;
  });
  let l = et(6);
  if (t.length === 1) {
    const g = i.indexOf(t[0]), _ = i[g - 1], R = i[g + 1];
    _ && _.bullet && _.bullet.listType.indexOf(s) === 0 ? (l = _.bullet.listId, s !== zt.CHECK_LIST && (s = _.bullet.listType)) : R && R.bullet && R.bullet.listType.indexOf(s) === 0 && (l = R.bullet.listId, s !== zt.CHECK_LIST && (s = R.bullet.listType));
  }
  const u = new Gn();
  u.reset();
  const c = new Ne();
  for (const g of t) {
    const { startIndex: _, paragraphStyle: R = {}, bullet: b } = g;
    c.push({
      t: Z.RETAIN,
      len: _ - u.cursor
    }), c.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          o ? {
            paragraphStyle: R,
            startIndex: 0
          } : {
            startIndex: 0,
            paragraphStyle: {
              ...R
            },
            bullet: {
              nestingLevel: (f = b == null ? void 0 : b.nestingLevel) != null ? f : 0,
              textStyle: {
                fs: 20
              },
              listType: s,
              listId: l
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), u.moveCursorTo(_ + 1);
  }
  return c;
};
var nE = (e) => {
  var h;
  const { paragraphIndex: t, segmentId: n, document: r } = e, s = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.paragraphs;
  if (s == null)
    return false;
  const i = s.find((d) => d.startIndex === t);
  if (!(i != null && i.bullet) || i.bullet.listType.indexOf(zt.CHECK_LIST) === -1)
    return false;
  const o = new Gn();
  o.reset();
  const a = new Ne(), { startIndex: l, paragraphStyle: u = {} } = i, c = i.bullet.listType === zt.CHECK_LIST ? zt.CHECK_LIST_CHECKED : zt.CHECK_LIST;
  return a.push({
    t: Z.RETAIN,
    len: l - o.cursor
  }), a.push({
    t: Z.RETAIN,
    len: 1,
    body: {
      dataStream: "",
      paragraphs: [
        {
          ...i,
          paragraphStyle: u,
          startIndex: 0,
          bullet: {
            ...i.bullet,
            listType: c
          }
        }
      ]
    },
    coverType: pe.REPLACE
  }), o.moveCursorTo(l + 1), a;
};
var rE = (e) => {
  var c, h;
  const { paragraphs: t, listType: n, segmentId: r, document: s } = e;
  if (((c = s.getSelfOrHeaderFooterModel(r).getBody()) == null ? void 0 : c.paragraphs) == null)
    return false;
  const a = et(6), l = new Gn();
  l.reset();
  const u = new Ne();
  for (const d of t) {
    const { startIndex: f, paragraphStyle: g = {}, bullet: _ } = d;
    u.push({
      t: Z.RETAIN,
      len: f - l.cursor
    }), u.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: g,
            bullet: {
              nestingLevel: (h = _ == null ? void 0 : _.nestingLevel) != null ? h : 0,
              textStyle: (_ == null ? void 0 : _.listType) === n ? _.textStyle : {
                fs: 20
              },
              listType: n,
              listId: a
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), l.moveCursorTo(f + 1);
  }
  return u;
};
function sE(e, t) {
  return t.some((n) => e.startIndex > n.startIndex && e.startIndex < n.endIndex);
}
var iE = (e) => {
  var u, c, h;
  const { paragraphs: t, document: n, type: r } = e, s = new Gn();
  s.reset();
  const i = new Ne(), o = (u = n.getSnapshot().lists) != null ? u : {}, a = (h = (c = n.getBody()) == null ? void 0 : c.tables) != null ? h : [], l = {
    ...$s,
    ...o
  };
  for (const d of t) {
    const { startIndex: f, paragraphStyle: g = {}, bullet: _ } = d, R = sE(d, a);
    if (i.push({
      t: Z.RETAIN,
      len: f - s.cursor
    }), _) {
      const b = _.listType;
      let H = l[b].nestingLevel.length - 1;
      R && (H = Math.min(H, 2)), i.push({
        t: Z.RETAIN,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              startIndex: 0,
              paragraphStyle: {
                ...g
              },
              bullet: {
                ..._,
                nestingLevel: Math.max(Math.min(_.nestingLevel + r, H), 0)
              }
            }
          ]
        },
        coverType: pe.REPLACE
      });
    } else
      i.push({
        t: Z.RETAIN,
        len: 1
      });
    s.moveCursorTo(f + 1);
  }
  return i;
};
var oE = (e) => {
  var R, b, H, P;
  const {
    textRanges: t,
    segmentId: n,
    document: r,
    style: s,
    paragraphTextRun: i,
    cursor: o,
    deleteLen: a,
    textX: l
  } = e, u = r.getSelfOrHeaderFooterModel(n), c = (b = (R = u.getBody()) == null ? void 0 : R.paragraphs) != null ? b : [], h = (P = (H = u.getBody()) == null ? void 0 : H.dataStream) != null ? P : "", d = $i(t, c, h), f = new Gn();
  o && f.moveCursorTo(o);
  const g = l != null ? l : new Ne();
  d.sort((W, w) => W.startIndex - w.startIndex);
  const _ = Math.max(0, d[0].paragraphStart - 1);
  _ > f.cursor && (g.push({
    t: Z.RETAIN,
    len: _ - f.cursor
  }), f.moveCursorTo(_)), a && g.push({
    t: Z.DELETE,
    len: a
  });
  for (const W of d) {
    const { startIndex: w, paragraphStyle: C = {} } = W, v = w - f.cursor;
    g.push({
      t: Z.RETAIN,
      len: v,
      ...i ? {
        body: {
          dataStream: "",
          textRuns: [{
            ts: i,
            st: 0,
            ed: v
          }]
        },
        coverType: pe.REPLACE
      } : null
    }), g.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: {
              ...C,
              ...s
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), f.moveCursorTo(w + 1);
  }
  return g;
};
var Je = class {
};
p(Je, "customRange", {
  add: W0,
  delete: j0,
  copyCustomRange: P0,
  getCustomRangesInterestsWithSelection: k0,
  isIntersecting: ec
}), p(Je, "customDecoration", {
  add: D0,
  delete: U0
}), p(Je, "selection", {
  replace: z0,
  makeSelection: Z0,
  normalizeSelection: J0,
  delete: rc,
  replaceTextRuns: G0,
  retain: Y0
}), p(Je, "range", {
  isIntersects: Q0,
  getParagraphsInRange: Fi,
  getParagraphsInRanges: $i
}), p(Je, "transform", {
  getPlainText: qo,
  fromPlainText: L0,
  isEmptyDocument: M0
}), p(Je, "paragraph", {
  bullet: {
    set: rE,
    switch: tE,
    toggleChecklist: nE,
    changeNestLevel: iE
  },
  style: {
    set: oE
  },
  util: {
    transform: Zo,
    getParagraphsInRange: Fi,
    getParagraphsInRanges: $i
  }
}), p(Je, "drawing", {
  add: q0
});
function AR(e, t, n, r) {
  var u;
  if (t === "")
    return e;
  const s = {
    id: "mock-id",
    body: e,
    documentStyle: {}
  }, i = new Pt(s), o = t.length;
  let a;
  for (; (a = (r ? i.getBody().dataStream : i.getBody().dataStream.toLowerCase()).indexOf(t)) >= 0; ) {
    const c = new Ne(), h = Qt.getInstance();
    if (a > 0 && c.retain(a), n.length > 0) {
      const d = i.sliceBody(a, a + o), f = {
        dataStream: n
      };
      if (Array.isArray(d == null ? void 0 : d.textRuns) && d.textRuns.length && (f.textRuns = [{
        ...d.textRuns[0],
        st: 0,
        ed: n.length
      }]), (u = d == null ? void 0 : d.customRanges) != null && u.length) {
        const g = d.customRanges[0];
        f.customRanges = [{
          ...g,
          startIndex: 0,
          endIndex: n.length - 1
        }];
      }
      c.insert(n.length, f);
    }
    c.delete(o), i.apply(h.editOp(c.serialize()));
  }
  const l = i.getBody();
  return i.dispose(), l;
}
function aE(e) {
  if (e.customRanges || (e.customRanges = []), !e.paragraphs) {
    e.paragraphs = [];
    for (let t = 0; t < e.dataStream.length; t++)
      e.dataStream[t] === "\r" && e.paragraphs.push({ startIndex: t });
  }
  return e.customBlocks || (e.customBlocks = []), e.textRuns || (e.textRuns = []), e.customDecorations || (e.customDecorations = []), e.sectionBreaks || (e.sectionBreaks = []), e.tables || (e.tables = []), e;
}
function sc(e) {
  var t;
  return e.body = aE((t = e.body) != null ? t : { dataStream: "" }), e.drawingsOrder || (e.drawingsOrder = []), e.drawings || (e.drawings = {}), e.documentStyle || (e.documentStyle = {}), e;
}
var Hs = class _Hs {
  /**
   * Creates a new TextStyleValue instance
   * @param {ITextStyle} style The initial style object
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  constructor(t = {}) {
    p(this, "_style");
    this._style = t;
  }
  /**
   * Creates an instance of TextStyleValue.
   * @param {ITextStyle} style style object
   * @returns {TextStyleValue} font style instance
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  static create(t = {}) {
    return new _Hs(t);
  }
  /**
   * Gets the font family
   * @returns {Nullable<string>} The font family name or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.fontFamily);
   * ```
   */
  get fontFamily() {
    return this._style.ff;
  }
  /**
   * Gets the font size in points
   * @returns {number | undefined} The font size or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.fontSize);
   * ```
   */
  get fontSize() {
    return this._style.fs;
  }
  /**
   * Gets whether the text is italic
   * @returns {boolean} True if italic, false otherwise
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.italic);
   * ```
   */
  get italic() {
    return this._style.it === ie.TRUE;
  }
  /**
   * Gets whether the text is bold
   * @returns {boolean} True if bold, false otherwise
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.bold);
   * ```
   */
  get bold() {
    return this._style.bl === ie.TRUE;
  }
  /**
   * Gets the underline decoration
   * @returns {TextDecorationBuilder | undefined} The underline decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.underline);
   * ```
   */
  get underline() {
    return this._style.ul && hn.create(this._style.ul);
  }
  /**
   * Gets the bottom border line decoration
   * @returns {TextDecorationBuilder | undefined} The bottom border line decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.bottomBorderLine);
   * ```
   */
  get bottomBorderLine() {
    return this._style.bbl && hn.create(this._style.bbl);
  }
  /**
   * Gets the strikethrough decoration
   * @returns {TextDecorationBuilder | undefined} The strikethrough decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.strikethrough);
   * ```
   */
  get strikethrough() {
    return this._style.st && hn.create(this._style.st);
  }
  /**
   * Gets the overline decoration
   * @returns {TextDecorationBuilder | undefined} The overline decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.overline);
   * ```
   */
  get overline() {
    return this._style.ol && hn.create(this._style.ol);
  }
  /**
   * Gets the background color
   * @returns {Nullable<IColorStyle>} The background color or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.background);
   * ```
   */
  get background() {
    return this._style.bg;
  }
  /**
   * Gets the border settings
   * @returns {Nullable<IBorderData>} The border settings or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.border);
   * ```
   */
  get border() {
    return this._style.bd;
  }
  /**
   * Gets the text color
   * @returns {Nullable<IColorStyle>} The text color or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.color);
   * ```
   */
  get color() {
    return this._style.cl;
  }
  /**
   * Gets the vertical alignment (subscript/superscript)
   * @returns {Nullable<BaselineOffset>} The vertical alignment or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.verticalAlign);
   * ```
   */
  get verticalAlign() {
    return this._style.va;
  }
  /**
   * Gets the number format pattern
   * @returns {Nullable<{ pattern: string }>} The number format pattern or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.numberFormat);
   * ```
   */
  get numberFormat() {
    return this._style.n;
  }
  /**
   * Creates a copy of this font style as a builder
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance with the same style
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * const copy = style.copy();
   * console.log(copy);
   * ```
   */
  copy() {
    return gn.create(J.deepClone(this._style));
  }
  /**
   * Gets the raw style object
   * @returns {ITextStyle} The underlying style object
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.getValue());
   * ```
   */
  getValue() {
    return { ...this._style };
  }
};
var gn = class _gn extends Hs {
  /**
   * Creates a new TextStyleBuilder instance
   * @param {ITextStyle} style Initial style object
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  static create(t = {}) {
    return new _gn(t);
  }
  /**
   * Creates a new TextStyleBuilder instance
   * @param {ITextStyle} style The initial style object
   * @example
   * ```ts
   * const style = new TextStyleBuilder({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  constructor(t = {}) {
    super(t);
  }
  /**
   * Sets the font family
   * @param {string} family The font family name
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setFontFamily('Times New Roman');
   * console.log(style.fontFamily);
   * ```
   */
  setFontFamily(t) {
    return this._style.ff = t, this;
  }
  /**
   * Sets the font size in points
   * @param {number} size The font size
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setFontSize(14);
   * console.log(style.fontSize);
   * ```
   */
  setFontSize(t) {
    return this._style.fs = t, this;
  }
  /**
   * Sets the italic style
   * @param {boolean} value True to make italic, false otherwise
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setItalic(true);
   * console.log(style.italic);
   * ```
   */
  setItalic(t) {
    return this._style.it = t ? 1 : 0, this;
  }
  /**
   * Sets the bold style
   * @param {boolean} value True to make bold, false otherwise
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setBold(true);
   * console.log(style.bold);
   * ```
   */
  setBold(t) {
    return this._style.bl = t ? 1 : 0, this;
  }
  /**
   * Sets the underline decoration
   * @param {TextDecorationBuilder} decoration The underline decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setUnderline({ type: 'single', color: '#FF0000' });
   * console.log(style.underline);
   * ```
   */
  setUnderline(t) {
    return this._style.ul = t.build(), this;
  }
  /**
   * Sets the bottom border line decoration
   * @param {TextDecorationBuilder} decoration The bottom border line decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setBottomBorderLine({ type: 'single', color: '#FF0000' });
   * console.log(style.bottomBorderLine);
   * ```
   */
  setBottomBorderLine(t) {
    return this._style.bbl = t.build(), this;
  }
  /**
   * Sets the strikethrough decoration
   * @param {TextDecorationBuilder} decoration The strikethrough decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setStrikethrough(t) {
    return this._style.st = t.build(), this;
  }
  /**
   * Sets the overline decoration
   * @param {TextDecorationBuilder} decoration The overline decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setOverline(t) {
    return this._style.ol = t.build(), this;
  }
  /**
   * Sets the background color
   * @param {IColorStyle | null} color The background color or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setBackground(t) {
    return this._style.bg = t, this;
  }
  /**
   * Sets the border settings
   * @param {IBorderData | null} border The border settings or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setBorder(t) {
    return this._style.bd = t, this;
  }
  /**
   * Sets the text color
   * @param {IColorStyle | null} color The text color or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setColor(t) {
    return this._style.cl = t, this;
  }
  /**
   * Sets the vertical alignment (subscript/superscript)
   * @param {BaselineOffset | null} offset The vertical alignment or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setVerticalAlign(t) {
    return this._style.va = t, this;
  }
  /**
   * Creates a copy of this font style builder
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance with the same style
   */
  copy() {
    return _gn.create(J.deepClone(this._style));
  }
  /**
   * Builds and returns the final style object
   * @returns {ITextStyle} The complete style object
   */
  build() {
    return this.getValue();
  }
};
var hn = class _hn {
  /**
   * Creates a new TextDecorationBuilder instance
   * @param {ITextDecoration} decoration The initial decoration object
   * @example
   * ```ts
   * const decoration = new TextDecorationBuilder({ s: 1, t: TextDecoration.SINGLE });
   * ```
   */
  constructor(t = { s: 1 }) {
    p(this, "_decoration");
    this._decoration = t;
  }
  /**
   * Creates an instance of TextDecorationBuilder.
   * @param {ITextDecoration} decoration Initial decoration object
   * @returns {TextDecorationBuilder} text decoration builder instance
   * @example
   * ```ts
   * const decoration = TextDecorationBuilder.create({ s: 1, t: TextDecoration.SINGLE });
   * console.log(decoration);
   * ```
   */
  static create(t = { s: 1 }) {
    return new _hn(t);
  }
  /**
   * Gets whether the decoration is shown
   * @returns {boolean} True if the decoration is shown
   */
  get show() {
    return this._decoration.s === ie.TRUE;
  }
  /**
   * Gets whether the decoration color follows the font color
   * @returns {boolean} True if the decoration color follows the font color
   */
  get followFontColor() {
    return this._decoration.c === ie.TRUE;
  }
  /**
   * Gets the decoration color
   * @returns {Nullable<IColorStyle>} The decoration color
   */
  get color() {
    return this._decoration.cl;
  }
  /**
   * Gets the decoration line type
   * @returns {Nullable<TextDecoration>} The decoration line type
   */
  get type() {
    return this._decoration.t;
  }
  /**
   * Sets whether the decoration is shown
   * @param {boolean} value True to show the decoration
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setShow(true);
   * ```
   */
  setShow(t) {
    return this._decoration.s = t ? 1 : 0, this;
  }
  /**
   * Sets whether the decoration color follows the font color
   * @param {boolean} value True to follow font color
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setFollowFontColor(false);
   * ```
   */
  setFollowFontColor(t) {
    return this._decoration.c = t ? 1 : 0, this;
  }
  /**
   * Sets the decoration color
   * @param {IColorStyle} color The color style
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setColor({ rgb: '#FF0000' });
   * ```
   */
  setColor(t) {
    return this._decoration.cl = t, this;
  }
  /**
   * Sets the decoration line type
   * @param {TextDecoration} type The line type
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setLineType(TextDecoration.SINGLE);
   * ```
   */
  setLineType(t) {
    return this._decoration.t = t, this;
  }
  /**
   * Creates a copy of this text decoration builder
   * @returns {TextDecorationBuilder} A new TextDecorationBuilder instance with the same decoration
   * @example
   * ```ts
   * const copy = decoration.copy();
   * ```
   */
  copy() {
    return _hn.create(J.deepClone(this._decoration));
  }
  /**
   * Builds and returns the final decoration object
   * @returns {ITextDecoration} The complete text decoration object
   * @example
   * ```ts
   * const style = decoration.build();
   * ```
   */
  build() {
    return { ...this._decoration };
  }
};
var Bs = class _Bs {
  constructor(t = {}) {
    p(this, "_style");
    this._style = t;
  }
  /**
   * Creates a new ParagraphStyleValue instance
   * @param {IParagraphStyle} style The initial style object
   * @returns A new ParagraphStyleValue instance
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * ```
   */
  static create(t = {}) {
    return new _Bs(t);
  }
  /**
   * Gets the first line indent
   * @returns {Nullable<INumberUnit>} The first line indent
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentFirstLine);
   * ```
   */
  get indentFirstLine() {
    return this._style.indentFirstLine;
  }
  /**
   * Gets the hanging indent
   * @returns {Nullable<INumberUnit>} The hanging indent
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.hanging);
   * ```
   */
  get hanging() {
    return this._style.hanging;
  }
  /**
   * Gets the indent start
   * @returns {Nullable<INumberUnit>} The indent start
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentStart);
   * ```
   */
  get indentStart() {
    return this._style.indentStart;
  }
  /**
   * Gets the indent end
   * @returns {Nullable<INumberUnit>} The indent end
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentEnd);
   * ```
   */
  get tabStops() {
    return this._style.tabStops;
  }
  /**
   * Gets the indent end
   * @returns {Nullable<INumberUnit>} The indent end
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentEnd);
   * ```
   */
  get indentEnd() {
    return this._style.indentEnd;
  }
  /**
   * Gets the text style
   * @returns {Nullable<ITextStyle>} The text style
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.textStyle);
   * ```
   */
  get textStyle() {
    return this._style.textStyle;
  }
  /**
   * Gets the heading id
   * @returns {Nullable<string>} The heading id
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.headingId);
   * ```
   */
  get headingId() {
    return this._style.headingId;
  }
  /**
   * Gets the named style type
   * @returns {Nullable<NamedStyleType>} The named style type
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.namedStyleType);
   * ```
   */
  get namedStyleType() {
    return this._style.namedStyleType;
  }
  /**
   * Gets the horizontal align
   * @returns {Nullable<HorizontalAlign>} The horizontal align
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.horizontalAlign);
   * ```
   */
  get horizontalAlign() {
    return this._style.horizontalAlign;
  }
  /**
   * Gets the line spacing
   * @returns {Nullable<number>} The line spacing
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.lineSpacing);
   * ```
   */
  get lineSpacing() {
    return this._style.lineSpacing;
  }
  /**
   * Gets the text direction
   * @returns {Nullable<TextDirection>} The text direction
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.direction);
   * ```
   */
  get direction() {
    return this._style.direction;
  }
  /**
   * Gets the spacing rule
   * @returns {Nullable<SpacingRule>} The spacing rule
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spacingRule);
   * ```
   */
  get spacingRule() {
    return this._style.spacingRule;
  }
  /**
   * Gets the snap to grid
   * @returns {Nullable<BooleanNumber>} The snap to grid
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.snapToGrid);
   * ```
   */
  get snapToGrid() {
    return this._style.snapToGrid;
  }
  /**
   * Gets the space above
   * @returns {Nullable<INumberUnit>} The space above
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spaceAbove);
   * ```
   */
  get spaceAbove() {
    return this._style.spaceAbove;
  }
  /**
   * Gets the space below
   * @returns {Nullable<INumberUnit>} The space below
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spaceBelow);
   * ```
   */
  get spaceBelow() {
    return this._style.spaceBelow;
  }
  /**
   * Gets the border between
   * @returns {Nullable<IParagraphBorder>} The border between
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderBetween);
   * ```
   */
  get borderBetween() {
    return this._style.borderBetween;
  }
  /**
   * Gets the border top
   * @returns {Nullable<IParagraphBorder>} The border top
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderTop);
   * ```
   */
  get borderTop() {
    return this._style.borderTop;
  }
  /**
   * Gets the border bottom
   * @returns {Nullable<IParagraphBorder>} The border bottom
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderBottom);
   * ```
   */
  get borderBottom() {
    return this._style.borderBottom;
  }
  /**
   * Gets the border left
   * @returns {Nullable<IParagraphBorder>} The border left
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderLeft);
   * ```
   */
  get borderLeft() {
    return this._style.borderLeft;
  }
  /**
   * Gets the border right
   * @returns {Nullable<IParagraphBorder>} The border right
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderRight);
   * ```
   */
  get borderRight() {
    return this._style.borderRight;
  }
  /**
   * Gets the keep lines
   * @returns {boolean} The keep lines
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.keepLines);
   * ```
   */
  get keepLines() {
    return this._style.keepLines === ie.TRUE;
  }
  /**
   * Gets the keep next
   * @returns {boolean} The keep next
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.keepNext);
   * ```
   */
  get keepNext() {
    return this._style.keepNext === ie.TRUE;
  }
  /**
   * Gets the word wrap
   * @returns {boolean} The word wrap
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.wordWrap);
   * ```
   */
  get wordWrap() {
    return this._style.wordWrap === ie.TRUE;
  }
  /**
   * Gets the widow control
   * @returns {boolean} The widow control
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.widowControl);
   * ```
   */
  get widowControl() {
    return this._style.widowControl === ie.TRUE;
  }
  /**
   * Gets the shading
   * @returns {Nullable<IShading>} The shading
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.shading);
   * ```
   */
  get shading() {
    return this._style.shading;
  }
  /**
   * Gets the suppress hyphenation
   * @returns {boolean} The suppress hyphenation
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.suppressHyphenation);
   * ```
   */
  get suppressHyphenation() {
    return this._style.suppressHyphenation === ie.TRUE;
  }
  /**
   * Creates a copy of the paragraph style
   * @returns {ParagraphStyleBuilder} The copy
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  copy() {
    return Cs.create(J.deepClone(this._style));
  }
  /**
   * Gets the value
   * @returns {IParagraphStyle} The value
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.getValue());
   * ```
   */
  getValue() {
    return this._style;
  }
};
var Cs = class _Cs extends Bs {
  /**
   * Creates a new paragraph style builder
   * @param style The paragraph style
   * @returns A new paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  static create(t = {}) {
    return new _Cs(t);
  }
  constructor(t = {}) {
    super(t);
  }
  /**
   * Sets the indent first line
   * @param value The indent first line
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentFirstLine(10);
   * ```
   */
  setIndentFirstLine(t) {
    return this._style.indentFirstLine = t, this;
  }
  /**
   * Sets the hanging
   * @param value The hanging
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setHanging(10);
   * ```
   */
  setHanging(t) {
    return this._style.hanging = t, this;
  }
  /**
   * Sets the indent start
   * @param value The indent start
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentStart(10);
   * ```
   */
  setIndentStart(t) {
    return this._style.indentStart = t, this;
  }
  /**
   * Sets the tab stops
   * @param value The tab stops
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTabStops([{ value: 10 }]);
   * ```
   */
  setTabStops(t) {
    return this._style.tabStops = t, this;
  }
  /**
   * Sets the indent end
   * @param value The indent end
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentEnd(10);
   * ```
   */
  setIndentEnd(t) {
    return this._style.indentEnd = t, this;
  }
  /**
   * Sets the text style
   * @param value The text style
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTextStyle({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * ```
   */
  setTextStyle(t) {
    return this._style.textStyle = t, this;
  }
  /**
   * Sets the heading id
   * @param value The heading id
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setHeadingId('test');
   * ```
   */
  setHeadingId(t) {
    return this._style.headingId = t, this;
  }
  /**
   * Sets the named style type
   * @param value The named style type
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setNamedStyleType(NamedStyleType.CHAPTER);
   * ```
   */
  setNamedStyleType(t) {
    return this._style.namedStyleType = t, this;
  }
  /**
   * Sets the vertical align
   * @param value The vertical align
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setVerticalAlign(VerticalAlign.CENTER);
   * ```
   */
  setHorizontalAlign(t) {
    return this._style.horizontalAlign = t, this;
  }
  /**
   * Sets the line spacing
   * @param value The line spacing
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setLineSpacing(10);
   * ```
   */
  setLineSpacing(t) {
    return this._style.lineSpacing = t, this;
  }
  /**
   * Sets the text direction
   * @param value The text direction
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTextDirection(TextDirection.RIGHT_TO_LEFT);
   * ```
   */
  setDirection(t) {
    return this._style.direction = t, this;
  }
  /**
   * Sets the spacing rule
   * @param value The spacing rule
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpacingRule(SpacingRule.AUTO);
   * ```
   */
  setSpacingRule(t) {
    return this._style.spacingRule = t, this;
  }
  /**
   * Sets the snap to grid
   * @param value The snap to grid
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSnapToGrid(true);
   * ```
   */
  setSnapToGrid(t) {
    return this._style.snapToGrid = t ? 1 : 0, this;
  }
  /**
   * Sets the space above
   * @param value The space above
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpaceAbove(10);
   * ```
   */
  setSpaceAbove(t) {
    return this._style.spaceAbove = t, this;
  }
  /**
   * Sets the space below
   * @param value The space below
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpaceBelow(10);
   * ```
   */
  setSpaceBelow(t) {
    return this._style.spaceBelow = t, this;
  }
  /**
   * Sets the border between
   * @param {IParagraphBorder} value The border between
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderBetween({ color: 'red', width: 1 });
   * ```
   */
  setBorderBetween(t) {
    return this._style.borderBetween = t, this;
  }
  /**
   * Sets the border top
   * @param {IParagraphBorder} value The border top
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderTop({ color: 'red', width: 1 });
   * ```
   */
  setBorderTop(t) {
    return this._style.borderTop = t, this;
  }
  /**
   * Sets the border bottom
   * @param {IParagraphBorder} value The border bottom
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderBottom({ color: 'red', width: 1 });
   * ```
   */
  setBorderBottom(t) {
    return this._style.borderBottom = t, this;
  }
  /**
   * Sets the border left
   * @param {IParagraphBorder} value The border left
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderLeft({ color: 'red', width: 1 });
   * ```
   */
  setBorderLeft(t) {
    return this._style.borderLeft = t, this;
  }
  /**
   * Sets the border right
   * @param {IParagraphBorder} value The border right
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderRight({ color: 'red', width: 1 });
   * ```
   */
  setBorderRight(t) {
    return this._style.borderRight = t, this;
  }
  /**
   * Sets the keep lines
   * @param value The keep lines
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setKeepLines(true);
   * ```
   */
  setKeepLines(t) {
    return this._style.keepLines = t ? 1 : 0, this;
  }
  /**
   * Sets the keep next
   * @param value The keep next
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setKeepNext(true);
   * ```
   */
  setKeepNext(t) {
    return this._style.keepNext = t ? 1 : 0, this;
  }
  /**
   * Sets the word wrap
   * @param value The word wrap
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setWordWrap(true);
   * ```
   */
  setWordWrap(t) {
    return this._style.wordWrap = t ? 1 : 0, this;
  }
  /**
   * Sets the widow control
   * @param {boolean} value The widow control value
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setWidowControl(true);
   * ```
   */
  setWidowControl(t) {
    return this._style.widowControl = t ? 1 : 0, this;
  }
  /**
   * Sets the shading style
   * @param {IShading} value The shading configuration
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setShading({ backgroundColor: '#f0f0f0' });
   * ```
   */
  setShading(t) {
    return this._style.shading = t, this;
  }
  /**
   * Sets whether to suppress hyphenation
   * @param {boolean} value The suppress hyphenation value
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSuppressHyphenation(true);
   * ```
   */
  setSuppressHyphenation(t) {
    return this._style.suppressHyphenation = t ? 1 : 0, this;
  }
  /**
   * Creates a copy of the current paragraph style builder
   * @returns {ParagraphStyleBuilder} A new instance of ParagraphStyleBuilder with the same settings
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  copy() {
    return _Cs.create(J.deepClone(this._style));
  }
  /**
   * Builds and returns the final paragraph style configuration
   * @returns {IParagraphStyle} The constructed paragraph style object
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const finalStyle = style.build();
   * ```
   */
  build() {
    return this.getValue();
  }
};
var dn = class _dn {
  constructor(t) {
    p(this, "_data");
    if (!t.body)
      throw new Error("Invalid document data, body is required");
    this._data = sc(t);
  }
  /**
   * Creates a new RichTextValue instance
   * @param {IDocumentData} data The initial data for the rich text value
   * @returns {RichTextValue} A new RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * ```
   */
  static create(t) {
    return new _dn(t);
  }
  /**
   * Creates a new RichTextValue instance
   * @param {IDocumentBody} data The initial data for the rich text value
   * @returns {RichTextValue} A new RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.createByBody({ dataStream: 'Hello World\r\n' });
   * ```
   */
  static createByBody(t) {
    return new _dn({ body: t, id: "d", documentStyle: {} });
  }
  /**
   * Creates a copy of the current RichTextValue instance
   * @returns {RichTextValue} A new instance of RichTextValue with the same data
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const copy = richText.copy();
   * ```
   */
  copy() {
    return Pn.create(J.deepClone(this._data));
  }
  /**
   * Slices the current RichTextValue instance
   * @param {number} start The start index
   * @param {number} end The end index
   * @returns {RichTextBuilder} A new instance of RichTextBuilder with the sliced data
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const sliced = richText.slice(0, 5);
   * ```
   */
  slice(t, n) {
    const { body: r, ...s } = this._data;
    return Pn.create({
      ...J.deepClone(s),
      body: kt(r, t, n)
    });
  }
  /**
   * Converts the current RichTextValue instance to plain text
   * @returns {string} The plain text representation of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const plainText = richText.toPlainText();
   * ```
   */
  toPlainText() {
    var t, n;
    return Je.transform.getPlainText((n = (t = this._data.body) == null ? void 0 : t.dataStream) != null ? n : "").replaceAll("\r", `
`);
  }
  /**
   * Gets the paragraph style of the current RichTextValue instance
   * @returns {ParagraphStyleValue} The paragraph style of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const style = richText.getParagraphStyle();
   * ```
   */
  getParagraphStyle() {
    var t, n;
    return Bs.create((n = (t = this._data.body) == null ? void 0 : t.paragraphs) == null ? void 0 : n[0].paragraphStyle);
  }
  /**
   * Gets the paragraph bullet of the current RichTextValue instance
   * @returns {ParagraphBulletValue} The paragraph bullet of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const bullet = richText.getParagraphBullet();
   * ```
   */
  getParagraphBullet() {
    var t, n;
    return (n = (t = this._data.body) == null ? void 0 : t.paragraphs) == null ? void 0 : n[0].bullet;
  }
  /**
   * Gets the paragraphs of the current RichTextValue instance
   * @returns {RichTextValue[]} The paragraphs of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const paragraphs = richText.getParagraphs();
   * ```
   */
  getParagraphs() {
    var r, s;
    const t = (s = (r = this._data.body) == null ? void 0 : r.paragraphs) != null ? s : [];
    let n = 0;
    return t.map((i) => {
      const o = this.slice(n, i.startIndex);
      return n = i.startIndex, o;
    });
  }
  /**
   * Gets the text runs of the current RichTextValue instance
   * @returns {TextRunValue[]} The text runs of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const textRuns = richText.getTextRuns();
   * ```
   */
  getTextRuns() {
    var t, n;
    return ((n = (t = this._data.body) == null ? void 0 : t.textRuns) != null ? n : []).map((r) => ({
      ...r,
      ts: r.ts ? Hs.create(r.ts) : null
    }));
  }
  /**
   * Gets the links of the current RichTextValue instance
   * @returns {ICustomRange[]} The links of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const links = richText.getLinks();
   * ```
   */
  getLinks() {
    var t, n, r;
    return (r = (n = (t = this._data.body) == null ? void 0 : t.customRanges) == null ? void 0 : n.filter((s) => s.rangeType === pn.HYPERLINK)) != null ? r : [];
  }
  /**
   * Gets the data of the current RichTextValue instance
   * @returns {IDocumentData} The data of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const data = richText.getData();
   * ```
   */
  getData() {
    return this._data;
  }
};
var Pn = class _Pn extends dn {
  constructor(n) {
    super(n);
    p(this, "_doc");
    this._doc = new Pt(n);
  }
  static newEmptyData() {
    return sc({
      id: "d",
      documentStyle: {},
      drawings: {},
      drawingsOrder: [],
      body: {
        dataStream: `\r
`,
        customBlocks: [],
        customRanges: [],
        paragraphs: [{ startIndex: 0 }],
        textRuns: [],
        tables: [],
        sectionBreaks: []
      }
    });
  }
  /**
   * Creates a new RichTextBuilder instance
   * @param {IDocumentData} data The initial data for the rich text builder
   * @returns {RichTextBuilder} A new RichTextBuilder instance
   */
  static create(n) {
    return new _Pn(n != null ? n : _Pn.newEmptyData());
  }
  insertText(n, r, s) {
    var c, h;
    let i = ((h = (c = this._data.body) == null ? void 0 : c.dataStream.length) != null ? h : 2) - 2, o, a;
    if (typeof n == "string" ? o = n : (i = Math.min(n, i), o = r), typeof r == "object" ? a = r instanceof gn ? r.build() : r : a = s instanceof gn ? s.build() : s, !o) return this;
    const l = {
      dataStream: o,
      textRuns: a ? [
        {
          ts: a,
          st: i,
          ed: i + o.length
        }
      ] : []
    }, u = Je.selection.replace({
      doc: this._doc,
      selection: { startOffset: i, endOffset: i, collapsed: true },
      body: l
    });
    if (!u)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), u.serialize()), this;
  }
  insertRichText(n, r) {
    var a, l;
    let s = ((l = (a = this._data.body) == null ? void 0 : a.dataStream.length) != null ? l : 2) - 2, i;
    typeof n == "object" ? i = n instanceof dn ? n.getData() : n : (s = Math.min(n, s), i = r instanceof dn ? r.getData() : r);
    const o = Je.selection.replace({
      doc: this._doc,
      selection: { startOffset: s, endOffset: s, collapsed: true },
      body: i.body
    });
    if (!o)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), o.serialize()), this;
  }
  delete(n, r) {
    if (r !== void 0) {
      if (!r) return this;
      const s = Je.selection.delete([{ startOffset: n, endOffset: n + r, collapsed: true }], this._data.body);
      Ne.apply(this._doc.getBody(), s);
    }
    return this;
  }
  /**
   * Sets the style of the text at the specified start and end positions
   * @param {number} start The start position of the text to set the style
   * @param {number} end The end position of the text to set the style
   * @param {TextStyleBuilder | ITextStyle} style The style to set
   * @returns {RichTextBuilder} The current RichTextBuilder instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const newRichText = richText.setStyle(5, 10, { ff: 'Arial', fs: 12 });
   * ```
   */
  setStyle(n, r, s) {
    const i = {
      dataStream: "",
      textRuns: [{
        ts: s instanceof gn ? s.build() : s,
        st: 0,
        ed: r - n
      }]
    }, o = Je.selection.retain([{ startOffset: n, endOffset: r, collapsed: true }], i);
    return Ne.apply(this._doc.getBody(), o), this;
  }
  /**
   * Sets the link of the text at the specified start and end positions
   * @param {number} start The start position of the text to set the link
   * @param {number} end The end position of the text to set the link
   * @param {string} link The link to set
   * @returns {RichTextBuilder} The current RichTextBuilder instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const newRichText = richText.setLink(5, 10, 'https://www.example.com');
   * ```
   */
  setLink(n, r, s) {
    const i = Je.customRange.add({
      rangeType: pn.HYPERLINK,
      rangeId: et(),
      properties: {
        url: s
      },
      ranges: [{ startOffset: n, endOffset: r, collapsed: false }],
      body: this._data.body
    });
    if (!i)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), i.serialize()), this;
  }
  cancelLink(n, r) {
    if (typeof n == "string") {
      const s = Je.customRange.delete({
        rangeId: n,
        documentDataModel: this._doc
      });
      if (!s)
        throw new Error("Insert text failed, please check.");
      Ne.apply(this._doc.getBody(), s.serialize());
    } else
      this.slice(n, r).getLinks().forEach((i) => {
        const o = Je.customRange.delete({
          rangeId: i.rangeId,
          documentDataModel: this._doc
        });
        if (!o)
          throw new Error("Insert text failed, please check.");
        Ne.apply(this._doc.getBody(), o.serialize());
      });
    return this;
  }
  updateLink(n, r) {
    var i, o;
    const s = (o = (i = this._data.body) == null ? void 0 : i.customRanges) == null ? void 0 : o.find((a) => a.rangeId === n);
    if (!s)
      throw new Error("Link not found");
    return s.properties.url = r, this;
  }
  insertParagraph(n, r) {
    var o, a;
    let s, i;
    return typeof n == "object" ? (s = {
      dataStream: "\r",
      paragraphs: [{
        startIndex: 0,
        paragraphStyle: n.build()
      }]
    }, i = ((a = (o = this._data.body) == null ? void 0 : o.dataStream.length) != null ? a : 2) - 2) : (i = n, s = {
      dataStream: "\r",
      paragraphs: [{
        startIndex: 0,
        paragraphStyle: r == null ? void 0 : r.build()
      }]
    }), this.insertRichText(i, dn.create({ body: s, id: "d", documentStyle: {} })), this;
  }
  insertLink(n, r, s) {
    let i = "", o = "";
    typeof n == "string" ? (i = n, o = r) : (i = r, o = s);
    const a = _Pn.createByBody({
      dataStream: i,
      customRanges: [{
        rangeType: pn.HYPERLINK,
        rangeId: et(),
        properties: {
          url: o
        },
        startIndex: 0,
        endIndex: i.length - 1
      }]
    });
    return typeof n == "number" ? this.insertRichText(n, a) : this.insertRichText(a);
  }
};
var yR = "__default_document_sub_component_id20231101__";
var lE = class {
  constructor() {
    p(this, "skipNextObservers", false);
    p(this, "lastReturnValue");
    p(this, "isStopPropagation", false);
  }
  stopPropagation() {
    this.isStopPropagation = true;
  }
};
var NR = class extends Subject {
  constructor() {
    super(...arguments);
    p(this, "_sortedObservers", []);
  }
  /** @deprecated Use `subscribeEvent` instead. */
  subscribe() {
    throw new Error("[EventSubject]: please use `subscribeEvent` instead of `subscribe` method for `EventSubject`.");
  }
  /** @deprecated Use `emitEvent` instead. */
  next() {
    throw new Error("[EventSubject]: please use `emitEvent` instead of `next` method for `EventSubject`.");
  }
  unsubscribe() {
    super.unsubscribe(), this._sortedObservers.length = 0;
  }
  complete() {
    super.complete(), this._sortedObservers.length = 0;
  }
  subscribeEvent(n) {
    let r;
    typeof n == "function" ? r = { next: ([i, o]) => n(i, o) } : r = n;
    const s = super.subscribe(r);
    return this._sortedObservers.push(r), this._sortedObservers.sort((i, o) => {
      var a, l;
      return ((a = i.priority) != null ? a : 0) - ((l = o.priority) != null ? l : 0);
    }), s.add(() => this._sortedObservers = this._sortedObservers.filter((i) => i !== r)), s;
  }
  clearObservers() {
    this._sortedObservers.forEach((n) => {
      var r;
      return (r = n.complete) == null ? void 0 : r.call(n);
    }), this._sortedObservers.length = 0;
  }
  emitEvent(n) {
    var r;
    if (!this.closed) {
      const s = new lE();
      s.lastReturnValue = n;
      for (const i of this._sortedObservers) {
        const o = (r = i.next) == null ? void 0 : r.call(i, [n, s]);
        if (s.lastReturnValue = o, s.skipNextObservers)
          return {
            handled: true,
            lastReturnValue: s.lastReturnValue,
            stopPropagation: s.isStopPropagation
          };
      }
      return {
        handled: this._sortedObservers.length > 0,
        lastReturnValue: s.lastReturnValue,
        stopPropagation: s.isStopPropagation
      };
    }
    throw new Error("[EventSubject]: cannot emit event on a closed subject.");
  }
};
function TR(e) {
  return new Observable((t) => {
    const n = e.subscribeEvent((r) => {
      t.next(r);
    });
    return () => n.unsubscribe();
  });
}
var Jo = createIdentifier("core.resource-manager.service");
var Hi = {
  [xt.Editor]: "Editor",
  [xt.Owner]: "Owner",
  [xt.Reader]: "Reader",
  [xt.UNRECOGNIZED]: "UNRECOGNIZED"
};
var Bi = (e) => e ? {
  userID: `${Hi[e]}_${et(8)}`,
  name: Hi[e],
  avatar: ""
} : {
  userID: "",
  name: "",
  avatar: "",
  anonymous: true,
  canBindAnonymous: false
};
var uE = (e, t) => e.startsWith(Hi[t]);
var Rs = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_model", /* @__PURE__ */ new Map());
    p(this, "_userChange$", new Subject());
    p(this, "userChange$", this._userChange$.asObservable());
    p(this, "_currentUser$", new BehaviorSubject(Bi()));
    p(this, "currentUser$", this._currentUser$.asObservable());
  }
  dispose() {
    super.dispose(), this._model.clear(), this._userChange$.complete(), this._currentUser$.complete();
  }
  getCurrentUser() {
    return this._currentUser$.getValue();
  }
  setCurrentUser(n) {
    this.addUser(n), this._currentUser$.next(n);
  }
  addUser(n) {
    this._model.set(n.userID, n), this._userChange$.next({ type: "add", user: n });
  }
  getUser(n, r) {
    const s = this._model.get(n);
    if (s)
      return s;
    r && r();
  }
  delete(n) {
    const r = this.getUser(n);
    this._model.delete(n), r && this._userChange$.next({ type: "delete", user: r });
  }
  clear() {
    this._model.clear(), this._userChange$.next({ type: "clear" });
  }
  list() {
    return Array.from(this._model.values());
  }
};
var cE = Object.getOwnPropertyDescriptor;
var hE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? cE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var pl = (e, t) => (n, r) => t(n, r, e);
var ji = class {
  // private _sheetPermissionPointMap: Map<string, { action: UnitAction; allowed: boolean }[]> = new Map();
  constructor(e, t) {
    p(this, "_permissionMap", /* @__PURE__ */ new Map([]));
    this._resourceManagerService = e, this._userManagerService = t, this._initSnapshot(), this._initDefaultUser();
  }
  _initDefaultUser() {
    const e = this._userManagerService.getCurrentUser();
    e && e.userID || this._userManagerService.setCurrentUser(Bi(xt.Owner));
  }
  _getRole(e) {
    const t = this._userManagerService.getCurrentUser();
    return t ? uE(t.userID, e) : false;
  }
  _initSnapshot() {
    this._resourceManagerService.registerPluginResource({
      toJson: (e) => {
        const t = [...this._permissionMap.keys()].reduce((n, r) => {
          const s = this._permissionMap.get(r);
          return n[r] = s, n;
        }, {});
        return JSON.stringify(t);
      },
      parseJson: (e) => JSON.parse(e),
      pluginName: "SHEET_AuthzIoMockService_PLUGIN",
      businesses: [we.UNIVER_SHEET, we.UNIVER_DOC, we.UNIVER_SLIDE],
      onLoad: (e, t) => {
        for (const n in t)
          this._permissionMap.set(n, t[n]);
      },
      onUnLoad: () => {
        this._permissionMap.clear();
      }
    });
  }
  async create(e) {
    return et(8);
  }
  async allowed(e) {
    return Promise.resolve([]);
  }
  async batchAllowed(e) {
    return Promise.resolve([]);
  }
  // eslint-disable-next-line max-lines-per-function
  async list(e) {
    const t = [];
    return e.objectIDs.forEach((n) => {
      const r = this._permissionMap.get(n);
      if (r) {
        const s = {
          objectID: n,
          unitID: e.unitID,
          objectType: r.objectType,
          name: r.name,
          shareOn: false,
          shareRole: xt.Owner,
          shareScope: -1,
          scope: {
            read: Ri.AllCollaborator,
            edit: Ri.AllCollaborator
          },
          creator: Bi(xt.Owner),
          strategies: [
            {
              action: 6,
              role: 1
            },
            {
              action: 16,
              role: 1
            },
            {
              action: 17,
              role: 1
            },
            {
              action: 18,
              role: 1
            },
            {
              action: 19,
              role: 1
            },
            {
              action: 33,
              role: 1
            },
            {
              action: 34,
              role: 1
            },
            {
              action: 35,
              role: 1
            },
            {
              action: 36,
              role: 1
            },
            {
              action: 37,
              role: 1
            },
            {
              action: 38,
              role: 1
            },
            {
              action: 39,
              role: 1
            },
            {
              action: 40,
              role: 1
            }
          ],
          actions: e.actions.map((i) => ({ action: i, allowed: this._getRole(xt.Owner) || this._getRole(xt.Editor) }))
        };
        t.push(s);
      }
    }), t;
  }
  async listCollaborators() {
    return [];
  }
  async listRoles() {
    return {
      roles: [],
      actions: []
    };
  }
  async deleteCollaborator() {
  }
  async update(e) {
  }
  async updateCollaborator() {
  }
  async createCollaborator() {
  }
  async putCollaborators(e) {
  }
};
ji = hE([
  pl(0, Jo),
  pl(1, Inject(Rs))
], ji);
var dE = createIdentifier("IAuthzIoIoService");
var ic = createIdentifier("univer.config-service");
var fE = class {
  constructor() {
    p(this, "_configChanged$", new Subject());
    p(this, "configChanged$", this._configChanged$.asObservable());
    p(this, "_config", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._config.clear(), this._configChanged$.complete();
  }
  getConfig(t) {
    return this._config.get(t);
  }
  setConfig(t, n, r) {
    var o;
    const { merge: s = false } = r || {};
    let i = (o = this._config.get(t)) != null ? o : {};
    s ? i = oo(i, n) : i = n, this._config.set(t, i), this._configChanged$.next({ [t]: i });
  }
  deleteConfig(t) {
    return this._config.delete(t);
  }
  subscribeConfigValue$(t) {
    return new Observable((n) => {
      Object.prototype.hasOwnProperty.call(this._config, t) && n.next(this._config.get(t));
      const r = this.configChanged$.pipe(filter((s) => Object.prototype.hasOwnProperty.call(s, t))).subscribe((s) => n.next(s[t]));
      return () => r.unsubscribe();
    });
  }
};
var Xr = "FOCUSING_UNIT";
var gr = "FOCUSING_SHEET";
var qr = "FOCUSING_DOC";
var Zr = "FOCUSING_SLIDE";
var MR = "FOCUSING_EDITOR_BUT_HIDDEN";
var mE = "EDITOR_ACTIVATED";
var LR = "FOCUSING_EDITOR_INPUT_FORMULA";
var gE = "FOCUSING_FX_BAR_EDITOR";
var xR = "FOCUSING_UNIVER_EDITOR";
var DR = "FOCUSING_EDITOR_INPUT_FORMULA";
var UR = "FOCUSING_PANEL_EDITOR";
var kR = "FOCUSING_UNIVER_EDITOR_STANDALONE_SINGLE_MODE";
var PR = "FOCUSING_COMMON_DRAWINGS";
var FR = "FORMULA_EDITOR_ACTIVATED";
var _E = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_error$", new Subject());
    p(this, "error$", this._error$.asObservable());
  }
  dispose() {
    this._error$.complete();
  }
  emit(n) {
    this._error$.next({ errorKey: n });
  }
};
var oc = ((e) => (e.URL = "URL", e.UUID = "UUID", e.BASE64 = "BASE64", e))(oc || {});
var pE = ((e) => (e.SUCCUSS = "0", e.ERROR_EXCEED_SIZE = "1", e.ERROR_IMAGE_TYPE = "2", e.ERROR_UPLOAD_COUNT_LIMIT = "3", e.ERROR_IMAGE = "4", e))(pE || {});
var El = createIdentifier("core.image-io.service");
var EE = "0.11.0";
var CE = {
  version: EE
};
function RE(e = "", t = Ns.ZH_CN, n = "") {
  return {
    id: e,
    sheetOrder: [],
    name: n,
    appVersion: CE.version,
    locale: t,
    styles: {},
    sheets: {},
    resources: []
  };
}
var IE = class {
  constructor(t = {}) {
    p(this, "_styles");
    p(this, "_cacheMap", new gs(1e5));
    this._styles = t, this._generateCacheMap();
  }
  each(t) {
    return Object.entries(this._styles).forEach(t), this;
  }
  search(t, n) {
    if (this._cacheMap.has(n))
      return this._cacheMap.get(n);
    const r = this._getExistingStyleId(t);
    return r || "-1";
  }
  get(t) {
    return typeof t != "string" ? t : (t = String(t), this._styles[t]);
  }
  add(t, n) {
    const r = et(6);
    return this._styles[r] = t, this._cacheMap.set(n, r), r;
  }
  setValue(t) {
    if (t == null) return;
    const n = JSON.stringify(t), r = this.search(t, n);
    return r !== "-1" ? r : this.add(t, n);
  }
  addCustomStyle(t, n) {
    n != null && (this._styles[t] = n, this._cacheMap.set(JSON.stringify(n), t));
  }
  remove(t) {
    this._styles[t] && (delete this._styles[t], this._cacheMap.delete(JSON.stringify(this._styles[t])));
  }
  toJSON() {
    return this._styles;
  }
  // TODO: this should be `deReuseStyle` to be more accurate.
  getStyleByCell(t) {
    let n;
    t && J.isObject(t.s) ? n = t.s : n = (t == null ? void 0 : t.s) && this.get(t.s);
    const r = t == null ? void 0 : t.interceptorStyle;
    return r ? {
      ...n,
      ...r
    } : n;
  }
  _generateCacheMap() {
    const { _styles: t, _cacheMap: n } = this;
    for (const r in t) {
      const s = JSON.stringify(t[r]);
      n.set(s, r);
    }
  }
  _getExistingStyleId(t) {
    const { _styles: n } = this;
    for (const r in n)
      if (J.diffValue(n[r], t))
        return r;
    return null;
  }
};
var $R = (e, t) => t.length === e.length && !e.some((n) => t.some((r) => !En.equals(r, n)));
var HR = (e, t) => t.length === e.length && e.every((n, r) => {
  const s = t[r];
  return s.unitId === n.unitId && s.sheetId === n.sheetId && En.equals(n.range, s.range);
});
var Wi = {
  t: 0,
  b: 2,
  // must over 1, see https://github.com/dream-num/univer/issues/2727
  l: 2,
  r: 2
};
var wE = (e) => ({
  sbr: 0.6,
  sbo: e,
  spr: 0.6,
  spo: e
});
var Cl = 90;
function Jr(e, t, n = {}) {
  const r = e.length, {
    textRotation: s,
    paddingData: i,
    horizontalAlign: o = Ut.UNSPECIFIED,
    verticalAlign: a = xn.UNSPECIFIED,
    wrapStrategy: l = Bn.UNSPECIFIED,
    cellValueType: u
  } = n, { t: c, r: h, b: d, l: f } = i || Wi, { vertexAngle: g, centerAngle: _ } = ac(s), R = {
    id: "d",
    body: {
      dataStream: `${e}${Bc}`,
      textRuns: [
        {
          ts: t,
          st: 0,
          ed: r
        }
      ],
      paragraphs: [
        {
          startIndex: r,
          paragraphStyle: {
            horizontalAlign: o
          }
        }
      ],
      sectionBreaks: [{
        startIndex: r + 1
      }]
    },
    documentStyle: {
      pageSize: {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      },
      marginTop: c,
      marginBottom: d,
      marginRight: h,
      marginLeft: f,
      renderConfig: {
        horizontalAlign: o,
        verticalAlign: a,
        centerAngle: _,
        vertexAngle: g,
        wrapStrategy: l,
        cellValueType: u
        /**
         * TODO@weird94
         * This config was previously used to fix the issue of cell image editing, now remove it first.
         * If you need to use it, please note the following issues:
         * 1. After delete cell content using backspace, the cell does not enter edit mode.
         * because the code `if (!info || info.actualWidth <= 0) return;`, code in `packages/sheets-ui/src/services/editor/cell-editor-resize.service.ts`
         * 2. copy empty cell content from excel and paste it to univer, the empty cell does not enter edit mode. The reason is the same as above.
         */
        // zeroWidthParagraphBreak: 1,
      }
    },
    drawings: {},
    drawingsOrder: []
  };
  return new Pt(R);
}
function SE(e) {
  if (!e) return {};
  const {
    tr: t,
    td: n,
    ht: r,
    vt: s,
    tb: i,
    pd: o
  } = e;
  return {
    textRotation: t,
    textDirection: n,
    horizontalAlign: r,
    verticalAlign: s,
    wrapStrategy: i,
    paddingData: o
  };
}
function Rl(e) {
  if (!e)
    return {};
  const { ff: t, fs: n, it: r, bl: s, ul: i, st: o, ol: a, cl: l, bg: u } = e, c = {};
  return t && (c.ff = t), n && (c.fs = n), r && (c.it = r), s && (c.bl = s), i && (c.ul = i), o && (c.st = o), a && (c.ol = a), l && (c.cl = l), u && (c.bg = u), c;
}
function OE(e, t, n) {
  var i;
  const r = e.getBody();
  if ((i = r.customRanges) != null && i.some((o) => o.rangeType === pn.HYPERLINK))
    return;
  const s = Je.customRange.add({
    ranges: [
      {
        startOffset: 0,
        endOffset: r.dataStream.length - 1,
        collapsed: false
      }
    ],
    rangeId: n,
    rangeType: pn.HYPERLINK,
    body: r,
    properties: {
      url: t,
      refId: n
    }
  });
  s && Ne.apply(r, s.serialize());
}
function vE(e) {
  return e != null;
}
var bE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
function Il(e) {
  const t = rt.ff, n = rt.fs;
  if (!e) {
    const h = `${n}pt  ${t}`;
    return {
      fontCache: h,
      fontString: h,
      fontSize: n,
      originFontSize: n,
      fontFamily: t
    };
  }
  let r = ir.ITALIC;
  (e.it === 0 || e.it === void 0) && (r = ir.NORMAL);
  let s = ir.BOLD;
  (e.bl === 0 || e.bl === void 0) && (s = ir.NORMAL);
  let i = n;
  e.fs && (i = Math.ceil(e.fs));
  let o = t;
  if (e.ff) {
    let h = e.ff;
    h = h.replace(/"/g, "").replace(/'/g, ""), h.indexOf(" ") > -1 && (h = `"${h}"`), h == null && (h = t), o = h;
  }
  const { va: a } = e;
  let l = i;
  if (a === Zt.SUBSCRIPT || a === Zt.SUPERSCRIPT) {
    const h = AE(o, l), { sbr: d, spr: f } = h;
    l *= a === Zt.SUBSCRIPT ? d : f;
  }
  const u = `${r} ${s} ${l}pt ${o}`, c = `${u}, ${bE} `;
  return {
    fontCache: u,
    fontString: c,
    fontSize: l,
    originFontSize: i,
    fontFamily: o
  };
}
function AE(e, t) {
  return wE(t);
}
function ac(e) {
  const { a: t = 0, v: n = ie.FALSE } = e || { a: 0, v: ie.FALSE };
  let r = 0, s = t;
  return n === ie.TRUE && (r = Cl, s = Cl), { centerAngle: r, vertexAngle: s };
}
var yE = class {
  constructor(t, n) {
    p(this, "_columnData", {});
    this._config = t, this._columnData = n;
  }
  /**
   * Get width and hidden status of columns in the sheet
   * @returns {IObjectArrayPrimitiveType<Partial<IColumnData>>} Column data, including width, hidden status, etc.
   */
  getColumnData() {
    return this._columnData;
  }
  getColVisible(t) {
    const { _columnData: n } = this, r = n[t];
    return r ? r.hd !== ie.TRUE : true;
  }
  /**
   * Get the column style
   * @param {number} col Column index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getColumnStyle(t) {
    var n;
    return (n = this._columnData[t]) == null ? void 0 : n.s;
  }
  /**
   * Set the set column  default style
   * @param {number} col Column index
   * @param {string | Nullable<IStyleData>} style Style data
   */
  setColumnStyle(t, n) {
    const r = this.getColumnOrCreate(t);
    r.s = n;
  }
  /**
   * Get all hidden columns
   * @param start Start index
   * @param end End index
   * @returns Hidden columns range list
   */
  getHiddenCols(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getColVisible(o);
      s && a ? (s = false, r.push({
        rangeType: ge.COLUMN,
        startColumn: i,
        endColumn: o - 1,
        startRow: 0,
        endRow: 0
      })) : !s && !a && (s = true, i = o);
    }
    return s && r.push({
      startRow: 0,
      endRow: 0,
      startColumn: i,
      endColumn: n,
      rangeType: ge.COLUMN
    }), r;
  }
  /**
   * Get all visible columns
   * @param start Start index
   * @param end End index
   * @returns Visible columns range list
   */
  getVisibleCols(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getColVisible(o);
      s && !a ? (s = false, r.push({
        rangeType: ge.COLUMN,
        startColumn: i,
        endColumn: o - 1,
        startRow: 0,
        endRow: 0
      })) : !s && a && (s = true, i = o);
    }
    return s && r.push({
      startRow: 0,
      endRow: 0,
      startColumn: i,
      endColumn: n,
      rangeType: ge.COLUMN
    }), r;
  }
  getColumnDatas(t, n) {
    const r = {};
    let s = 0;
    for (let i = t; i < t + n; i++) {
      const o = this.getColumn(i);
      r[s] = o != null ? o : {
        w: this._config.defaultColumnWidth,
        hd: ie.FALSE
      }, s++;
    }
    return r;
  }
  /**
   * Get count of column in the sheet
   * @returns {number} count of column
   */
  getSize() {
    return mn(this._columnData);
  }
  /**
   * Get the width of column
   * @param columnPos column index
   * @returns {number} width of column
   */
  getColumnWidth(t) {
    var n, r;
    return (r = (n = this._columnData[t]) == null ? void 0 : n.w) != null ? r : this._config.defaultColumnWidth;
  }
  /**
   * Set the width of column
   * @param columnPos column index
   * @param width width of column
   */
  setColumnWidth(t, n) {
    const r = this._columnData[t];
    n === this._config.defaultColumnWidth ? r && (delete r.w, Object.keys(r).length === 0 && delete this._columnData[t]) : this._columnData[t] = r ? { ...r, w: n } : { w: n };
  }
  /**
   * Get given column data
   * @param columnPos column index
   */
  getColumn(t) {
    return this._columnData[t];
  }
  /**
   * Remove column data of given column
   * @param columnPos
   */
  removeColumn(t) {
    delete this._columnData[t];
  }
  /**
   * Get given column data or create a column data when it's null
   * This method is used to ensure that the column data should not be null when setting column properties.
   * To prevent data redundancy, if is not setting column properties, you can use `getColumn` method to get column data. don't use this method.
   * @param columnPos column index
   * @returns {Partial<IColumnData>} columnData
   */
  getColumnOrCreate(t) {
    const { _columnData: n } = this, r = n[t];
    if (r)
      return r;
    const s = {};
    return this._columnData[t] = s, s;
  }
  setCustomMetadata(t, n) {
    const r = this.getColumn(t);
    r && (r.custom = n);
  }
  getCustomMetadata(t) {
    var n;
    return (n = this.getColumn(t)) == null ? void 0 : n.custom;
  }
};
var NE = 2e3;
var TE = class {
  constructor(t, n, r) {
    p(this, "_rowData");
    this._config = t, this._viewModel = n, this._rowData = r;
  }
  /**
   * Get height and hidden status of columns in the sheet
   * @returns {IObjectArrayPrimitiveType<Partial<IRowData>>} Row data, including height, hidden status, etc.
   */
  getRowData() {
    return this._rowData;
  }
  /**
   * Get the row style
   * @param {number} row Row index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getRowStyle(t) {
    var n;
    return (n = this._rowData[t]) == null ? void 0 : n.s;
  }
  /**
   * Set row default style
   * @param {number} row The row index
   * @param {string | Nullable<IStyleData>} style The style data
   */
  setRowStyle(t, n) {
    const r = this.getRowOrCreate(t);
    r.s = n;
  }
  getRowDatas(t, n) {
    const r = {};
    let s = 0;
    for (let i = t; i < t + n; i++) {
      const o = this.getRow(i);
      r[s] = o != null ? o : {
        h: this._config.defaultRowHeight,
        hd: ie.FALSE
      }, s++;
    }
    return r;
  }
  getRowHeight(t, n = 1) {
    const { _rowData: r } = this, s = this._config;
    let i = 0;
    for (let o = 0; o < n; o++) {
      const a = r[o + t] || {
        hd: ie.FALSE,
        h: s.defaultRowHeight
      }, { ia: l, ah: u, h: c = s.defaultRowHeight } = a;
      i += (l == null || l === ie.TRUE) && typeof u == "number" ? u : c;
    }
    return i;
  }
  /**
   * Set row height of given row
   * @param rowPos row index
   * @param height row height
   */
  setRowHeight(t, n) {
    const r = this._rowData[t];
    if (n === this._config.defaultRowHeight)
      r && (delete r.h, Object.keys(r).length === 0 && delete this._rowData[t]);
    else {
      const s = Math.min(n, NE);
      this._rowData[t] = r ? { ...r, h: s } : { h: s };
    }
  }
  /**
   * Get row data of given row
   * @param rowPos row index
   * @returns {Nullable<Partial<IRowData>>} rowData
   */
  getRow(t) {
    return this._rowData[t];
  }
  /**
   * Remove row data of given row
   * @param rowPos
   */
  removeRow(t) {
    delete this._rowData[t];
  }
  /**
   * Get given row data or create a row data when it's null
   * This method is used to ensure that the row data should not be null when setting row properties.
   * To prevent data redundancy, if is not setting row properties, you can use `getRow` method to get row data. don't use this method.
   * @param rowPos row index
   * @returns {Partial<IRowData>} rowData
   */
  getRowOrCreate(t) {
    const { _rowData: n } = this, r = n[t];
    if (r)
      return r;
    const s = {};
    return n[t] = s, s;
  }
  /**
   * Get all hidden rows
   * @param start Start index
   * @param end End index
   * @returns Hidden rows range list
   */
  getHiddenRows(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getRowRawVisible(o);
      s && a ? (s = false, r.push({
        startRow: i,
        endRow: o - 1,
        startColumn: 0,
        endColumn: 0,
        rangeType: ge.ROW
      })) : !s && !a && (s = true, i = o);
    }
    return s && r.push({ startRow: i, endRow: n, startColumn: 0, endColumn: 0, rangeType: ge.ROW }), r;
  }
  /**
   * Get all visible rows
   * @param start Start index
   * @param end End index
   * @returns Visible rows range list
   */
  getVisibleRows(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getRowRawVisible(o);
      s && !a ? (s = false, r.push({
        startRow: i,
        endRow: o - 1,
        startColumn: 0,
        endColumn: 0,
        rangeType: ge.ROW
      })) : !s && a && (s = true, i = o);
    }
    return s && r.push({ startRow: i, endRow: n, startColumn: 0, endColumn: 0, rangeType: ge.ROW }), r;
  }
  getRowRawVisible(t) {
    const n = this.getRow(t);
    return n ? n.hd !== ie.TRUE : true;
  }
  /**
   * Get count of row in the sheet
   * @returns {number} row count
   */
  getSize() {
    return mn(this._rowData);
  }
  setCustomMetadata(t, n) {
    const r = this.getRow(t);
    r && (r.custom = n);
  }
  getCustomMetadata(t) {
    var n;
    return (n = this.getRow(t)) == null ? void 0 : n.custom;
  }
};
var BR = "DEFAULT_WORKSHEET_ROW_COUNT";
var ME = 1e3;
var jR = "DEFAULT_WORKSHEET_COLUMN_COUNT";
var LE = 20;
var WR = "DEFAULT_WORKSHEET_ROW_HEIGHT";
var xE = 24;
var YR = "DEFAULT_WORKSHEET_COLUMN_WIDTH";
var DE = 88;
var zR = "DEFAULT_WORKSHEET_ROW_TITLE_WIDTH";
var UE = 46;
var VR = "DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT";
var kE = 20;
function PE(e) {
  const t = {
    name: "Sheet1",
    // TODO: name should have i18n
    id: "sheet-01",
    tabColor: "",
    hidden: ie.FALSE,
    rowCount: ME,
    columnCount: LE,
    zoomRatio: 1,
    freeze: {
      xSplit: 0,
      ySplit: 0,
      startRow: -1,
      startColumn: -1
    },
    scrollTop: 0,
    scrollLeft: 0,
    defaultColumnWidth: DE,
    defaultRowHeight: xE,
    mergeData: [],
    cellData: {},
    rowData: {},
    columnData: {},
    showGridlines: ie.TRUE,
    rowHeader: {
      width: UE,
      hidden: ie.FALSE
    },
    columnHeader: {
      height: kE,
      hidden: ie.FALSE
    },
    rightToLeft: ie.FALSE
  };
  return Object.keys(t).forEach((n) => {
    const r = n;
    typeof e[r] > "u" && (e[r] = t[r]);
  }), e;
}
var FE = class extends Ve {
  constructor(n) {
    super();
    p(this, "_cellCache", /* @__PURE__ */ new Map());
    p(this, "_rowCache", /* @__PURE__ */ new Map());
    p(this, "_columnCache", /* @__PURE__ */ new Map());
    p(this, "_hasRow", false);
    p(this, "_hasColumn", false);
    p(this, "_hasAll", false);
    p(this, "_allIndex", -1);
    p(this, "_mergeData");
    p(this, "_rangeMap", new gs(5e4));
    p(this, "_skeletonCache", new gs(5e4));
    this._init(n.concat());
  }
  _init(n) {
    this._mergeData = n, this._createCache(n);
  }
  _clearCache() {
    this._cellCache.clear(), this._rowCache.clear(), this._columnCache.clear(), this._hasAll = false, this._allIndex = -1, this._rangeMap.clear(), this._skeletonCache.clear(), this._hasColumn = false, this._hasRow = false;
  }
  _createCache(n) {
    let r = 0;
    for (const s of n) {
      const { rangeType: i } = s;
      i === ge.ROW ? this._createRowCache(s, r) : i === ge.COLUMN ? this._createColumnCache(s, r) : i === ge.ALL ? this._createCellAllCache(r) : this._createCellCache(s, r), r++;
    }
  }
  /**
   * Rebuild the merge data cache when the merge data is changed.
   * @param {IRange[]} mergeData
   */
  rebuild(n) {
    this._clearCache(), this._init(n.concat());
  }
  _createRowCache(n, r) {
    const { startRow: s, endRow: i } = n;
    for (let o = s; o <= i; o++)
      this._rowCache.set(o, r), this._hasRow = true;
  }
  _createColumnCache(n, r) {
    const { startColumn: s, endColumn: i } = n;
    for (let o = s; o <= i; o++)
      this._columnCache.set(o, r), this._hasColumn = true;
  }
  _createCellAllCache(n) {
    this._hasAll = true, this._allIndex = n;
  }
  _createCellCache(n, r) {
    for (let s = n.startRow; s <= n.endRow; s++) {
      let i = this._cellCache.get(s);
      i == null && (i = /* @__PURE__ */ new Map(), this._cellCache.set(s, i));
      for (let o = n.startColumn; o <= n.endColumn; o++)
        i.set(o, r);
    }
  }
  add(n) {
    this._mergeData.push(n), this._clearCache(), this._createCache(this._mergeData);
  }
  remove(n, r) {
    const s = this._getMergeDataIndex(n, r);
    s !== -1 && (this._mergeData.splice(s, 1), this._clearCache(), this._createCache(this._mergeData));
  }
  getMergedCell(n, r) {
    const s = this._getMergeDataIndex(n, r);
    return s !== -1 ? this._mergeData[s] : null;
  }
  /**
   * Return index of merge data if (row,col) is in merge range. -1 means not in merge range.
   * @param row
   * @param column
   * @returns {number} index of merge range.
   */
  getMergeDataIndex(n, r) {
    return this._getMergeDataIndex(n, r);
  }
  isRowContainsMergedCell(n) {
    return this._hasAll || !J.isEmptyObject(this._columnCache) ? true : this._mergeData.some((r) => r.startRow <= n && n <= r.endRow);
  }
  isColumnContainsMergedCell(n) {
    return this._hasAll || !J.isEmptyObject(this._rowCache) ? true : this._mergeData.some((r) => r.startColumn <= n && n <= r.endColumn);
  }
  getMergedCellRange(n, r, s, i) {
    const o = [], a = `${n}-${r}-${s}-${i}`;
    if (this._rangeMap.has(a))
      return this._getRangeFromCache(a);
    let l = 0;
    const u = [];
    for (const c of this._mergeData || [])
      En.intersects(c, {
        startRow: n,
        endRow: s,
        startColumn: r,
        endColumn: i
      }) && (o.push({
        ...c
      }), u.push(l)), l++;
    return this._rangeMap.set(a, u), o;
  }
  /**
   * @deprecated sigificant performance impact, use _getCellMergeInfo instead.
   * @param startRow
   * @param startColumn
   * @param endRow
   * @param endColumn
   */
  getMergedCellRangeForSkeleton(n, r, s, i) {
    const o = [], a = this._mergeData, l = `${n}-${r}-${s}-${i}`;
    if (this._skeletonCache.has(l))
      return this._getSkeletonRangeFromCache(l);
    const u = [];
    for (let c = 0; c < a.length; c++) {
      const {
        startRow: h,
        endRow: d,
        startColumn: f,
        endColumn: g
      } = a[c];
      for (let _ = n; _ <= s; _++) {
        let R = false;
        for (let b = r; b <= i; b++)
          if (_ >= h && _ <= d && b >= f && b <= g) {
            o.push({
              startRow: h,
              endRow: d,
              startColumn: f,
              endColumn: g
            }), u.push(c), R = true;
            break;
          }
        if (R)
          break;
      }
    }
    return this._skeletonCache.set(l, u), o;
  }
  _getRangeFromCache(n) {
    const r = this._rangeMap.get(n) || [], s = [];
    for (const i of r)
      s.push({
        ...this._mergeData[i]
      });
    return s;
  }
  _getSkeletonRangeFromCache(n) {
    const r = this._skeletonCache.get(n) || [], s = [];
    for (const i of r)
      s.push({
        ...this._mergeData[i]
      });
    return s;
  }
  _getMergeDataIndex(n, r) {
    var i;
    if (this._hasAll)
      return this._allIndex;
    if (this._hasRow) {
      const o = this._rowCache.get(n);
      if (o !== void 0)
        return o;
    }
    if (this._hasColumn) {
      const o = this._columnCache.get(r);
      if (o !== void 0)
        return o;
    }
    const s = (i = this._cellCache.get(n)) == null ? void 0 : i.get(r);
    return s !== void 0 ? s : -1;
  }
  getMergeDataSnapshot() {
    return this._mergeData;
  }
  dispose() {
    this._clearCache(), this._mergeData = [];
  }
};
var $E = class extends Ve {
  constructor(n) {
    super();
    p(this, "_cellContentInterceptor", null);
    p(this, "_rowFilteredInterceptor", null);
    this.getRawCell = n;
  }
  dispose() {
    super.dispose(), this._cellContentInterceptor = null, this._rowFilteredInterceptor = null;
  }
  getCell(n, r, s, i) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, sr.Value | sr.Style, s, i) : this.getRawCell(n, r);
  }
  getCellValueOnly(n, r) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, sr.Value) : this.getRawCell(n, r);
  }
  getCellStyleOnly(n, r) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, sr.Style) : this.getRawCell(n, r);
  }
  getRowFiltered(n) {
    var r, s;
    return (s = (r = this._rowFilteredInterceptor) == null ? void 0 : r.getRowFiltered(n)) != null ? s : false;
  }
  registerCellContentInterceptor(n) {
    if (this._cellContentInterceptor)
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    return this._cellContentInterceptor = n, We(() => this._cellContentInterceptor = null);
  }
  registerRowFilteredInterceptor(n) {
    if (this._rowFilteredInterceptor)
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    return this._rowFilteredInterceptor = n, We(() => this._rowFilteredInterceptor = null);
  }
};
var wl = {
  isDeepClone: false,
  displayRawFormula: false,
  ignoreTextRotation: false
};
var Is = class _Is {
  constructor(t, n, r) {
    p(this, "_sheetId");
    p(this, "_snapshot");
    p(this, "_cellData");
    p(this, "_rowManager");
    p(this, "_columnManager");
    p(this, "_viewModel");
    p(this, "_spanModel");
    p(this, "_isRowStylePrecedeColumnStyle", true);
    p(this, "_getCellHeight");
    var a;
    this.unitId = t, this._styles = r, this._snapshot = PE(n);
    const { columnData: s, rowData: i, cellData: o } = this._snapshot;
    this._sheetId = (a = this._snapshot.id) != null ? a : et(6), this._cellData = new pt(o), this._viewModel = new $E((l, u) => this.getCellRaw(l, u)), this._rowManager = new TE(this._snapshot, this._viewModel, i), this._columnManager = new yE(this._snapshot, s), this._spanModel = new FE(this._snapshot.mergeData);
  }
  /**
   * @internal
   * @param callback
   */
  __interceptViewModel(t) {
    t(this._viewModel);
  }
  /**
   * @internal
   * this is an internal method, please do not use it
   */
  __registerGetCellHeight(t) {
    return this._getCellHeight = t, We(() => {
      this._getCellHeight = null;
    });
  }
  getSnapshot() {
    return this._snapshot;
  }
  getCellHeight(t, n) {
    return this._getCellHeight ? this._getCellHeight(t, n) : this._snapshot.defaultRowHeight;
  }
  /**
   * Set the merge data of the sheet, all the merged cells will be rebuilt.
   * @param mergeData
   */
  setMergeData(t) {
    this._snapshot.mergeData = t, this.getSpanModel().rebuild(t);
  }
  getSpanModel() {
    return this._spanModel;
  }
  setIsRowStylePrecedeColumnStyle(t) {
    this._isRowStylePrecedeColumnStyle = t;
  }
  getStyleDataByHash(t) {
    return { ...this._styles.get(t) };
  }
  setStyleData(t) {
    return this._styles.setValue(t);
  }
  getColumnStyle(t, n = false) {
    return n ? this._columnManager.getColumnStyle(t) : this._styles.get(this._columnManager.getColumnStyle(t));
  }
  /**
   * Set the style of the column.
   * @param {number} column The column index
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setColumnStyle(t, n) {
    this._columnManager.setColumnStyle(t, n);
  }
  getRowStyle(t, n = false) {
    return n ? this._rowManager.getRowStyle(t) : this._styles.get(this._rowManager.getRowStyle(t));
  }
  /**
   * Set the style of the row.
   * @param {number} row
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setRowStyle(t, n) {
    this._rowManager.setRowStyle(t, n);
  }
  /**
   * Get the default style of the worksheet.
   * @returns {Nullable<IStyleData>} Default Style
   */
  getDefaultCellStyle() {
    return this._snapshot.defaultStyle;
  }
  getDefaultCellStyleInternal() {
    const t = this._snapshot.defaultStyle;
    return this._styles.get(t);
  }
  /**
   * Set Default Style, if the style has been set, all cells style will be base on this style.
   * @param {Nullable<IStyleData>} style The style to be set as default style
   */
  setDefaultCellStyle(t) {
    this._snapshot.defaultStyle = t;
  }
  getCellStyle(t, n) {
    const r = this.getCell(t, n);
    if (r) {
      const s = r.s;
      return typeof s == "string" ? this._styles.get(s) : s;
    }
    return null;
  }
  /**
   * Get the composed style of the cell. If you want to get the style of the cell without merging row style,
   * col style and default style, please use {@link getCellStyle} instead.
   *
   * @param {number} row The row index of the cell
   * @param {number} col The column index of the cell
   * @param {boolean} [rowPriority] If true, row style will precede column style, otherwise use this._isRowStylePrecedeColumnStyle
   * @returns {IStyleData} The composed style of the cell
   */
  getComposedCellStyle(t, n, r) {
    const s = this.getDefaultCellStyleInternal(), i = this.getRowStyle(t), o = this.getColumnStyle(n), a = this.getCell(t, n), l = this._styles.getStyleByCell(a);
    return (r != null ? r : this._isRowStylePrecedeColumnStyle) ? xr(s, o, i, a == null ? void 0 : a.themeStyle, l) : xr(s, i, o, a == null ? void 0 : a.themeStyle, l);
  }
  /**
   * Get the composed style of the cell. If you want to get the style of the cell without merging row style,
   * col style and default style, please use {@link getCellStyle} instead.
   * For performance reason, if you already have the cell data, you can use this method to avoid getting the cell data again.
   *
   * @param {number} row The row index of the cell
   * @param {number} col The column index of the cell
   * @param {Nullable<ICellDataForSheetInterceptor>} cellData The cell data of the cell.
   * @param {boolean} [rowPriority] If true, row style will precede column style, otherwise use this._isRowStylePrecedeColumnStyle
   * @returns {IStyleData} The composed style of the cell
   */
  getComposedCellStyleByCellData(t, n, r, s) {
    const i = this.getDefaultCellStyleInternal(), o = this.getRowStyle(t), a = this.getColumnStyle(n), l = this._styles.getStyleByCell(r);
    return (s != null ? s : this._isRowStylePrecedeColumnStyle) ? xr(i, a, o, r == null ? void 0 : r.themeStyle, l) : xr(i, o, a, r == null ? void 0 : r.themeStyle, l);
  }
  /**
   * Returns WorkSheet Cell Data Matrix
   * @returns WorkSheet Cell Data Matrix
   */
  getCellMatrix() {
    return this._cellData;
  }
  /**
   * Get worksheet printable cell range.
   * @returns
   */
  // eslint-disable-next-line max-lines-per-function
  getCellMatrixPrintRange() {
    const t = this.getCellMatrix(), n = this.getMergeData();
    let r = -1, s = -1, i = -1, o = -1, a = false, l = false;
    return t.forEach((u, c) => {
      Object.keys(c).forEach((h) => {
        const d = +h, f = t.getValue(u, d), g = f != null && f.s ? this._styles.get(f.s) : null, _ = (g == null ? void 0 : g.bd) && (g.bd.b || g.bd.l || g.bd.r || g.bd.t || g.bd.bc_tr || g.bd.bl_tr || g.bd.ml_tr || g.bd.tl_bc || g.bd.tl_br || g.bd.tl_mr);
        (f && (f.v !== null && f.v !== void 0 && f.v !== "" || f.p) || g != null && g.bg || _) && (a ? r = Math.min(r, u) : (r = u, a = true), s = Math.max(s, u), l ? i = Math.min(i, d) : (l = true, i = d), o = Math.max(o, d));
      });
    }), n.forEach((u) => {
      a ? r = Math.min(r, u.startRow) : (r = u.startRow, a = true), s = Math.max(s, u.endRow), l ? i = Math.min(i, u.startColumn) : (i = u.startColumn, a = true), o = Math.max(o, u.endColumn);
    }), !a || !l ? null : {
      startColumn: i,
      startRow: r,
      endColumn: o,
      endRow: s
    };
  }
  /**
   * Returns Row Manager
   * @returns Row Manager
   */
  getRowManager() {
    return this._rowManager;
  }
  /**
   * Returns the ID of its parent unit.
   */
  getUnitId() {
    return this.unitId;
  }
  /**
   * Returns the ID of the sheet represented by this object.
   * @returns ID of the sheet
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Returns Column Manager
   * @returns Column Manager
   */
  getColumnManager() {
    return this._columnManager;
  }
  /**
   * Returns the name of the sheet.
   * @returns name of the sheet
   */
  getName() {
    return this._snapshot.name;
  }
  /**
   * Returns WorkSheet Clone Object
   * @returns WorkSheet Clone Object
   * @deprecated
   */
  clone() {
    const { _snapshot: t } = this, n = J.deepClone(t);
    return new _Is(this.unitId, n, this._styles);
  }
  /**
   * Get the merged cell list of the sheet.
   * @returns {IRange[]} merged cell list
   */
  getMergeData() {
    return this._spanModel.getMergeDataSnapshot();
  }
  /**
   * Get the merged cell Range of the sheet cell.
   * If (row, col) is not in a merged cell, return null
   *
   * @param {number} row The row index of test cell
   * @param {number} col The column index of test cell
   * @returns {Nullable<IRange>} The merged cell range of the cell, if the cell is not in a merged cell, return null
   */
  getMergedCell(t, n) {
    return this._spanModel.getMergedCell(t, n);
  }
  /**
   * Get the merged cell info list which has intersection with the given range.
   * @param {number} startRow The start row index of the range
   * @param {number} startColumn The start column index of the range
   * @param {number} endRow The end row index of the range
   * @param {number} endColumn The end column index of the range
   * @returns {IRange} The merged cell info list which has intersection with the given range or empty array if no merged cell in the range
   */
  getMergedCellRange(t, n, r, s) {
    return this._spanModel.getMergedCellRange(t, n, r, s);
  }
  /**
   * Get if the row contains merged cell
   * @param {number} row The row index
   * @returns {boolean} Is merge cell across row
   */
  isRowContainsMergedCell(t) {
    return this._spanModel.isRowContainsMergedCell(t);
  }
  /**
   * Get if the column contains merged cell
   * @param {number} column The column index
   * @returns {boolean} Is merge cell across column
   */
  isColumnContainsMergedCell(t) {
    return this._spanModel.isColumnContainsMergedCell(t);
  }
  /**
   * Get cell info with merge data
   * @param {number} row - The row index of the cell.
   * @param {number} column - The column index of the cell.
   * @type {selectionCell}
   * @property {number} actualRow - The actual row index of the cell
   * @property {number} actualColumn - The actual column index of the cell
   * @property {boolean} isMergedMainCell - Whether the cell is the main cell of the merged cell, only the upper left cell in the merged cell returns true here
   * @property {boolean} isMerged - Whether the cell is in a merged cell, the upper left cell in the merged cell returns false here
   * @property {number} endRow - The end row index of the merged cell
   * @property {number} endColumn - The end column index of the merged cell
   * @property {number} startRow - The start row index of the merged cell
   * @property {number} startColumn - The start column index of the merged cell
   * @returns  {selectionCell} - The cell info with merge data
   */
  getCellInfoInMergeData(t, n) {
    const r = this.getMergedCell(t, n);
    let s = false, i = false, o = t, a = n, l = t, u = n;
    if (r) {
      const {
        startRow: c,
        endRow: h,
        startColumn: d,
        endColumn: f
      } = r;
      t === c && n === d ? (o = h, a = f, l = c, u = d, i = true) : t >= c && t <= h && n >= d && n <= f && (o = h, a = f, l = c, u = d, s = true);
    }
    return {
      actualRow: t,
      actualColumn: n,
      isMergedMainCell: i,
      isMerged: s,
      endRow: o,
      endColumn: a,
      startRow: l,
      startColumn: u
    };
  }
  /**
   * Get cellData, includes cellData, customRender, markers, dataValidate, etc.
   *
   * WARNING: All sheet CELL_CONTENT interceptors will be called in this method, cause performance issue.
   * example: this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT);
   *
   * @param row
   * @param col
   * @returns ICellDataForSheetInterceptor
   */
  getCell(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCell(t, n);
  }
  /**
   * Get cellData only use effect on value interceptor
   * @param {number} number row The row index of the cell.
   * @param {number} number col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on value interceptor
   */
  getCellValueOnly(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCellValueOnly(t, n);
  }
  /**
   * Get cellData only use effect on style interceptor
   * @param {number} row The row index of the cell.
   * @param {number} col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on style interceptor
   */
  getCellStyleOnly(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCellStyleOnly(t, n);
  }
  getCellRaw(t, n) {
    return this.getCellMatrix().getValue(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  getCellWithFilteredInterceptors(t, n, r, s) {
    return this._viewModel.getCell(t, n, r, s);
  }
  getRowFiltered(t) {
    return this._viewModel.getRowFiltered(t);
  }
  /**
   * Get the filtered out rows in a given range. used for remove rows operation, etc.
   * @param range - The range to get filtered rows from.
   * @returns {number[]} An array of row indices that are filtered out within the specified range.
   */
  getRangeFilterRows(t) {
    const n = [];
    for (let r = t.startRow; r <= t.endRow; r++)
      this.getRowFiltered(r) && n.push(r);
    return n;
  }
  getMatrixWithMergedCells(t, n, r, s, i = or.Raw) {
    const o = this.getCellMatrix(), a = this._spanModel.getMergedCellRange(t, n, r, s), l = new pt();
    return cl(t, r, n, s).forEach((u, c) => {
      var d;
      let h;
      if (i === or.Raw)
        h = this.getCellRaw(u, c);
      else if (i === or.Intercepted)
        h = this.getCell(u, c);
      else if (i === or.Both) {
        const f = this.getCellRaw(u, c);
        if (f) {
          h = { ...f };
          const g = (d = this.getCell(u, c)) == null ? void 0 : d.v;
          vE(g) && h && (h.displayV = String(g));
        }
      }
      h && l.setValue(u, c, h);
    }), a.forEach((u) => {
      const { startColumn: c, startRow: h, endColumn: d, endRow: f } = u;
      cl(h, f, c, d).forEach((g, _) => {
        g === h && _ === c && l.setValue(g, _, {
          ...o.getValue(g, _),
          rowSpan: f - h + 1,
          colSpan: d - c + 1
        }), (g !== h || _ !== c) && l.realDeleteValue(g, _);
      });
    }), l;
  }
  getRange(t, n, r, s) {
    return typeof t == "object" ? new Or(this, t, {
      getStyles: () => this._styles
    }) : new Or(
      this,
      {
        startRow: t,
        startColumn: n,
        endColumn: s || n,
        endRow: r || t
      },
      {
        getStyles: () => this._styles
      }
    );
  }
  getScrollLeftTopFromSnapshot() {
    return {
      scrollLeft: this._snapshot.scrollLeft,
      scrollTop: this._snapshot.scrollTop
    };
  }
  /**
   * Return WorkSheetZoomRatio
   * @return zoomRatio
   */
  getZoomRatio() {
    return this._snapshot.zoomRatio || 1;
  }
  /**
   * Returns WorkSheet Configures
   * @returns WorkSheet Configures
   */
  getConfig() {
    return this._snapshot;
  }
  /**
   * Returns  frozen.
   * @returns  frozen
   */
  getFreeze() {
    return this._snapshot.freeze;
  }
  /**
   * Returns the current number of columns in the sheet, regardless of content.
   * @returns the current number of columns in the sheet, regardless of content
   */
  getMaxColumns() {
    const { _snapshot: t } = this, { columnCount: n } = t;
    return n;
  }
  /**
   * Returns the current number of rows in the sheet, regardless of content.
   * @returns the current number of rows in the sheet, regardless of content
   */
  getMaxRows() {
    const { _snapshot: t } = this, { rowCount: n } = t;
    return n;
  }
  getRowCount() {
    return this._snapshot.rowCount;
  }
  setRowCount(t) {
    this._snapshot.rowCount = t;
  }
  getColumnCount() {
    return this._snapshot.columnCount;
  }
  setColumnCount(t) {
    this._snapshot.columnCount = t;
  }
  /**
   * isSheetHidden
   * @returns hidden status of sheet
   */
  isSheetHidden() {
    return this._snapshot.hidden;
  }
  /**
   * Returns true if the sheet's gridlines are hidden; otherwise returns false. Gridlines are visible by default.
   * @returns {boolean} Gridlines Hidden Status.
   */
  hasHiddenGridlines() {
    const { _snapshot: t } = this, { showGridlines: n } = t;
    return n === 0;
  }
  /**
   * Returns the color of the gridlines, or undefined if the gridlines are not colored.
   * @returns {string | undefined} returns the color of the gridlines, or undefined if the gridlines are default.
   */
  getGridlinesColor() {
    return this.getConfig().gridlinesColor;
  }
  /**
   * Gets the sheet tab color, or null if the sheet tab has no color.
   * @returns the sheet tab color or null
   */
  getTabColor() {
    const { _snapshot: t } = this, { tabColor: n } = t;
    return n;
  }
  /**
   * Gets the width in pixels of the given column.
   * @param columnPosition column index
   * @returns Gets the width in pixels of the given column.
   */
  getColumnWidth(t) {
    return this.getColumnManager().getColumnWidth(t);
  }
  /**
   * Gets the height in pixels of the given row.
   * @param row row index
   * @returns Gets the height in pixels of the given row.
   */
  getRowHeight(t) {
    return this._viewModel.getRowFiltered(t) ? 0 : this.getRowManager().getRowHeight(t);
  }
  /**
   * Row is filtered out, that means this row is invisible.
   * @param row
   * @returns {boolean} is row hidden by filter
   */
  isRowFiltered(t) {
    return this._viewModel.getRowFiltered(t);
  }
  /**
   * Get if the row is visible. It may be affected by features like filter and view.
   * @param row the row index
   * @returns {boolean} if the row in visible to the user
   */
  getRowVisible(t) {
    return !this.isRowFiltered(t) && this.getRowRawVisible(t);
  }
  /**
   * Get if the row does not have `hidden` property. This value won't affected by features like filter and view.
   * @param row the row index
   * @returns if the row does not have `hidden` property
   */
  getRowRawVisible(t) {
    return this.getRowManager().getRowRawVisible(t);
  }
  getHiddenRows(t, n) {
    const r = this.getMaxColumns() - 1, s = this._rowManager.getHiddenRows(t, n);
    return s.forEach((i) => i.endColumn = r), s;
  }
  getColVisible(t) {
    return this._columnManager.getColVisible(t);
  }
  getHiddenCols(t, n) {
    const r = this.getMaxRows() - 1, s = this._columnManager.getHiddenCols(t, n);
    return s.forEach((i) => i.endRow = r), s;
  }
  /**
   * Get all visible rows in the sheet.(not include filter & view, like getRawVisibleRows)
   * @returns Visible rows range list
   */
  getVisibleRows() {
    const t = this.getRowCount();
    return this._rowManager.getVisibleRows(0, t - 1);
  }
  /**
   * Get all visible columns in the sheet.(not include filter & view)
   * @returns Visible columns range list
   */
  getVisibleCols() {
    const t = this.getColumnCount();
    return this._columnManager.getVisibleCols(0, t - 1);
  }
  /**
   * Returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   * @returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   */
  isRightToLeft() {
    const { _snapshot: t } = this, { rightToLeft: n } = t;
    return n;
  }
  /**
   * Returns the position of the last row that has content.
   * @returns the position of the last row that has content.
   */
  getLastRowWithContent() {
    return this._cellData.getLength() - 1;
  }
  /**
   * Returns the position of the last column that has content.
   * @returns the position of the last column that has content.
   */
  getLastColumnWithContent() {
    return this._cellData.getRange().endColumn;
  }
  getDataRangeScope() {
    return this._cellData.getStartEndScope();
  }
  cellHasValue(t) {
    return t && (t.v !== void 0 || t.f !== void 0 || t.p !== void 0);
  }
  // #region iterators
  // NOTE: performance intensive. Should keep an eye on methods in this region.
  /**
   * Iterate a range row by row.
   *
   * Performance intensive.
   *
   * @param range the iterate range
   * @param skipEmpty whether to skip empty cells, default to be `true`
   */
  iterateByRow(t, n = true) {
    const { startRow: r, startColumn: s, endRow: i, endColumn: o } = t, a = this;
    return {
      [Symbol.iterator]: () => {
        let l = r, u = s;
        return {
          next() {
            for (; ; ) {
              if (u > o && (l += 1, u = s), l > i)
                return { done: true, value: void 0 };
              const c = a.getCell(l, u), h = !c, d = a.getMergedCell(l, u);
              if (d) {
                if (l !== d.startRow || u !== d.startColumn) {
                  u = d.endColumn + 1;
                  continue;
                }
                if (h && n) {
                  u = d.endColumn + 1;
                  continue;
                }
                const g = { row: l, col: u, value: c };
                return g.colSpan = d.endColumn - d.startColumn + 1, g.rowSpan = d.endRow - d.startRow + 1, u = d.endColumn + 1, { done: false, value: g };
              }
              if (h && n)
                u += 1;
              else {
                const f = { row: l, col: u, value: c };
                return u += 1, { done: false, value: f };
              }
            }
          }
        };
      }
    };
  }
  /**
   * Iterate a range column by column. This is pretty similar to `iterateByRow` but with different order.
   *
   * Performance intensive.
   *
   * @param range The iterate range.
   * @param skipEmpty Whether to skip empty cells, default to be `true`.
   * @param skipNonTopLeft Whether to skip non-top-left cells of merged cells, default to be `true`. If the
   * parameter is set to `false`, the iterator will return cells in the top row.
   */
  iterateByColumn(t, n = true, r = true) {
    const { startRow: s, startColumn: i, endRow: o, endColumn: a } = t, l = this;
    return {
      [Symbol.iterator]: () => {
        let u = s, c = i;
        return {
          next() {
            for (; ; ) {
              if (u > o && (c += 1, u = s), c > a)
                return { done: true, value: void 0 };
              const h = l.getMergedCell(u, c);
              if (h) {
                const g = u !== h.startRow, _ = g || c !== h.startColumn;
                if (r && _ || !r && g) {
                  u = h.endRow + 1;
                  continue;
                }
                const R = l.getCell(h.startRow, h.startColumn);
                if (!R && n) {
                  u = h.endRow + 1;
                  continue;
                }
                const H = { row: u, col: h.startColumn, value: R };
                return H.colSpan = h.endColumn - h.startColumn + 1, H.rowSpan = h.endRow - h.startRow + 1, u = h.endRow + 1, { done: false, value: H };
              }
              const d = l.getCell(u, c);
              if (!d && n)
                u += 1;
              else {
                const g = { row: u, col: c, value: d };
                return u += 1, { done: false, value: g };
              }
            }
          }
        };
      }
    };
  }
  /**
   * This method generates a document model based on the cell's properties and handles the associated styles and configurations.
   * If the cell does not exist, it will return null.
   * PS: This method has significant impact on performance.
   * @param cell
   * @param options
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  getCellDocumentModel(t, n, r = wl) {
    var _;
    if (!t)
      return;
    const { isDeepClone: s, displayRawFormula: i, ignoreTextRotation: o } = {
      ...wl,
      ...r
    };
    let a, l = "document";
    const u = SE(n), c = o ? rt.tr : u.textRotation || rt.tr;
    let h = u.horizontalAlign || rt.ht;
    const d = u.verticalAlign || rt.vt, f = u.wrapStrategy || rt.tb, g = u.paddingData || Wi;
    if (t.f && i)
      a = Jr(t.f.toString(), {}, { verticalAlign: d }), h = rt.ht;
    else if (t.p) {
      const { centerAngle: R, vertexAngle: b } = ac(c);
      a = this._updateConfigAndGetDocumentModel(
        s ? J.deepClone(t.p) : t.p,
        h,
        g,
        {
          horizontalAlign: h,
          verticalAlign: d,
          centerAngle: R,
          vertexAngle: b,
          wrapStrategy: f,
          zeroWidthParagraphBreak: 1
        }
      );
    } else if (t.v != null) {
      const R = Rl(n);
      l = Il(R).fontCache;
      let b = HE(t);
      t.t === fn.FORCE_STRING && i && (b = `'${b}`), a = Jr(b, R, {
        ...u,
        textRotation: c,
        cellValueType: t.t
      });
    }
    return a && t.linkUrl && t.linkId && OE(a, t.linkUrl, t.linkId), {
      documentModel: a,
      fontString: l,
      textRotation: c,
      wrapStrategy: f,
      verticalAlign: d,
      horizontalAlign: h,
      paddingData: g,
      fill: (_ = n == null ? void 0 : n.bg) == null ? void 0 : _.rgb
    };
  }
  _updateConfigAndGetDocumentModel(t, n, r, s) {
    var o, a, l, u, c;
    if (!s || !((o = t.body) != null && o.dataStream))
      return;
    t.documentStyle || (t.documentStyle = {}), t.documentStyle.marginTop = (a = r.t) != null ? a : 0, t.documentStyle.marginBottom = (l = r.b) != null ? l : 2, t.documentStyle.marginLeft = (u = r.l) != null ? u : 2, t.documentStyle.marginRight = (c = r.r) != null ? c : 2, t.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    }, t.documentStyle.renderConfig = {
      ...t.documentStyle.renderConfig,
      ...s
    };
    const i = t.body.paragraphs || [];
    for (const h of i)
      h.paragraphStyle || (h.paragraphStyle = {}), h.paragraphStyle.horizontalAlign = n;
    return new Pt(t);
  }
  /**
   * Only used for cell edit, and no need to rotate text when edit cell content!
   */
  getBlankCellDocumentModel(t, n, r) {
    const s = this.getComposedCellStyleByCellData(n, r, t), i = Rl(s), o = this.getCellDocumentModel(t, s, { ignoreTextRotation: true });
    if (o != null)
      return o.documentModel == null && (o.documentModel = Jr("", i)), o;
    const a = "";
    let l = "document";
    const u = rt.tr, c = rt.ht, h = rt.vt, d = rt.tb, f = Wi;
    return l = Il({}).fontCache, {
      documentModel: Jr(a, i),
      fontString: l,
      textRotation: u,
      wrapStrategy: d,
      verticalAlign: h,
      horizontalAlign: c,
      paddingData: f
    };
  }
  // Only used for cell edit, and no need to rotate text when edit cell content!
  getCellDocumentModelWithFormula(t, n, r) {
    const s = this.getComposedCellStyleByCellData(n, r, t);
    return this.getCellDocumentModel(t, s, {
      isDeepClone: true,
      displayRawFormula: true,
      ignoreTextRotation: true
    });
  }
  /**
   * Get custom metadata of worksheet
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(t) {
    this._snapshot.custom = t;
  }
};
function HE(e) {
  var r, s;
  if (!e)
    return "";
  const t = (s = (r = e.p) == null ? void 0 : r.body) == null ? void 0 : s.dataStream;
  if (t)
    return Je.transform.getPlainText(t);
  const n = e.v;
  return typeof n == "string" ? e.t === fn.BOOLEAN ? n.toUpperCase() : n.replace(/[\r\n]/g, "") : typeof n == "number" ? e.t === fn.BOOLEAN ? n ? "TRUE" : "FALSE" : n.toString() : typeof n == "boolean" ? n ? "TRUE" : "FALSE" : "";
}
function GR(e) {
  if (e === null)
    return "";
  if (e != null && e.p) {
    const t = e == null ? void 0 : e.p.body;
    if (t == null)
      return "";
    const n = t.dataStream;
    return Je.transform.getPlainText(n);
  }
  return e == null ? void 0 : e.v;
}
var BE = Object.getOwnPropertyDescriptor;
var jE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? BE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var WE = (e, t) => (n, r) => t(n, r, e);
function KR(e, t) {
  return `${e.getUnitId()}|${t.getSheetId()}`;
}
var ws = class extends lo {
  constructor(t = {}, n) {
    super();
    p(this, "type", we.UNIVER_SHEET);
    p(this, "_sheetCreated$", new Subject());
    p(this, "sheetCreated$", this._sheetCreated$.asObservable());
    p(this, "_sheetDisposed$", new Subject());
    p(this, "sheetDisposed$", this._sheetDisposed$.asObservable());
    p(this, "_activeSheet$", new BehaviorSubject(null));
    p(this, "activeSheet$", this._activeSheet$.asObservable());
    p(this, "_worksheets");
    p(this, "_styles");
    p(this, "_snapshot");
    p(this, "_unitId");
    p(this, "_count");
    p(this, "_name$");
    p(this, "name$");
    this._logService = n;
    const r = RE();
    J.isEmptyObject(t) ? this._snapshot = r : this._snapshot = J.commonExtend(r, t);
    const { styles: s } = this._snapshot;
    (this._snapshot.id == null || this._snapshot.id.length === 0) && (this._snapshot.id = et(6)), this._unitId = this._snapshot.id, this._styles = new IE(s), this._count = 1, this._worksheets = /* @__PURE__ */ new Map(), this._name$ = new BehaviorSubject(t.name || ""), this.name$ = this._name$.asObservable(), this._parseWorksheetSnapshots();
  }
  get _activeSheet() {
    return this._activeSheet$.getValue();
  }
  get name() {
    return this._name$.getValue();
  }
  static isIRangeType(t) {
    return typeof t == "string" || "startRow" in t || "row" in t;
  }
  dispose() {
    super.dispose(), this._sheetCreated$.complete(), this._sheetDisposed$.complete(), this._activeSheet$.complete(), this._name$.complete();
  }
  /**
   * Create a clone of the current snapshot.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @memberof Workbook
   */
  save() {
    return J.deepClone(this._snapshot);
  }
  /**
   * Get current snapshot reference.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @return {*}  {IWorkbookData}
   * @memberof Workbook
   */
  getSnapshot() {
    return this._snapshot;
  }
  /** @deprecated use use name property instead */
  getName() {
    return this._snapshot.name;
  }
  setName(t) {
    this._name$.next(t), this._snapshot.name = t;
  }
  getUnitId() {
    return this._unitId;
  }
  getRev() {
    var t;
    return (t = this._snapshot.rev) != null ? t : 1;
  }
  incrementRev() {
    this._snapshot.rev = this.getRev() + 1;
  }
  setRev(t) {
    this._snapshot.rev = t;
  }
  /**
   * Add a Worksheet into Workbook.
   */
  addWorksheet(t, n, r) {
    const { sheets: s, sheetOrder: i } = this._snapshot;
    if (s[t])
      return false;
    s[t] = r, i.splice(n, 0, t);
    const o = new Is(this._unitId, r, this._styles);
    return this._worksheets.set(t, o), this._sheetCreated$.next(o), true;
  }
  getSheetOrders() {
    return this._snapshot.sheetOrder;
  }
  getWorksheets() {
    return this._worksheets;
  }
  getActiveSpreadsheet() {
    return this;
  }
  getStyles() {
    return this._styles;
  }
  addStyles(t) {
    Object.entries(t).forEach(([n, r]) => {
      this._styles.addCustomStyle(n, r);
    });
  }
  removeStyles(t) {
    t.forEach((n) => {
      this._styles.remove(n);
    });
  }
  getConfig() {
    return this._snapshot;
  }
  getIndexBySheetId(t) {
    const { sheetOrder: n } = this._snapshot;
    return n.findIndex((r) => r === t);
  }
  getActiveSheet(t) {
    if (!this._activeSheet && typeof t > "u")
      throw new Error(`[Workbook]: no active Worksheet on Workbook ${this._unitId}!`);
    return this._activeSheet;
  }
  /**
   * If there is no active sheet, the first sheet would
   * be set active.
   * @returns
   */
  ensureActiveSheet() {
    const t = this._activeSheet;
    if (t)
      return t;
    const n = this._snapshot.sheetOrder;
    for (let s = 0, i = n.length; s < i; s++) {
      const o = this._worksheets.get(n[s]);
      if (o && o.isSheetHidden() !== ie.TRUE)
        return this.setActiveSheet(o), o;
    }
    const r = this._worksheets.get(n[0]);
    return this.setActiveSheet(r), r;
  }
  /**
   * ActiveSheet should not be null!
   * There is at least one sheet in a workbook. You can not delete all sheets in a workbook.
   * @param worksheet
   */
  setActiveSheet(t) {
    this._activeSheet$.next(t);
  }
  removeSheet(t) {
    const n = this._worksheets.get(t);
    return n ? (this._worksheets.delete(t), this._snapshot.sheetOrder.splice(this._snapshot.sheetOrder.indexOf(t), 1), delete this._snapshot.sheets[t], this._sheetDisposed$.next(n), true) : false;
  }
  getActiveSheetIndex() {
    const { sheetOrder: t } = this._snapshot;
    return t.findIndex((n) => this._worksheets.get(n) === this._activeSheet);
  }
  getSheetSize() {
    return this._snapshot.sheetOrder.length;
  }
  getSheets() {
    const { sheetOrder: t } = this._snapshot;
    return t.map((n) => this._worksheets.get(n));
  }
  getSheetsName() {
    const { sheetOrder: t } = this._snapshot, n = [];
    return t.forEach((r) => {
      const s = this._worksheets.get(r);
      s && n.push(s.getName());
    }), n;
  }
  getSheetIndex(t) {
    const { sheetOrder: n } = this._snapshot;
    return n.findIndex((r) => t.getSheetId() === r);
  }
  getSheetBySheetName(t) {
    const { sheetOrder: n } = this._snapshot, r = n.find((s) => this._worksheets.get(s).getName() === t);
    return this._worksheets.get(r);
  }
  getSheetBySheetId(t) {
    return this._worksheets.get(t);
  }
  getSheetByIndex(t) {
    const { sheetOrder: n } = this._snapshot;
    return this._worksheets.get(n[t]);
  }
  getHiddenWorksheets() {
    return this.getSheets().filter((t) => t.getConfig().hidden === ie.TRUE).map((t) => t.getConfig().id);
  }
  getUnhiddenWorksheets() {
    return this.getSheets().filter((t) => t.getConfig().hidden !== ie.TRUE).map((t) => t.getConfig().id);
  }
  load(t) {
    this._snapshot = t;
  }
  /**
   * Check if sheet name is unique
   * @param name sheet name
   * @returns True if sheet name is unique
   */
  checkSheetName(t) {
    return this.getSheetsName().includes(t);
  }
  /**
   *  Check whether the sheet name is unique and generate a new unique sheet name
   * @param name sheet name
   * @returns Unique sheet name
   */
  uniqueSheetName(t = "Sheet1") {
    let n = t;
    for (; this.checkSheetName(n); )
      n = t + this._count, this._count++;
    return n;
  }
  /**
   * Automatically generate new sheet name
   * @param name sheet name
   * @returns New sheet name
   */
  generateNewSheetName(t) {
    let n = t + this._count;
    for (; this.checkSheetName(n); )
      n = t + this._count, this._count++;
    return n;
  }
  // FIXME: now we always create worksheet from DEFAULT_WORKSHEET?
  /**
   * Get Default Sheet
   */
  _parseWorksheetSnapshots() {
    const { _snapshot: t, _worksheets: n } = this, { sheets: r, sheetOrder: s } = t;
    if (J.isEmptyObject(r)) {
      const i = et();
      r[i] = { id: i };
    }
    for (const i in r) {
      const o = r[i], { name: a } = o;
      o.name = this.uniqueSheetName(a), o.name !== a && this._logService.debug("[Workbook]", `The worksheet name ${a} is duplicated, we changed it to ${o.name}. Please fix the problem in your snapshot.`);
      const l = new Is(this._unitId, o, this._styles);
      n.set(i, l), s.includes(i) || s.push(i);
    }
    this.ensureActiveSheet();
  }
  /**
   * Get custom metadata of workbook
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(t) {
    this._snapshot.custom = t;
  }
};
ws = jE([
  WE(1, yt)
], ws);
var lc = class extends lo {
  constructor(n) {
    var r;
    super();
    p(this, "type", we.UNIVER_SLIDE);
    p(this, "_activePage$", new BehaviorSubject(null));
    p(this, "activePage$", this._activePage$.asObservable());
    p(this, "_name$");
    p(this, "name$");
    p(this, "_snapshot");
    p(this, "_unitId");
    this._snapshot = { ...Mp, ...n }, this._unitId = (r = this._snapshot.id) != null ? r : et(6), this._name$ = new BehaviorSubject(this._snapshot.title), this.name$ = this._name$.asObservable();
  }
  get _activePage() {
    var r, s;
    const n = this._activePage$.getValue();
    if (!n) {
      const i = (r = this.getPageOrder()) == null ? void 0 : r[0];
      return i ? (s = this.getPages()) == null ? void 0 : s[i] : null;
    }
    return n;
  }
  setName(n) {
    var r;
    this._snapshot.title = n, this._name$.next(n), this._unitId = (r = this._snapshot.id) != null ? r : et(6);
  }
  getRev() {
    return 0;
  }
  incrementRev() {
  }
  setRev(n) {
  }
  getSnapshot() {
    return this._snapshot;
  }
  getUnitId() {
    return this._unitId;
  }
  getPages() {
    var n;
    return (n = this._snapshot.body) == null ? void 0 : n.pages;
  }
  getPageOrder() {
    var n;
    return (n = this._snapshot.body) == null ? void 0 : n.pageOrder;
  }
  getPage(n) {
    const r = this.getPages();
    return r == null ? void 0 : r[n];
  }
  getElementsByPage(n) {
    var r;
    return (r = this.getPage(n)) == null ? void 0 : r.pageElements;
  }
  getElement(n, r) {
    var s;
    return (s = this.getElementsByPage(n)) == null ? void 0 : s[r];
  }
  getPageSize() {
    return this._snapshot.pageSize;
  }
  getBlankPage() {
    const n = et(6);
    return {
      id: n,
      pageType: cu.SLIDE,
      zIndex: 10,
      title: n,
      description: "",
      pageBackgroundFill: {
        rgb: "rgb(255,255,255)"
      },
      pageElements: {}
    };
  }
  setActivePage(n) {
    this._activePage$.next(n);
  }
  getActivePage() {
    return this._activePage;
  }
  updatePage(n, r) {
    this._snapshot.body && (this._snapshot.body.pages[n] = r);
  }
  appendPage(n) {
    var i;
    if (!this._snapshot.body) return;
    this._snapshot.body.pages[n.id] = n;
    const r = this._activePage, s = this._snapshot.body.pageOrder.indexOf((i = r == null ? void 0 : r.id) != null ? i : "");
    this._snapshot.body.pageOrder.splice(s + 1, 0, n.id);
  }
};
var YE = Object.getOwnPropertyDescriptor;
var zE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? YE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var Sl = (e, t) => (n, r) => t(n, r, e);
var vr = createIdentifier("univer.current");
var Yi = class extends Ve {
  constructor(t, n) {
    super();
    p(this, "_unitsByType", /* @__PURE__ */ new Map());
    p(this, "_createHandler");
    p(this, "_ctorByType", /* @__PURE__ */ new Map());
    p(this, "_currentUnits", /* @__PURE__ */ new Map());
    p(this, "_currentUnits$", new BehaviorSubject(this._currentUnits));
    p(this, "currentUnits$", this._currentUnits$.asObservable());
    p(this, "_unitAdded$", new Subject());
    p(this, "unitAdded$", this._unitAdded$.asObservable());
    p(this, "_unitDisposed$", new Subject());
    p(this, "unitDisposed$", this._unitDisposed$.asObservable());
    p(this, "_focused$", new BehaviorSubject(null));
    p(this, "focused$", this._focused$.asObservable());
    this._injector = t, this._contextService = n;
  }
  dispose() {
    super.dispose(), this._focused$.complete(), this._currentUnits$.complete(), this._unitAdded$.complete(), this._currentUnits.clear(), this._unitsByType.clear();
  }
  __setCreateHandler(t) {
    this._createHandler = t;
  }
  createUnit(t, n, r) {
    return this._createHandler(t, n, this._ctorByType.get(t), r);
  }
  registerCtorForType(t, n) {
    return this._ctorByType.set(t, n), {
      dispose: () => {
        this._ctorByType.delete(t);
      }
    };
  }
  getCurrentTypeOfUnit$(t) {
    return this.currentUnits$.pipe(map((n) => {
      var r;
      return (r = n.get(t)) != null ? r : null;
    }), distinctUntilChanged());
  }
  getCurrentUnitForType(t) {
    return this._currentUnits.get(t);
  }
  getCurrentUnitOfType(t) {
    return this.getCurrentUnitForType(t);
  }
  setCurrentUnitForType(t) {
    const n = this._getUnitById(t);
    if (!n) throw new Error(`[UniverInstanceService]: no document with unitId ${t}!`);
    this._currentUnits.set(n[1], n[0]), this._currentUnits$.next(this._currentUnits);
  }
  getTypeOfUnitAdded$(t) {
    return this._unitAdded$.pipe(filter((n) => n.type === t));
  }
  /**
   * Add a unit into Univer.
   *
   * @ignore
   *
   * @param unit The unit to be added.
   */
  __addUnit(t, n) {
    var o;
    const r = t.type;
    this._unitsByType.has(r) || this._unitsByType.set(r, []);
    const s = this._unitsByType.get(r), i = t.getUnitId();
    if (s.findIndex((a) => a.getUnitId() === i) !== -1)
      throw new Error(`[UniverInstanceService]: cannot create a unit with the same unit id: ${i}.`);
    s.push(t), this._unitAdded$.next(t), ((o = n == null ? void 0 : n.makeCurrent) == null || o) && this.setCurrentUnitForType(t.getUnitId());
  }
  getTypeOfUnitDisposed$(t) {
    return this.unitDisposed$.pipe(filter((n) => n.type === t));
  }
  getUnit(t, n) {
    var s;
    const r = (s = this._getUnitById(t)) == null ? void 0 : s[0];
    return n && (r == null ? void 0 : r.type) !== n ? null : r;
  }
  getCurrentUniverDocInstance() {
    return this.getCurrentUnitForType(we.UNIVER_DOC);
  }
  getUniverDocInstance(t) {
    return this.getUnit(t, we.UNIVER_DOC);
  }
  getUniverSheetInstance(t) {
    return this.getUnit(t, we.UNIVER_SHEET);
  }
  getAllUnitsForType(t) {
    var n;
    return (n = this._unitsByType.get(t)) != null ? n : [];
  }
  changeDoc(t, n) {
    const r = this.getAllUnitsForType(we.UNIVER_DOC), s = r.find((i) => i.getUnitId() === t);
    if (s != null) {
      const i = r.indexOf(s);
      r.splice(i, 1);
    }
    this.__addUnit(n);
  }
  get focused() {
    var n;
    const t = this._focused$.getValue();
    return t ? (n = this._getUnitById(t)) == null ? void 0 : n[0] : null;
  }
  focusUnit(t) {
    this._focused$.next(t), this.focused instanceof ws ? (this._contextService.setContextValue(Xr, true), this._contextService.setContextValue(qr, false), this._contextService.setContextValue(gr, true), this._contextService.setContextValue(Zr, false), this.setCurrentUnitForType(t)) : this.focused instanceof Pt ? (this._contextService.setContextValue(Xr, true), this._contextService.setContextValue(qr, true), this._contextService.setContextValue(gr, false), this._contextService.setContextValue(Zr, false), this.setCurrentUnitForType(t)) : this.focused instanceof lc ? (this._contextService.setContextValue(Xr, true), this._contextService.setContextValue(qr, false), this._contextService.setContextValue(gr, false), this._contextService.setContextValue(Zr, true), this.setCurrentUnitForType(t)) : (this._contextService.setContextValue(Xr, false), this._contextService.setContextValue(qr, false), this._contextService.setContextValue(gr, false), this._contextService.setContextValue(Zr, false));
  }
  getFocusedUnit() {
    return this.focused;
  }
  getUnitType(t) {
    const n = this._getUnitById(t);
    return n ? n[1] : we.UNRECOGNIZED;
  }
  disposeUnit(t) {
    const n = this._getUnitById(t);
    if (!n) return false;
    const [r, s] = n, i = this._unitsByType.get(s), o = i.indexOf(r);
    return i.splice(o, 1), this._tryResetCurrentOnRemoval(t, s), this._tryResetFocusOnRemoval(t), this._unitDisposed$.next(r), true;
  }
  _tryResetCurrentOnRemoval(t, n) {
    const r = this.getCurrentUnitForType(n);
    (r == null ? void 0 : r.getUnitId()) === t && (this._currentUnits.set(n, null), this._currentUnits$.next(this._currentUnits));
  }
  _tryResetFocusOnRemoval(t) {
    var n;
    ((n = this.focused) == null ? void 0 : n.getUnitId()) === t && this._focused$.next(null);
  }
  _getUnitById(t) {
    for (const [n, r] of this._unitsByType) {
      const s = r.find((i) => i.getUnitId() === t);
      if (s)
        return [s, n];
    }
  }
};
Yi = zE([
  Sl(0, Inject(Injector)),
  Sl(1, Nr)
], Yi);
var ke = ((e) => (e[e.Starting = 0] = "Starting", e[e.Ready = 1] = "Ready", e[e.Rendered = 2] = "Rendered", e[e.Steady = 3] = "Steady", e))(ke || {});
var uc = {
  0: "Starting",
  1: "Ready",
  2: "Rendered",
  3: "Steady"
};
var VE = Object.getOwnPropertyDescriptor;
var GE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? VE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var KE = (e, t) => (n, r) => t(n, r, e);
var XE = class extends Error {
  constructor(t) {
    super(`[LifecycleService]: lifecycle stage "${uc[t]}" will never be reached!`), this.name = "LifecycleUnreachableError";
  }
};
var Wn = class extends Ve {
  constructor(t) {
    super();
    p(this, "_lifecycle$", new BehaviorSubject(ke.Starting));
    p(this, "lifecycle$", this._lifecycle$.asObservable());
    p(this, "_lock", false);
    this._logService = t, this._reportProgress(ke.Starting);
  }
  get stage() {
    return this._lifecycle$.getValue();
  }
  set stage(t) {
    if (this._lock) throw new Error("[LifecycleService]: cannot set new stage when related logic is all handled!");
    if (t < this.stage) throw new Error("[LifecycleService]: lifecycle stage cannot go backward!");
    t !== this.stage && (this._lock = true, this._reportProgress(t), this._lifecycle$.next(t), this._lock = false);
  }
  dispose() {
    this._lifecycle$.complete(), super.dispose();
  }
  /**
   * Wait for a specific lifecycle stage to be reached.
   * @param stage The lifecycle stage to wait for.
   * If the current stage is already at or beyond the specified stage, it will
   * resolve immediately.
   * If the specified stage is unreachable, it will reject with a
   * `LifecycleUnreachableError`.
   * @returns A promise that resolves when the specified stage is reached.
   */
  onStage(t) {
    return firstValueFrom(this.lifecycle$.pipe(
      filter((n) => n >= t),
      xa((n) => n === t),
      map(() => {
      })
    )).catch((n) => n.name === "EmptyError" ? Promise.reject(new XE(t)) : Promise.reject(n));
  }
  /**
   * Subscribe to lifecycle changes and all previous stages and the current
   * stage will be emitted immediately.
   * @returns An observable that emits the lifecycle stages, including the current
   */
  subscribeWithPrevious() {
    return merge(cc(this.stage), this._lifecycle$.pipe(skip(1))).pipe(xa((t) => t === ke.Steady));
  }
  _reportProgress(t) {
    this._logService.debug("[LifecycleService]", `lifecycle progressed to "${uc[t]}".`);
  }
};
Wn = GE([
  KE(0, yt)
], Wn);
function cc(e) {
  switch (e) {
    case ke.Starting:
      return of(ke.Starting);
    case ke.Ready:
      return of(ke.Starting, ke.Ready);
    case ke.Rendered:
      return of(ke.Starting, ke.Ready, ke.Rendered);
    default:
      return of(
        ke.Starting,
        ke.Ready,
        ke.Rendered,
        ke.Steady
      );
  }
}
var XR = createIdentifier("ILocalStorageService");
var Fn = class extends Ve {
  constructor() {
    super();
    p(this, "_currentLocale$", new BehaviorSubject(Ns.ZH_CN));
    p(this, "currentLocale$", this._currentLocale$.asObservable());
    p(this, "_locales", null);
    p(this, "localeChanged$", new Subject());
    p(this, "t", (n, ...r) => {
      if (!this._locales) throw new Error("[LocaleService]: Locale not initialized");
      const s = n.split("."), i = this.resolveKeyPath(this._locales[this._currentLocale], s);
      if (typeof i == "string") {
        let o = i;
        return r.forEach((a, l) => {
          o = o.replace(`{${l}}`, a);
        }), o;
      } else
        return n;
    });
    this.disposeWithMe(We(() => {
      this._locales = null, this._currentLocale$.complete(), this.localeChanged$.complete();
    }));
  }
  get _currentLocale() {
    return this._currentLocale$.value;
  }
  /**
   * Load more locales after init.
   *
   * @param locales - Locale object
   */
  load(n) {
    var r;
    this._locales = oo((r = this._locales) != null ? r : {}, n);
  }
  setLocale(n) {
    this._currentLocale$.next(n), this.localeChanged$.next();
  }
  getLocales() {
    var n;
    return (n = this._locales) == null ? void 0 : n[this._currentLocale];
  }
  getCurrentLocale() {
    return this._currentLocale;
  }
  resolveKeyPath(n, r) {
    const s = r.shift();
    if (s && n && s in n) {
      const i = n[s];
      return r.length > 0 && (typeof i == "object" || Array.isArray(i)) ? this.resolveKeyPath(i, r) : i;
    }
    return null;
  }
};
var qE = Object.getOwnPropertyDescriptor;
var ZE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? qE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var JE = (e, t) => (n, r) => t(n, r, e);
var zi = class {
  constructor(e) {
    this._userManagerService = e;
  }
  async list(e) {
    return {
      list: [{
        type: Ii.PERSON,
        mentions: [
          {
            objectType: Ii.PERSON,
            objectId: this._userManagerService.getCurrentUser().userID,
            label: this._userManagerService.getCurrentUser().name,
            metadata: {
              icon: this._userManagerService.getCurrentUser().avatar
            }
          }
        ],
        metadata: {},
        title: "PEOPLE"
      }],
      page: e.page,
      size: e.size,
      total: 1
    };
  }
};
zi = ZE([
  JE(0, Inject(Rs))
], zi);
var QE = createIdentifier("univer.service.mention-io");
var hc = ((e) => (e.INIT = "init", e.FETCHING = "fetching", e.DONE = "done", e))(hc || {});
var eC = createIdentifier("univer.permission-service");
var tC = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_permissionPointMap", /* @__PURE__ */ new Map());
    p(this, "_permissionPointUpdate$", new Subject());
    p(this, "permissionPointUpdate$", this._permissionPointUpdate$.asObservable());
    p(this, "_showComponents", true);
  }
  setShowComponents(n) {
    this._showComponents = n;
  }
  getShowComponents() {
    return this._showComponents;
  }
  deletePermissionPoint(n) {
    const r = this._permissionPointMap.get(n);
    r && (r.complete(), this._permissionPointMap.delete(n));
  }
  addPermissionPoint(n) {
    const r = n instanceof BehaviorSubject, s = r ? n.getValue() : n;
    return s.id ? this._permissionPointMap.get(s.id) ? (console.warn(`${s.id} PermissionPoint already exists`), false) : (this._permissionPointMap.set(s.id, r ? n : new BehaviorSubject(s)), this._permissionPointUpdate$.next(s), true) : false;
  }
  updatePermissionPoint(n, r) {
    const s = this._permissionPointMap.get(n);
    if (!s)
      return;
    const i = s.getValue();
    i.value = r, i.status = hc.DONE, s.next(i), this._permissionPointUpdate$.next(i);
  }
  clearPermissionMap() {
    this._permissionPointMap.clear();
  }
  getPermissionPoint(n) {
    const r = this._permissionPointMap.get(n);
    if (r)
      return r.getValue();
  }
  getPermissionPoint$(n) {
    const r = this._permissionPointMap.get(n);
    if (r)
      return r;
  }
  composePermission$(n) {
    const r = n.map((s) => {
      var o;
      const i = (o = this._permissionPointMap) == null ? void 0 : o.get(s);
      if (!i)
        throw new Error(`[PermissionService]: ${s} permissionPoint does not exist!`);
      return i.asObservable();
    });
    return combineLatest(r).pipe(
      // Check that all permissions exist
      map((s) => s)
    );
  }
  composePermission(n) {
    return n.map((s) => {
      var o;
      const i = (o = this._permissionPointMap) == null ? void 0 : o.get(s);
      if (!i)
        throw new Error(`[PermissionService]: ${s} permissionPoint does not exist!`);
      return i.getValue();
    });
  }
  getAllPermissionPoint() {
    const n = /* @__PURE__ */ new Map();
    return this._permissionPointMap.forEach((r, s) => {
      n.set(s, r);
    }), n;
  }
};
function nC(e, t) {
  if (!t) return e;
  const n = [];
  for (const r of e) {
    const s = t.find(([i]) => i === r[0]);
    if (s) {
      if (s[1] === null) continue;
      n.push([r[0], s[1]]);
    } else
      n.push(r);
  }
  return n;
}
var rC = Object.getOwnPropertyDescriptor;
var sC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? rC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var di = (e, t) => (n, r) => t(n, r, e);
var iC = 4;
var dc = Symbol("DependentOn");
var Ol = class extends Ve {
  onStarting() {
  }
  onReady() {
  }
  onRendered() {
  }
  onSteady() {
  }
  getUnitType() {
    return this.constructor.type;
  }
  getPluginName() {
    return this.constructor.pluginName;
  }
};
p(Ol, "pluginName"), p(Ol, "type", we.UNIVER_UNKNOWN);
var oC = class {
  constructor() {
    p(this, "_plugins", []);
  }
  addPlugin(t) {
    this._plugins.push(t);
  }
  removePlugins() {
    const t = this._plugins.slice();
    return this._plugins.length = 0, t;
  }
  forEachPlugin(t) {
    this._plugins.forEach(t);
  }
};
function qR(...e) {
  return function(t) {
    t[dc] = e;
  };
}
var Ss = class {
  constructor(e, t, n) {
    p(this, "_pluginRegistry", /* @__PURE__ */ new Map());
    p(this, "_pluginStore", new oC());
    p(this, "_seenPlugins", /* @__PURE__ */ new Set());
    p(this, "_loadedPlugins", /* @__PURE__ */ new Set());
    p(this, "_loadedPluginTypes", /* @__PURE__ */ new Set([we.UNIVER_UNKNOWN]));
    p(this, "_flushTimerByType", /* @__PURE__ */ new Map());
    this._injector = e, this._lifecycleService = t, this._logService = n;
  }
  dispose() {
    this._pluginStore.removePlugins().forEach((e) => e.dispose()), this._flushTimerByType.forEach((e) => clearTimeout(e));
  }
  /**
   * Register a plugin into univer.
   * @param {PluginCtor} ctor The plugin's constructor.
   * @param {ConstructorParameters} [config] The configuration for the plugin.
   */
  registerPlugin(e, t) {
    this._assertPluginValid(e);
    const n = { plugin: e, options: t };
    this._pluginRegistry.set(e.pluginName, n), this._logService.debug("[PluginService]", `Plugin "${e.pluginName}" registered.`);
    const { type: r } = e;
    this._loadedPluginTypes.has(r) && (r === we.UNIVER_UNKNOWN ? this._loadFromPlugins([n]) : this._flushType(r));
  }
  startPluginsForType(e) {
    this._loadedPluginTypes.has(e) || this._loadPluginsForType(e);
  }
  _loadPluginsForType(e) {
    const t = Array.from(this._pluginRegistry.keys()), n = [];
    t.forEach((r) => {
      const s = this._pluginRegistry.get(r);
      s.plugin.type === e && n.push(s);
    }), this._loadFromPlugins(n), this._loadedPluginTypes.add(e);
  }
  _assertPluginValid(e) {
    const { type: t, pluginName: n } = e;
    if (t === we.UNRECOGNIZED)
      throw new Error(`[PluginService]: invalid plugin type for ${e.name}. Please assign a "type" to your plugin.`);
    if (!n)
      throw new Error(`[PluginService]: no plugin name for ${e.name}. Please assign a "pluginName" to your plugin.`);
    if (this._seenPlugins.has(n))
      throw new Error(`[PluginService]: duplicated plugin name for "${n}". Maybe a plugin that dependents on "${n} has already registered it. In that case please register "${n}" before the that plugin.`);
    this._seenPlugins.add(e.pluginName);
  }
  _flushType(e) {
    this._flushTimerByType.get(e) === void 0 && this._flushTimerByType.set(e, setTimeout(() => {
      this._loadPluginsForType(e), this._flushTimerByType.delete(e);
    }, iC));
  }
  _loadFromPlugins(e) {
    const t = [], n = /* @__PURE__ */ new Set(), r = (i) => {
      const { plugin: o } = i, { pluginName: a } = o;
      if (this._loadedPlugins.has(a) || n.has(a))
        return;
      n.add(a), this._pluginRegistry.delete(a);
      const l = o[dc];
      l && l.forEach((u) => {
        const c = this._pluginRegistry.get(u.pluginName);
        if (c)
          r(c);
        else if (!this._seenPlugins.has(u.pluginName) && !n.has(u.pluginName)) {
          if (o.type === we.UNIVER_UNKNOWN && u.type !== we.UNIVER_UNKNOWN)
            throw new Error(
              `[PluginService]: cannot register a plugin with Univer type that depends on a plugin with other type. The dependent is ${o.pluginName} and the dependency is ${u.pluginName}.`
            );
          o.type !== u.type && u.type !== we.UNIVER_UNKNOWN && this._logService.debug(
            "[PluginService]",
            `Plugin "${a}" depends on "${u.pluginName}" which has different type.`
          ), this._logService.debug(
            "[PluginService]",
            `Plugin "${a}" depends on "${u.pluginName}" which is not registered. Univer will automatically register it with default configuration.`
          ), this._assertPluginValid(u), r({ plugin: u, options: void 0 });
        }
      }), t.push(i);
    };
    e.forEach((i) => r(i));
    const s = t.map((i) => this._initPlugin(i.plugin, i.options));
    this._pluginsRunLifecycle(s);
  }
  _pluginsRunLifecycle(e) {
    const t = this._lifecycleService.stage;
    if (cc(t).subscribe((n) => this._runStage(e, n)), t !== ke.Steady) {
      const n = this._lifecycleService.lifecycle$.pipe(
        skip(1)
      ).subscribe((r) => {
        this._runStage(e, r), r === ke.Steady && n.unsubscribe();
      });
    }
  }
  _runStage(e, t) {
    e.forEach((n) => {
      switch (t) {
        case ke.Starting:
          n.onStarting();
          break;
        case ke.Ready:
          n.onReady();
          break;
        case ke.Rendered:
          n.onRendered();
          break;
        case ke.Steady:
          n.onSteady();
          break;
      }
    });
  }
  _initPlugin(e, t) {
    const n = this._injector.createInstance(e, t);
    return this._pluginStore.addPlugin(n), this._loadedPlugins.add(e.pluginName), this._logService.debug("[PluginService]", `Plugin "${n.getPluginName()}" loaded.`), n;
  }
};
Ss = sC([
  di(0, Inject(Injector)),
  di(1, Inject(Wn)),
  di(2, yt)
], Ss);
var vl = createIdentifier("resource-loader-service");
var aC = Object.getOwnPropertyDescriptor;
var lC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? aC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var uC = (e, t) => (n, r) => t(n, r, e);
var Vi = class extends Ve {
  constructor(t) {
    super();
    p(this, "_resourceMap", /* @__PURE__ */ new Map());
    p(this, "_register$", new Subject());
    p(this, "register$", this._register$.asObservable());
    this._logService = t;
  }
  getAllResourceHooks() {
    return [...this._resourceMap.values()];
  }
  getResources(t, n) {
    return n ? this.getResourcesByType(t, n) : this.getAllResourceHooks().map((i) => {
      const o = i.toJson(t);
      return {
        name: i.pluginName,
        data: o
      };
    });
  }
  getResourcesByType(t, n) {
    return this.getAllResourceHooks().filter((i) => i.businesses.includes(n)).map((i) => {
      const o = i.toJson(t);
      return {
        name: i.pluginName,
        data: o
      };
    });
  }
  registerPluginResource(t) {
    const n = t.pluginName;
    if (this._resourceMap.has(n))
      throw new Error(`the pluginName is registered {${n}}`);
    return this._resourceMap.set(n, t), this._register$.next(t), We(() => this._resourceMap.delete(n));
  }
  disposePluginResource(t) {
    this._resourceMap.delete(t);
  }
  loadResources(t, n) {
    this.getAllResourceHooks().forEach((r) => {
      var i;
      const s = (i = n == null ? void 0 : n.find((o) => o.name === r.pluginName)) == null ? void 0 : i.data;
      if (s)
        try {
          const o = r.parseJson(s);
          r.onLoad(t, o);
        } catch (o) {
          this._logService.error("[ResourceManagerService]", "loadResources error", o);
        }
    });
  }
  unloadResources(t, n) {
    this.getAllResourceHooks().filter((r) => r.businesses.includes(n)).forEach((r) => {
      r.onUnLoad(t);
    });
  }
  dispose() {
    this._register$.complete(), this._resourceMap.clear();
  }
};
Vi = lC([
  uC(0, yt)
], Vi);
var Gi = class extends Ve {
  constructor() {
    super();
    p(this, "_darkMode$", new BehaviorSubject(false));
    p(this, "darkMode$", this._darkMode$.asObservable());
    p(this, "_validColorCache", /* @__PURE__ */ new Map());
    p(this, "_currentTheme", F);
    p(this, "_currentTheme$", new BehaviorSubject(this._currentTheme));
    p(this, "currentTheme$", this._currentTheme$.asObservable());
    this.disposeWithMe(We(() => {
      this._currentTheme = F, this._currentTheme$.complete(), this._darkMode$.complete();
    }));
  }
  get darkMode() {
    return this._darkMode$.getValue();
  }
  /**
   * Whether the given color is a valid theme color.
   * A valid theme color can be a direct key in the theme object or a nested key with a dot notation.
   * For example:
   * @param {string} color - The color string to validate.
   * @returns {boolean} True if the color is valid, false otherwise.
   * @example
   * isValidThemeColor('primary.600'); // true
   * isValidThemeColor('blue'); // false
   */
  isValidThemeColor(n) {
    if (this._validColorCache.has(n))
      return this._validColorCache.get(n);
    let r = false;
    const s = n.split(".");
    if (s.length === 1)
      r = n in F;
    else if (s.length === 2) {
      const [i, o] = s;
      r = i in F && o in this._currentTheme[i];
    }
    return this._validColorCache.set(n, r), r;
  }
  /**
   * Get the current theme.
   * @returns The current theme.
   */
  getCurrentTheme() {
    return this._currentTheme;
  }
  /**
   * Set the current theme.
   * @param theme - The new theme to set.
   */
  setTheme(n) {
    this._currentTheme = n, this._currentTheme$.next(n);
  }
  /**
   * Get the current theme as an observable.
   * @param {boolean} darkMode - Whether to set the theme in dark mode.
   */
  setDarkMode(n) {
    this._darkMode$.next(n);
  }
  /**
   * Get a color from the current theme.
   * @param {string} color - The color key to retrieve.
   * @returns {string} The color value from the current theme.
   */
  getColorFromTheme(n) {
    return vf(this._currentTheme, n);
  }
};
var cC = Object.getOwnPropertyDescriptor;
var hC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? cC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var fi = (e, t) => (n, r) => t(n, r, e);
var Qo = createIdentifier("univer.undo-redo.service");
var dC = 20;
var fc = class {
  dispose() {
  }
  async dispatchToHandlers() {
    return false;
  }
};
var fC = "univer.command.redo";
var mC = "univer.command.undo";
var gC = new class extends fc {
  constructor() {
    super(...arguments);
    p(this, "type", Ms.COMMAND);
    p(this, "id", mC);
  }
  handler(t) {
    const n = t.get(Qo), r = n.pitchTopUndoElement();
    if (!r)
      return false;
    const s = t.get(Ls);
    return fo(r.undoMutations, s) ? (n.popUndoToRedo(), true) : false;
  }
}();
var _C = new class extends fc {
  constructor() {
    super(...arguments);
    p(this, "type", Ms.COMMAND);
    p(this, "id", fC);
  }
  handler(t) {
    const n = t.get(Qo), r = n.pitchTopRedoElement();
    if (!r)
      return false;
    const s = t.get(Ls);
    return fo(r.redoMutations, s) ? (n.popRedoToUndo(), true) : false;
  }
}();
var Ki = class extends Ve {
  constructor(t, n, r) {
    super();
    p(this, "undoRedoStatus$");
    p(this, "_undoRedoStatus$", new BehaviorSubject({ undos: 0, redos: 0 }));
    p(this, "_undoStacks", /* @__PURE__ */ new Map());
    p(this, "_redoStacks", /* @__PURE__ */ new Map());
    p(this, "_batchingStatus", /* @__PURE__ */ new Map());
    this._univerInstanceService = t, this._commandService = n, this._contextService = r, this.undoRedoStatus$ = this._undoRedoStatus$.asObservable(), this.disposeWithMe(this._commandService.registerCommand(gC)), this.disposeWithMe(this._commandService.registerCommand(_C)), this.disposeWithMe(We(() => this._undoRedoStatus$.complete())), this.disposeWithMe(We(this._univerInstanceService.focused$.subscribe(() => this._updateStatus())));
  }
  pushUndoRedo(t) {
    const { unitID: n } = t, r = this._getRedoStack(n, true), s = this._getUndoStack(n, true);
    if (r.length = 0, this._batchingStatus.has(t.unitID)) {
      const o = this._batchingStatus.get(t.unitID), a = this._pitchUndoElement(t.unitID);
      o === 0 || !a ? (i(t), this._batchingStatus.set(
        t.unitID,
        1
        /* CREATED */
      )) : this._tryBatchingElements(a, t);
    } else
      i(t);
    function i(o) {
      s.push(o), s.length > dC && s.splice(0, 1);
    }
    this._updateStatus();
  }
  clearUndoRedo(t) {
    const n = this._getRedoStack(t);
    n && (n.length = 0);
    const r = this._getUndoStack(t);
    r && (r.length = 0), this._updateStatus();
  }
  pitchTopUndoElement() {
    const t = this._getFocusedUnitId();
    return this._pitchUndoElement(t);
  }
  pitchTopRedoElement() {
    const t = this._getFocusedUnitId();
    return this._pitchRedoElement(t);
  }
  _pitchUndoElement(t) {
    const n = this._getUndoStack(t);
    return n != null && n.length ? n[n.length - 1] : null;
  }
  _pitchRedoElement(t) {
    const n = this._getRedoStack(t);
    return n != null && n.length ? n[n.length - 1] : null;
  }
  popUndoToRedo() {
    const n = this._getUndoStackForFocused().pop();
    n && (this._getRedoStackForFocused().push(n), this._updateStatus());
  }
  popRedoToUndo() {
    const n = this._getRedoStackForFocused().pop();
    n && (this._getUndoStackForFocused().push(n), this._updateStatus());
  }
  rollback(t, n) {
    const r = n || this._getFocusedUnitId(), s = this._getUndoStack(r), i = s == null ? void 0 : s[(s == null ? void 0 : s.length) - 1];
    i && i.id === t && (s.pop(), fo(i.undoMutations, this._commandService));
  }
  __tempBatchingUndoRedo(t) {
    if (this._batchingStatus.has(t))
      throw new Error("[LocalUndoRedoService]: cannot batching undo redo twice at the same time!");
    return this._batchingStatus.set(
      t,
      0
      /* WAITING */
    ), We(() => this._batchingStatus.delete(t));
  }
  _updateStatus() {
    var s, i;
    const t = this._getFocusedUnitId(), n = t && ((s = this._undoStacks.get(t)) == null ? void 0 : s.length) || 0, r = t && ((i = this._redoStacks.get(t)) == null ? void 0 : i.length) || 0;
    this._undoRedoStatus$.next({
      undos: n,
      redos: r
    });
  }
  _getUndoStack(t, n = false) {
    let r = this._undoStacks.get(t);
    return !r && n && (r = [], this._undoStacks.set(t, r)), r || null;
  }
  _getRedoStack(t, n = false) {
    let r = this._redoStacks.get(t);
    return !r && n && (r = [], this._redoStacks.set(t, r)), r || null;
  }
  _getUndoStackForFocused() {
    const t = this._getFocusedUnitId();
    if (!t)
      throw new Error("No focused univer instance!");
    return this._getUndoStack(t, true);
  }
  _getRedoStackForFocused() {
    const t = this._getFocusedUnitId();
    if (!t)
      throw new Error("No focused univer instance!");
    return this._getRedoStack(t, true);
  }
  _tryBatchingElements(t, n) {
    t.redoMutations.push(...n.redoMutations), t.undoMutations.push(...n.undoMutations);
  }
  _getFocusedUnitId() {
    var i, o, a, l;
    let t = "";
    const n = this._contextService.getContextValue(gr), r = this._contextService.getContextValue(gE), s = this._contextService.getContextValue(mE);
    return n ? r ? t = Ul : s ? t = Dl : t = (o = (i = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : i.getUnitId()) != null ? o : "" : t = (l = (a = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : a.getUnitId()) != null ? l : "", t;
  }
};
Ki = hC([
  fi(0, vr),
  fi(1, Ls),
  fi(2, Nr)
], Ki);
var pC = class {
  constructor(t, n = 100) {
    p(this, "_imageCacheMap");
    this._injector = t, this._imageCacheMap = new gs(n);
  }
  _getImageCacheKey(t, n) {
    return `${t}-${n}`;
  }
  getImage(t, n, r, s) {
    const i = this._getImageCacheKey(t, n), o = this._imageCacheMap.get(i);
    return o || ((async () => {
      const a = new Image(), l = this._injector.has(El) ? this._injector.get(El) : null;
      if (t === oc.UUID)
        try {
          a.src = await (l == null ? void 0 : l.getImage(n)) || "";
        } catch (u) {
          console.error(u);
        }
      else
        a.src = n;
      a.onload = () => {
        a.removeAttribute("data-error"), r == null || r();
      }, a.onerror = () => {
        a.setAttribute("data-error", "true"), s == null || s();
      }, this._imageCacheMap.set(i, a);
    })(), null);
  }
};
function ZR(e) {
  return !(e.length === 0 || e.length > 31 || e.startsWith("'") || e.endsWith("'") || /[:\\\/\?\*\[\]]/.test(e));
}
function JR(e, t) {
  return !(!e || e.length === 0 || e.length > 255 || t.has(e) || /[ :\\\/\?\*\[\]]/.test(e) || !/^[\p{L}_]/u.test(e) || /^\$?[A-Za-z]{1,3}\$?[0-9]+$/.test(e) || /^[rR]\d+[cC]\d+$/.test(e) || /^\d+$/.test(e));
}
var bl = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var mi = 1;
var tr = 8;
var ea = class _ea {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const s = r >> 4;
    if (s !== mi)
      throw new Error(`Got v${s} data when expected v${mi}.`);
    const i = bl[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [o] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new _ea(a, o, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, s) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = bl.indexOf(this.ArrayType), o = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    s && s instanceof ArrayBuffer ? (this.data = s, this.ids = new this.IndexArrayType(this.data, tr, t), this.coords = new this.ArrayType(this.data, tr + a + l, t * 2), this._pos = t * 2, this._finished = true) : (this.data = new ArrayBuffer(tr + o + a + l), this.ids = new this.IndexArrayType(this.data, tr, t), this.coords = new this.ArrayType(this.data, tr + a + l, t * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (mi << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Xi(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, s) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: o, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, h = l.pop() || 0, d = l.pop() || 0;
      if (h - d <= a) {
        for (let R = d; R <= h; R++) {
          const b = o[2 * R], H = o[2 * R + 1];
          b >= t && b <= r && H >= n && H <= s && u.push(i[R]);
        }
        continue;
      }
      const f = d + h >> 1, g = o[2 * f], _ = o[2 * f + 1];
      g >= t && g <= r && _ >= n && _ <= s && u.push(i[f]), (c === 0 ? t <= g : n <= _) && (l.push(d), l.push(f - 1), l.push(1 - c)), (c === 0 ? r >= g : s >= _) && (l.push(f + 1), l.push(h), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: s, coords: i, nodeSize: o } = this, a = [0, s.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, h = a.pop() || 0, d = a.pop() || 0;
      if (h - d <= o) {
        for (let R = d; R <= h; R++)
          Al(i[2 * R], i[2 * R + 1], t, n) <= u && l.push(s[R]);
        continue;
      }
      const f = d + h >> 1, g = i[2 * f], _ = i[2 * f + 1];
      Al(g, _, t, n) <= u && l.push(s[f]), (c === 0 ? t - r <= g : n - r <= _) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= _) && (a.push(f + 1), a.push(h), a.push(1 - c));
    }
    return l;
  }
};
function Xi(e, t, n, r, s, i) {
  if (s - r <= n) return;
  const o = r + s >> 1;
  mc(e, t, o, r, s, i), Xi(e, t, n, r, o - 1, 1 - i), Xi(e, t, n, o + 1, s, 1 - i);
}
function mc(e, t, n, r, s, i) {
  for (; s > r; ) {
    if (s - r > 600) {
      const u = s - r + 1, c = n - r + 1, h = Math.log(u), d = 0.5 * Math.exp(2 * h / 3), f = 0.5 * Math.sqrt(h * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), g = Math.max(r, Math.floor(n - c * d / u + f)), _ = Math.min(s, Math.floor(n + (u - c) * d / u + f));
      mc(e, t, n, g, _, i);
    }
    const o = t[2 * n + i];
    let a = r, l = s;
    for (nr(e, t, r, n), t[2 * s + i] > o && nr(e, t, r, s); a < l; ) {
      for (nr(e, t, a, l), a++, l--; t[2 * a + i] < o; ) a++;
      for (; t[2 * l + i] > o; ) l--;
    }
    t[2 * r + i] === o ? nr(e, t, r, l) : (l++, nr(e, t, l, s)), l <= n && (r = l + 1), n <= l && (s = l - 1);
  }
}
function nr(e, t, n, r) {
  gi(e, n, r), gi(t, 2 * n, 2 * r), gi(t, 2 * n + 1, 2 * r + 1);
}
function gi(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Al(e, t, n, r) {
  const s = e - n, i = t - r;
  return s * s + i * i;
}
var QR = class {
  constructor(t = false) {
    p(this, "_tree", /* @__PURE__ */ new Map());
    p(this, "_oneCellCache", /* @__PURE__ */ new Map());
    p(this, "_kdTree", /* @__PURE__ */ new Map());
    this._enableOneCellCache = t;
  }
  dispose() {
    this.clear();
  }
  getTree(t, n) {
    return this._tree.has(t) || this._tree.set(t, /* @__PURE__ */ new Map()), this._tree.get(t).has(n) || this._tree.get(t).set(n, new Di()), this._tree.get(t).get(n);
  }
  _getOneCellCache(t, n, r, s) {
    return this._oneCellCache.has(t) || this._oneCellCache.set(t, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).has(n) || this._oneCellCache.get(t).set(n, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).get(n).has(r) || this._oneCellCache.get(t).get(n).set(r, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).get(n).get(r).has(s) || this._oneCellCache.get(t).get(n).get(r).set(s, /* @__PURE__ */ new Set()), this._oneCellCache.get(t).get(n).get(r).get(s);
  }
  _removeOneCellCache(t, n, r, s, i) {
    const o = this._oneCellCache.get(t);
    if (!o) return;
    const a = o.get(n);
    if (!a) return;
    const l = a.get(r);
    if (!l) return;
    const u = l.get(s);
    u && u.delete(i);
  }
  _removeCellCacheByRange(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, o = this._oneCellCache.get(n);
    if (!o) return;
    const a = o.get(r);
    if (!a) return;
    const { startRow: l, startColumn: u, endRow: c, endColumn: h } = s;
    for (let d = l; d <= c; d++) {
      const f = a.get(d);
      if (f)
        for (let g = u; g <= h; g++) {
          const _ = f.get(g);
          _ && _.delete(i);
        }
    }
  }
  _insertOneCellCache(t, n, r, s, i) {
    this._getOneCellCache(t, n, r, s).add(i);
  }
  _getRdTreeItems(t) {
    const n = [];
    for (const [r, s] of t)
      for (const [i, o] of s)
        n.push({
          x: i,
          y: r,
          ids: o
        });
    return n;
  }
  _searchByOneCellCache(t) {
    var g;
    const { unitId: n, sheetId: r, range: s } = t, { startRow: i, startColumn: o, endRow: a, endColumn: l } = s, u = (g = this._kdTree.get(n)) == null ? void 0 : g.get(r);
    if (!u)
      return [];
    const { tree: c, items: h } = u, d = c.range(o, i, l, a), f = [];
    for (const _ of d) {
      const R = h[_];
      f.push(...Array.from(R.ids));
    }
    return f;
  }
  /**
   * Open the kd-tree search state.
   * The kd-tree is used to search for data in a single cell.
   */
  openKdTree() {
    var t;
    for (const [n, r] of this._oneCellCache) {
      this._kdTree.has(n) || this._kdTree.set(n, /* @__PURE__ */ new Map());
      for (const [s, i] of r) {
        const o = this._getRdTreeItems(i), a = new ea(o.length);
        (t = this._kdTree.get(n)) == null || t.set(s, {
          tree: a,
          items: o
        });
        for (const l of o)
          a.add(l.x, l.y);
        a.finish();
      }
    }
  }
  closeKdTree() {
    var t;
    for (const [n, r] of this._oneCellCache)
      for (const [s, i] of r)
        (t = this._kdTree.get(n)) == null || t.set(s, void 0);
  }
  insert(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t;
    if (!n || n.length === 0)
      return;
    let { startRow: o, endRow: a, startColumn: l, endColumn: u } = s;
    if (this._enableOneCellCache && o === a && l === u) {
      this._insertOneCellCache(n, r, o, l, i);
      return;
    }
    const c = this.getTree(n, r);
    Number.isNaN(o) && (o = 0), Number.isNaN(l) && (l = 0), Number.isNaN(a) && (a = Number.POSITIVE_INFINITY), Number.isNaN(u) && (u = Number.POSITIVE_INFINITY), c.insert({
      minX: l,
      minY: o,
      maxX: u,
      maxY: a,
      id: i
    });
  }
  bulkInsert(t) {
    for (const n of t)
      this.insert(n);
  }
  *searchGenerator(t) {
    var a;
    const { unitId: n, sheetId: r, range: s } = t;
    if (this._enableOneCellCache) {
      const l = this._searchByOneCellCache(t);
      for (const u of l)
        yield u;
    }
    const i = (a = this._tree.get(n)) == null ? void 0 : a.get(r);
    if (!i)
      return;
    const o = i.search({
      minX: s.startColumn,
      minY: s.startRow,
      maxX: s.endColumn,
      maxY: s.endRow
    });
    for (const l of o)
      yield l.id;
  }
  bulkSearch(t, n) {
    const r = /* @__PURE__ */ new Set();
    for (const s of t)
      for (const i of this.searchGenerator(s))
        (n == null ? void 0 : n.has(i)) !== true && r.add(i);
    return r;
  }
  removeById(t, n) {
    var r, s;
    n ? ((r = this._tree.get(t)) == null || r.delete(n), (s = this._oneCellCache.get(t)) == null || s.delete(n)) : (this._tree.delete(t), this._oneCellCache.delete(t));
  }
  _removeRTreeItem(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, o = this.getTree(n, r), a = o.search({
      minX: s.startColumn,
      minY: s.startRow,
      maxX: s.endColumn,
      maxY: s.endRow
    });
    for (let l = 0; l < a.length; l++)
      a[l].id === i && o.remove(a[l]);
  }
  remove(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, { startRow: o, startColumn: a, endRow: l, endColumn: u } = s;
    this._enableOneCellCache ? o === l && a === u ? this._removeOneCellCache(n, r, s.startRow, s.startColumn, i) : (this._removeCellCacheByRange(t), this._removeRTreeItem(t)) : this._removeRTreeItem(t);
  }
  bulkRemove(t) {
    for (const n of t)
      this.remove(n);
  }
  clear() {
    this._tree.clear(), this._oneCellCache.clear();
  }
  toJSON() {
    const t = {};
    return this._tree.forEach((n, r) => {
      t[r] = {}, n.forEach((s, i) => {
        t[r][i] = s.toJSON();
      });
    }), t;
  }
  fromJSON(t) {
    this._tree.clear();
    for (const n in t) {
      this._tree.set(n, /* @__PURE__ */ new Map());
      for (const r in t[n]) {
        const s = new Di();
        s.fromJSON(t[n][r]), this._tree.get(n).set(r, s);
      }
    }
  }
};
function eI(e) {
  return new Promise((t) => setTimeout(t, e));
}
function tI(e = 1) {
  return new Promise((t) => {
    let n = 0;
    const r = () => {
      n++, n >= e ? t() : requestAnimationFrame(r);
    };
    requestAnimationFrame(r);
  });
}
var EC = Object.getOwnPropertyDescriptor;
var CC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? EC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var RC = (e, t) => (n, r) => t(n, r, e);
var qi = class extends Ve {
  constructor(t) {
    super();
    p(this, "_fontLocale");
    p(this, "_dirty", true);
    this._localeService = t, this._localeInitial();
  }
  get dirty() {
    return this._dirty;
  }
  getFontLocale() {
    return this._fontLocale;
  }
  makeDirty(t) {
    this._dirty = t;
  }
  dispose() {
    super.dispose(), this._fontLocale = null;
  }
  _localeInitial() {
  }
};
qi = CC([
  RC(0, Inject(Fn))
], qi);
var IC = Object.getOwnPropertyDescriptor;
var wC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? IC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var Qr = (e, t) => (n, r) => t(n, r, e);
var yl = class extends qi {
  constructor(t, n, r, s, i, o) {
    super(r);
    p(this, "_worksheetData");
    p(this, "_renderRawFormula", false);
    p(this, "_cellData");
    p(this, "_imageCacheMap");
    p(this, "_skipAutoHeightForMergedCells", true);
    p(this, "_rowTotalHeight", 0);
    p(this, "_columnTotalWidth", 0);
    p(this, "_rowHeaderWidth", 0);
    p(this, "_columnHeaderHeight", 0);
    p(this, "_rowHeightAccumulation", []);
    p(this, "_columnWidthAccumulation", []);
    p(this, "_marginTop", 0);
    p(this, "_marginLeft", 0);
    p(this, "_scaleX");
    p(this, "_scaleY");
    p(this, "_scrollX");
    p(this, "_scrollY");
    this.worksheet = t, this._styles = n, this._contextService = s, this._configService = i, this._injector = o, this._worksheetData = this.worksheet.getConfig(), this._cellData = this.worksheet.getCellMatrix(), this._imageCacheMap = new pC(this._injector), this.initConfig();
  }
  initConfig() {
    var t, n;
    this._skipAutoHeightForMergedCells = !((t = this._configService.getConfig(Wc)) != null && t), this.worksheet.setIsRowStylePrecedeColumnStyle((n = this._configService.getConfig(jc)) != null ? n : false);
  }
  resetCache() {
  }
  /**
   * @deprecated should never expose a property that is provided by another module!
   */
  getWorksheetConfig() {
    return this._worksheetData;
  }
  /**
   * Get which Workbook and Worksheet this skeleton is attached to.
   * @returns [unitId, sheetId]
   */
  getLocation() {
    return [this.worksheet.getUnitId(), this.worksheet.getSheetId()];
  }
  set columnHeaderHeight(t) {
    this._columnHeaderHeight = t, this._worksheetData.columnHeader.height = t;
  }
  set rowHeaderWidth(t) {
    this._rowHeaderWidth = t, this._worksheetData.rowHeader.width = t;
  }
  get rowHeightAccumulation() {
    return this._rowHeightAccumulation;
  }
  get rowTotalHeight() {
    return this._rowTotalHeight;
  }
  get columnWidthAccumulation() {
    return this._columnWidthAccumulation;
  }
  get columnTotalWidth() {
    return this._columnTotalWidth;
  }
  get rowHeaderWidth() {
    return this._rowHeaderWidth;
  }
  get columnHeaderHeight() {
    return this._columnHeaderHeight;
  }
  setMarginLeft(t) {
    this._marginLeft = t;
  }
  setMarginTop(t) {
    this._marginTop = t;
  }
  setScale(t, n) {
    this._updateLayout(), this._scaleX = t, this._scaleY = n || t, this._updateLayout();
  }
  setScroll(t, n) {
    J.isDefine(t) && (this._scrollX = t), J.isDefine(n) && (this._scrollY = n);
  }
  get scrollX() {
    return this._scrollX;
  }
  get scrollY() {
    return this._scrollY;
  }
  get scaleX() {
    return this._scaleX;
  }
  get scaleY() {
    return this._scaleY;
  }
  get rowHeaderWidthAndMarginLeft() {
    return this.rowHeaderWidth + this._marginLeft;
  }
  get columnHeaderHeightAndMarginTop() {
    return this.columnHeaderHeight + this._marginTop;
  }
  get imageCacheMap() {
    return this._imageCacheMap;
  }
  _generateRowMatrixCache(t, n, r) {
    let s = 0;
    const i = [], o = n;
    for (let a = 0; a < t; a++) {
      let l = r;
      if (this.worksheet.getRowFiltered(a))
        l = 0;
      else if (o[a] != null) {
        const u = o[a];
        if (!u)
          continue;
        const { h: c = r, ah: h, ia: d } = u;
        (d == null || d === ie.TRUE) && typeof h == "number" ? l = h : l = c, u.hd === ie.TRUE && (l = 0);
      }
      s += l, i.push(s);
    }
    return {
      rowTotalHeight: s,
      rowHeightAccumulation: i
    };
  }
  /**
   * Calc columnWidthAccumulation by columnData
   * @param colCount
   * @param columnData
   * @param defaultColumnWidth
   */
  _generateColumnMatrixCache(t, n, r) {
    let s = 0;
    const i = [], o = n;
    for (let a = 0; a < t; a++) {
      let l = r;
      if (o[a] != null) {
        const u = o[a];
        if (!u)
          continue;
        u.w != null && (l = u.w), u.hd === ie.TRUE && (l = 0);
      }
      s += l, i.push(s);
    }
    return {
      columnTotalWidth: s,
      columnWidthAccumulation: i
    };
  }
  intersectMergeRange(t, n) {
    return !!this.worksheet.getMergedCell(t, n);
  }
  //eslint-disable-next-line complexity
  _getOverflowBound(t, n, r, s, i = Ut.LEFT) {
    let o = 0;
    if (n > r) {
      const a = this._columnWidthAccumulation.length - 1;
      for (let l = n; l >= r; l--) {
        const u = l, c = this.worksheet.getCell(t, u);
        if (!Fa(c) && u !== n || this.intersectMergeRange(t, u))
          return u === n ? u : u + 1 > a ? a : u + 1;
        const { startX: h, endX: d } = rr(
          t,
          u,
          this.rowHeightAccumulation,
          this.columnWidthAccumulation
        );
        if (i === Ut.CENTER && u === n ? o += (d - h) / 2 : o += d - h, s < o)
          return u;
      }
      return n;
    }
    for (let a = n; a <= r; a++) {
      const l = a, u = this.worksheet.getCell(t, l);
      if (!Fa(u) && l !== n || this.intersectMergeRange(t, l))
        return l === n ? l : l - 1 < 0 ? 0 : l - 1;
      const { startX: c, endX: h } = rr(
        t,
        l,
        this.rowHeightAccumulation,
        this.columnWidthAccumulation
      );
      if (i === Ut.CENTER && l === n ? o += (h - c) / 2 : o += h - c, s < o)
        return l;
    }
    return r;
  }
  /**
   * Calculate data for row col & cell position.
   * This method should be called whenever a sheet is dirty.
   * Update position value to this._rowHeaderWidth & this._rowHeightAccumulation & this._columnHeaderHeight & this._columnWidthAccumulation.
   */
  _updateLayout() {
    if (!this.dirty)
      return;
    const {
      rowData: t,
      columnData: n,
      defaultRowHeight: r,
      defaultColumnWidth: s,
      rowCount: i,
      columnCount: o,
      rowHeader: a,
      columnHeader: l
    } = this._worksheetData, { rowTotalHeight: u, rowHeightAccumulation: c } = this._generateRowMatrixCache(i, t, r), { columnTotalWidth: h, columnWidthAccumulation: d } = this._generateColumnMatrixCache(
      o,
      n,
      s
    );
    this._rowHeaderWidth = a.hidden !== ie.TRUE ? this._dynamicallyUpdateRowHeaderWidth(a) : 0, this._columnHeaderHeight = l.hidden !== ie.TRUE ? l.height : 0, this._rowTotalHeight = u, this._rowHeightAccumulation = c, this._columnTotalWidth = h, this._columnWidthAccumulation = d, this.makeDirty(false);
  }
  /**
   * Refresh cache after markDirty by SheetSkeletonManagerService.reCalculate()
   * @param bounds
   */
  calculate() {
    return this.resetCache(), this._updateLayout(), this;
  }
  resetRangeCache(t) {
  }
  _dynamicallyUpdateRowHeaderWidth(t) {
    const r = `${this.worksheet.getRowCount()}`.length * 8;
    return Math.max(t.width, r);
  }
  _hasUnMergedCellInRow(t, n, r) {
    if (!this.worksheet.getMergeData())
      return false;
    for (let i = n; i <= r; i++) {
      const { isMerged: o, isMergedMainCell: a } = this.worksheet.getCellInfoInMergeData(t, i);
      if (!o && !a)
        return true;
    }
    return false;
  }
  /**
   * expand curr range if it's intersect with merge range.
   * @param range
   * @returns {IRange} expanded range because merge info.
   */
  expandRangeByMerge(t) {
    let { startRow: n, startColumn: r, endRow: s, endColumn: i } = t;
    const o = this._worksheetData.mergeData;
    if (!o)
      return {
        startRow: n,
        startColumn: r,
        endRow: s,
        endColumn: i
      };
    let a = true;
    const l = new pt();
    for (; a; ) {
      a = false;
      for (let u = 0; u < o.length; u++) {
        const {
          startRow: c,
          startColumn: h,
          endRow: d,
          endColumn: f
        } = o[u];
        if (l.getValue(c, h))
          continue;
        Wp({
          startColumn: r,
          startRow: n,
          endColumn: i,
          endRow: s
        }, {
          startColumn: h,
          startRow: c,
          endColumn: f,
          endRow: d
        }) && (n = Math.min(n, c), r = Math.min(r, h), s = Math.max(s, d), i = Math.max(i, f), l.setValue(c, h, true), a = true);
      }
    }
    return {
      startRow: n,
      startColumn: r,
      endRow: s,
      endColumn: i
    };
  }
  getColumnCount() {
    return this._columnWidthAccumulation.length;
  }
  getRowCount() {
    return this._rowHeightAccumulation.length;
  }
  /**
   * New version to get merge data.
   * @param row
   * @param column
   * @returns {ISelectionCell} The cell info with merge data
   */
  _getCellMergeInfo(t, n) {
    return this.worksheet.getCellInfoInMergeData(t, n);
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex instead.
   * @param rowIndex
   * @param columnIndex
   * @param header
   * @returns
   */
  getNoMergeCellPositionByIndex(t, n, r = true) {
    return this.getNoMergeCellWithCoordByIndex(t, n, r);
  }
  /**
   * Original name: getNoMergeCellPositionByIndex
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellWithCoordByIndex(t, n, r = true) {
    const {
      rowHeightAccumulation: s,
      columnWidthAccumulation: i,
      rowHeaderWidthAndMarginLeft: o,
      columnHeaderHeightAndMarginTop: a
    } = this;
    let { startY: l, endY: u, startX: c, endX: h } = rr(
      t,
      n,
      s,
      i
    );
    return r && (l += a, u += a, c += o, h += o), {
      startY: l,
      endY: u,
      startX: c,
      endX: h
    };
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex(row, col, false)
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellPositionByIndexWithNoHeader(t, n) {
    const { rowHeightAccumulation: r, columnWidthAccumulation: s } = this, { startY: i, endY: o, startX: a, endX: l } = rr(
      t,
      n,
      r,
      s
    );
    return {
      startY: i,
      endY: o,
      startX: a,
      endX: l
    };
  }
  /**
   *
   * @param offsetY scaled offset y
   * @param scaleY scale y
   * @param scrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   */
  getRowIndexByOffsetY(t, n, r, s) {
    var a;
    const { rowHeightAccumulation: i } = this;
    t = OC(
      t,
      n,
      r,
      this.columnHeaderHeightAndMarginTop
    );
    let o = Pr(
      i,
      t,
      s == null ? void 0 : s.firstMatch
    );
    return s != null && s.closeFirst && Math.abs(i[o] - t) < Math.abs(t - ((a = i[o - 1]) != null ? a : 0)) && (o = o + 1), o;
  }
  /**
   * Get column index by offset x.
   * @param offsetX scaled offset x
   * @param scaleX scale x
   * @param scrollXY scrollXY
   * @returns column index
   */
  getColumnIndexByOffsetX(t, n, r, s) {
    var l;
    const i = SC(
      t,
      n,
      r,
      this.rowHeaderWidthAndMarginLeft
    ), { columnWidthAccumulation: o } = this;
    let a = Pr(
      o,
      i,
      s == null ? void 0 : s.firstMatch
    );
    return s != null && s.closeFirst && Math.abs(o[a] - i) < Math.abs(i - ((l = o[a - 1]) != null ? l : 0)) && (a = a + 1), a;
  }
  /**
   * Get cell index by offset(o)
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY  render viewport scroll {x, y}, scene.getScrollXYByRelativeCoords, scene.getScrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   * @returns {row, col}
   */
  getCellIndexByOffset(t, n, r, s, i, o) {
    const a = this.getRowIndexByOffsetY(
      n,
      s,
      i,
      o
    ), l = this.getColumnIndexByOffsetX(
      t,
      r,
      i,
      o
    );
    return {
      row: a,
      column: l
    };
  }
  /**
   * Unlike getCellWithCoordByOffset, returning data doesn't include coord.
   * @param offsetX
   * @param offsetY
   * @param scaleX
   * @param scaleY
   * @param scrollXY
   */
  getCellByOffset(t, n, r, s, i) {
    const o = this == null ? void 0 : this.getCellIndexByOffset(
      t,
      n,
      r,
      s,
      i,
      { firstMatch: true }
    );
    return o ? this.worksheet.getCellInfoInMergeData(
      o.row,
      o.column
    ) : null;
  }
  /**
   * Return cell information corresponding to the current coordinates, including the merged cell object.
   *
   * @param row Specified Row Coordinate
   * @param column Specified Column Coordinate
   */
  getCellWithCoordByIndex(t, n, r = true) {
    const {
      rowHeightAccumulation: s,
      columnWidthAccumulation: i,
      rowHeaderWidthAndMarginLeft: o,
      columnHeaderHeightAndMarginTop: a
    } = this, l = rr(
      t,
      n,
      s,
      i,
      this.worksheet.getCellInfoInMergeData(t, n)
    ), { isMerged: u, isMergedMainCell: c } = l;
    let { startY: h, endY: d, startX: f, endX: g, mergeInfo: _ } = l, R = o, b = a;
    return r === false && (R = 0, b = 0), h += b, d += b, f += R, g += R, _.startY += b, _.endY += b, _.startX += R, _.endX += R, {
      actualRow: t,
      actualColumn: n,
      startX: f,
      startY: h,
      endX: g,
      endY: d,
      isMerged: u,
      isMergedMainCell: c,
      mergeInfo: _
    };
  }
  /**
   * Get cell by pos(offsetX, offsetY). Combine getCellIndexByOffset and then getCellWithCoordByIndex.
   *
   * options.matchFirst true means get cell would skip all invisible cells.
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY render viewportScroll {x, y}
   * @param options {IGetRowColByPosOptions}
   * @returns {ICellWithCoord} Selection data with coordinates
   */
  getCellWithCoordByOffset(t, n, r, s, i, o) {
    const { row: a, column: l } = this.getCellIndexByOffset(
      t,
      n,
      r,
      s,
      i,
      o
    );
    return this.getCellWithCoordByIndex(a, l);
  }
  /**
   * Original name: getOffsetByPositionX
   * @param column
   * @returns
   */
  getOffsetByColumn(t) {
    const { columnWidthAccumulation: n, rowHeaderWidthAndMarginLeft: r } = this, s = n.length - 1, i = n[t];
    return i != null ? i + r : t < 0 ? r : n[s] + r;
  }
  /**
   * Original name: getOffsetByPositionY
   * @param row
   */
  getOffsetByRow(t) {
    const { rowHeightAccumulation: n, columnHeaderHeightAndMarginTop: r } = this, s = n.length - 1, i = n[t];
    return i != null ? i + r : t < 0 ? r : n[s] + r;
  }
  /**
   * Original name: getDecomposedOffset
   * @param offsetX
   * @param offsetY
   */
  getOffsetRelativeToRowCol(t, n) {
    const r = Pr(this.columnWidthAccumulation, t);
    let s = 0;
    r === 0 ? s = t : s = t - this._columnWidthAccumulation[r - 1];
    const i = Pr(this.rowHeightAccumulation, n);
    let o = 0;
    return i === 0 ? o = n : o = n - this._rowHeightAccumulation[i - 1], {
      row: i,
      column: r,
      columnOffset: s,
      rowOffset: o
    };
  }
  _updateConfigAndGetDocumentModel(t, n, r, s) {
    var o, a, l, u, c;
    if (!s || !((o = t.body) != null && o.dataStream))
      return;
    t.documentStyle || (t.documentStyle = {}), t.documentStyle.marginTop = (a = r.t) != null ? a : 0, t.documentStyle.marginBottom = (l = r.b) != null ? l : 2, t.documentStyle.marginLeft = (u = r.l) != null ? u : 2, t.documentStyle.marginRight = (c = r.r) != null ? c : 2, t.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    }, t.documentStyle.renderConfig = {
      ...t.documentStyle.renderConfig,
      ...s
    };
    const i = t.body.paragraphs || [];
    for (const h of i)
      h.paragraphStyle || (h.paragraphStyle = {}), h.paragraphStyle.horizontalAlign = n;
    return new Pt(t);
  }
  dispose() {
    super.dispose(), this._rowHeightAccumulation = [], this._columnWidthAccumulation = [], this._rowTotalHeight = 0, this._columnTotalWidth = 0, this._rowHeaderWidth = 0, this._columnHeaderHeight = 0, this._worksheetData = null, this._cellData = null, this._styles = null, this.worksheet = null;
  }
};
yl = wC([
  Qr(2, Inject(Fn)),
  Qr(3, Nr),
  Qr(4, ic),
  Qr(5, Inject(Injector))
], yl);
function gc(e, t, n, r) {
  const s = e - 1, i = t - 1, o = n[s] || 0;
  let a = n[e];
  a == null && (a = n[n.length - 1]);
  const l = r[i] || 0;
  let u = r[t];
  return u == null && (u = r[r.length - 1]), {
    startY: o,
    endY: a,
    startX: l,
    endX: u
  };
}
function nI(e, t, n, r) {
  return gc(e, t, n, r);
}
function rr(e, t, n, r, s) {
  e = J.clamp(e, 0, n.length - 1), t = J.clamp(t, 0, r.length - 1);
  let { startY: i, endY: o, startX: a, endX: l } = gc(
    e,
    t,
    n,
    r
  );
  if (!s)
    return {
      startY: i,
      endY: o,
      startX: a,
      endX: l,
      isMerged: false,
      isMergedMainCell: false,
      actualRow: e,
      actualColumn: t,
      mergeInfo: {
        startY: i,
        endY: o,
        startX: a,
        endX: l,
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    };
  const {
    isMerged: u,
    isMergedMainCell: c,
    startRow: h,
    startColumn: d,
    endRow: f,
    endColumn: g
  } = s;
  let _ = {
    startRow: h,
    startColumn: d,
    endRow: f,
    endColumn: g,
    startY: i,
    endY: o,
    startX: a,
    endX: l
  };
  const R = n.length - 1, b = r.length - 1;
  if (u && h !== -1 && d !== -1) {
    const H = n[h - 1] || 0, P = n[f] || n[R], W = r[d - 1] || 0, w = r[g] || r[b];
    _ = {
      ..._,
      startY: H,
      endY: P,
      startX: W,
      endX: w
    };
  } else if (!u && f !== -1 && g !== -1) {
    const H = n[f] || n[R], P = r[g] || r[b];
    _ = {
      ..._,
      startY: i,
      endY: H,
      startX: a,
      endX: P
    };
  }
  return {
    isMerged: u,
    isMergedMainCell: c,
    actualRow: e,
    actualColumn: t,
    startY: i,
    endY: o,
    startX: a,
    endX: l,
    mergeInfo: _
  };
}
function SC(e, t, n, r) {
  const { x: s } = n;
  return e / t + s - r;
}
function OC(e, t, n, r) {
  const { y: s } = n;
  return e = e / t + s - r, e;
}
var rI = ["script", "style", "meta", "comment", "link"];
var vC = ((e) => (e[e.INFO = 0] = "INFO", e[e.STOP = 1] = "STOP", e[e.WARNING = 2] = "WARNING", e))(vC || {});
var bC = ((e) => (e[e.DISABLED = 0] = "DISABLED", e[e.FULL_ALPHA = 1] = "FULL_ALPHA", e[e.FULL_HANGUL = 2] = "FULL_HANGUL", e[e.FULL_KATAKANA = 3] = "FULL_KATAKANA", e[e.HALF_ALPHA = 4] = "HALF_ALPHA", e[e.HALF_HANGUL = 5] = "HALF_HANGUL", e[e.HALF_KATAKANA = 6] = "HALF_KATAKANA", e[e.HIRAGANA = 7] = "HIRAGANA", e[e.NO_CONTROL = 8] = "NO_CONTROL", e[e.OFF = 9] = "OFF", e[e.ON = 10] = "ON", e))(bC || {});
var AC = ((e) => (e.BETWEEN = "between", e.EQUAL = "equal", e.GREATER_THAN = "greaterThan", e.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", e.LESS_THAN = "lessThan", e.LESS_THAN_OR_EQUAL = "lessThanOrEqual", e.NOT_BETWEEN = "notBetween", e.NOT_EQUAL = "notEqual", e))(AC || {});
var yC = ((e) => (e[e.TEXT = 0] = "TEXT", e[e.ARROW = 1] = "ARROW", e[e.CUSTOM = 2] = "CUSTOM", e))(yC || {});
var NC = ((e) => (e.VALID = "valid", e.INVALID = "invalid", e.VALIDATING = "validating", e))(NC || {});
var TC = ((e) => (e.CUSTOM = "custom", e.LIST = "list", e.LIST_MULTIPLE = "listMultiple", e.NONE = "none", e.TEXT_LENGTH = "textLength", e.DATE = "date", e.TIME = "time", e.WHOLE = "whole", e.DECIMAL = "decimal", e.CHECKBOX = "checkbox", e.ANY = "any", e))(TC || {});
var MC = Object.getOwnPropertyDescriptor;
var LC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? MC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var Nl = (e, t) => (n, r) => t(n, r, e);
var Zi = class extends Ve {
  constructor(e, t) {
    super(), this._resourceManagerService = e, this._univerInstanceService = t, this._init();
  }
  _init() {
    const e = (n) => {
      n.businesses.forEach((r) => {
        switch (r) {
          case we.UNRECOGNIZED:
          case we.UNIVER_UNKNOWN:
          case we.UNIVER_SLIDE:
          case we.UNIVER_DOC: {
            this._univerInstanceService.getAllUnitsForType(we.UNIVER_DOC).forEach((s) => {
              const o = (s.getSnapshot().resources || []).find((a) => a.name === n.pluginName);
              if (o)
                try {
                  const a = n.parseJson(o.data);
                  n.onLoad(s.getUnitId(), a);
                } catch {
                  console.error(`Load Document{${s.getUnitId()}} Resources{${n.pluginName}} Data Error.`);
                }
            });
            break;
          }
          case we.UNIVER_SHEET:
            this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET).forEach((s) => {
              const o = (s.getSnapshot().resources || []).find((a) => a.name === n.pluginName);
              if (o)
                try {
                  const a = n.parseJson(o.data);
                  n.onLoad(s.getUnitId(), a);
                } catch {
                  console.error(`Load Workbook{${s.getUnitId()}} Resources{${n.pluginName}} Data Error.`);
                }
            });
        }
      });
    };
    this._resourceManagerService.getAllResourceHooks().forEach((n) => e(n)), this.disposeWithMe(this._resourceManagerService.register$.subscribe((n) => e(n))), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_SHEET).subscribe((n) => {
        this._resourceManagerService.loadResources(n.getUnitId(), n.getSnapshot().resources);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_DOC).subscribe((n) => {
        const r = n.getUnitId();
        Yc(r) || this._resourceManagerService.loadResources(n.getUnitId(), n.getSnapshot().resources);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_SHEET).subscribe((n) => {
        this._resourceManagerService.unloadResources(n.getUnitId(), we.UNIVER_SHEET);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_DOC).subscribe((n) => {
        this._resourceManagerService.unloadResources(n.getUnitId(), we.UNIVER_DOC);
      })
    );
  }
  saveUnit(e) {
    const t = this._univerInstanceService.getUnit(e);
    if (!t)
      return null;
    const n = this._resourceManagerService.getResources(e, t.type), r = J.deepClone(t.getSnapshot());
    return r.resources = n, r;
  }
};
Zi = LC([
  Nl(0, Inject(Jo)),
  Nl(1, Inject(vr))
], Zi);
var sI = class {
  /**
   * Create a Univer instance.
   * @param config Configuration data for Univer
   * @param parentInjector An optional parent injector of the Univer injector. For more information, see https://redi.wendell.fun/docs/hierarchy.
   */
  constructor(t = {}, n) {
    p(this, "_startedTypes", /* @__PURE__ */ new Set());
    p(this, "_injector");
    p(this, "_disposingCallbacks", new ao());
    const r = this._injector = xC(n, t == null ? void 0 : t.override), { theme: s, darkMode: i, locale: o, locales: a, logLevel: l } = t;
    s && this._injector.get(Gi).setTheme(s), i && this._injector.get(Gi).setDarkMode(i), a && this._injector.get(Fn).load(a), o && this._injector.get(Fn).setLocale(o), l && this._injector.get(yt).setLogLevel(l), this._init(r);
  }
  get _univerInstanceService() {
    return this._injector.get(vr);
  }
  get _pluginService() {
    return this._injector.get(Ss);
  }
  /**
   * @ignore
   */
  __getInjector() {
    return this._injector;
  }
  /**
   * Register a callback function which will be called when this Univer instance is disposing.
   *
   * @ignore
   *
   * @param callback The callback function.
   * @returns To remove this callback function from this Univer instance's on disposing list.
   */
  onDispose(t) {
    const n = this._disposingCallbacks.add(We(t));
    return We(() => n.dispose(true));
  }
  dispose() {
    this._disposingCallbacks.dispose(), this._injector.dispose();
  }
  setLocale(t) {
    this._injector.get(Fn).setLocale(t);
  }
  createUnit(t, n) {
    return this._univerInstanceService.createUnit(t, n);
  }
  /**
   * Create a univer sheet instance with internal dependency injection.
   *
   * @deprecated use `createUnit` instead
   */
  createUniverSheet(t) {
    return this._injector.get(yt).warn("[Univer]", "Univer.createUniverSheet is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_SHEET, t);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverDoc(t) {
    return this._injector.get(yt).warn("[Univer]", "Univer.createUniverDoc is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_DOC, t);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverSlide(t) {
    return this._injector.get(yt).warn("[Univer]", "Univer.createUniverSlide is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_SLIDE, t);
  }
  _init(t) {
    this._univerInstanceService.registerCtorForType(we.UNIVER_SHEET, ws), this._univerInstanceService.registerCtorForType(we.UNIVER_DOC, Pt), this._univerInstanceService.registerCtorForType(we.UNIVER_SLIDE, lc);
    const n = t.get(vr);
    n.__setCreateHandler(
      (r, s, i, o) => {
        if (!this._startedTypes.has(r)) {
          this._pluginService.startPluginsForType(r), this._startedTypes.add(r);
          const l = t.createInstance(i, s);
          return n.__addUnit(l, o), this._tryProgressToReady(), l;
        }
        const a = t.createInstance(i, s);
        return n.__addUnit(a, o), a;
      }
    );
  }
  _tryProgressToReady() {
    this._injector.get(Wn).stage < ke.Ready && (this._injector.get(Wn).stage = ke.Ready);
  }
  /** Register a plugin into univer. */
  registerPlugin(t, n) {
    this._pluginService.registerPlugin(t, n);
  }
  /**
   * Register multiple plugins into univer.
   * @param plugins An array of tuples, where each tuple contains a plugin constructor and its optional configuration.
   */
  registerPlugins(t) {
    t.forEach((n) => {
      const [r, s] = n;
      this._pluginService.registerPlugin(r, s);
    });
  }
};
function xC(e, t) {
  const n = nC([
    [_E],
    [Fn],
    [Gi],
    [Wn],
    [Ss],
    [Rs],
    // abstract services
    [vr, { useClass: Yi }],
    [eC, { useClass: tC }],
    [yt, { useClass: gg, lazy: true }],
    [Ls, { useClass: vi }],
    [Qo, { useClass: Ki, lazy: true }],
    [ic, { useClass: fE }],
    [Nr, { useClass: fg }],
    [Jo, { useClass: Vi, lazy: true }],
    [vl, { useClass: Zi, lazy: true }],
    [dE, { useClass: ji }],
    [QE, { useClass: zi, lazy: true }]
  ], t), r = e ? e.createChild(n) : new Injector(n);
  return zc(r, [
    [Rs],
    [vl]
  ]), r;
}
Dc();

export {
  isCtor,
  isClassDependencyItem,
  isFactoryDependencyItem,
  isValueDependencyItem,
  isAsyncDependencyItem,
  isAsyncHook,
  RediError,
  Quantity,
  LookUp,
  createIdentifier,
  SkipSelf,
  Self,
  Many,
  Optional,
  Inject,
  setDependencies,
  forwardRef,
  WithNew,
  isDisposable,
  Injector,
  Subscription,
  Observable,
  Subject,
  BehaviorSubject,
  ReplaySubject,
  animationFrameScheduler,
  EMPTY,
  of,
  throwError,
  isObservable,
  firstValueFrom,
  map,
  combineLatest,
  fromEvent,
  timer,
  merge,
  filter,
  race,
  auditTime,
  bufferTime,
  bufferWhen,
  catchError,
  combineLatestWith,
  concatMap,
  debounceTime,
  take,
  mapTo,
  delay,
  distinctUntilChanged,
  first,
  retry,
  share,
  shareReplay,
  skip,
  startWith,
  switchMap,
  takeUntil,
  tap,
  throttleTime,
  withLatestFrom,
  F,
  D,
  Os,
  $C,
  HC,
  BC,
  jC,
  WC,
  YC,
  zC,
  Dl,
  Ul,
  Hc,
  Bc,
  jc,
  Wc,
  VC,
  Yc,
  GC,
  zc,
  Vc,
  _i,
  KC,
  XC,
  sr,
  qC,
  Gc,
  ZC,
  JC,
  QC,
  e1,
  t1,
  vf,
  n1,
  r1,
  oo,
  s1,
  Gn,
  i1,
  Jf,
  o1,
  a1,
  su,
  iu,
  l1,
  Qf,
  em,
  u1,
  We,
  c1,
  ao,
  Ve,
  h1,
  d1,
  we,
  lo,
  J,
  et,
  xr,
  f1,
  m1,
  dm,
  Le,
  fm,
  At,
  mm,
  gm,
  _m,
  pm,
  Em,
  Cm,
  g1,
  Rm,
  Ns,
  Ii,
  Im,
  wm,
  Sm,
  Om,
  vm,
  bm,
  Am,
  ms,
  ym,
  Ut,
  xn,
  Bn,
  wi,
  Si,
  Zt,
  ie,
  fn,
  st,
  co,
  Nm,
  Tm,
  me,
  Ts,
  pn,
  Dn,
  Mm,
  uu,
  Lm,
  xm,
  Dm,
  Um,
  km,
  Pm,
  Fm,
  qe,
  $m,
  Hm,
  Bm,
  jm,
  Wm,
  Ym,
  zm,
  Vm,
  Gm,
  ir,
  Km,
  Xm,
  qm,
  Zm,
  Jm,
  Qm,
  eg,
  gt,
  _1,
  tg,
  ng,
  cu,
  rg,
  sg,
  p1,
  pe,
  Z,
  Nr,
  fg,
  mg,
  yt,
  gg,
  Ms,
  Ls,
  Rg,
  vi,
  fo,
  E1,
  wg,
  xa,
  C1,
  R1,
  I1,
  w1,
  Sg,
  S1,
  Og,
  Pr,
  O1,
  Fr,
  vg,
  v1,
  Qs,
  b1,
  Da,
  bg,
  mo,
  jn,
  Ag,
  bi,
  Ai,
  A1,
  y1,
  Ua,
  bt,
  N1,
  T1,
  $g,
  M1,
  L1,
  Hg,
  ge,
  ye,
  x1,
  Bg,
  jg,
  D1,
  or,
  U1,
  mn,
  k1,
  ka,
  P1,
  F1,
  Pa,
  pt,
  zg,
  $1,
  H1,
  Vg,
  Fa,
  Wt,
  Gg,
  B1,
  j1,
  W1,
  Y1,
  z1,
  V1,
  $a,
  G1,
  mu,
  Kg,
  K1,
  tn,
  go,
  X1,
  q1,
  T_,
  M_,
  L_,
  Z1,
  J1,
  Q1,
  gs,
  Br,
  eR,
  bp,
  Ap,
  yp,
  tR,
  nR,
  rR,
  sR,
  iR,
  oR,
  aR,
  lR,
  rt,
  Mp,
  uR,
  cR,
  hR,
  dR,
  fR,
  Lp,
  mR,
  Or,
  Di,
  gR,
  Pu,
  Wp,
  En,
  _R,
  pR,
  cl,
  ER,
  CR,
  Xp,
  RR,
  IR,
  wR,
  Ps,
  Fs,
  e0,
  zt,
  $s,
  SR,
  Ju,
  Pi,
  c0,
  h0,
  OR,
  d0,
  kt,
  vR,
  f0,
  m0,
  fl,
  er,
  C0,
  R0,
  Ne,
  Qt,
  N0,
  ct,
  bR,
  qo,
  Qu,
  Pt,
  nc,
  Je,
  AR,
  Hs,
  gn,
  hn,
  Bs,
  Cs,
  dn,
  Pn,
  yR,
  lE,
  NR,
  TR,
  Jo,
  Bi,
  Rs,
  ji,
  dE,
  ic,
  fE,
  Xr,
  gr,
  qr,
  Zr,
  MR,
  mE,
  LR,
  gE,
  xR,
  DR,
  UR,
  kR,
  PR,
  FR,
  _E,
  oc,
  pE,
  El,
  IE,
  $R,
  HR,
  Jr,
  OE,
  vE,
  BR,
  ME,
  jR,
  LE,
  WR,
  xE,
  YR,
  DE,
  zR,
  UE,
  VR,
  kE,
  PE,
  $E,
  Is,
  HE,
  GR,
  KR,
  ws,
  lc,
  vr,
  Yi,
  ke,
  XE,
  Wn,
  XR,
  Fn,
  zi,
  QE,
  hc,
  eC,
  tC,
  nC,
  Ol,
  qR,
  Ss,
  vl,
  Vi,
  Gi,
  Qo,
  fC,
  mC,
  gC,
  _C,
  Ki,
  pC,
  ZR,
  JR,
  QR,
  eI,
  tI,
  qi,
  yl,
  gc,
  nI,
  rr,
  SC,
  OC,
  rI,
  vC,
  bC,
  AC,
  yC,
  NC,
  TC,
  sI
};
/*! Bundled license information:

@wendellhu/redi/dist/esm/index.js:
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-RGZYGL3P.js.map
