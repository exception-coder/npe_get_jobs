import {
  Bn,
  Tt,
  fe as fe2
} from "./chunk-Q5F7IOB3.js";
import {
  C as C3,
  Da,
  Ea,
  Ee,
  F as F2,
  H,
  Ie,
  Ja,
  K,
  Ka,
  Le,
  Q as Q2,
  Ra,
  Sa,
  Te,
  Ue as Ue2,
  Ve as Ve2,
  Za,
  _a,
  _e,
  ar,
  er,
  fa,
  fe,
  ft,
  ga,
  ia,
  ma,
  na,
  ne,
  oe,
  pa,
  pe as pe2,
  tr,
  we,
  ye,
  za
} from "./chunk-ZKTLMAEM.js";
import {
  B,
  C,
  Ce,
  F,
  G,
  I,
  N,
  P,
  Q,
  S,
  Ue,
  Ve,
  h,
  j,
  p,
  pe,
  v,
  x
} from "./chunk-VAEXAE3K.js";
import "./chunk-6335LBDU.js";
import {
  C as C2,
  S as S2,
  k
} from "./chunk-FOCXVU2X.js";
import "./chunk-RWMUFXJB.js";
import "./chunk-DZMX4FYO.js";
import {
  Ss
} from "./chunk-I7I3GTAS.js";
import {
  I as I2,
  j as j2
} from "./chunk-YFGUMDM2.js";
import {
  AC,
  KC,
  Ls,
  NC,
  TC,
  We,
  et,
  filter,
  vC,
  vr
} from "./chunk-RGZYGL3P.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@univerjs/sheets-data-validation/lib/es/facade.js
var $ = Object.defineProperty;
var W = (f2, t, e) => t in f2 ? $(f2, t, { enumerable: true, configurable: true, writable: true, value: e }) : f2[t] = e;
var v2 = (f2, t, e) => W(f2, typeof t != "symbol" ? t + "" : t, e);
var C4 = class _C {
  constructor(t) {
    v2(this, "_rule");
    this._rule = t != null ? t : {
      uid: et(),
      ranges: void 0,
      type: TC.CUSTOM
    };
  }
  /**
   * Builds an FDataValidation instance based on the _rule property of the current class
   * @returns {FDataValidation} A new instance of the FDataValidation class
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number between 1 and 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberBetween(1, 10)
   *   .setOptions({
   *     allowBlank: true,
   *     showErrorMessage: true,
   *     error: 'Please enter a number between 1 and 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  build() {
    return new w(this._rule);
  }
  /**
   * Creates a duplicate of the current DataValidationBuilder object
   * @returns {FDataValidationBuilder} A new instance of the DataValidationBuilder class
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number between 1 and 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const builder = univerAPI.newDataValidation()
   *   .requireNumberBetween(1, 10)
   *   .setOptions({
   *     allowBlank: true,
   *     showErrorMessage: true,
   *     error: 'Please enter a number between 1 and 10'
   *   });
   * fRange.setDataValidation(builder.build());
   *
   * // Copy the builder applied to the new range F1:G10
   * const newRange = fWorksheet.getRange('F1:G10');
   * const copyBuilder = builder.copy();
   * newRange.setDataValidation(copyBuilder.build());
   * ```
   */
  copy() {
    return new _C({
      ...this._rule,
      uid: et()
    });
  }
  /**
   * Determines whether invalid data is allowed
   * @returns {boolean} True if invalid data is allowed, False otherwise
   * @example
   * ```typescript
   * const builder = univerAPI.newDataValidation().requireNumberBetween(1, 10);
   * console.log(builder.getAllowInvalid());
   * ```
   */
  getAllowInvalid() {
    return this._rule.errorStyle !== vC.STOP;
  }
  /**
   * Gets the data validation type of the rule
   * @returns {DataValidationType | string} The data validation type
   * @example
   * ```typescript
   * const builder = univerAPI.newDataValidation();
   * console.log(builder.getCriteriaType()); // custom
   *
   * builder.requireNumberBetween(1, 10);
   * console.log(builder.getCriteriaType()); // decimal
   *
   * builder.requireValueInList(['Yes', 'No']);
   * console.log(builder.getCriteriaType()); // list
   * ```
   */
  getCriteriaType() {
    return this._rule.type;
  }
  /**
   * Gets the values used for criteria evaluation
   * @returns {[string | undefined, string | undefined, string | undefined]} An array containing the operator, formula1, and formula2 values
   * @example
   * ```typescript
   * const builder = univerAPI.newDataValidation().requireNumberBetween(1, 10);
   * const [operator, formula1, formula2] = builder.getCriteriaValues();
   * console.log(operator, formula1, formula2); // between 1 10
   *
   * builder.requireValueInList(['Yes', 'No']);
   * console.log(builder.getCriteriaValues()); // undefined Yes,No undefined
   * ```
   */
  getCriteriaValues() {
    return [this._rule.operator, this._rule.formula1, this._rule.formula2];
  }
  /**
   * Gets the help text information, which is used to provide users with guidance and support
   * @returns {string | undefined} Returns the help text information. If there is no error message, it returns an undefined value
   * @example
   * ```typescript
   * const builder = univerAPI.newDataValidation().setOptions({
   *   showErrorMessage: true,
   *   error: 'Please enter a valid value'
   * });
   * console.log(builder.getHelpText()); // 'Please enter a valid value'
   * ```
   */
  getHelpText() {
    return this._rule.error;
  }
  /**
   * Sets the data validation rule to require that the input is a boolean value; this value is rendered as a checkbox.
   * @param {string} [checkedValue] - The value assigned to a checked box.
   * @param {string} [uncheckedValue] - The value assigned to an unchecked box.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set the data validation for cell A1:A10 to require a checkbox with default 1 and 0 values
   * const fRange = fWorksheet.getRange('A1:A10');
   * const rule = univerAPI.newDataValidation()
   *   .requireCheckbox()
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Set the data validation for cell B1:B10 to require a checkbox with 'Yes' and 'No' values
   * const fRange2 = fWorksheet.getRange('B1:B10');
   * const rule2 = univerAPI.newDataValidation()
   *   .requireCheckbox('Yes', 'No')
   *   .build();
   * fRange2.setDataValidation(rule2);
   * ```
   */
  requireCheckbox(t, e) {
    return this._rule.type = TC.CHECKBOX, this._rule.formula1 = t, this._rule.formula2 = e, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be after a specific date.
   * @param {Date} date - The latest unacceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date after 2025-01-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateAfter(new Date('2025-01-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['invalid', 'invalid', 'invalid', 'valid']]
   * ```
   */
  requireDateAfter(t) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.operator = AC.GREATER_THAN, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be before a specific date.
   * @param {Date} date - The earliest unacceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date before 2025-01-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateBefore(new Date('2025-01-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['valid', 'valid', 'invalid', 'invalid']]
   * ```
   */
  requireDateBefore(t) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.formula2 = void 0, this._rule.operator = AC.LESS_THAN, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be within a specific date range.
   * @param {Date} start - The earliest acceptable date.
   * @param {Date} end - The latest acceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date between 2024-06-01 and 2025-06-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateBetween(new Date('2024-06-01'), new Date('2025-06-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['invalid', 'valid', 'valid', 'invalid']]
   * ```
   */
  requireDateBetween(t, e) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.formula2 = e.toLocaleDateString(), this._rule.operator = AC.BETWEEN, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be equal to a specific date.
   * @param {Date} date - The sole acceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date equal to 2025-01-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateEqualTo(new Date('2025-01-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the cell A2
   * const status = await fWorksheet.getRange('A2').getValidatorStatus();
   * console.log(status?.[0]?.[0]); // 'valid'
   *
   * // Get the validation status of the cell B2
   * const status2 = await fWorksheet.getRange('B2').getValidatorStatus();
   * console.log(status2?.[0]?.[0]); // 'invalid'
   * ```
   */
  requireDateEqualTo(t) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.formula2 = void 0, this._rule.operator = AC.EQUAL, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be not within a specific date range.
   * @param {Date} start - The earliest unacceptable date.
   * @param {Date} end - The latest unacceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date not between 2024-06-01 and 2025-06-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateNotBetween(new Date('2024-06-01'), new Date('2025-06-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['valid', 'invalid', 'invalid', 'valid']]
   * ```
   */
  requireDateNotBetween(t, e) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.formula2 = e.toLocaleDateString(), this._rule.operator = AC.NOT_BETWEEN, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be on or after a specific date.
   * @param {Date} date - The earliest acceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date on or after 2025-01-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateOnOrAfter(new Date('2025-01-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['invalid', 'invalid', 'valid', 'valid']]
   * ```
   */
  requireDateOnOrAfter(t) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.formula2 = void 0, this._rule.operator = AC.GREATER_THAN_OR_EQUAL, this;
  }
  /**
   * Set the data validation type to DATE and configure the validation rules to be on or before a specific date.
   * @param {Date} date - The latest acceptable date.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some date values in the range A1:B2
   * const fRange = fWorksheet.getRange('A1:B2');
   * fRange.setValues([
   *   ['2024-01-01', '2024-12-31'],
   *   ['2025-01-01', '2025-12-31']
   * ]);
   *
   * // Create a data validation rule that requires a date on or before 2025-01-01
   * const rule = univerAPI.newDataValidation()
   *   .requireDateOnOrBefore(new Date('2025-01-01'))
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['valid', 'valid', 'valid', 'invalid']]
   * ```
   */
  requireDateOnOrBefore(t) {
    return this._rule.type = TC.DATE, this._rule.formula1 = t.toLocaleDateString(), this._rule.formula2 = void 0, this._rule.operator = AC.LESS_THAN_OR_EQUAL, this;
  }
  /**
   * Sets the data validation rule to require that the given formula evaluates to `true`.
   * @param {string} formula - The formula string that needs to be satisfied, formula result should be TRUE or FALSE, and references range will relative offset.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set some values in the range A1:B2 and C1:D2
   * const cell = fWorksheet.getRange('A1:B2');
   * cell.setValues([
   *   [4, 3],
   *   [2, 1]
   * ]);
   * const fRange = fWorksheet.getRange('C1:D2');
   * fRange.setValues([
   *   [1, 2],
   *   [3, 4]
   * ]);
   *
   * // Create a data validation rule that requires the formula '=A1>2' to be satisfied
   * const rule = univerAPI.newDataValidation()
   *   .requireFormulaSatisfied('=A1>2')
   *   .setOptions({
   *     showErrorMessage: true,
   *     error: 'Please enter a value equal to A1'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Get the validation status of the range
   * const status = await fRange.getValidatorStatus();
   * console.log(status); // [['valid', 'valid', 'invalid', 'invalid']]
   * ```
   */
  requireFormulaSatisfied(t) {
    return this._rule.type = TC.CUSTOM, this._rule.formula1 = t, this._rule.formula2 = void 0, this;
  }
  /**
   * Sets the data validation rule to require a number that falls between, or is either of, two specified numbers.
   * @param {number} start - The lowest acceptable value.
   * @param {number} end - The highest acceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number between 1 and 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberBetween(1, 10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number between 1 and 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberBetween(t, e, a) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = `${e}`, this._rule.operator = AC.BETWEEN, this._rule.type = a ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number equal to the given value.
   * @param {number} num - The sole acceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number equal to 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberEqualTo(10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number equal to 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberEqualTo(t, e) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = void 0, this._rule.operator = AC.EQUAL, this._rule.type = e ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number greater than the given value.
   * @param {number} num - The highest unacceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number greater than 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberGreaterThan(10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number greater than 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberGreaterThan(t, e) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = void 0, this._rule.operator = AC.GREATER_THAN, this._rule.type = e ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number greater than or equal to the given value.
   * @param {number} num - The lowest acceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number greater than 10 or equal to 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberGreaterThanOrEqualTo(10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number greater than 10 or equal to 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberGreaterThanOrEqualTo(t, e) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = void 0, this._rule.operator = AC.GREATER_THAN_OR_EQUAL, this._rule.type = e ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number less than the given value.
   * @param {number} num - The lowest unacceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number less than 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberLessThan(10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number less than 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberLessThan(t, e) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = void 0, this._rule.operator = AC.LESS_THAN, this._rule.type = e ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number less than or equal to the given value.
   * @param {number} num - The highest acceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number less than 10 or equal to 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberLessThanOrEqualTo(10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number less than 10 or equal to 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberLessThanOrEqualTo(t, e) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = void 0, this._rule.operator = AC.LESS_THAN_OR_EQUAL, this._rule.type = e ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number that does not fall between, and is neither of, two specified numbers.
   * @param {number} start - The lowest unacceptable value.
   * @param {number} end - The highest unacceptable value.
   * @param {boolean} [isInteger] - Optional parameter, indicating whether the number to be verified is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number not between 1 and 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberNotBetween(1, 10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number not between 1 and 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberNotBetween(t, e, a) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = `${e}`, this._rule.operator = AC.NOT_BETWEEN, this._rule.type = a ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets the data validation rule to require a number not equal to the given value.
   * @param {number} num - The sole unacceptable value.
   * @param {boolean} [isInteger] - Indicates whether the required number is an integer.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number not equal to 10 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberNotEqualTo(10)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a number not equal to 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireNumberNotEqualTo(t, e) {
    return this._rule.formula1 = `${t}`, this._rule.formula2 = void 0, this._rule.operator = AC.NOT_EQUAL, this._rule.type = e ? TC.WHOLE : TC.DECIMAL, this;
  }
  /**
   * Sets a data validation rule that requires the user to enter a value from a list of specific values.
   * The list can be displayed in a dropdown, and the user can choose multiple values according to the settings.
   * @param {string[]} values - An array of acceptable values.
   * @param {boolean} [multiple] - Optional parameter indicating whether the user can select multiple values.
   * @param {boolean} [showDropdown] - Optional parameter indicating whether to display the list in a dropdown.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires the user to enter a value from the list ['Yes', 'No'] for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireValueInList(['Yes', 'No'])
   *   .setOptions({
   *     allowBlank: true,
   *     showErrorMessage: true,
   *     error: 'Please enter a value from the list'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  requireValueInList(t, e, a) {
    return this._rule.type = e ? TC.LIST_MULTIPLE : TC.LIST, this._rule.formula1 = t.join(","), this._rule.formula2 = void 0, this._rule.showDropDown = a != null ? a : true, this;
  }
  /**
   * Sets a data validation rule that requires the user to enter a value within a specific range.
   * The range is defined by an FRange object, which contains the unit ID, sheet name, and cell range.
   * @param {FRange} range - An FRange object representing the range of values that the user can enter.
   * @param {boolean} [multiple] - Optional parameter indicating whether the user can select multiple values.
   * @param {boolean} [showDropdown] - Optional parameter indicating whether to display the list in a dropdown.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set the values in the range B1:B2
   * const fRange = fWorksheet.getRange('B1:B2');
   * fRange.setValues([
   *   ['Yes'],
   *   ['No']
   * ]);
   *
   * // Create a new data validation rule that requires the user to enter a value from the range B1:B2 for the range A1:A10
   * const rule = univerAPI.newDataValidation()
   *   .requireValueInRange(fRange)
   *   .setOptions({
   *     allowBlank: false,
   *     showErrorMessage: true,
   *     error: 'Please enter a value from the list'
   *   })
   *   .build();
   * const cell = fWorksheet.getRange('A1');
   * cell.setDataValidation(rule);
   * ```
   */
  requireValueInRange(t, e, a) {
    return this._rule.type = e ? TC.LIST_MULTIPLE : TC.LIST, this._rule.formula1 = `=${Ss({
      unitId: t.getUnitId(),
      sheetName: t.getSheetName(),
      range: t.getRange()
    })}`, this._rule.formula2 = void 0, this._rule.showDropDown = a != null ? a : true, this;
  }
  /**
   * Sets whether to allow invalid data and configures the error style.
   * If invalid data is not allowed, the error style will be set to STOP, indicating that data entry must stop upon encountering an error.
   * If invalid data is allowed, the error style will be set to WARNING, indicating that a warning will be displayed when invalid data is entered, but data entry can continue.
   * @param {boolean} allowInvalidData - Whether to allow invalid data.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set the data validation for cell A1:B2 to allow invalid data, so A1:B2 will display a warning when invalid data is entered
   * const fRange = fWorksheet.getRange('A1:B2');
   * const rule = univerAPI.newDataValidation()
   *   .requireValueInList(['Yes', 'No'])
   *   .setAllowInvalid(true)
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Set the data validation for cell C1:D2 to not allow invalid data, so C1:D2 will stop data entry when invalid data is entered
   * const fRange2 = fWorksheet.getRange('C1:D2');
   * const rule2 = univerAPI.newDataValidation()
   *   .requireValueInList(['Yes', 'No'])
   *   .setAllowInvalid(false)
   *   .build();
   * fRange2.setDataValidation(rule2);
   * ```
   */
  setAllowInvalid(t) {
    return this._rule.errorStyle = t ? vC.WARNING : vC.STOP, this;
  }
  /**
   * Sets whether to allow blank values.
   * @param {boolean} allowBlank - Whether to allow blank values.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * // Assume current sheet is empty data
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Set the data validation for cell A1:B2 to allow blank values
   * const fRange = fWorksheet.getRange('A1:B2');
   * const rule = univerAPI.newDataValidation()
   *   .requireValueInList(['Yes', 'No'])
   *   .setAllowBlank(true)
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Set the data validation for cell C1:D2 to not allow blank values
   * const fRange2 = fWorksheet.getRange('C1:D2');
   * const rule2 = univerAPI.newDataValidation()
   *   .requireValueInList(['Yes', 'No'])
   *   .setAllowBlank(false)
   *   .build();
   * fRange2.setDataValidation(rule2);
   * ```
   */
  setAllowBlank(t) {
    return this._rule.allowBlank = t, this;
  }
  /**
   * Sets the options for the data validation rule.
   * @param {Partial<IDataValidationRuleOptions>} options - The options to set for the data validation rule.
   * @returns {FDataValidationBuilder} The current instance for method chaining.
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires the user to enter a value from the list ['Yes', 'No'] for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireValueInList(['Yes', 'No'])
   *   .setOptions({
   *     allowBlank: true,
   *     showErrorMessage: true,
   *     error: 'Please enter a value from the list'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * ```
   */
  setOptions(t) {
    return Object.assign(this._rule, t), this;
  }
};
var w = class {
  constructor(t, e, a) {
    v2(this, "rule");
    v2(this, "_worksheet");
    v2(this, "_injector");
    this._injector = a, this.rule = t, this._worksheet = e;
  }
  /**
   * Gets whether invalid data is allowed based on the error style value
   * @returns {boolean} true if invalid data is allowed, false otherwise
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const rules = fWorksheet.getDataValidations();
   * rules.forEach((rule) => {
   *   console.log(rule, rule.getAllowInvalid());
   * });
   * ```
   */
  getAllowInvalid() {
    return this.rule.errorStyle !== vC.STOP;
  }
  /**
   * Gets the data validation type of the rule
   * @returns {DataValidationType | string} The data validation type
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const rules = fWorksheet.getDataValidations();
   * rules.forEach((rule) => {
   *   console.log(rule, rule.getCriteriaType());
   * });
   * ```
   */
  getCriteriaType() {
    return this.rule.type;
  }
  /**
   * Gets the values used for criteria evaluation
   * @returns {[string | undefined, string | undefined, string | undefined]} An array containing the operator, formula1, and formula2 values
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const rules = fWorksheet.getDataValidations();
   * rules.forEach((rule) => {
   *   console.log(rule);
   *   const criteriaValues = rule.getCriteriaValues();
   *   const [operator, formula1, formula2] = criteriaValues;
   *   console.log(operator, formula1, formula2);
   * });
   * ```
   */
  getCriteriaValues() {
    return [this.rule.operator, this.rule.formula1, this.rule.formula2];
  }
  /**
   * Gets the help text information, which is used to provide users with guidance and support
   * @returns {string | undefined} Returns the help text information. If there is no error message, it returns an undefined value
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberBetween(1, 10)
   *   .setOptions({
   *     allowBlank: true,
   *     showErrorMessage: true,
   *     error: 'Please enter a number between 1 and 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   * console.log(fRange.getDataValidation().getHelpText()); // 'Please enter a number between 1 and 10'
   * ```
   */
  getHelpText() {
    return this.rule.error;
  }
  /**
   * Creates a new instance of FDataValidationBuilder using the current rule object
   * @returns {FDataValidationBuilder} A new FDataValidationBuilder instance with the same rule configuration
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberBetween(1, 10)
   *   .setOptions({
   *     allowBlank: true,
   *     showErrorMessage: true,
   *     error: 'Please enter a number between 1 and 10'
   *   })
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * const builder = fRange.getDataValidation().copy();
   * const newRule = builder
   *   .requireNumberBetween(1, 5)
   *   .setOptions({
   *     error: 'Please enter a number between 1 and 5'
   *   })
   *   .build();
   * fRange.setDataValidation(newRule);
   * ```
   */
  copy() {
    return new C4(this.rule);
  }
  /**
   * Gets whether the data validation rule is applied to the worksheet
   * @returns {boolean} true if the rule is applied, false otherwise
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const rules = fWorksheet.getDataValidations();
   * rules.forEach((rule) => {
   *   console.log(rule, rule.getApplied());
   * });
   *
   * const fRange = fWorksheet.getRange('A1:B10');
   * console.log(fRange.getDataValidation()?.getApplied());
   * ```
   */
  getApplied() {
    if (!this._worksheet)
      return false;
    const e = this._injector.get(h).getRuleById(this._worksheet.getUnitId(), this._worksheet.getSheetId(), this.rule.uid);
    return !!(e && e.ranges.length);
  }
  /**
   * Gets the ranges to which the data validation rule is applied
   * @returns {FRange[]} An array of FRange objects representing the ranges to which the data validation rule is applied
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const rules = fWorksheet.getDataValidations();
   * rules.forEach((rule) => {
   *   console.log(rule);
   *   const ranges = rule.getRanges();
   *   ranges.forEach((range) => {
   *     console.log(range.getA1Notation());
   *   });
   * });
   * ```
   */
  getRanges() {
    if (!this.getApplied())
      return [];
    const t = this._injector.get(vr).getUnit(this._worksheet.getUnitId());
    return this.rule.ranges.map((e) => this._injector.createInstance(k, t, this._worksheet, e));
  }
  /**
   * Gets the unit ID of the worksheet
   * @returns {string | undefined} The unit ID of the worksheet
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const fRange = fWorksheet.getRange('A1:B10');
   * console.log(fRange.getDataValidation().getUnitId());
   * ```
   */
  getUnitId() {
    var t;
    return (t = this._worksheet) == null ? void 0 : t.getUnitId();
  }
  /**
   * Gets the sheet ID of the worksheet
   * @returns {string | undefined} The sheet ID of the worksheet
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   * const fRange = fWorksheet.getRange('A1:B10');
   * console.log(fRange.getDataValidation().getSheetId());
   * ```
   */
  getSheetId() {
    var t;
    return (t = this._worksheet) == null ? void 0 : t.getSheetId();
  }
  /**
   * Set Criteria for the data validation rule
   * @param {DataValidationType} type - The type of data validation criteria
   * @param {[DataValidationOperator, string, string]} values - An array containing the operator, formula1, and formula2 values
   * @param {boolean} [allowBlank] - Whether to allow blank values
   * @returns {FDataValidation} The current instance for method chaining
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number equal to 20 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberEqualTo(20)
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Change the rule criteria to require a number between 1 and 10
   * fRange.getDataValidation().setCriteria(
   *   univerAPI.Enum.DataValidationType.DECIMAL,
   *   [univerAPI.Enum.DataValidationOperator.BETWEEN, '1', '10']
   * );
   * ```
   */
  setCriteria(t, e, a = true) {
    if (this.getApplied() && !this._injector.get(Ls).syncExecuteCommand(pa.id, {
      unitId: this.getUnitId(),
      subUnitId: this.getSheetId(),
      ruleId: this.rule.uid,
      setting: {
        operator: e[0],
        formula1: e[1],
        formula2: e[2],
        type: this.rule.type,
        allowBlank: a
      }
    }))
      throw new Error("setCriteria failed");
    return this.rule.operator = e[0], this.rule.formula1 = e[1], this.rule.formula2 = e[2], this.rule.type = t, this.rule.allowBlank = a, this;
  }
  /**
   * Set the options for the data validation rule
   * @param {Partial<IDataValidationRuleOptions>} options - The options to set for the data validation rule
   * @returns {FDataValidation} The current instance for method chaining
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number equal to 20 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberEqualTo(20)
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Supplement the rule with additional options
   * fRange.getDataValidation().setOptions({
   *   allowBlank: true,
   *   showErrorMessage: true,
   *   error: 'Please enter a valid value'
   * });
   * ```
   */
  setOptions(t) {
    if (this.getApplied() && !this._injector.get(Ls).syncExecuteCommand(fa.id, {
      unitId: this.getUnitId(),
      subUnitId: this.getSheetId(),
      ruleId: this.rule.uid,
      options: {
        ...j(this.rule),
        ...t
      }
    }))
      throw new Error("setOptions failed");
    return Object.assign(this.rule, t), this;
  }
  /**
   * Set the ranges to the data validation rule
   * @param {FRange[]} ranges - New ranges array
   * @returns {FDataValidation} The current instance for method chaining
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number equal to 20 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberEqualTo(20)
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Change the range to C1:D10
   * const newRuleRange = fWorksheet.getRange('C1:D10');
   * fRange.getDataValidation().setRanges([newRuleRange]);
   * ```
   */
  setRanges(t) {
    if (this.getApplied() && !this._injector.get(Ls).syncExecuteCommand(ma.id, {
      unitId: this.getUnitId(),
      subUnitId: this.getSheetId(),
      ruleId: this.rule.uid,
      ranges: t.map((r) => r.getRange())
    }))
      throw new Error("setRanges failed");
    return this.rule.ranges = t.map((e) => e.getRange()), this;
  }
  /**
   * Delete the data validation rule from the worksheet
   * @returns {boolean} true if the rule is deleted successfully, false otherwise
   * @example
   * ```typescript
   * const fWorkbook = univerAPI.getActiveWorkbook();
   * const fWorksheet = fWorkbook.getActiveSheet();
   *
   * // Create a new data validation rule that requires a number equal to 20 for the range A1:B10
   * const fRange = fWorksheet.getRange('A1:B10');
   * const rule = univerAPI.newDataValidation()
   *   .requireNumberEqualTo(20)
   *   .build();
   * fRange.setDataValidation(rule);
   *
   * // Delete the data validation rule
   * fRange.getDataValidation().delete();
   * ```
   */
  delete() {
    return this.getApplied() ? this._injector.get(Ls).syncExecuteCommand(Sa.id, {
      unitId: this.getUnitId(),
      subUnitId: this.getSheetId(),
      ruleId: this.rule.uid
    }) : false;
  }
};
var X = class extends k {
  setDataValidation(t) {
    if (!t)
      return this._commandService.syncExecuteCommand(_a.id, {
        unitId: this._workbook.getUnitId(),
        subUnitId: this._worksheet.getSheetId(),
        ranges: [this._range]
      }), this;
    const e = {
      unitId: this._workbook.getUnitId(),
      subUnitId: this._worksheet.getSheetId(),
      rule: {
        ...t.rule,
        ranges: [this._range]
      }
    };
    return this._commandService.syncExecuteCommand(ga.id, e), this;
  }
  getDataValidation() {
    const e = this._injector.get(we).getDataValidation(
      this._workbook.getUnitId(),
      this._worksheet.getSheetId(),
      [this._range]
    );
    return e && new w(e, this._worksheet, this._injector);
  }
  getDataValidations() {
    return this._injector.get(we).getDataValidations(
      this._workbook.getUnitId(),
      this._worksheet.getSheetId(),
      [this._range]
    ).map((e) => new w(e, this._worksheet, this._injector));
  }
  async getValidatorStatus() {
    return this._injector.get(we).validatorRanges(
      this._workbook.getUnitId(),
      this._worksheet.getSheetId(),
      [this._range]
    );
  }
  async getDataValidationErrorAsync() {
    const t = this._workbook.getUnitId(), e = this._worksheet.getSheetId();
    return this._collectValidationErrorsForRange(t, e, [this._range]);
  }
  async _collectValidationErrorsForRange(t, e, a) {
    if (!a.length)
      return [];
    const r = this._injector.get(we), i = this._worksheet, h2 = i.getName(), s = [];
    for (const o of a) {
      const d = [];
      for (let u = o.startRow; u <= o.endRow; u++)
        for (let l = o.startColumn; l <= o.endColumn; l++)
          d.push((async () => {
            var c;
            try {
              if (await r.validatorCell(t, e, u, l) !== NC.VALID) {
                const m = this._injector.get(F2).getRuleByLocation(t, e, u, l);
                if (m) {
                  const k2 = ((c = i.getCell(u, l)) == null ? void 0 : c.v) || null, I3 = this._createDataValidationError(
                    h2,
                    u,
                    l,
                    m,
                    k2
                  );
                  s.push(I3);
                }
              }
            } catch (_) {
              console.warn(`Failed to validate cell [${u}, ${l}]:`, _);
            }
          })());
      await Promise.all(d);
    }
    return s;
  }
  _createDataValidationError(t, e, a, r, i) {
    return {
      sheetName: t,
      row: e,
      column: a,
      ruleId: r.uid,
      inputValue: i,
      rule: r
    };
  }
};
k.extend(X);
var J = class extends I2 {
  /**
   * @deprecated use `univerAPI.newDataValidation()` as instead.
   * @returns {FDataValidationBuilder} A new instance of the FDataValidationBuilder class
   */
  static newDataValidation() {
    return new C4();
  }
  newDataValidation() {
    return new C4();
  }
  /**
   * @ignore
   */
  // eslint-disable-next-line max-lines-per-function
  _initialize(t) {
    const e = t.get(Ls);
    this.registerEventHandler(
      this.Event.SheetDataValidationChanged,
      () => t.has(F2) ? t.get(F2).ruleChange$.subscribe((r) => {
        const { unitId: i, subUnitId: h2, rule: s, oldRule: o, type: d } = r, u = this.getSheetTarget(i, h2);
        if (!u)
          return;
        const { workbook: l, worksheet: c } = u, _ = new w(s, c.getSheet(), this._injector);
        this.fireEvent(this.Event.SheetDataValidationChanged, {
          origin: r,
          worksheet: c,
          workbook: l,
          changeType: d,
          oldRule: o,
          rule: _
        });
      }) : { dispose: () => {
      } }
    ), this.registerEventHandler(
      this.Event.SheetDataValidatorStatusChanged,
      () => t.has(F2) ? t.get(F2).validStatusChange$.subscribe((r) => {
        const { unitId: i, subUnitId: h2, ruleId: s, status: o, row: d, col: u } = r, l = this.getSheetTarget(i, h2);
        if (!l)
          return;
        const { workbook: c, worksheet: _ } = l, E = _.getDataValidation(s);
        E && this.fireEvent(this.Event.SheetDataValidatorStatusChanged, {
          workbook: c,
          worksheet: _,
          row: d,
          column: u,
          rule: E,
          status: o
        });
      }) : { dispose: () => {
      } }
    ), this.registerEventHandler(
      this.Event.BeforeSheetDataValidationAdd,
      () => e.beforeCommandExecuted((a) => {
        if (a.id === ga.id) {
          const r = a.params, i = this.getSheetTarget(r.unitId, r.subUnitId);
          if (!i)
            return;
          const { workbook: h2, worksheet: s } = i, o = {
            worksheet: s,
            workbook: h2,
            rule: r.rule
          };
          if (this.fireEvent(this.Event.BeforeSheetDataValidationAdd, o), o.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetDataValidationCriteriaUpdate,
      () => e.beforeCommandExecuted((a) => {
        if (a.id === pa.id) {
          const r = a.params, i = this.getSheetTarget(r.unitId, r.subUnitId);
          if (!i)
            return;
          const { workbook: h2, worksheet: s } = i, o = s.getDataValidation(r.ruleId);
          if (!o)
            return;
          const d = {
            worksheet: s,
            workbook: h2,
            rule: o,
            ruleId: r.ruleId,
            newCriteria: r.setting
          };
          if (this.fireEvent(this.Event.BeforeSheetDataValidationCriteriaUpdate, d), d.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetDataValidationRangeUpdate,
      () => e.beforeCommandExecuted((a) => {
        if (a.id === ma.id) {
          const r = a.params, i = this.getSheetTarget(r.unitId, r.subUnitId);
          if (!i)
            return;
          const { workbook: h2, worksheet: s } = i, o = s.getDataValidation(r.ruleId);
          if (!o)
            return;
          const d = {
            worksheet: s,
            workbook: h2,
            rule: o,
            ruleId: r.ruleId,
            newRanges: r.ranges
          };
          if (this.fireEvent(this.Event.BeforeSheetDataValidationRangeUpdate, d), d.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetDataValidationOptionsUpdate,
      () => e.beforeCommandExecuted((a) => {
        if (a.id === fa.id) {
          const r = a.params, i = this.getSheetTarget(r.unitId, r.subUnitId);
          if (!i)
            return;
          const { workbook: h2, worksheet: s } = i, o = s.getDataValidation(r.ruleId);
          if (!o)
            return;
          const d = {
            worksheet: s,
            workbook: h2,
            rule: o,
            ruleId: r.ruleId,
            newOptions: r.options
          };
          if (this.fireEvent(this.Event.BeforeSheetDataValidationOptionsUpdate, d), d.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetDataValidationDelete,
      () => e.beforeCommandExecuted((a) => {
        if (a.id === Sa.id) {
          const r = a.params, i = this.getSheetTarget(r.unitId, r.subUnitId);
          if (!i)
            return;
          const { workbook: h2, worksheet: s } = i, o = s.getDataValidation(r.ruleId);
          if (!o)
            return;
          const d = {
            worksheet: s,
            workbook: h2,
            rule: o,
            ruleId: r.ruleId
          };
          if (this.fireEvent(this.Event.BeforeSheetDataValidationDelete, d), d.cancel)
            throw new KC();
        }
      })
    ), this.registerEventHandler(
      this.Event.BeforeSheetDataValidationDeleteAll,
      () => e.beforeCommandExecuted((a) => {
        if (a.id === Ra.id) {
          const r = a.params, i = this.getSheetTarget(r.unitId, r.subUnitId);
          if (!i)
            return;
          const { workbook: h2, worksheet: s } = i, o = {
            worksheet: s,
            workbook: h2,
            rules: s.getDataValidations()
          };
          if (this.fireEvent(this.Event.BeforeSheetDataValidationDeleteAll, o), o.cancel)
            throw new KC();
        }
      })
    );
  }
};
I2.extend(J);
var Y = class extends C2 {
  _initialize() {
    Object.defineProperty(this, "_dataValidationModel", {
      get() {
        return this._injector.get(F2);
      }
    });
  }
  getValidatorStatus() {
    return this._injector.get(we).validatorWorkbook(this._workbook.getUnitId());
  }
  async getAllDataValidationErrorAsync() {
    const t = this._workbook.getUnitId(), e = this._dataValidationModel.getSubUnitIds(t), a = [];
    for (const r of e) {
      const i = await this._collectValidationErrorsForSheet(t, r);
      a.push(...i);
    }
    return a;
  }
  async _collectValidationErrorsForSheet(t, e) {
    const a = this._dataValidationModel.getRules(t, e);
    if (!a.length)
      return [];
    const r = a.flatMap((i) => i.ranges);
    return this._collectValidationErrorsForRange(t, e, r);
  }
  async _collectValidationErrorsForRange(t, e, a) {
    if (!a.length)
      return [];
    const r = this._injector.get(we), h2 = this._workbook.getSheetBySheetId(e);
    if (!h2)
      throw new Error(`Cannot find worksheet with sheetId: ${e}`);
    const s = h2.getName(), o = [];
    for (const d of a) {
      const u = [];
      for (let l = d.startRow; l <= d.endRow; l++)
        for (let c = d.startColumn; c <= d.endColumn; c++)
          u.push((async () => {
            var _;
            try {
              if (await r.validatorCell(t, e, l, c) !== NC.VALID) {
                const m = this._dataValidationModel.getRuleByLocation(t, e, l, c);
                if (m) {
                  const k2 = ((_ = h2.getCell(l, c)) == null ? void 0 : _.v) || null, I3 = this._createDataValidationError(
                    s,
                    l,
                    c,
                    m,
                    k2
                  );
                  o.push(I3);
                }
              }
            } catch (E) {
              console.warn(`Failed to validate cell [${l}, ${c}]:`, E);
            }
          })());
      await Promise.all(u);
    }
    return o;
  }
  _createDataValidationError(t, e, a, r, i) {
    return {
      sheetName: t,
      row: e,
      column: a,
      ruleId: r.uid,
      inputValue: i,
      rule: r
    };
  }
  // region DataValidationHooks
  onDataValidationChange(t) {
    return We(this._dataValidationModel.ruleChange$.pipe(filter((e) => e.unitId === this._workbook.getUnitId())).subscribe(t));
  }
  onDataValidationStatusChange(t) {
    return We(this._dataValidationModel.validStatusChange$.pipe(filter((e) => e.unitId === this._workbook.getUnitId())).subscribe(t));
  }
  onBeforeAddDataValidation(t) {
    return We(this._commandService.beforeCommandExecuted((e, a) => {
      const r = e.params;
      if (e.id === ga.id) {
        if (r.unitId !== this._workbook.getUnitId())
          return;
        if (t(r, a) === false)
          throw new Error("Command is stopped by the hook onBeforeAddDataValidation");
      }
    }));
  }
  onBeforeUpdateDataValidationCriteria(t) {
    return We(this._commandService.beforeCommandExecuted((e, a) => {
      const r = e.params;
      if (e.id === pa.id) {
        if (r.unitId !== this._workbook.getUnitId())
          return;
        if (t(r, a) === false)
          throw new Error("Command is stopped by the hook onBeforeUpdateDataValidationCriteria");
      }
    }));
  }
  onBeforeUpdateDataValidationRange(t) {
    return We(this._commandService.beforeCommandExecuted((e, a) => {
      const r = e.params;
      if (e.id === ma.id) {
        if (r.unitId !== this._workbook.getUnitId())
          return;
        if (t(r, a) === false)
          throw new Error("Command is stopped by the hook onBeforeUpdateDataValidationRange");
      }
    }));
  }
  onBeforeUpdateDataValidationOptions(t) {
    return We(this._commandService.beforeCommandExecuted((e, a) => {
      const r = e.params;
      if (e.id === fa.id) {
        if (r.unitId !== this._workbook.getUnitId())
          return;
        if (t(r, a) === false)
          throw new Error("Command is stopped by the hook onBeforeUpdateDataValidationOptions");
      }
    }));
  }
  onBeforeDeleteDataValidation(t) {
    return We(this._commandService.beforeCommandExecuted((e, a) => {
      const r = e.params;
      if (e.id === Sa.id) {
        if (r.unitId !== this._workbook.getUnitId())
          return;
        if (t(r, a) === false)
          throw new Error("Command is stopped by the hook onBeforeDeleteDataValidation");
      }
    }));
  }
  onBeforeDeleteAllDataValidation(t) {
    return We(this._commandService.beforeCommandExecuted((e, a) => {
      const r = e.params;
      if (e.id === Ra.id) {
        if (r.unitId !== this._workbook.getUnitId())
          return;
        if (t(r, a) === false)
          throw new Error("Command is stopped by the hook onBeforeDeleteAllDataValidation");
      }
    }));
  }
};
C2.extend(Y);
var Z = class extends S2 {
  getDataValidations() {
    return this._injector.get(h).getRules(this._workbook.getUnitId(), this._worksheet.getSheetId()).map((e) => new w(e, this._worksheet, this._injector));
  }
  getValidatorStatus() {
    return this._injector.get(we).validatorWorksheet(
      this._workbook.getUnitId(),
      this._worksheet.getSheetId()
    );
  }
  getValidatorStatusAsync() {
    return this.getValidatorStatus();
  }
  getDataValidation(t) {
    const a = this._injector.get(h).getRuleById(this._workbook.getUnitId(), this._worksheet.getSheetId(), t);
    return a ? new w(a, this._worksheet, this._injector) : null;
  }
  async getAllDataValidationErrorAsync() {
    const t = this._workbook.getUnitId(), e = this._worksheet.getSheetId();
    return this._collectValidationErrorsForSheet(t, e);
  }
  async _collectValidationErrorsForSheet(t, e) {
    const r = this._injector.get(h).getRules(t, e);
    if (!r.length)
      return [];
    const i = r.flatMap((h2) => h2.ranges);
    return this._collectValidationErrorsForRange(t, e, i);
  }
  async _collectValidationErrorsForRange(t, e, a) {
    if (!a.length)
      return [];
    const r = this._injector.get(we), i = this._worksheet, h2 = i.getName(), s = [];
    for (const o of a) {
      const d = [];
      for (let u = o.startRow; u <= o.endRow; u++)
        for (let l = o.startColumn; l <= o.endColumn; l++)
          d.push((async () => {
            var c;
            try {
              if (await r.validatorCell(t, e, u, l) !== NC.VALID) {
                const m = this._injector.get(F2).getRuleByLocation(t, e, u, l);
                if (m) {
                  const k2 = ((c = i.getCell(u, l)) == null ? void 0 : c.v) || null, I3 = this._createDataValidationError(
                    h2,
                    u,
                    l,
                    m,
                    k2
                  );
                  s.push(I3);
                }
              }
            } catch (_) {
              console.warn(`Failed to validate cell [${u}, ${l}]:`, _);
            }
          })());
      await Promise.all(d);
    }
    return s;
  }
  _createDataValidationError(t, e, a, r, i) {
    return {
      sheetName: t,
      row: e,
      column: a,
      ruleId: r.uid,
      inputValue: i,
      rule: r
    };
  }
};
S2.extend(Z);
var tt = class {
  get SheetDataValidationChanged() {
    return "SheetDataValidationChanged";
  }
  get SheetDataValidatorStatusChanged() {
    return "SheetDataValidatorStatusChanged";
  }
  get BeforeSheetDataValidationAdd() {
    return "BeforeSheetDataValidationAdd";
  }
  get BeforeSheetDataValidationDelete() {
    return "BeforeSheetDataValidationDelete";
  }
  get BeforeSheetDataValidationDeleteAll() {
    return "BeforeSheetDataValidationDeleteAll";
  }
  get BeforeSheetDataValidationCriteriaUpdate() {
    return "BeforeSheetDataValidationCriteriaUpdate";
  }
  get BeforeSheetDataValidationRangeUpdate() {
    return "BeforeSheetDataValidationRangeUpdate";
  }
  get BeforeSheetDataValidationOptionsUpdate() {
    return "BeforeSheetDataValidationOptionsUpdate";
  }
};
j2.extend(tt);

// node_modules/@univerjs/preset-sheets-data-validation/lib/es/index.js
function f(t = {}) {
  const { showEditOnDropdown: i } = t;
  return {
    plugins: [
      C,
      Ie,
      [Tt, {
        showEditOnDropdown: i
      }]
    ].filter((o) => !!o)
  };
}
export {
  S as AddDataValidationMutation,
  ga as AddSheetDataValidationCommand,
  er as BASE_FORMULA_INPUT_NAME,
  G as BaseDataValidator,
  fe2 as BaseSheetDataValidatorView,
  Ee as CHECKBOX_FORMULA_1,
  Ve2 as CHECKBOX_FORMULA_2,
  ar as CHECKBOX_FORMULA_INPUT_NAME,
  Ja as CUSTOM_FORMULA_INPUT_NAME,
  ia as CheckboxValidator,
  _a as ClearRangeDataValidationCommand,
  Ea as DATA_VALIDATION_PLUGIN_NAME,
  Q2 as DataValidationCacheService,
  H as DataValidationCustomFormulaService,
  Te as DataValidationFormulaController,
  K as DataValidationFormulaService,
  h as DataValidationModel,
  I as DataValidationResourceController,
  Ve as DataValidatorDropdownType,
  pe as DataValidatorRegistryScope,
  F as DataValidatorRegistryService,
  na as DateValidator,
  B as FORMULA1,
  x as FORMULA2,
  tr as LIST_FORMULA_INPUT_NAME,
  Da as ListMultipleValidator,
  ft as ListValidator,
  N as RemoveDataValidationMutation,
  Ra as RemoveSheetAllDataValidationCommand,
  Sa as RemoveSheetDataValidationCommand,
  F2 as SheetDataValidationModel,
  we as SheetsDataValidationValidatorService,
  Ce as TWO_FORMULA_OPERATOR_COUNT,
  P as TYPE,
  Ue as TextLengthErrorTitleMap,
  C as UniverDataValidationPlugin,
  Bn as UniverSheetsDataValidationMobileUIPlugin,
  Ie as UniverSheetsDataValidationPlugin,
  f as UniverSheetsDataValidationPreset,
  Tt as UniverSheetsDataValidationUIPlugin,
  v as UpdateDataValidationMutation,
  p as UpdateRuleType,
  fa as UpdateSheetDataValidationOptionsCommand,
  ma as UpdateSheetDataValidationRangeCommand,
  pa as UpdateSheetDataValidationSettingCommand,
  Za as createDefaultNewRule,
  _e as deserializeListOptions,
  ye as getCellValueNumber,
  ne as getCellValueOrigin,
  za as getDataValidationCellValue,
  Ue2 as getDataValidationDiffMutations,
  pe2 as getFormulaCellData,
  oe as getFormulaResult,
  j as getRuleOptions,
  Q as getRuleSetting,
  Le as getTransformedFormula,
  C3 as isLegalFormulaResult,
  Ka as serializeListOptions,
  fe as transformCheckboxValue
};
//# sourceMappingURL=@univerjs_presets_preset-sheets-data-validation.js.map
