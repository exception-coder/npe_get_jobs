var Ku = Object.defineProperty;
var Xu = (i, a, e) => a in i ? Ku(i, a, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[a] = e;
var A = (i, a, e) => Xu(i, typeof a != "symbol" ? a + "" : a, e);
import { ObjectMatrix as Ce, CommandType as Fe, RANGE_TYPE as et, AbsoluteRefType as we, Tools as qe, createIdentifier as Ze, Disposable as Ne, IUniverInstanceService as Yn, LRUMap as Zu, hashAlgorithm as zu, moveRangeByOffset as aa, isValidRange as Ju, isFormulaString as dt, isFormulaId as Nt, Rectangle as Za, cellToRange as ec, Inject as ye, UniverInstanceType as fr, BooleanNumber as qi, LocaleService as tc, LocaleType as mt, numfmt as At, BuildTextUtils as rc, isRealNum as W, getNumfmtParseValueFilter as nc, CellValueType as Vt, isTextFormat as sc, RichTextBuilder as ac, toDisposable as ic, Injector as Ki, generateRandomId as oc, sortRules as uc, RTree as Os, IConfigService as ia, AsyncLock as cc, requestImmediateMacroTask as lc, ICommandService as ir, DataStreamTreeTokenType as Te, DisposableCollection as fc, Optional as hc, Plugin as mc, merge as gc, touchDependencies as cs } from "@univerjs/core";
import { Subject as hr, BehaviorSubject as Xi, distinctUntilChanged as Zi, combineLatest as dc, map as Cc, Observable as _c, shareReplay as Ac } from "rxjs";
import { DataSyncPrimaryController as Ec } from "@univerjs/rpc";
var rr = /* @__PURE__ */ ((i) => (i.FALSE = "FALSE", i.TRUE = "TRUE", i))(rr || {}), Ut = /* @__PURE__ */ ((i) => (i[i.SUCCESS = 0] = "SUCCESS", i[i.ERROR = 1] = "ERROR", i))(Ut || {}), ct = /* @__PURE__ */ ((i) => (i[i.FRONT = 0] = "FRONT", i[i.BACK = 1] = "BACK", i))(ct || {});
function bc(i, a, e, t, r) {
  for (let n = 0, s = i.length; n < s; n++) {
    const o = i[n];
    if (a !== o.unitId || e !== o.sheetId)
      continue;
    const { startRow: u, startColumn: c, endRow: l, endColumn: f } = o.range;
    if (t >= u && t <= l && r >= c && r <= f)
      return !0;
  }
  return !1;
}
var m = /* @__PURE__ */ ((i) => (i.DIV_BY_ZERO = "#DIV/0!", i.NAME = "#NAME?", i.VALUE = "#VALUE!", i.NUM = "#NUM!", i.NA = "#N/A", i.CYCLE = "#CYCLE!", i.REF = "#REF!", i.SPILL = "#SPILL!", i.CALC = "#CALC!", i.ERROR = "#ERROR!", i.CONNECT = "#GETTING_DATA", i.NULL = "#NULL!", i))(m || {});
const or = new Set(Object.values(m)), za = [...new Set(Object.values(m).map((i) => i.length))];
var yc = /* @__PURE__ */ ((i) => (i[i.Financial = 0] = "Financial", i[i.Date = 1] = "Date", i[i.Math = 2] = "Math", i[i.Statistical = 3] = "Statistical", i[i.Lookup = 4] = "Lookup", i[i.Database = 5] = "Database", i[i.Text = 6] = "Text", i[i.Logical = 7] = "Logical", i[i.Information = 8] = "Information", i[i.Engineering = 9] = "Engineering", i[i.Cube = 10] = "Cube", i[i.Compatibility = 11] = "Compatibility", i[i.Web = 12] = "Web", i[i.Array = 13] = "Array", i[i.Univer = 14] = "Univer", i[i.User = 15] = "User", i[i.DefinedName = 16] = "DefinedName", i))(yc || {}), X = /* @__PURE__ */ ((i) => (i.PLUS = "+", i.MINUS = "-", i.MULTIPLY = "*", i.DIVIDED = "/", i.CONCATENATE = "&", i.POWER = "^", i.EQUALS = "=", i.NOT_EQUAL = "<>", i.GREATER_THAN = ">", i.GREATER_THAN_OR_EQUAL = ">=", i.LESS_THAN = "<", i.LESS_THAN_OR_EQUAL = "<=", i))(X || {}), F = /* @__PURE__ */ ((i) => (i.EQUALS = "=", i.NOT_EQUAL = "<>", i.GREATER_THAN = ">", i.GREATER_THAN_OR_EQUAL = ">=", i.LESS_THAN = "<", i.LESS_THAN_OR_EQUAL = "<=", i))(F || {});
const sn = /* @__PURE__ */ new Map([
  ["<>", 4],
  ["<", 4],
  [">=", 4],
  ["=", 4],
  [">", 4],
  ["<=", 4],
  ["&", 3],
  ["+", 2],
  ["-", 2],
  ["/", 1],
  ["*", 1],
  ["^", 0]
  // ^
]), xt = new Set(sn.keys()), Rc = /* @__PURE__ */ new Set([
  "=",
  "<>",
  ">",
  ">=",
  "<",
  "<="
  /* LESS_THAN_OR_EQUAL */
]);
var K = /* @__PURE__ */ ((i) => (i.OPEN_BRACKET = "(", i.CLOSE_BRACKET = ")", i.COMMA = ",", i.SINGLE_QUOTATION = "'", i.DOUBLE_QUOTATION = '"', i.OPEN_BRACES = "{", i.CLOSE_BRACES = "}", i.COLON = ":", i.OPEN_SQUARE_BRACKET = "[", i.CLOSE_SQUARE_BRACKET = "]", i))(K || {}), tt = /* @__PURE__ */ ((i) => (i.PERCENTAGE = "%", i.POUND = "#", i))(tt || {});
const ls = /* @__PURE__ */ new Set([
  "%",
  "#"
  /* POUND */
]);
var Me = /* @__PURE__ */ ((i) => (i.AT = "@", i.MINUS = "-", i.PLUS = "+", i))(Me || {});
const pc = " ", zi = [
  ...Object.values(F),
  ...Object.values(X),
  ...Object.values(K),
  ...Object.values(tt),
  ...Object.values(Me)
];
function an(i) {
  return zi.includes(i);
}
function Vc(i) {
  for (const a of zi)
    if (i.indexOf(a) > -1)
      return !0;
  return !1;
}
function Kb(i) {
  return i[0] === "'" && i[i.length - 1] === "'" ? i.substring(1, i.length - 1) : i;
}
function Xb(i) {
  return an(i) && i !== K.CLOSE_BRACES && i !== K.CLOSE_BRACKET && i !== K.SINGLE_QUOTATION && i !== K.DOUBLE_QUOTATION || i === " ";
}
const Nc = /* @__PURE__ */ new Set([
  X.PLUS,
  X.MINUS,
  X.MULTIPLY,
  X.DIVIDED,
  X.CONCATENATE,
  X.POWER,
  X.EQUALS,
  X.NOT_EQUAL,
  X.GREATER_THAN,
  X.GREATER_THAN_OR_EQUAL,
  X.LESS_THAN,
  X.LESS_THAN_OR_EQUAL,
  K.OPEN_BRACKET,
  K.COMMA,
  K.COLON,
  K.OPEN_BRACES,
  K.OPEN_SQUARE_BRACKET
]);
function Oc(i) {
  return Nc.has(i);
}
const Mc = /* @__PURE__ */ new Set([
  X.PLUS,
  X.MINUS,
  X.MULTIPLY,
  X.DIVIDED,
  X.CONCATENATE,
  X.POWER,
  X.EQUALS,
  X.NOT_EQUAL,
  X.GREATER_THAN,
  X.GREATER_THAN_OR_EQUAL,
  X.LESS_THAN,
  X.LESS_THAN_OR_EQUAL,
  K.OPEN_BRACKET,
  K.COMMA,
  K.COLON,
  K.OPEN_BRACES,
  K.OPEN_SQUARE_BRACKET,
  tt.PERCENTAGE,
  tt.POUND
]);
function wc(i) {
  return Mc.has(i);
}
const Ji = '\\[([^\\[\\]\\/?:"<>|*\\\\]+)\\]', Ja = new RegExp(Ji), Sc = "((?![\\[\\]\\/?*\\\\]).)*!", It = "$", oa = "\\s*?:\\s*?", dn = "[A-Za-z]+", Cn = "[1-9][0-9]*", Vr = `'?(${Ji})?(${Sc})?'?`, Ms = `\\${It}?${dn}\\${It}?${Cn}`, Dc = `^(${Me.AT})?${Vr}${Ms}${oa}${Ms}$`, ei = new RegExp(Dc), Lc = `^${Vr}\\s*?${Ms}(${tt.POUND})?$`, ti = new RegExp(Lc), Pc = `^${Vr}\\${It}?${Cn}${oa}\\${It}?${Cn}$`, ri = new RegExp(Pc), xc = `^${Vr}\\${It}?${dn}${oa}\\${It}?${dn}$`, ni = new RegExp(xc), jc = `^${Vr}\\s*?\\${It}?${Cn}$`, si = new RegExp(jc), Uc = `^${Vr}\\s*?\\${It}?${dn}$`, ai = new RegExp(Uc), vc = "{.*?}", ii = new RegExp(vc, "g");
function Br(i) {
  return ti.lastIndex = 0, ti.test(i);
}
function Tc(i) {
  return ei.lastIndex = 0, ei.test(i);
}
function eo(i) {
  return ri.lastIndex = 0, ri.test(i);
}
function to(i) {
  return ni.lastIndex = 0, ni.test(i);
}
function ro(i) {
  return si.lastIndex = 0, si.test(i);
}
function no(i) {
  return ai.lastIndex = 0, ai.test(i);
}
function Bc(i) {
  return ii.lastIndex = 0, ii.test(i);
}
function so(i) {
  return Br(i) || Tc(i) || eo(i) || to(i);
}
function Ic(i) {
  const a = {};
  return Object.keys(i).forEach((e) => {
    const t = i[e];
    if (t == null)
      return !0;
    a[e] == null && (a[e] = {}), Object.keys(t).forEach((r) => {
      const n = t[r];
      a[e][r] = new Ce(n);
    });
  }), a;
}
function Fc(i) {
  const a = {};
  for (const e in i) {
    const t = i[e];
    if (t != null) {
      a[e] == null && (a[e] = {});
      for (const r in t) {
        const n = t[r], s = {};
        n.forValue((o, u, c) => {
          s[o] === void 0 && (s[o] = {}), s[o][u] = c;
        }), a[e][r] = s;
      }
    }
  }
  return a;
}
const kc = {
  id: "formula.mutation.register-function",
  type: Fe.MUTATION,
  handler: () => !0
}, ws = {
  id: "formula.mutation.set-array-formula-data",
  type: Fe.MUTATION,
  handler: (i, a) => !0
}, $c = /[^0-9]/g, Yc = /[^A-Za-z]/g;
function on(i) {
  let a = i[0] === "$";
  const e = i.substring(1);
  let t = e.indexOf("$") > -1;
  return qe.isStringNumber(e) && a && !t && (a = !1, t = !0), a && t ? we.ALL : a ? we.COLUMN : t ? we.ROW : we.NONE;
}
function Zb(i) {
  const a = i.split("!");
  a.length > 1 && (i = a[a.length - 1]);
  const e = i.split(":");
  return e.length > 1 ? {
    startAbsoluteRefType: on(e[0]),
    endAbsoluteRefType: on(e[1])
  } : { startAbsoluteRefType: on(e[0]) };
}
function oi(i = we.NONE) {
  let a = "", e = "";
  return i === we.ROW ? a = "$" : i === we.COLUMN ? e = "$" : i === we.ALL && (a = "$", e = "$"), {
    rowAbsoluteString: a,
    columnAbsoluteString: e
  };
}
function Ft(i) {
  const {
    startColumn: a,
    startRow: e,
    endColumn: t,
    endRow: r,
    startAbsoluteRefType: n,
    endAbsoluteRefType: s,
    rangeType: o = et.NORMAL
  } = i, u = oi(n), c = oi(s);
  if (o === et.ROW || o === et.ALL) {
    const h = `${u.rowAbsoluteString}${e + 1}`, d = `${c.rowAbsoluteString}${r + 1}`;
    return `${h}:${d}`;
  }
  if (o === et.COLUMN) {
    const h = `${u.columnAbsoluteString}${qe.chatAtABC(a)}`, d = `${c.columnAbsoluteString}${qe.chatAtABC(t)}`;
    return `${h}:${d}`;
  }
  const l = `${u.columnAbsoluteString}${qe.chatAtABC(a)}${u.rowAbsoluteString}${e + 1}`, f = `${c.columnAbsoluteString}${qe.chatAtABC(t)}${c.rowAbsoluteString}${r + 1}`;
  return l === f ? l : `${l}:${f}`;
}
function Hc(i, a) {
  return `${io(i)}!${Ft(a)}`;
}
function Gc(i, a, e) {
  return Ds(i) || Ds(a) ? `'[${Ls(i)}]${Ls(a)}'!${Ft(e)}` : `[${i}]${a}!${Ft(e)}`;
}
function Ss(i) {
  const { unitId: a, sheetName: e, range: t } = i;
  return a != null && a.length > 0 && e != null && e.length > 0 ? Gc(a, e, t) : e != null && e.length > 0 ? Hc(e, t) : Ft(t);
}
function fs(i) {
  const a = Number.parseInt(i.replace($c, "")) - 1, e = qe.ABCatNum(i.replace(Yc, "")), t = on(i);
  return {
    row: a,
    column: e,
    absoluteRefType: t
  };
}
function ua(i) {
  const a = Ja.exec(i);
  let e = "";
  a != null && (e = a[0].trim(), e = ui(e.slice(1, e.length - 1)), i = i.replace(Ja, ""));
  const t = i.indexOf("!");
  let r = "", n = "";
  return t > -1 ? (r = i.substring(0, t), r[0] === "'" && r[r.length - 1] === "'" && (r = r.substring(1, r.length - 1)), r = ui(r), n = i.substring(t + 1)) : n = i, {
    refBody: n,
    sheetName: r,
    unitId: e
  };
}
function Dr(i) {
  const { refBody: a, sheetName: e, unitId: t } = ua(i), r = a.indexOf(":");
  if (r === -1) {
    const _ = fs(a), C = _.row, E = _.column, b = _.absoluteRefType;
    return {
      unitId: t,
      sheetName: e,
      range: {
        startRow: C,
        startColumn: E,
        endRow: C,
        endColumn: E,
        startAbsoluteRefType: b,
        endAbsoluteRefType: b
      }
    };
  }
  const n = a.substring(0, r), s = a.substring(r + 1), o = fs(n), u = fs(s), c = o.row > u.row ? u.row : o.row, l = o.column > u.column ? u.column : o.column, f = o.row > u.row ? o.row : u.row, h = o.column > u.column ? o.column : u.column;
  let d = et.NORMAL;
  return Number.isNaN(c) && Number.isNaN(f) ? d = et.COLUMN : Number.isNaN(l) && Number.isNaN(h) && (d = et.ROW), {
    unitId: t,
    sheetName: e,
    range: {
      startRow: c,
      startColumn: l,
      endRow: f,
      endColumn: h,
      startAbsoluteRefType: o.absoluteRefType,
      endAbsoluteRefType: u.absoluteRefType,
      rangeType: d
    }
  };
}
const Qc = ["LOG10"];
function un(i) {
  const a = ao(i);
  if (!so(a) || Qc.includes(a.toUpperCase().trim()))
    return !1;
  const { range: e } = Dr(a);
  return !(e.endColumn >= 16384);
}
function ao(i) {
  const a = [];
  let e = !1;
  for (let t = 0, r = i.length; t < r; t++) {
    const n = i[t];
    if (n === pc && !e)
      a.push(n);
    else {
      if (!e && (n === Me.AT || n === Me.MINUS || n === Me.PLUS))
        continue;
      a.push(n), e = !0;
    }
  }
  return a.join("");
}
function zb(i, a) {
  const e = (i == null ? void 0 : i.split(",")) || [];
  return i === "" || e.length === 0 ? [] : Wc(i) ? e.map((n) => {
    const s = Dr(n);
    return {
      unitId: s.unitId,
      sheetId: a(s.sheetName),
      range: s.range,
      sheetName: s.sheetName
    };
  }) : [];
}
function Wc(i) {
  return ((i == null ? void 0 : i.split(",")) || []).every((e) => un(e.trim()));
}
function Ds(i) {
  return i.length === 0 ? !1 : !!(Vc(i) || qc(i) || Kc(i) || Xc(i) || /[\s!$%^&*()+\-=\[\]{};':"\\|,.<>\/?（）]/.test(i));
}
function io(i) {
  return Ds(i) ? `'${Ls(i)}'` : i;
}
function Ls(i) {
  return i.replace(/'/g, "''");
}
function ui(i) {
  return i.replace(/''/g, "'");
}
function qc(i) {
  const a = i.match(/[1-9][0-9]{0,6}/);
  return /^[A-Z]+[1-9][0-9]{0,6}$/.test(i) && a !== null;
}
function Kc(i) {
  return /^(R(-?[0-9]+)?C(-?[0-9]+)?|C(-?[0-9]+)?|R(-?[0-9]+)?)$/.test(i);
}
function Xc(i) {
  return !new RegExp("^\\p{Letter}", "u").test(i.charAt(0));
}
var Zc = Object.getOwnPropertyDescriptor, zc = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Zc(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Jc = (i, a) => (e, t) => a(e, t, i);
let Ps = class extends Ne {
  constructor(a) {
    super();
    // 18.2.6 definedNames (Defined Names)
    A(this, "_definedNameMap", {});
    A(this, "_nameCacheMap", {});
    // Cache for name-to-definition mapping
    A(this, "_update$", new hr());
    A(this, "update$", this._update$.asObservable());
    A(this, "_currentRange", {
      unitId: "",
      sheetId: "",
      range: {
        startRow: 0,
        endRow: 0,
        startColumn: 0,
        endColumn: 0
      }
    });
    A(this, "_currentRange$", new hr());
    A(this, "currentRange$", this._currentRange$.asObservable());
    A(this, "_focusRange$", new hr());
    A(this, "focusRange$", this._focusRange$.asObservable());
    this._univerInstanceService = a;
  }
  dispose() {
    super.dispose(), this._definedNameMap = {}, this._nameCacheMap = {}, this._update$.complete(), this._currentRange$.complete(), this._focusRange$.complete();
  }
  getWorksheetByRef(a, e) {
    var r;
    const { sheetName: t } = ua(e);
    return (r = this._univerInstanceService.getUnit(a)) == null ? void 0 : r.getSheetBySheetName(t);
  }
  focusRange(a, e) {
    const t = this.getValueById(a, e);
    t !== void 0 && this._focusRange$.next({ ...t, unitId: a });
  }
  setCurrentRange(a) {
    this._currentRange = a, this._currentRange$.next(a);
  }
  getCurrentRange() {
    return this._currentRange;
  }
  getCurrentRangeForString() {
    return Ft(this._currentRange.range);
  }
  registerDefinedNames(a, e) {
    this._definedNameMap[a] = e, this._updateCache(a), this._update();
  }
  registerDefinedName(a, e) {
    this._definedNameMap[a] === void 0 && (this._definedNameMap[a] = {}), this._definedNameMap[a][e.id] = e, this._updateCache(a), this._update();
  }
  removeDefinedName(a, e) {
    var t;
    (t = this._definedNameMap[a]) == null || delete t[e], this._updateCache(a), this._update();
  }
  removeUnitDefinedName(a) {
    delete this._definedNameMap[a], this._updateCache(a), this._update();
  }
  getDefinedNameMap(a) {
    return this._definedNameMap[a];
  }
  getValueByName(a, e) {
    const t = this._nameCacheMap[a];
    if (t)
      return t[e] || null;
    const r = this._definedNameMap[a];
    if (r === void 0)
      return null;
    let n = null;
    for (const s of Object.values(r))
      if (s.name === e) {
        n = s;
        break;
      }
    return n && (this._nameCacheMap[a] = this._nameCacheMap[a] || {}, this._nameCacheMap[a][e] = n), n;
  }
  getValueById(a, e) {
    var t;
    return (t = this._definedNameMap[a]) == null ? void 0 : t[e];
  }
  hasDefinedName(a) {
    return this._definedNameMap[a] === void 0 ? !1 : (Array.from(Object.values(this._definedNameMap[a])).length || 0) !== 0;
  }
  _update() {
    this._update$.next(null);
  }
  _updateCache(a) {
    const e = this._definedNameMap[a];
    if (e === void 0) {
      delete this._nameCacheMap[a];
      return;
    }
    this._nameCacheMap[a] = {};
    for (const t of Object.values(e))
      this._nameCacheMap[a][t.name] = t;
  }
};
Ps = zc([
  Jc(0, Yn)
], Ps);
const Nr = Ze("univer.formula.defined-names.service"), Jb = (i, a) => {
  const { unitId: e, id: t } = a;
  return {
    ...i.get(Nr).getValueById(e, t),
    unitId: e
  };
}, ca = {
  id: "formula.mutation.set-defined-name",
  type: Fe.MUTATION,
  handler: (i, a) => {
    if (a == null)
      return !1;
    const e = i.get(Nr), { id: t, unitId: r, name: n, formulaOrRefString: s, comment: o, hidden: u, localSheetId: c } = a;
    return e.registerDefinedName(r, {
      id: t,
      name: n.trim(),
      formulaOrRefString: s.trim(),
      comment: o == null ? void 0 : o.trim(),
      hidden: u,
      localSheetId: c
    }), !0;
  }
}, oo = {
  id: "formula.mutation.remove-defined-name",
  type: Fe.MUTATION,
  handler: (i, a) => {
    if (a == null)
      return !1;
    const e = i.get(Nr), { unitId: t, id: r } = a;
    return e.removeDefinedName(t, r), !0;
  }
}, la = {
  id: "formula.mutation.set-feature-calculation",
  type: Fe.MUTATION,
  handler: () => !0
}, fa = {
  id: "formula.mutation.remove-feature-calculation",
  type: Fe.MUTATION,
  handler: () => !0
}, uo = {
  id: "formula.mutation.set-formula-calculation-start",
  type: Fe.MUTATION,
  handler: () => !0
}, co = {
  id: "formula.mutation.set-formula-calculation-stop",
  type: Fe.MUTATION,
  handler: () => !0
}, _n = {
  id: "formula.mutation.set-formula-calculation-notification",
  type: Fe.MUTATION,
  handler: () => !0
}, lo = {
  id: "formula.mutation.set-formula-calculation-result",
  type: Fe.MUTATION,
  handler: () => !0
}, fo = {
  id: "formula.mutation.set-formula-data",
  type: Fe.MUTATION,
  handler: (i, a) => !0
}, ha = {
  id: "formula.mutation.set-other-formula",
  type: Fe.MUTATION,
  handler: () => !0
}, ma = {
  id: "formula.mutation.remove-other-formula",
  type: Fe.MUTATION,
  handler: () => !0
}, el = {
  id: "formula.mutation.set-super-table",
  type: Fe.MUTATION,
  handler: () => !0
}, tl = {
  id: "formula.mutation.remove-super-table",
  type: Fe.MUTATION,
  handler: () => !0
}, ho = {
  id: "formula.mutation.set-super-table-option",
  type: Fe.MUTATION,
  handler: () => !0
};
class wt {
  constructor(a) {
    A(this, "_cache");
    this._cache = new Zu(a);
  }
  set(a, e) {
    const t = this._hash(a);
    this._cache.set(t, e);
  }
  get(a) {
    const e = this._hash(a);
    return this._cache.get(e);
  }
  clear() {
    this._cache.clear();
  }
  delete(a) {
    this._cache.delete(this._hash(a));
  }
  forEach(a, e) {
    this._cache.forEach(a, e);
  }
  _hash(a) {
    return a.length <= 64 ? a : zu(a).toString();
  }
}
const gt = "P_1", Tt = "R_1", dr = "L_1", Ir = "LR_1", mo = "LO_1", rl = "LET", Lr = "LAMBDA", nl = "CUBE", sl = /* @__PURE__ */ new Set(["RAND", "RANDBETWEEN", "NOW", "TODAY"]), xs = new wt(1e5);
function Cr(i) {
  const a = xs.get(i);
  if (a)
    return a;
  const e = Dr(i);
  return xs.set(i, e), Dr(i);
}
function al() {
  xs.clear();
}
var $e = /* @__PURE__ */ ((i) => (i[i.NORMAL = 0] = "NORMAL", i[i.NUMBER = 1] = "NUMBER", i[i.STRING = 2] = "STRING", i[i.FUNCTION = 3] = "FUNCTION", i[i.REFERENCE = 4] = "REFERENCE", i[i.ARRAY = 5] = "ARRAY", i[i.DEFINED_NAME = 6] = "DEFINED_NAME", i))($e || {});
function ci(i) {
  let a = "";
  for (const e of i)
    typeof e == "string" ? a += e : a += e.token;
  return a;
}
class ae {
  constructor() {
    A(this, "_parent");
    A(this, "_token", Tt);
    A(this, "_children", []);
    A(this, "_lambdaId");
    A(this, "_functionDefinitionPrivacyVar");
    A(this, "_lambdaParameter", "");
    A(this, "_startIndex", -1);
    A(this, "_endIndex", -1);
    A(this, "_definedNames", []);
  }
  dispose() {
    var a;
    this._children.forEach((e) => {
      typeof e != "string" && e.dispose();
    }), (a = this._functionDefinitionPrivacyVar) == null || a.clear(), this._functionDefinitionPrivacyVar = null, this._children = [], this._parent = null, this._definedNames = [];
  }
  getDefinedNames() {
    return this._definedNames;
  }
  getStartIndex() {
    return this._startIndex;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  setLambdaId(a) {
    this._lambdaId = a;
  }
  getFunctionDefinitionPrivacyVar() {
    return this._functionDefinitionPrivacyVar;
  }
  setLambdaPrivacyVar(a) {
    this._functionDefinitionPrivacyVar = a;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  setLambdaParameter(a) {
    this._lambdaParameter = a;
  }
  getParent() {
    return this._parent;
  }
  setParent(a) {
    this._parent = a;
  }
  getChildren() {
    return this._children;
  }
  setChildren(a) {
    this._children = a;
  }
  addChildren(a) {
    this._children.push(a);
  }
  addChildrenFirst(a) {
    this._children.unshift(a);
  }
  getToken() {
    return this._token;
  }
  setToken(a) {
    this._token = a;
  }
  setIndex(a, e) {
    this._startIndex = a, this._endIndex = e;
  }
  setDefinedNames(a) {
    this._definedNames = a;
  }
  hasDefinedNames() {
    return this._definedNames.length > 0;
  }
  replaceChild(a, e) {
    const t = this._getIndexInParent(a);
    t != null && (this.getChildren().splice(t, 1, e), e.setParent(this));
  }
  changeToParent(a) {
    const e = this.getParent();
    e && e.removeChild(this), this.setParent(a), a.getChildren().push(this);
  }
  removeChild(a) {
    const e = this._getIndexInParent(a);
    e != null && this.getChildren().splice(e, 1);
  }
  serialize() {
    const a = this.getToken(), e = this.getChildren(), t = [], r = e.length;
    for (let n = 0; n < r; n++) {
      const s = e[n];
      s instanceof ae ? t.push(s.serialize()) : t.push(s);
    }
    return {
      token: a,
      st: this._startIndex,
      ed: this._endIndex,
      children: t
    };
  }
  _getIndexInParent(a) {
    const e = this.getChildren(), t = e.length;
    for (let r = 0; r < t; r++)
      if (e[r] === a)
        return r;
  }
}
const go = 2e3, hs = new wt(go), ms = new wt(go);
class ga extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_currentLexerNode", new ae());
    A(this, "_upLevel", 0);
    A(this, "_segment", "");
    A(this, "_bracketState", []);
    // ()
    A(this, "_squareBracketState", 0);
    A(this, "_bracesState", 0);
    // {}
    A(this, "_singleQuotationState", 0);
    // ''
    A(this, "_doubleQuotationState", 0);
    // ""
    A(this, "_lambdaState", !1);
    // Lambda
    A(this, "_colonState", !1);
    // :
    A(this, "_formulaErrorCount", 0);
    A(this, "_tableBracketState", !1);
  }
  // Table3[[#All],[Column1]:[Column2]]
  dispose() {
    this._resetTemp(), this._currentLexerNode.dispose(), hs.clear(), ms.clear();
  }
  getUpLevel() {
    return this._upLevel;
  }
  isColonClose() {
    return this._colonState === !1;
  }
  isColonOpen() {
    return this._colonState === !0;
  }
  isDoubleQuotationClose() {
    return this._doubleQuotationState === 0;
  }
  isLambdaOpen() {
    return this._lambdaState === !0;
  }
  isLambdaClose() {
    return this._lambdaState === !1;
  }
  isSingleQuotationClose() {
    return this._singleQuotationState === 0;
  }
  isBracesClose() {
    return this._bracesState === 0;
  }
  isBracketClose() {
    return this._bracketState.length === 0;
  }
  isSquareBracketClose() {
    return this._squareBracketState === 0;
  }
  getCurrentLexerNode() {
    return this._currentLexerNode;
  }
  getFunctionAndParameter(e, t) {
    const r = this._getCurrentParamIndex(e, t);
    if (r == null || r === m.VALUE)
      return;
    const n = r[0];
    if (typeof n == "string")
      return;
    let s = n.getParent(), o = n;
    for (; s; ) {
      const u = s.getToken();
      if (u !== gt && !an(u) && s.getStartIndex() !== -1) {
        const c = s.getChildren().indexOf(o);
        return {
          functionName: u,
          paramIndex: c
        };
      }
      o = s, s = s.getParent();
    }
  }
  /**
   * Estimate the number of right brackets that need to be automatically added to the end of the formula.
   * @param formulaString
   */
  checkIfAddBracket(e) {
    let t = 0, r = e.length - 1, n = e[r];
    for (; (n === K.CLOSE_BRACKET || n === " ") && r >= 0; )
      n === K.CLOSE_BRACKET && t++, n = e[--r];
    const s = this._getCurrentParamIndex(e, e.length - 2);
    if (s == null || s === m.VALUE)
      return 0;
    const o = s[0];
    if (typeof o == "string")
      return 0;
    let u = o.getParent(), c = 0;
    for (s[1] === K.OPEN_BRACKET && c++; u; ) {
      const l = u.getToken();
      l !== gt && l !== K.COLON && u.getStartIndex() !== -1 && l.toUpperCase() !== Lr && (t === 0 ? c += 1 : t--), u = u.getParent();
    }
    return c;
  }
  sequenceNodesBuilder(e) {
    const t = ms.get(e);
    if (t)
      return [...t];
    const r = this._getSequenceArray(e);
    if (r.length === 0)
      return;
    const n = this.getSequenceNode(r);
    return ms.set(e, [...n]), n;
  }
  convertRefersToAbsolute(e, t, r, n = "") {
    const s = this.sequenceNodesBuilder(e);
    if (s == null)
      return e;
    let o = "";
    e.substring(0, 1) === X.EQUALS && (o = X.EQUALS);
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (typeof l != "string" && l.nodeType === $e.REFERENCE) {
        const { token: f, endIndex: h } = l, d = Cr(f);
        if (d == null)
          continue;
        const { range: _, sheetName: C, unitId: E } = d, b = {
          ..._,
          startAbsoluteRefType: t,
          endAbsoluteRefType: r
        }, R = Ss({
          range: b,
          unitId: E,
          sheetName: C || n
        }), p = R.length - f.length;
        s[u] = {
          ...l,
          token: R,
          endIndex: h + p
        };
        for (let N = u + 1; N < c; N++) {
          const M = s[N];
          typeof M != "string" && (M.startIndex += p, M.endIndex += p);
        }
      }
    }
    return `${o}${ci(s)}`;
  }
  moveFormulaRefOffset(e, t, r, n = !1) {
    const s = this.sequenceNodesBuilder(e);
    if (s == null)
      return e;
    const o = [];
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (typeof l == "string" || l.nodeType !== $e.REFERENCE) {
        o.push(l);
        continue;
      }
      const { token: f } = l, h = Cr(f), { sheetName: d, unitId: _ } = h;
      let C = h.range;
      if (!n && C.startAbsoluteRefType === we.ALL && C.endAbsoluteRefType === we.ALL) {
        o.push(l);
        continue;
      } else
        C = aa(C, t, r, n);
      let E = "";
      Ju(C) ? E = Ss({
        range: C,
        unitId: _,
        sheetName: d
      }) : E = m.REF, o.push({
        ...l,
        token: E
      });
    }
    return `=${ci(o)}`;
  }
  /**
   * univer-pro/issues/1684
   * =sum({}{})
   */
  _formulaSpellCheck() {
    if (this._currentLexerNode.getChildren().length === 0)
      return !0;
    const e = this._currentLexerNode.getChildren()[0];
    return !!(e instanceof ae || xt.has(e) || ls.has(e) || e === Me.AT || e === K.COMMA || e === K.COLON || e === K.OPEN_BRACKET);
  }
  // eslint-disable-next-line complexity
  getSequenceNode(e) {
    const t = [];
    let r = !1;
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n], u = e[n - 1], { segment: c, currentString: l } = o;
      if (l === K.DOUBLE_QUOTATION && (r = !0), (c !== "" || n === 0) && n !== s - 1) {
        t.push(l);
        continue;
      }
      let f = (u == null ? void 0 : u.segment) || "";
      const h = n - f.length;
      let d = n - 1;
      const _ = n - 1;
      if (n === s - 1 && this._isLastMergeString(l) && (f += l, d += 1), f === "" || sn.has(f)) {
        t.push(l);
        continue;
      }
      const C = f.trim(), E = ao(C);
      r === !0 && C[C.length - 1] === K.DOUBLE_QUOTATION && C[0] !== K.OPEN_BRACES ? (r = !1, this._processPushSequenceNode(t, $e.STRING, f, h, d, _)) : Br(E) && un(E) ? this._processPushSequenceNode(t, $e.REFERENCE, f, h, d, _) : qe.isStringNumber(C) ? this._processPushSequenceNode(t, $e.NUMBER, f, h, d, _) : C.length > 0 && this._processPushSequenceNode(t, $e.FUNCTION, f, h, d, _), (n !== s - 1 || !this._isLastMergeString(l)) && t.push(l);
    }
    return this._mergeSequenceNodeReference(t);
  }
  _processPushSequenceNode(e, t, r, n, s, o) {
    this._pushSequenceNode(
      e,
      {
        nodeType: t,
        token: r,
        startIndex: n,
        endIndex: s
      },
      o
    );
  }
  _getCurrentParamIndex(e, t) {
    return this._nodeMaker(e, void 0, t);
  }
  _isLastMergeString(e) {
    return e === K.DOUBLE_QUOTATION || qe.isStringNumber(e) || !an(e);
  }
  /**
   * Merge array and handle ref operations
   *
   */
  _mergeSequenceNodeReference(e) {
    const t = [], r = e.length;
    let n = 0;
    for (; n < r; ) {
      const s = e[n];
      if (typeof s == "string") {
        const o = e[n - 1];
        if (s.trim() === K.CLOSE_BRACES && o != null && typeof o != "string" && o.nodeType === $e.FUNCTION && o.token.trim().substring(0, 1) === K.OPEN_BRACES) {
          o.nodeType = $e.ARRAY, o.token += s, o.endIndex += s.length, n++;
          continue;
        }
        t.push(s);
      } else {
        const o = e[n + 1], u = e[n + 2];
        o === K.COLON && typeof s != "string" && u != null && typeof u != "string" && un((s.token + o + u.token).trim()) && (s.nodeType = $e.REFERENCE, s.token += o + u.token, s.endIndex = u.endIndex, n += 2), t.push(s);
      }
      n++;
    }
    return this._minusSplitSequenceNode(t);
  }
  /**
   * =-A1  Separate the negative sign from the ref string.
   */
  _minusSplitSequenceNode(e) {
    const t = [];
    for (const r of e) {
      if (typeof r != "string") {
        const s = r.token.match(/^(\s*([-@+]\s*)+)(.*)$/);
        if (s) {
          const o = s[1], u = s[3];
          if (un(u.trim())) {
            const c = o.length, l = r.startIndex, f = r.startIndex + c - 1, h = {
              nodeType: $e.NORMAL,
              // Use appropriate nodeType for operators
              token: o,
              startIndex: l,
              endIndex: f
            }, d = {
              nodeType: $e.REFERENCE,
              token: u,
              startIndex: f + 1,
              endIndex: r.endIndex
            };
            t.push(h), t.push(d);
            continue;
          }
        }
      }
      t.push(r);
    }
    return t;
  }
  _pushSequenceNode(e, t, r) {
    const n = r - t.startIndex + 1;
    e.splice(e.length - n, n, t);
  }
  nodeMakerTest(e) {
    return this._nodeMaker(e);
  }
  treeBuilder(e, t = !0, r) {
    var f;
    if (t === !0) {
      const h = hs.get(e), d = r && ((f = this._simpleCheckDefinedName) == null ? void 0 : f.call(this, e, r));
      if (h && !d)
        return h;
    }
    this._resetCurrentLexerNode(), this._currentLexerNode.setToken(Tt);
    const n = [];
    let s = this._nodeMaker(e, n);
    if (s === m.VALUE || n.length === 0)
      return s;
    let o = !1, u = "", c = [];
    if (r) {
      const { hasDefinedName: h, sequenceString: d, definedNames: _ } = this._handleDefinedName(n, r);
      o = h, u = d, c = _;
    }
    if (o && (this._resetCurrentLexerNode(), this._currentLexerNode.setToken(Tt), s = this._nodeMaker(`=${u}`), s === m.VALUE))
      return s;
    const l = this._getTopNode(this._currentLexerNode);
    if (l && (this._currentLexerNode = l), t) {
      if (!this._suffixExpressionHandler(this._currentLexerNode))
        return m.VALUE;
      hs.set(e, this._currentLexerNode);
    }
    return o && this._currentLexerNode.setDefinedNames(c), this._currentLexerNode;
  }
  _handleDefinedName(e, t) {
    const { unitId: r, getValueByName: n } = t;
    if (r == null)
      return {
        sequenceString: "",
        hasDefinedName: !1,
        definedNames: []
      };
    const s = this.getSequenceNode(e);
    let o = "", u = !1;
    const c = [];
    for (let l = 0, f = s.length; l < f; l++) {
      const h = s[l];
      if (typeof h == "string") {
        o += h;
        continue;
      }
      const { nodeType: d, token: _ } = h;
      if (d === $e.REFERENCE || d === $e.FUNCTION) {
        const C = n(r, _);
        if (C) {
          const E = C.formulaOrRefString, b = this._handleNestedDefinedName(E, t);
          if (b == null || typeof b != "object")
            o += b || m.NAME, u = !0, c.push(_);
          else if (typeof b == "object") {
            const { sequenceString: R, definedNames: p } = b;
            o += R, p.forEach((N) => {
              c.push(N);
            }), u = !0;
          }
        } else this._checkDefinedNameDirty(_, t) ? (o += m.NAME, u = !0, c.push(_)) : o += _;
      } else
        o += _;
    }
    return {
      sequenceString: o,
      hasDefinedName: u,
      definedNames: c
    };
  }
  _handleNestedDefinedName(e, t) {
    const r = [], n = this._nodeMaker(e, r);
    return n === m.VALUE || r.length === 0 ? n : this._handleDefinedName(r, t);
  }
  _simpleCheckDefinedName(e, t) {
    const { getDirtyDefinedNameMap: r, unitId: n } = t, s = r(), o = n;
    if (o != null && s[o] != null) {
      const u = Object.keys(s[o]);
      for (let c = 0, l = u.length; c < l; c++) {
        const f = u[c];
        if (e.indexOf(f) > -1)
          return !0;
      }
    }
    return !1;
  }
  _checkDefinedNameDirty(e, t) {
    const { getDirtyDefinedNameMap: r, unitId: n } = t, s = r(), o = n;
    if (o != null && s[o] != null) {
      const u = Object.keys(s[o]);
      for (let c = 0, l = u.length; c < l; c++)
        if (u[c] === e)
          return !0;
    }
    return !1;
  }
  // eslint-disable-next-line complexity
  _suffixExpressionHandler(e) {
    var u;
    const t = e.getChildren();
    if (!t)
      return !1;
    const r = t.length, n = [], s = [];
    let o = !0;
    for (let c = 0; c < r; c++) {
      const l = t[c];
      if (l instanceof ae)
        o = this._suffixExpressionHandler(l), n.push(l);
      else {
        const f = l.trim();
        if (f === "")
          continue;
        if (xt.has(f)) {
          if (f === X.PLUS && this._deletePlusForPreNode(t[c - 1]))
            continue;
          if (f !== X.PLUS && f !== X.MINUS && this._deletePlusForPreNode(t[c - 1]))
            return !1;
          for (; s.length > 0; ) {
            const h = (u = s[s.length - 1]) == null ? void 0 : u.trim();
            if (!h || h === K.OPEN_BRACKET)
              break;
            const d = sn.get(h), _ = sn.get(f);
            if (d === void 0 || _ === void 0)
              break;
            if (_ >= d)
              n.push(s.pop());
            else
              break;
          }
          s.push(l);
        } else if (f === K.OPEN_BRACKET)
          s.push(l);
        else if (f === K.CLOSE_BRACKET)
          this._processSuffixExpressionCloseBracket(n, s, t, c);
        else {
          if (this._checkCloseBracket(t[c - 1]))
            return !1;
          n.push(l);
        }
      }
    }
    return o ? this._processSuffixExpressionRemain(n, s, e) : !1;
  }
  _processSuffixExpressionRemain(e, t, r) {
    const n = e.length, s = e[n - 1];
    for (; t.length > 0; ) {
      const o = t.pop();
      if (!(s instanceof ae) && (o === K.OPEN_BRACKET || o === K.CLOSE_BRACKET))
        return !1;
      e.push(o);
    }
    return r.setChildren(e), !0;
  }
  _processSuffixExpressionCloseBracket(e, t, r, n) {
    var s;
    if (this._checkOpenBracket(r[n - 1]) || this._checkOperator(r[n - 1]))
      return !1;
    for (; t.length > 0; ) {
      const o = (s = t[t.length - 1]) == null ? void 0 : s.trim();
      if (!o)
        break;
      if (o === K.OPEN_BRACKET) {
        t.pop();
        break;
      }
      e.push(t.pop());
    }
  }
  _checkCloseBracket(e) {
    return e === K.CLOSE_BRACKET || e instanceof ae;
  }
  _checkOpenBracket(e) {
    return e === K.OPEN_BRACKET;
  }
  _checkOperator(e) {
    return e == null || e instanceof ae ? !1 : xt.has(e);
  }
  _deletePlusForPreNode(e) {
    if (e == null)
      return !0;
    if (!(e instanceof ae)) {
      const t = e.trim();
      if (xt.has(t) || t === K.OPEN_BRACKET)
        return !0;
    }
    return !1;
  }
  _resetCurrentLexerNode() {
    this._currentLexerNode = new ae();
  }
  _resetSegment() {
    this._segment = "";
  }
  _openBracket(e = 0) {
    this._bracketState.push(e);
  }
  _closeBracket() {
    this._bracketState.pop();
  }
  _openSquareBracket() {
    this._squareBracketState += 1;
  }
  _closeSquareBracket() {
    this._squareBracketState -= 1;
  }
  _getCurrentBracket() {
    const e = this._bracketState;
    return e[e.length - 1];
  }
  _changeCurrentBracket(e) {
    const t = this._bracketState;
    t[t.length - 1] = e;
  }
  _openBraces() {
    this._bracesState += 1;
  }
  _closeBraces() {
    this._bracesState -= 1;
  }
  _openSingleQuotation() {
    this._singleQuotationState += 1;
  }
  _closeSingleQuotation() {
    this._singleQuotationState -= 1;
  }
  _openDoubleQuotation() {
    this._doubleQuotationState += 1;
  }
  _closeDoubleQuotation() {
    this._doubleQuotationState -= 1;
  }
  _openLambda() {
    this._lambdaState = !0;
  }
  _closeLambda() {
    this._lambdaState = !1;
  }
  _openColon(e) {
    this._upLevel = e, this._colonState = !0;
  }
  _closeColon() {
    this._upLevel = 0, this._colonState = !1;
  }
  _isTableBracket() {
    return this._tableBracketState;
  }
  _openTableBracket() {
    this._tableBracketState = !0;
  }
  _closeTableBracket() {
    this._tableBracketState = !1;
  }
  _formalErrorOccurred() {
    this._formulaErrorCount += 1;
  }
  _hasFormalError() {
    return this._formulaErrorCount > 0;
  }
  _getLastChildCurrentLexerNode() {
    const e = this._currentLexerNode.getChildren();
    if (e && e.length > 0) {
      const t = e[e.length - 1];
      if (t instanceof ae)
        return t;
    }
    return !1;
  }
  _getLastChildCurrent() {
    const e = this._currentLexerNode.getChildren();
    return e && e.length > 0 ? e[e.length - 1] : !1;
  }
  _setParentCurrentLexerNode() {
    const e = this._currentLexerNode.getParent();
    return e ? (this._currentLexerNode = e, !0) : !1;
  }
  _setAncestorCurrentLexerNode() {
    var r, n, s, o, u, c;
    const e = (r = this._currentLexerNode) == null ? void 0 : r.getParent();
    let t = !1;
    if (e && e.getToken() === dr) {
      if ((n = e == null ? void 0 : e.getParent()) != null && n.getParent()) {
        const l = (o = (s = this._currentLexerNode.getParent()) == null ? void 0 : s.getParent()) == null ? void 0 : o.getParent();
        l && (this._currentLexerNode = l), t = !0;
      }
    } else if (e != null && e.getParent()) {
      const l = (u = this._currentLexerNode.getParent()) == null ? void 0 : u.getParent();
      l && (this._currentLexerNode = l), t = !0;
    }
    for (let l = 0; l < this._upLevel; l++) {
      const f = (c = this._currentLexerNode) == null ? void 0 : c.getParent();
      f && (this._currentLexerNode = f), this._currentLexerNode ? t = !0 : t = !1;
    }
    return t;
  }
  _segmentCount() {
    return this._segment.trim().length;
  }
  _pushSegment(e) {
    this._segment += e;
  }
  _pushNodeToChildren(e, t = !1) {
    let r = e;
    if (r !== "") {
      const n = this._currentLexerNode.getChildren();
      if (!(r instanceof ae) && this.isColonOpen()) {
        const s = new ae();
        s.setToken(r), s.setParent(this._currentLexerNode), r = s;
      }
      t ? n.unshift(r) : n.push(r);
    }
    this.isColonOpen() && (this._setAncestorCurrentLexerNode(), this._closeColon());
  }
  _setCurrentLexerNode(e, t = !1) {
    this._pushNodeToChildren(e, t), e.setParent(this._currentLexerNode), this._currentLexerNode = e;
  }
  _newAndPushCurrentLexerNode(e, t, r = !1) {
    const n = new ae();
    n.setToken(e), n.setIndex(t - e.length, t - 1), this._setCurrentLexerNode(n, r);
  }
  _getTopNode(e) {
    let t = e;
    for (; t != null && t.getParent(); )
      t = t.getParent();
    return t;
  }
  _removeLastChild() {
    this._currentLexerNode.getChildren().splice(-1);
  }
  /**
   * fix univer-pro/issues/2447
   * =1/3+
   * =+
   * =sum(A1+)
   */
  _formulaErrorLastTokenCheck(e, t) {
    const r = this._findPreviousToken(e, t) || "", n = e.length - 1 === t;
    if (!n && this._isOperatorToken(r) || n && Oc(r))
      return !0;
    if (ls.has(r)) {
      const s = this._findSecondLastNonSpaceToken(e, t);
      if (s == null || wc(s))
        return !0;
    }
    return !1;
  }
  _findPreviousToken(e, t) {
    let r = t;
    for (; r >= 0; ) {
      const n = e[r];
      if (n !== " ")
        return n;
      r--;
    }
  }
  _findSecondLastNonSpaceToken(e, t) {
    let r = t, n = 0;
    for (; r >= 0; ) {
      const s = e[r];
      if (s !== " " && (n++, n === 2))
        return s;
      r--;
    }
    return null;
  }
  _findNextToken(e, t) {
    let r = t;
    for (; r >= 0; ) {
      const n = e[r];
      if (n !== " ")
        return n;
      r++;
    }
  }
  _unexpectedEndingTokenExcludeOperator(e) {
    return (
      // OPERATOR_TOKEN_SET.has(prevString) ||
      e === K.OPEN_BRACKET || e === K.COMMA || e === X.EQUALS || e === ""
    );
  }
  _unexpectedEndingToken(e) {
    return !!(this._isOperatorToken(e) || this._unexpectedEndingTokenExcludeOperator(e));
  }
  _isOperatorToken(e) {
    return !!xt.has(e);
  }
  _getSequenceArray(e) {
    const t = [];
    return this._nodeMaker(e, t), t;
  }
  _resetTemp() {
    this._currentLexerNode = new ae(), this._upLevel = 0, this._segment = "", this._bracketState = [], this._bracesState = 0, this._singleQuotationState = 0, this._doubleQuotationState = 0, this._lambdaState = !1, this._colonState = !1, this._formulaErrorCount = 0;
  }
  _checkErrorState() {
    return !!(this._bracketState.length > 0 || this._bracesState > 0 || this._singleQuotationState > 0 || this._doubleQuotationState > 0 || this._hasFormalError());
  }
  _checkSimilarErrorToken(e, t, r) {
    let n = t;
    if (e !== tt.POUND)
      return !0;
    let s = r[++n];
    for (; s === " "; )
      s = r[++n];
    return !!an(s);
  }
  _checkIfErrorObject(e, t) {
    return !!this._findErrorObject(e, t);
  }
  _findErrorObject(e, t) {
    for (let r = 0; r < za.length; r++) {
      const n = za[r], s = t.slice(e, e + n).join("").toUpperCase();
      if (or.has(s))
        return s;
    }
  }
  // NOTE@wzhudev: this method is over complex, need to refactor. Using recursive descend to parse the formula string
  // without a standalone lexer phase
  // eslint-disable-next-line max-lines-per-function, complexity
  _nodeMaker(e, t, r) {
    let n = e.replace(/\r\n$|\r|\n/g, " ");
    n.substring(0, 1) === X.EQUALS && (n = n.substring(1));
    const s = n.split(""), o = s.length;
    this._resetTemp(), this._formulaErrorLastTokenCheck(s, o - 1) && this._formalErrorOccurred();
    let u = 0;
    for (; u < o; ) {
      const c = s[u];
      if (r === u)
        return [this._currentLexerNode, c];
      if (c === tt.POUND && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose() && this._checkIfErrorObject(u, s)) {
        const l = this._findErrorObject(u, s);
        if (l == null)
          return m.VALUE;
        this._pushNodeToChildren(l);
        for (let f = 0; f < l.length; f++) {
          const h = s[u];
          this._pushSegment(h), this._addSequenceArray(t, h, u), u++;
        }
        this._resetSegment();
        continue;
      } else if (c === K.OPEN_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        if (this._segmentCount() > 0 || this.isLambdaOpen()) {
          this.isLambdaClose() && (this._newAndPushCurrentLexerNode(this._segment, u), this._resetSegment()), this._openBracket(
            1
            /* FUNCTION */
          ), this._closeLambda();
          const l = s[u + 1];
          if (l && l === K.CLOSE_BRACKET) {
            if (!this._setParentCurrentLexerNode() && u !== o - 1)
              return m.VALUE;
            this._addSequenceArray(t, c, u), u++, this._addSequenceArray(t, l, u), u++, this._closeBracket();
            continue;
          } else l && this._newAndPushCurrentLexerNode(gt, u);
        } else
          this._pushNodeToChildren(c), this._openBracket(
            0
            /* NORMAL */
          ), this._resetSegment();
      else if (c === K.CLOSE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        this._formulaErrorLastTokenCheck(s, u - 1) && this._formalErrorOccurred(), this._pushNodeToChildren(this._segment), this._resetSegment();
        const l = this._getCurrentBracket();
        if (l === 0)
          this._pushNodeToChildren(c);
        else if (l === 1) {
          const f = s[u + 1];
          if (f && f === K.OPEN_BRACKET) {
            if (!this._setParentCurrentLexerNode() && u !== o - 1)
              return m.VALUE;
            this._newAndPushCurrentLexerNode(dr, u, !0), this._openLambda();
          } else if (!this._setAncestorCurrentLexerNode() && u !== o - 1)
            return m.VALUE;
        } else
          return m.VALUE;
        this._closeBracket();
      } else if (c === K.OPEN_BRACES && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        if (this._pushSegment(c), this._openBraces(), !this._formulaSpellCheck())
          return m.VALUE;
      } else if (c === K.CLOSE_BRACES && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._pushSegment(c), this._pushNodeToChildren(this._segment), this._resetSegment(), this._closeBraces();
      else if (c === K.OPEN_SQUARE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._segment.length > 0 && this._openTableBracket(), this._pushSegment(c), this._openSquareBracket();
      else if (c === K.CLOSE_SQUARE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._closeSquareBracket(), this.isSquareBracketClose() ? (this._pushSegment(c), this._isTableBracket() && (this._pushNodeToChildren(this._segment), this._resetSegment()), this._closeTableBracket()) : this._pushSegment(c);
      else if (c === K.DOUBLE_QUOTATION && this.isSingleQuotationClose() && this.isSquareBracketClose()) {
        if (this.isDoubleQuotationClose())
          this._openDoubleQuotation();
        else {
          const l = s[u + 1];
          l && l === K.DOUBLE_QUOTATION ? u++ : this._closeDoubleQuotation();
        }
        this._pushSegment(c);
      } else if (c === K.SINGLE_QUOTATION && this.isDoubleQuotationClose()) {
        if (this.isSingleQuotationClose())
          this._openSingleQuotation(), this._segmentCount() === 0 && this._resetSegment();
        else {
          const l = s[u + 1];
          if (l && l === K.SINGLE_QUOTATION) {
            this._pushSegment(c), this._addSequenceArray(t, c, u), u++, this._pushSegment(l), this._addSequenceArray(t, l, u), u++;
            continue;
          } else
            this._closeSingleQuotation();
        }
        this._pushSegment(c);
      } else if (c === K.COMMA && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        this._formulaErrorLastTokenCheck(s, u - 1) && this._formalErrorOccurred();
        const l = this._getCurrentBracket();
        if (l === 1 || l == null) {
          if (this._pushNodeToChildren(this._segment), this._resetSegment(), !this._setParentCurrentLexerNode() && u !== o - 1 && l != null)
            return m.VALUE;
          this._newAndPushCurrentLexerNode(gt, u);
        } else {
          const f = new ae();
          f.setToken(nl);
          const h = new ae();
          h.setToken(gt), h.changeToParent(f);
          const d = this._currentLexerNode.getParent();
          if (d && d.getToken() === K.COLON) {
            const _ = d.getParent();
            if (!_)
              return m.VALUE;
            d.changeToParent(h), _.setChildren([]), f.changeToParent(_);
          } else
            return m.VALUE;
          this._changeCurrentBracket(
            1
            /* FUNCTION */
          ), this._pushNodeToChildren(this._segment), this._resetSegment(), this._currentLexerNode = f, this._newAndPushCurrentLexerNode(gt, u);
        }
      } else if (c === K.COLON && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        const l = new ae();
        l.setToken(c);
        const f = new ae();
        f.setToken(gt), f.setParent(l);
        const h = new ae();
        h.setToken(gt), h.setParent(l), l.getChildren().push(f, h);
        let d = l, _ = 0;
        if (this._segmentCount() > 0) {
          let C, E, b = 0;
          const R = this._segment.trim(), p = R[0], N = R[1];
          if (p === Me.MINUS && (C = new ae(), C.setToken(Me.MINUS), b++), (p === Me.AT || N === Me.AT) && (E = new ae(), E.setToken(Me.AT), C && (C.addChildren(E), E.setParent(C)), b++), b > 0 && (this._segment = R.slice(b)), _ = b, E)
            if (E.addChildren(l), l.setParent(E), E.getParent()) {
              const w = E.getParent();
              w && (d = w);
            } else
              d = E;
          else C && (d = C, C.addChildren(l), l.setParent(C));
          const M = new ae();
          M.setToken(this._segment), M.setParent(f), f.getChildren().push(M), this._resetSegment();
        } else {
          const C = this._getLastChildCurrentLexerNode();
          C && C.changeToParent(f);
        }
        this._setCurrentLexerNode(d), this._currentLexerNode = h, this._openColon(_);
      } else if (ls.has(c) && this._checkSimilarErrorToken(c, u, s) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        this._pushNodeToChildren(this._segment);
        const l = new ae();
        l.setToken(c);
        const f = this._getLastChildCurrent();
        f instanceof ae ? f.changeToParent(l) : f !== !1 && (l.getChildren().push(f), this._removeLastChild()), this._pushNodeToChildren(l), l.setParent(this._currentLexerNode), this._resetSegment();
      } else if (xt.has(c) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        let l = this._segment.trim();
        if (c === X.MINUS && l === "") {
          const f = this._findPreviousToken(s, u - 1) || "", h = this._findNextToken(s, u + 1) || "";
          if (this._unexpectedEndingTokenExcludeOperator(f) && this._isOperatorToken(h)) {
            this._pushNodeToChildren("0"), this._pushNodeToChildren(X.MINUS), this._addSequenceArray(t, c, u), this._resetSegment(), u++;
            continue;
          } else if (this._unexpectedEndingToken(f))
            if (h === X.PLUS) {
              this._pushSegment(X.MINUS), this._addSequenceArray(t, c, u), this._addSequenceArray(t, X.PLUS, u + 1), u += 2;
              continue;
            } else {
              this._pushSegment(X.MINUS), this._addSequenceArray(t, c, u), u++;
              continue;
            }
        } else if (this._segment.length > 0 && this._isScientificNotation(s, u, c)) {
          this._pushSegment(c), this._addSequenceArray(t, c, u), u++;
          continue;
        } else this._segment.length > 0 && l === "" ? l = this._segment : (this._pushNodeToChildren(this._segment), l = "");
        if (c === X.LESS_THAN || c === X.GREATER_THAN) {
          const f = s[u + 1];
          if (f && xt.has(c + f)) {
            this._pushNodeToChildren(l + c + f), this._resetSegment(), this._addSequenceArray(t, c, u), u++, this._addSequenceArray(t, f, u), u++;
            continue;
          } else
            this._pushNodeToChildren(l + c);
        } else
          this._pushNodeToChildren(l + c);
        this._resetSegment();
      } else
        (this._segment !== "" || c !== " ") && this._pushSegment(c);
      this._addSequenceArray(t, c, u), u++;
    }
    if (this._pushNodeToChildren(this._segment), this._checkErrorState())
      return m.VALUE;
  }
  _isScientificNotation(e, t, r) {
    const n = e[t - 2];
    if (n && Number.isNaN(Number(n)) || !(r === X.MINUS || r === X.PLUS))
      return !1;
    const s = e[t + 1];
    if (s && Number.isNaN(Number(s)))
      return !1;
    const o = e[t - 1];
    return o && o.toUpperCase() === "E";
  }
  _addSequenceArray(e, t, r) {
    e == null || e.push({
      segment: this._segment,
      currentString: t,
      cur: r,
      currentLexerNode: this._currentLexerNode
    });
  }
}
function il(i, a, e, t, r, n, s) {
  const o = (s == null ? void 0 : s.f) || "", u = (s == null ? void 0 : s.si) || "", c = dt(o), l = Nt(u), f = i.getValue(r, n), h = (f == null ? void 0 : f.f) || "", d = (f == null ? void 0 : f.si) || "";
  function _() {
    var C;
    if (dt(h) && Nt(d)) {
      const E = (C = e == null ? void 0 : e[d]) == null ? void 0 : C.f;
      E ? t.set(d, E) : t.set(d, h);
    }
  }
  c && l ? (d !== u && _(), i.setValue(r, n, {
    f: o,
    si: u
  }), e[u] = { f: o, r, c: n }, a.setValue(r, n, {
    f: o,
    si: u
  })) : c && !l ? (h !== o && _(), i.setValue(r, n, {
    f: o
  }), a.setValue(r, n, {
    f: o
  })) : !c && l ? (d !== u && _(), i.setValue(r, n, {
    f: "",
    si: u
  })) : !c && !l && i.getValue(r, n) && (_(), i.realDeleteValue(r, n), a.setValue(r, n, null));
}
function ol(i, a, e, t) {
  const r = i == null ? void 0 : i.getValue(e, t);
  if (r == null)
    return !0;
  const n = [];
  i.forValue((l, f, h) => {
    l === e && f === t || Za.intersects(h, r) && n.push(h);
  });
  const { startRow: s, startColumn: o, endRow: u, endColumn: c } = r;
  for (let l = s; l <= u; l++)
    for (let f = o; f <= c; f++) {
      let h = !1;
      const d = ec(l, f);
      n.some((_) => Za.contains(_, d) ? (h = !0, !0) : !1), h || a.realDeleteValue(l, f);
    }
}
var ul = Object.getOwnPropertyDescriptor, cl = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ul(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, li = (i, a) => (e, t) => a(e, t, i);
let _r = class extends Ne {
  constructor(a, e) {
    super();
    A(this, "_arrayFormulaRange", {});
    A(this, "_arrayFormulaCellData", {});
    this._univerInstanceService = a, this._lexerTreeBuilder = e;
  }
  dispose() {
    super.dispose(), this._arrayFormulaRange = {}, this._arrayFormulaCellData = {};
  }
  clearPreviousArrayFormulaCellData(a) {
    Object.keys(a).forEach((e) => {
      const t = a[e];
      if (t == null)
        return !0;
      Object.keys(t).forEach((r) => {
        var c, l, f, h;
        const n = t[r], s = (l = (c = this._arrayFormulaRange) == null ? void 0 : c[e]) == null ? void 0 : l[r];
        if (s == null)
          return !0;
        const o = new Ce(s);
        let u = new Ce();
        ((f = this._arrayFormulaCellData[e]) == null ? void 0 : f[r]) != null && (u = new Ce(
          (h = this._arrayFormulaCellData[e]) == null ? void 0 : h[r]
        )), n.forValue((d, _) => {
          const C = o.getValue(d, _);
          if (C == null)
            return !0;
          const { startRow: E, startColumn: b, endRow: R, endColumn: p } = C;
          for (let N = E; N <= R; N++)
            for (let M = b; M <= p; M++)
              u.setValue(N, M, null);
          o.realDeleteValue(d, _);
        }), this._arrayFormulaCellData[e] && (this._arrayFormulaCellData[e][r] = u.getData());
      });
    });
  }
  mergeArrayFormulaCellData(a) {
    Object.keys(a).forEach((e) => {
      const t = a[e];
      if (t == null)
        return !0;
      this._arrayFormulaRange[e] == null && (this._arrayFormulaRange[e] = {}), this._arrayFormulaCellData[e] == null && (this._arrayFormulaCellData[e] = {}), Object.keys(t).forEach((r) => {
        var u, c;
        const n = t[r], s = new Ce((u = this._arrayFormulaRange[e]) == null ? void 0 : u[r]), o = new Ce((c = this._arrayFormulaCellData[e]) == null ? void 0 : c[r]);
        n.forValue((l, f) => {
          const h = s == null ? void 0 : s.getValue(l, f);
          if (h == null)
            return !0;
          const { startRow: d, startColumn: _, endRow: C, endColumn: E } = h;
          for (let b = d; b <= C; b++)
            for (let R = _; R <= E; R++)
              o.setValue(b, R, null);
        }), n.forValue((l, f, h) => {
          o.setValue(l, f, h);
        }), this._arrayFormulaCellData[e] && (this._arrayFormulaCellData[e][r] = o.getData());
      });
    });
  }
  getFormulaData() {
    const a = {}, e = this._univerInstanceService.getAllUnitsForType(fr.UNIVER_SHEET);
    return e.length === 0 || e.forEach((t) => {
      const r = t.getUnitId();
      a[r] = {}, t.getSheets().forEach((s) => {
        const o = s.getCellMatrix(), u = s.getSheetId();
        fi(a, r, u, o);
      });
    }), a;
  }
  getSheetFormulaData(a, e) {
    const t = {}, r = this._univerInstanceService.getUnit(a);
    if (r == null)
      return {};
    t[a] = {};
    const n = r.getSheetBySheetId(e);
    if (n == null)
      return {};
    const s = n.getCellMatrix();
    return fi(t, a, e, s), t[a][e];
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  setArrayFormulaRange(a) {
    this._arrayFormulaRange = a;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(a) {
    this._arrayFormulaCellData = a;
  }
  mergeArrayFormulaRange(a) {
    Object.keys(a).forEach((e) => {
      const t = a[e];
      if (t == null)
        return !0;
      this._arrayFormulaRange[e] || (this._arrayFormulaRange[e] = {}), Object.keys(t).forEach((r) => {
        var o;
        const n = new Ce(t[r]), s = new Ce((o = this._arrayFormulaRange[e]) == null ? void 0 : o[r]);
        n.forValue((u, c, l) => {
          s.setValue(u, c, l);
        }), this._arrayFormulaRange[e] && (this._arrayFormulaRange[e][r] = s.getData());
      });
    });
  }
  deleteArrayFormulaRange(a, e, t, r) {
    var o;
    const n = (o = this._arrayFormulaRange[a]) == null ? void 0 : o[e];
    if (n == null)
      return;
    const s = new Ce(n);
    s.getValue(t, r) && (s.realDeleteValue(t, r), this._arrayFormulaRange[a] && (this._arrayFormulaRange[a][e] = s.getData()));
  }
  getCalculateData() {
    const a = this._univerInstanceService.getAllUnitsForType(fr.UNIVER_SHEET), e = {}, t = {}, r = {};
    for (const n of a) {
      const s = n.getUnitId(), o = n.getSheets(), u = {}, c = {};
      for (const l of o) {
        const f = l.getSheetId(), h = l.getConfig();
        u[f] = {
          cellData: new Ce(h.cellData),
          rowCount: h.rowCount,
          columnCount: h.columnCount,
          rowData: h.rowData,
          columnData: h.columnData,
          defaultRowHeight: h.defaultRowHeight,
          defaultColumnWidth: h.defaultColumnWidth
        }, c[l.getName()] = l.getSheetId();
      }
      e[s] = u, t[s] = n.getStyles(), r[s] = c;
    }
    return {
      allUnitData: e,
      unitStylesData: t,
      unitSheetNameMap: r
    };
  }
  /**
   * Get the hidden rows that are filtered or manually hidden.
   *
   * For formulas that are sensitive to hidden rows.
   */
  getHiddenRowsFiltered() {
    const a = this._univerInstanceService.getAllUnitsForType(fr.UNIVER_SHEET), e = {};
    for (const t of a) {
      const r = t.getUnitId(), n = t.getSheets();
      e[r] = {};
      for (const s of n) {
        const o = s.getSheetId();
        e[r][o] = {};
        const u = 0, c = s.getRowCount() - 1, l = {};
        for (let f = u; f <= c; f++)
          s.getRowVisible(f) || (l[f] = {
            hd: qi.TRUE
          });
        e[r][o] = l;
      }
    }
    return e;
  }
  updateFormulaData(a, e, t) {
    const r = new Ce(t), n = this._getSheetFormulaIdMap(a, e), s = /* @__PURE__ */ new Map(), o = this.getFormulaData();
    o[a] == null && (o[a] = {});
    const u = o[a];
    u[e] == null && (u[e] = {});
    const c = new Ce(u[e] || {}), l = new Ce();
    return r.forValue((f, h, d) => {
      il(c, l, n, s, f, h, d);
    }), c.forValue((f, h, d) => {
      const _ = (d == null ? void 0 : d.f) || "", C = (d == null ? void 0 : d.si) || "";
      if (Nt(C)) {
        const E = n == null ? void 0 : n[C], b = s.get(C);
        if (E && !dt(_)) {
          const R = E.f, p = h - E.c, N = f - E.r;
          c.setValue(f, h, { f: R, si: C, x: p, y: N }), l.setValue(f, h, { f: R, si: C, x: p, y: N });
        } else if (typeof b == "string") {
          const R = (d == null ? void 0 : d.x) || 0, p = (d == null ? void 0 : d.y) || 0, N = this._lexerTreeBuilder.moveFormulaRefOffset(b, R, p);
          s.set(C, { r: f, c: h, f: N }), c.setValue(f, h, { f: N, si: C }), l.setValue(f, h, { f: N, si: C });
        } else if (typeof b == "object") {
          const R = h - b.c, p = f - b.r;
          c.setValue(f, h, { f: b.f, si: C, x: R, y: p }), l.setValue(f, h, { f: b.f, si: C, x: R, y: p });
        }
      }
    }), l.getMatrix();
  }
  updateArrayFormulaRange(a, e, t) {
    var o;
    const r = (o = this._arrayFormulaRange[a]) == null ? void 0 : o[e];
    if (!r) return;
    const n = new Ce(r);
    new Ce(t).forValue((u, c, l) => {
      n.realDeleteValue(u, c);
    });
  }
  updateArrayFormulaCellData(a, e, t) {
    var c, l;
    const r = (c = this._arrayFormulaRange[a]) == null ? void 0 : c[e];
    if (!r) return;
    const n = new Ce(r), s = (l = this._arrayFormulaCellData[a]) == null ? void 0 : l[e];
    if (!s) return;
    const o = new Ce(s);
    new Ce(t).forValue((f, h, d) => {
      ol(n, o, f, h);
    });
  }
  getFormulaStringByCell(a, e, t, r) {
    const n = this._univerInstanceService.getUnit(r);
    if (n == null)
      return null;
    const s = n.getSheetBySheetId(t);
    if (s == null)
      return null;
    const o = s.getCellMatrix(), u = o.getValue(a, e);
    if (u == null)
      return null;
    const { f: c, si: l } = u;
    if (dt(c))
      return c;
    if (Nt(l)) {
      let f = null;
      return o.forValue((h, d, _) => {
        if (_ == null)
          return !0;
        const { f: C, si: E } = _;
        if (dt(C) && l === E)
          return f = this._lexerTreeBuilder.moveFormulaRefOffset(
            C,
            e - d,
            a - h
          ), !1;
      }), f;
    }
    return null;
  }
  /**
   * Function to get all formula ranges
   * @returns
   */
  getFormulaDirtyRanges() {
    const a = this.getFormulaData(), e = [];
    for (const t in a) {
      const r = a[t];
      if (!r) continue;
      const n = this._univerInstanceService.getUnit(t);
      if (n)
        for (const s in r) {
          const o = r[s];
          if (!o) continue;
          const u = n.getSheetBySheetId(s);
          if (!u) continue;
          const c = {};
          for (const l of Object.keys(o)) {
            const f = Number(l);
            for (const h in o[f]) {
              const d = Number(h), _ = u.getCellRaw(f, d), C = dt(_ == null ? void 0 : _.f) || Nt(_ == null ? void 0 : _.si), E = (_ == null ? void 0 : _.v) === void 0;
              if (!(C && E)) continue;
              c[d] || (c[d] = []);
              const b = c[d].slice(-1)[0];
              b && b.endRow === f - 1 ? b.endRow = f : c[d].push({ startRow: f, endRow: f });
            }
          }
          for (const l in c) {
            const f = c[l];
            for (let h = 0; h < f.length; h++) {
              const d = f[h];
              e.push({
                unitId: t,
                sheetId: s,
                range: {
                  rangeType: et.NORMAL,
                  startRow: d.startRow,
                  endRow: d.endRow,
                  // Use endRow as the inclusive end row
                  startColumn: Number(l),
                  endColumn: Number(l)
                }
              });
            }
          }
        }
    }
    return e;
  }
  _getSheetFormulaIdMap(a, e) {
    const t = {}, r = this._univerInstanceService.getUnit(a);
    if (r == null)
      return t;
    const n = r.getSheetBySheetId(e);
    return n == null || n.getCellMatrix().forValue((o, u, c) => {
      if (c == null)
        return !0;
      const { f: l, si: f } = c;
      dt(l) && Nt(f) && (t[f] = { f: l, r: o, c: u });
    }), t;
  }
};
_r = cl([
  li(0, Yn),
  li(1, ye(ga))
], _r);
function fi(i, a, e, t) {
  i[a] || (i[a] = {}), i[a][e] || (i[a][e] = {});
  const r = /* @__PURE__ */ new Map(), n = new Ce(i[a][e]);
  t.forValue((o, u, c) => {
    const l = (c == null ? void 0 : c.f) || "", f = (c == null ? void 0 : c.si) || "", h = dt(l), d = Nt(f);
    h && d ? (n.setValue(o, u, {
      f: l,
      si: f
    }), r.set(f, { f: l, r: o, c: u })) : h && !d ? n.setValue(o, u, {
      f: l
    }) : !h && d && n.setValue(o, u, {
      f: "",
      si: f
    });
  }), n.forValue((o, u, c) => {
    const l = (c == null ? void 0 : c.f) || "", f = (c == null ? void 0 : c.si) || "";
    if (Nt(f) && !dt(l)) {
      const h = r.get(f);
      if (h) {
        const d = h.f, _ = u - h.c, C = o - h.r;
        n.setValue(o, u, { f: d, si: f, x: _, y: C });
      } else
        n.realDeleteValue(o, u);
    }
  });
  const s = n.getMatrix();
  return {
    [a]: {
      [e]: s
    }
  };
}
const ll = class js {
  /**
   * Accept two comparable values and creates new instance of interval
   * Predicate Interval.comparable_less(low, high) supposed to return true on these values
   * @param low
   * @param high
   */
  constructor(a, e) {
    this.low = a, this.high = e;
  }
  /**
   * Clone interval
   * @returns {Interval}
   */
  clone() {
    return new js(this.low, this.high);
  }
  /**
   * Propery max returns clone of this interval
   * @returns {Interval}
   */
  get max() {
    return this.clone();
  }
  /**
   * Predicate returns true is this interval less than other interval
   * @param other_interval
   * @returns {boolean}
   */
  less_than(a) {
    return this.low < a.low || this.low === a.low && this.high < a.high;
  }
  /**
   * Predicate returns true is this interval equals to other interval
   * @param other_interval
   * @returns {boolean}
   */
  equal_to(a) {
    return this.low === a.low && this.high === a.high;
  }
  /**
   * Predicate returns true if this interval intersects other interval
   * @param other_interval
   * @returns {boolean}
   */
  intersect(a) {
    return !this.not_intersect(a);
  }
  /**
   * Predicate returns true if this interval does not intersect other interval
   * @param other_interval
   * @returns {boolean}
   */
  not_intersect(a) {
    return this.high < a.low || a.high < this.low;
  }
  /**
   * Returns new interval merged with other interval
   * @param {Interval} other_interval - Other interval to merge with
   * @returns {Interval}
   */
  merge(a) {
    return new js(
      this.low === void 0 ? a.low : this.low < a.low ? this.low : a.low,
      this.high === void 0 ? a.high : this.high > a.high ? this.high : a.high
    );
  }
  /**
   * Returns how key should return
   */
  output() {
    return [this.low, this.high];
  }
  /**
   * Function returns maximum between two comparable values
   * @param interval1
   * @param interval2
   * @returns {Interval}
   */
  static comparable_max(a, e) {
    return a.merge(e);
  }
  /**
   * Predicate returns true if first value less than second value
   * @param val1
   * @param val2
   * @returns {boolean}
   */
  static comparable_less_than(a, e) {
    return a < e;
  }
}, je = 0, Ae = 1;
class Wt {
  constructor(a = void 0, e = void 0, t = null, r = null, n = null, s = Ae) {
    if (this.left = t, this.right = r, this.parent = n, this.color = s, this.item = { key: a, value: e }, a && a instanceof Array && a.length === 2 && !Number.isNaN(a[0]) && !Number.isNaN(a[1])) {
      let [o, u] = a;
      o > u && ([o, u] = [u, o]), this.item.key = new ll(o, u);
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === Ae;
  }
  _value_less_than(a) {
    return this.item.value && a.item.value && this.item.value.less_than ? this.item.value.less_than(a.item.value) : this.item.value < a.item.value;
  }
  less_than(a) {
    return this.item.value === this.item.key && a.item.value === a.item.key ? this.item.key.less_than(a.item.key) : this.item.key.less_than(a.item.key) || this.item.key.equal_to(a.item.key) && this._value_less_than(a);
  }
  _value_equal(a) {
    return this.item.value && a.item.value && this.item.value.equal_to ? this.item.value.equal_to(a.item.value) : this.item.value === a.item.value;
  }
  equal_to(a) {
    return this.item.value === this.item.key && a.item.value === a.item.key ? this.item.key.equal_to(a.item.key) : this.item.key.equal_to(a.item.key) && this._value_equal(a);
  }
  intersect(a) {
    return this.item.key.intersect(a.item.key);
  }
  copy_data(a) {
    this.item.key = a.item.key, this.item.value = a.item.value;
  }
  update_max() {
    if (this.max = this.item.key ? this.item.key.max : void 0, this.right && this.right.max) {
      const a = this.item.key.constructor.comparable_max;
      this.max = a(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const a = this.item.key.constructor.comparable_max;
      this.max = a(this.max, this.left.max);
    }
  }
  // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
  not_intersect_left_subtree(a) {
    const e = this.item.key.constructor.comparable_less_than;
    let t = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return e(t, a.item.key.low);
  }
  // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
  not_intersect_right_subtree(a) {
    const e = this.item.key.constructor.comparable_less_than;
    let t = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return e(a.item.key.high, t);
  }
}
class da {
  /**
   * Construct new empty instance of IntervalTree
   */
  constructor() {
    this.root = null, this.nil_node = new Wt();
  }
  /**
   * Returns number of items stored in the interval tree
   * @returns {number}
   */
  get size() {
    let a = 0;
    return this.tree_walk(this.root, () => a++), a;
  }
  /**
   * Returns array of sorted keys in the ascending order
   * @returns {Array}
   */
  get keys() {
    let a = [];
    return this.tree_walk(this.root, (e) => a.push(
      e.item.key.output ? e.item.key.output() : e.item.key
    )), a;
  }
  /**
   * Return array of values in the ascending keys order
   * @returns {Array}
   */
  get values() {
    let a = [];
    return this.tree_walk(this.root, (e) => a.push(e.item.value)), a;
  }
  /**
   * Returns array of items (<key,value> pairs) in the ascended keys order
   * @returns {Array}
   */
  get items() {
    let a = [];
    return this.tree_walk(this.root, (e) => a.push({
      key: e.item.key.output ? e.item.key.output() : e.item.key,
      value: e.item.value
    })), a;
  }
  /**
   * Returns true if tree is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.root == null || this.root === this.nil_node;
  }
  /**
   * Clear tree
   */
  clear() {
    this.root = null;
  }
  /**
   * Insert new item into interval tree
   * @param {Interval} key - interval object or array of two numbers [low, high]
   * @param {any} value - value representing any object (optional)
   * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}
   */
  insert(a, e = a) {
    if (a === void 0) return;
    let t = new Wt(a, e, this.nil_node, this.nil_node, null, je);
    return this.tree_insert(t), this.recalc_max(t), t;
  }
  /**
   * Returns true if item {key,value} exist in the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object to be checked
   * @returns {boolean} true if item {key, value} exist in the tree, false otherwise
   */
  exist(a, e = a) {
    let t = new Wt(a, e);
    return !!this.tree_search(this.root, t);
  }
  /**
   * Remove entry {key, value} from the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object
   * @returns {boolean} true if item {key, value} deleted, false if not found
   */
  remove(a, e = a) {
    let t = new Wt(a, e), r = this.tree_search(this.root, t);
    return r && this.tree_delete(r), r;
  }
  /**
   * Returns array of entry values which keys intersect with given interval <br/>
   * If no values stored in the tree, returns array of keys which intersect given interval
   * @param {Interval} interval - search interval, or tuple [low, high]
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Array}
   */
  search(a, e = (t, r) => t === r ? r.output() : t) {
    let t = new Wt(a), r = [];
    return this.tree_search_interval(this.root, t, r), r.map((n) => e(n.item.value, n.item.key));
  }
  /**
   * Returns true if intersection between given and any interval stored in the tree found
   * @param {Interval} interval - search interval or tuple [low, high]
   * @returns {boolean}
   */
  intersect_any(a) {
    let e = new Wt(a);
    return this.tree_find_any_interval(this.root, e);
  }
  /**
   * Tree visitor. For each node implement a callback function. <br/>
   * Method calls a callback function with two parameters (key, value)
   * @param visitor(key,value) - function to be called for each tree item
   */
  forEach(a) {
    this.tree_walk(this.root, (e) => a(e.item.key, e.item.value));
  }
  /**
   * Value Mapper. Walk through every node and map node value to another value
   * @param callback(value,key) - function to be called for each tree item
   */
  map(a) {
    const e = new da();
    return this.tree_walk(this.root, (t) => e.insert(t.item.key, a(t.item.value, t.item.key))), e;
  }
  /**
   * @param {Interval} interval - optional if the iterator is intended to start from the beginning
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Iterator}
   */
  *iterate(a, e = (t, r) => t === r ? r.output() : t) {
    let t;
    for (a ? t = this.tree_search_nearest_forward(this.root, new Wt(a)) : this.root && (t = this.local_minimum(this.root)); t; )
      yield e(t.item.value, t.item.key), t = this.tree_successor(t);
  }
  recalc_max(a) {
    let e = a;
    for (; e.parent != null; )
      e.parent.update_max(), e = e.parent;
  }
  tree_insert(a) {
    let e = this.root, t = null;
    if (this.root == null || this.root === this.nil_node)
      this.root = a;
    else {
      for (; e !== this.nil_node; )
        t = e, a.less_than(e) ? e = e.left : e = e.right;
      a.parent = t, a.less_than(t) ? t.left = a : t.right = a;
    }
    this.insert_fixup(a);
  }
  // After insertion insert_node may have red-colored parent, and this is a single possible violation
  // Go upwords to the root and re-color until violation will be resolved
  insert_fixup(a) {
    let e, t;
    for (e = a; e !== this.root && e.parent.color === je; )
      e.parent === e.parent.parent.left ? (t = e.parent.parent.right, t.color === je ? (e.parent.color = Ae, t.color = Ae, e.parent.parent.color = je, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, this.rotate_left(e)), e.parent.color = Ae, e.parent.parent.color = je, this.rotate_right(e.parent.parent))) : (t = e.parent.parent.left, t.color === je ? (e.parent.color = Ae, t.color = Ae, e.parent.parent.color = je, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, this.rotate_right(e)), e.parent.color = Ae, e.parent.parent.color = je, this.rotate_left(e.parent.parent)));
    this.root.color = Ae;
  }
  tree_delete(a) {
    let e, t;
    a.left === this.nil_node || a.right === this.nil_node ? e = a : e = this.tree_successor(a), e.left !== this.nil_node ? t = e.left : t = e.right, t.parent = e.parent, e === this.root ? this.root = t : (e === e.parent.left ? e.parent.left = t : e.parent.right = t, e.parent.update_max()), this.recalc_max(t), e !== a && (a.copy_data(e), a.update_max(), this.recalc_max(a)), /*fix_node != this.nil_node && */
    e.color === Ae && this.delete_fixup(t);
  }
  delete_fixup(a) {
    let e = a, t;
    for (; e !== this.root && e.parent != null && e.color === Ae; )
      e === e.parent.left ? (t = e.parent.right, t.color === je && (t.color = Ae, e.parent.color = je, this.rotate_left(e.parent), t = e.parent.right), t.left.color === Ae && t.right.color === Ae ? (t.color = je, e = e.parent) : (t.right.color === Ae && (t.color = je, t.left.color = Ae, this.rotate_right(t), t = e.parent.right), t.color = e.parent.color, e.parent.color = Ae, t.right.color = Ae, this.rotate_left(e.parent), e = this.root)) : (t = e.parent.left, t.color === je && (t.color = Ae, e.parent.color = je, this.rotate_right(e.parent), t = e.parent.left), t.left.color === Ae && t.right.color === Ae ? (t.color = je, e = e.parent) : (t.left.color === Ae && (t.color = je, t.right.color = Ae, this.rotate_left(t), t = e.parent.left), t.color = e.parent.color, e.parent.color = Ae, t.left.color = Ae, this.rotate_right(e.parent), e = this.root));
    e.color = Ae;
  }
  tree_search(a, e) {
    if (!(a == null || a === this.nil_node))
      return e.equal_to(a) ? a : e.less_than(a) ? this.tree_search(a.left, e) : this.tree_search(a.right, e);
  }
  tree_search_nearest_forward(a, e) {
    let t, r = a;
    for (; r && r !== this.nil_node; )
      r.less_than(e) ? r.intersect(e) ? (t = r, r = r.left) : r = r.right : ((!t || r.less_than(t)) && (t = r), r = r.left);
    return t || null;
  }
  // Original search_interval method; container res support push() insertion
  // Search all intervals intersecting given one
  tree_search_interval(a, e, t) {
    a != null && a !== this.nil_node && (a.left !== this.nil_node && !a.not_intersect_left_subtree(e) && this.tree_search_interval(a.left, e, t), a.intersect(e) && t.push(a), a.right !== this.nil_node && !a.not_intersect_right_subtree(e) && this.tree_search_interval(a.right, e, t));
  }
  tree_find_any_interval(a, e) {
    let t = !1;
    return a != null && a !== this.nil_node && (a.left !== this.nil_node && !a.not_intersect_left_subtree(e) && (t = this.tree_find_any_interval(a.left, e)), t || (t = a.intersect(e)), !t && a.right !== this.nil_node && !a.not_intersect_right_subtree(e) && (t = this.tree_find_any_interval(a.right, e))), t;
  }
  local_minimum(a) {
    let e = a;
    for (; e.left != null && e.left !== this.nil_node; )
      e = e.left;
    return e;
  }
  // not in use
  local_maximum(a) {
    let e = a;
    for (; e.right != null && e.right !== this.nil_node; )
      e = e.right;
    return e;
  }
  tree_successor(a) {
    let e, t, r;
    if (a.right !== this.nil_node)
      e = this.local_minimum(a.right);
    else {
      for (t = a, r = a.parent; r != null && r.right === t; )
        t = r, r = r.parent;
      e = r;
    }
    return e;
  }
  //           |            right-rotate(T,y)       |
  //           y            ---------------.       x
  //          / \                                  / \
  //         x   c          left-rotate(T,x)      a   y
  //        / \             <---------------         / \
  //       a   b                                    b   c
  rotate_left(a) {
    let e = a.right;
    a.right = e.left, e.left !== this.nil_node && (e.left.parent = a), e.parent = a.parent, a === this.root ? this.root = e : a === a.parent.left ? a.parent.left = e : a.parent.right = e, e.left = a, a.parent = e, a != null && a !== this.nil_node && a.update_max(), e = a.parent, e != null && e !== this.nil_node && e.update_max();
  }
  rotate_right(a) {
    let e = a.left;
    a.left = e.right, e.right !== this.nil_node && (e.right.parent = a), e.parent = a.parent, a === this.root ? this.root = e : a === a.parent.left ? a.parent.left = e : a.parent.right = e, e.right = a, a.parent = e, a !== null && a !== this.nil_node && a.update_max(), e = a.parent, e != null && e !== this.nil_node && e.update_max();
  }
  tree_walk(a, e) {
    a != null && a !== this.nil_node && (this.tree_walk(a.left, e), e(a), this.tree_walk(a.right, e));
  }
  /* Return true if all red nodes have exactly two black child nodes */
  testRedBlackProperty() {
    let a = !0;
    return this.tree_walk(this.root, function(e) {
      e.color === je && (e.left.color === Ae && e.right.color === Ae || (a = !1));
    }), a;
  }
  /* Throw error if not every path from root to bottom has same black height */
  testBlackHeightProperty(a) {
    let e = 0, t = 0, r = 0;
    if (a.color === Ae && e++, a.left !== this.nil_node ? t = this.testBlackHeightProperty(a.left) : t = 1, a.right !== this.nil_node ? r = this.testBlackHeightProperty(a.right) : r = 1, t !== r)
      throw new Error("Red-black height property violated");
    return e += t, e;
  }
}
class fl {
  constructor() {
    /**
     * {
     *    unitId:{
     *       sheetId:{
     *          'columnIndex': {
     *              10:[1,3,4,5],
     *              5:[2,6,11,22]
     *          }
     *       }
     *    }
     * }
     */
    A(this, "_cache", /* @__PURE__ */ new Map());
    A(this, "_continueBuildingCache", /* @__PURE__ */ new Map());
  }
  set(a, e, t, r, n, s = !1) {
    if (!this.shouldContinueBuildingCache(a, e, t, n) && !s)
      return;
    let o = this._cache.get(a);
    o == null && (o = /* @__PURE__ */ new Map(), this._cache.set(a, o));
    let u = o.get(e);
    u == null && (u = /* @__PURE__ */ new Map(), o.set(e, u));
    let c = u.get(t);
    if (c == null && (c = /* @__PURE__ */ new Map(), u.set(t, c)), s) {
      for (const [f, h] of c)
        if (h.has(n)) {
          h.delete(n);
          break;
        }
    }
    let l = c.get(r);
    l == null && (l = /* @__PURE__ */ new Set(), c.set(r, l)), l.add(n);
  }
  getCellValuePositions(a, e, t) {
    var r, n;
    return (n = (r = this._cache.get(a)) == null ? void 0 : r.get(e)) == null ? void 0 : n.get(t);
  }
  getCellPositions(a, e, t, r, n) {
    var o, u, c;
    const s = (c = (u = (o = this._cache.get(a)) == null ? void 0 : o.get(e)) == null ? void 0 : u.get(t)) == null ? void 0 : c.get(r);
    return s && [...s].filter((l) => n.some(([f, h]) => l >= f && l <= h));
  }
  setContinueBuildingCache(a, e, t, r, n) {
    if (t === -1 || r === -1 || n === -1)
      return;
    let s = this._continueBuildingCache.get(a);
    s == null && (s = /* @__PURE__ */ new Map(), this._continueBuildingCache.set(a, s));
    let o = s.get(e);
    o == null && (o = /* @__PURE__ */ new Map(), s.set(e, o));
    let u = o.get(t);
    if (u == null) {
      u = new da(), u.insert([r, n]), o.set(t, u);
      return;
    }
    this._handleNewInterval(u, r, n);
  }
  shouldContinueBuildingCache(a, e, t, r) {
    var o, u;
    if (t === -1 || r === -1)
      return !1;
    const n = (u = (o = this._continueBuildingCache.get(a)) == null ? void 0 : o.get(e)) == null ? void 0 : u.get(t);
    return n ? n.search([r, r]).length === 0 : !0;
  }
  canUseCache(a, e, t, r, n) {
    var f, h;
    const s = (h = (f = this._continueBuildingCache.get(a)) == null ? void 0 : f.get(e)) == null ? void 0 : h.get(t);
    if (t === -1 || r === -1 || n === -1 || !s)
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    const o = s.search([r, n]);
    if (o.length === 0)
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    o.sort((d, _) => d[0] - _[0]);
    const u = [], c = [];
    let l = r;
    for (let d = 0; d < o.length; d++) {
      const [_, C] = o[d];
      if (l >= _) {
        if (n <= C) {
          u.push([l, n]);
          break;
        }
        u.push([l, C]), l = C + 1, d === o.length - 1 && l <= n && c.push([l, n]);
      } else {
        if (n > C) {
          u.push([_, C]), c.push([l, _ - 1]), l = C + 1, d === o.length - 1 && l <= n && c.push([l, n]);
          continue;
        }
        u.push([_, n]), c.push([l, _ - 1]);
      }
    }
    return {
      rowsInCache: u,
      rowsNotInCache: c
    };
  }
  clear() {
    this._cache.clear(), this._continueBuildingCache.clear();
  }
  _handleNewInterval(a, e, t) {
    let r = a.search([e, t]);
    if (r.length === 0) {
      const o = [e - 1 < 0 ? 0 : e - 1, t + 1];
      if (r = a.search(o), r.length === 0) {
        a.insert([e, t]);
        return;
      }
    }
    let n = e, s = t;
    for (const o of r)
      n = Math.min(n, o[0]), s = Math.max(s, o[1]), a.remove(o);
    a.insert([n, s]);
  }
}
const We = new fl(), Ca = "engine-formula.config", Co = 1, ey = "CYCLE_REFERENCE_COUNT", hi = {};
class hl extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_getRowFilteredCallback");
  }
  register(e) {
    this._getRowFilteredCallback = e;
  }
  getRowFiltered(e, t, r) {
    var n;
    return this._getRowFilteredCallback && (n = this._getRowFilteredCallback(e, t, r)) != null ? n : !1;
  }
}
const _o = Ze(
  "univer.formula.sheet-row-filtered.service"
);
var ml = Object.getOwnPropertyDescriptor, gl = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ml(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Xr = (i, a) => (e, t) => a(e, t, i);
let Us = class extends Ne {
  constructor(a, e, t, r) {
    super();
    A(this, "_unitData", {});
    A(this, "_unitStylesData", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_arrayFormulaRange", {});
    A(this, "_formulaData", {});
    A(this, "_sheetNameMap", {});
    A(this, "_forceCalculate", !1);
    A(this, "_clearDependencyTreeCache", {});
    A(this, "_dirtyRanges", []);
    A(this, "_dirtyNameMap", {});
    A(this, "_dirtyDefinedNameMap", {});
    A(this, "_dirtyUnitFeatureMap", {});
    A(this, "_dirtyUnitOtherFormulaMap", {});
    A(this, "_excludedCell");
    A(this, "_sheetIdToNameMap", {});
    A(this, "_executeUnitId", "");
    A(this, "_executeSubUnitId", "");
    this._univerInstanceService = a, this._localeService = e, this._formulaDataModel = t, this._sheetRowFilteredService = r;
  }
  dispose() {
    super.dispose(), this._unitData = {}, this._unitStylesData = {}, this._arrayFormulaCellData = {}, this._arrayFormulaRange = {}, this._formulaData = {}, this._sheetNameMap = {}, this._clearDependencyTreeCache = {}, this._dirtyRanges = [], this._dirtyNameMap = {}, this._dirtyDefinedNameMap = {}, this._dirtyUnitFeatureMap = {}, this._dirtyUnitOtherFormulaMap = {}, this._excludedCell = {}, this._sheetIdToNameMap = {};
  }
  getExecuteUnitId() {
    return this._executeUnitId;
  }
  getExecuteSubUnitId() {
    return this._executeSubUnitId;
  }
  setExecuteUnitId(a) {
    this._executeUnitId = a;
  }
  setExecuteSubUnitId(a) {
    this._executeSubUnitId = a;
  }
  getExcludedRange() {
    return this._excludedCell;
  }
  getUnitData() {
    return this._unitData;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  getFormulaData() {
    return this._formulaData;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  getSheetNameMap() {
    return this._sheetNameMap;
  }
  isForceCalculate() {
    return this._forceCalculate;
  }
  getDirtyRanges() {
    return this._dirtyRanges;
  }
  getDirtyNameMap() {
    return this._dirtyNameMap;
  }
  getDirtyDefinedNameMap() {
    return this._dirtyDefinedNameMap;
  }
  getDirtyUnitFeatureMap() {
    return this._dirtyUnitFeatureMap;
  }
  getDirtyUnitOtherFormulaMap() {
    return this._dirtyUnitOtherFormulaMap;
  }
  getSheetName(a, e) {
    return this._sheetIdToNameMap[a] == null ? "" : this._sheetIdToNameMap[a][e] || "";
  }
  getClearDependencyTreeCache() {
    return this._clearDependencyTreeCache;
  }
  getLocale() {
    return this._localeService.getCurrentLocale();
  }
  getSheetsInfo() {
    const a = this._univerInstanceService.getCurrentUnitForType(fr.UNIVER_SHEET), { id: e, sheetOrder: t } = a.getSnapshot();
    return {
      sheetOrder: t,
      sheetNameMap: this._sheetIdToNameMap[e]
    };
  }
  getSheetRowColumnCount(a, e) {
    const t = this._univerInstanceService.getUnit(a), r = t == null ? void 0 : t.getSheetBySheetId(e), n = r == null ? void 0 : r.getSnapshot();
    if (!n)
      return { rowCount: 0, columnCount: 0 };
    const { rowCount: s, columnCount: o } = n;
    return { rowCount: s, columnCount: o };
  }
  getFilteredOutRows(a, e, t, r) {
    const n = [];
    for (let s = t; s <= r; s++)
      this._sheetRowFilteredService.getRowFiltered(a, e, s) && n.push(s);
    return n;
  }
  load(a) {
    if (a.allUnitData && a.unitSheetNameMap && a.unitStylesData)
      this._unitData = a.allUnitData, this._unitStylesData = a.unitStylesData, this._sheetNameMap = a.unitSheetNameMap;
    else {
      const { allUnitData: e, unitSheetNameMap: t, unitStylesData: r } = this._loadSheetData();
      this._unitData = e, this._unitStylesData = r, this._sheetNameMap = t;
    }
    a.rowData && this._applyUnitRowData(a.rowData), this._formulaData = a.formulaData, this._arrayFormulaCellData = Ic(a.arrayFormulaCellData), this._arrayFormulaRange = a.arrayFormulaRange, this._forceCalculate = a.forceCalculate, this._clearDependencyTreeCache = a.clearDependencyTreeCache || {}, this._dirtyRanges = a.dirtyRanges, this._dirtyNameMap = a.dirtyNameMap, this._dirtyDefinedNameMap = a.dirtyDefinedNameMap, this._dirtyUnitFeatureMap = a.dirtyUnitFeatureMap, this._dirtyUnitOtherFormulaMap = a.dirtyUnitOtherFormulaMap, this._excludedCell = a.excludedCell, this._mergeNameMap(this._sheetNameMap, this._dirtyNameMap);
  }
  getDirtyData() {
    return {
      forceCalculation: this._forceCalculate,
      dirtyRanges: this._dirtyRanges,
      dirtyNameMap: this._dirtyNameMap,
      dirtyDefinedNameMap: this._dirtyDefinedNameMap,
      dirtyUnitFeatureMap: this._dirtyUnitFeatureMap,
      dirtyUnitOtherFormulaMap: this._dirtyUnitOtherFormulaMap,
      clearDependencyTreeCache: this._clearDependencyTreeCache
    };
  }
  loadDirtyRangesAndExcludedCell(a, e) {
    this._dirtyRanges = a, this._excludedCell = e, this._dirtyNameMap = {};
  }
  registerUnitData(a) {
    this._unitData = a;
  }
  registerFormulaData(a) {
    this._formulaData = a;
  }
  registerSheetNameMap(a) {
    this._sheetNameMap = a;
  }
  // private _loadOtherFormulaData() {
  //     const unitAllDoc = this._univerInstanceService.getAllUniverDocsInstance();
  //     const unitAllSlide = this._univerInstanceService.getAllUniverSlidesInstance();
  //     const otherFormulaData: IOtherFormulaData = {};
  //     for (const documentDataModel of unitAllDoc) {
  //         const unitId = documentDataModel.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const subComponent = otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID];
  //         const customRanges = documentDataModel.getBody()?.customRanges;
  //         if (customRanges == null) {
  //             continue;
  //         }
  //         for (const customRange of customRanges) {
  //             subComponent[customRange.rangeId] = {
  //                 f: customRange.endIndex.toString(),
  //             };
  //         }
  //     }
  //     for (const slide of unitAllSlide) {
  //         const unitId = slide.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const pages = slide.getPages();
  //         if (pages == null) {
  //             continue;
  //         }
  //         const pageIds = Object.keys(pages);
  //         for (const pageId of pageIds) {
  //             const page = pages[pageId];
  //             const subComponent = otherFormulaData[unitId][pageId];
  //             const pageElements = page.pageElements;
  //             if (pageElements == null) {
  //                 continue;
  //             }
  //             const pageElementIds = Object.keys(pageElements);
  //             for (const pageElementId of pageElementIds) {
  //                 const pageElement = pageElements[pageElementId];
  //                 subComponent[pageElementId] = {
  //                     f: pageElement.title,
  //                 };
  //             }
  //         }
  //     }
  //     return otherFormulaData;
  // }
  _mergeNameMap(a, e) {
    Object.keys(e).forEach((t) => {
      e[t] && Object.keys(e[t]).forEach((r) => {
        a[t] == null && (a[t] = {}), a[t][e[t][r]] = r;
      });
    }), this._sheetIdToNameMap = {}, Object.keys(a).forEach((t) => {
      Object.keys(a[t]).forEach((r) => {
        this._sheetIdToNameMap[t] == null && (this._sheetIdToNameMap[t] = {}), this._sheetIdToNameMap[t][a[t][r]] = r;
      });
    });
  }
  _loadSheetData() {
    const a = this._univerInstanceService.getCurrentUnitForType(fr.UNIVER_SHEET), e = a == null ? void 0 : a.getActiveSheet();
    return this._executeUnitId = a == null ? void 0 : a.getUnitId(), this._executeSubUnitId = e == null ? void 0 : e.getSheetId(), this._formulaDataModel.getCalculateData();
  }
  /**
   * There is no filter information in the worker, it must be passed in from the main thread after it is ready
   * @param rowData
   */
  _applyUnitRowData(a) {
    for (const e in a)
      if (a[e] != null)
        for (const t in a[e])
          a[e][t] != null && (this._unitData[e] == null && (this._unitData[e] = {}), this._unitData[e][t] == null && (this._unitData[e][t] = {
            cellData: new Ce({}),
            rowCount: 0,
            columnCount: 0,
            rowData: {},
            columnData: {}
          }), this._unitData[e][t].rowData = a[e][t]);
  }
};
Us = gl([
  Xr(0, Yn),
  Xr(1, ye(tc)),
  Xr(2, ye(_r)),
  Xr(3, ye(_o))
], Us);
const Yt = Ze(
  "univer.formula.current-data.service"
);
var dl = Object.getOwnPropertyDescriptor, Cl = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? dl(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, gs = (i, a) => (e, t) => a(e, t, i);
let Ar = class extends Ne {
  constructor(i, a, e) {
    super(), this._definedNamesService = i, this._lexerTreeBuilder = a, this._formulaCurrentConfigService = e;
  }
  treeBuilder(i, a = !0) {
    return this._lexerTreeBuilder.treeBuilder(i, a, {
      unitId: this._formulaCurrentConfigService.getExecuteUnitId(),
      getValueByName: this._definedNamesService.getValueByName.bind(this._definedNamesService),
      getDirtyDefinedNameMap: this._formulaCurrentConfigService.getDirtyDefinedNameMap.bind(this._formulaCurrentConfigService)
    });
  }
};
Ar = Cl([
  gs(0, Nr),
  gs(1, ye(ga)),
  gs(2, Yt)
], Ar);
function cn(i) {
  if (i == null)
    return !0;
  const { v: a, f: e, si: t, p: r } = i;
  return !(!(a == null || typeof a == "string" && a.length === 0) || e != null && e.length > 0 || t != null && t.length > 0 || r != null);
}
function Ao(i, a, e, t, r) {
  var s;
  const n = Object.keys(r);
  for (const o of n) {
    const u = r[o], c = (s = u == null ? void 0 : u[t]) == null ? void 0 : s[e];
    if (c == null)
      continue;
    const l = c.getValue(i, a);
    if (l != null)
      return l;
  }
}
const _l = [
  "$",
  "£",
  "¥",
  "¤",
  "֏",
  "؋",
  "৳",
  "฿",
  "៛",
  "₡",
  "₦",
  "₩",
  "₪",
  "₫",
  "€",
  "₭",
  "₮",
  "₱",
  "₲",
  "₴",
  "₸",
  "₹",
  "₺",
  "₼",
  "₽",
  "₾",
  "₿"
], Al = {
  currency: 2,
  date: 4,
  datetime: 5,
  error: 11,
  fraction: 7,
  general: 0,
  grouped: 11,
  number: 1,
  percent: 6,
  scientific: 8,
  text: 9,
  time: 5,
  unknown: 11
  /* Custom */
};
function ty(i, a, e) {
  var u, c;
  if (i == null || a == null)
    return a;
  const t = (e == null ? void 0 : e.getStyleByCell(i)) || i.s, r = (e == null ? void 0 : e.getStyleByCell(a)) || a.s;
  if (t == null || r == null || typeof t != "object" || typeof r != "object")
    return a;
  const n = (u = t == null ? void 0 : t.n) == null ? void 0 : u.pattern, s = (c = r == null ? void 0 : r.n) == null ? void 0 : c.pattern;
  if (n == null || s == null)
    return a;
  const o = n || s;
  return r.n.pattern = o, a;
}
const vs = new wt(1e5);
function mi(i) {
  const a = vs.get(i);
  if (a !== void 0)
    return a;
  const e = bl(i);
  return vs.set(i, e), e;
}
function El() {
  vs.clear();
}
function bl(i) {
  if (yl(i))
    return 3;
  const a = At.getFormatInfo(i).type || "unknown";
  return Al[a];
}
function yl(i) {
  return !!_l.find((a) => i.includes(a)) && i.startsWith("_(");
}
function Zr(i, a, e) {
  if (i === "")
    return a;
  if (a === "")
    return i;
  const t = mi(i), r = mi(a);
  return e === X.PLUS || e === X.MINUS ? t === 4 && r === 4 || t === 11 && r === 11 ? "" : a : e === X.MULTIPLY || e === X.DIVIDED ? t === 6 && r === 6 || t === 7 && r === 7 || t === 8 && r === 8 || t === 9 && r === 9 ? a : "" : i || a;
}
const Rl = /* @__PURE__ */ new Map([
  [mt.EN_US, "$"],
  [mt.RU_RU, "₽"],
  [mt.VI_VN, "₫"],
  [mt.ZH_CN, "¥"],
  [mt.ZH_TW, "NT$"],
  [mt.FR_FR, "€"],
  [mt.FA_IR, "﷼"],
  [mt.KO_KR, "₩"],
  [mt.ES_ES, "€"],
  [mt.CA_ES, "€"]
]);
function gi(i) {
  return Rl.get(i) || "$";
}
function ze(i, a = 2) {
  let e = a;
  a > 127 && (e = 127);
  let t = "";
  return e > 0 && (t = `.${"0".repeat(e)}`), `"${gi(i)}"#,##0${t}_);[Red]("${gi(i)}"#,##0${t})`;
}
function pl(i, a, e = 2) {
  return At.format(ze(i, e), a);
}
const _a = new wt(1e5);
function Vl(i) {
  let a = i;
  a.startsWith('"') && a.endsWith('"') && (a = a.slice(1, -1));
  const e = _a.get(a);
  if (e)
    return {
      isNumberPattern: !0,
      value: e.value,
      pattern: e.pattern
    };
  const t = At.parseNumber(a);
  if (t && t.z)
    return ds(a, t.v, t.z);
  const r = At.parseDate(a);
  if (r && r.z)
    return ds(a, r.v, r.z);
  const n = At.parseTime(a);
  return n && n.z ? ds(a, n.v, n.z) : {
    isNumberPattern: !1
  };
}
function ds(i, a, e) {
  return _a.set(i, {
    value: a,
    pattern: e
  }), {
    isNumberPattern: !0,
    value: a,
    pattern: e
  };
}
function Nl() {
  _a.clear();
}
class Hn {
  constructor() {
    A(this, "pattern", "");
  }
  dispose() {
  }
  getPattern() {
    return this.pattern;
  }
  /**
   * Only used in NumberValueObject
   * @param pattern
   */
  setPattern(a) {
    this.pattern = a;
  }
  isError() {
    return !1;
  }
  isAsyncObject() {
    return !1;
  }
  isAsyncArrayObject() {
    return !1;
  }
  isReferenceObject() {
    return !1;
  }
  isArray() {
    return !1;
  }
  isValueObject() {
    return !1;
  }
  isEqualType(a) {
    return !1;
  }
}
class Ht extends Hn {
  constructor(e) {
    super();
    A(this, "_customData");
    this._rawValue = e;
  }
  isValueObject() {
    return !0;
  }
  toUnitRange() {
    return {
      range: {
        startColumn: -1,
        startRow: -1,
        endRow: -1,
        endColumn: -1
      },
      sheetId: "",
      unitId: ""
    };
  }
  getValue() {
    return 0;
  }
  getArrayValue() {
    return [];
  }
  setValue(e) {
  }
  setArrayValue(e) {
  }
  withCustomData(e) {
    return this._customData = e, this;
  }
  getCustomData() {
    return this._customData;
  }
  isCube() {
    return !1;
  }
  isString() {
    return !1;
  }
  isNumber() {
    return !1;
  }
  isBoolean() {
    return !1;
  }
  isLambda() {
    return !1;
  }
  isError() {
    return !1;
  }
  isNull() {
    return !1;
  }
  isHyperlink() {
    return !1;
  }
  sum() {
    return g.create(m.VALUE);
  }
  max() {
    return g.create(m.VALUE);
  }
  min() {
    return g.create(m.VALUE);
  }
  count() {
    return g.create(m.VALUE);
  }
  countA() {
    return g.create(m.VALUE);
  }
  countBlank() {
    return g.create(m.VALUE);
  }
  getNegative() {
    return g.create(m.VALUE);
  }
  getReciprocal() {
    return g.create(m.VALUE);
  }
  plus(e) {
    return g.create(m.VALUE);
  }
  minus(e) {
    return g.create(m.VALUE);
  }
  multiply(e) {
    return g.create(m.VALUE);
  }
  divided(e) {
    return g.create(m.VALUE);
  }
  mod(e) {
    return g.create(m.VALUE);
  }
  /**
   * return every value in the array after the callback function, excluding the error value
   * @param callbackFn
   * @returns
   */
  map(e) {
    return g.create(m.NAME);
  }
  /**
   * return every value in the array after the callback function
   * @param callbackFn
   * @returns
   */
  mapValue(e) {
    return g.create(m.NAME);
  }
  compare(e, t, r = !1) {
    return g.create(m.NAME);
  }
  isEqual(e) {
    return this.compare(e, F.EQUALS);
  }
  isNotEqual(e) {
    return this.compare(e, F.NOT_EQUAL);
  }
  isGreaterThanOrEqual(e) {
    return this.compare(e, F.GREATER_THAN_OR_EQUAL);
  }
  isLessThanOrEqual(e) {
    return this.compare(e, F.LESS_THAN_OR_EQUAL);
  }
  isLessThan(e) {
    return this.compare(e, F.LESS_THAN);
  }
  isGreaterThan(e) {
    return this.compare(e, F.GREATER_THAN);
  }
  concatenateFront(e) {
    return g.create(m.NAME);
  }
  concatenateBack(e) {
    return g.create(m.NAME);
  }
  plusBy(e) {
    return g.create(m.VALUE);
  }
  minusBy(e) {
    return g.create(m.VALUE);
  }
  multiplyBy(e) {
    return g.create(m.VALUE);
  }
  dividedBy(e) {
    return g.create(m.VALUE);
  }
  modInverse(e) {
    return g.create(m.VALUE);
  }
  compareBy(e, t) {
    return g.create(m.NAME);
  }
  concatenate(e, t = ct.FRONT) {
    let r = this.getValue().toString();
    if (typeof e == "string")
      t === ct.FRONT ? r = e + r : r += e;
    else if (typeof e == "number")
      t === ct.FRONT ? r = e.toString() + r : r += e.toString();
    else if (typeof e == "boolean") {
      const n = e ? "TRUE" : "FALSE";
      t === ct.FRONT ? r = n + r : r += n;
    }
    return r;
  }
  pow(e) {
    return g.create(m.VALUE);
  }
  powInverse(e) {
    return g.create(m.VALUE);
  }
  sqrt() {
    return g.create(m.VALUE);
  }
  cbrt() {
    return g.create(m.VALUE);
  }
  cos() {
    return g.create(m.VALUE);
  }
  cosh() {
    return g.create(m.VALUE);
  }
  acos() {
    return g.create(m.VALUE);
  }
  acosh() {
    return g.create(m.VALUE);
  }
  sin() {
    return g.create(m.VALUE);
  }
  sinh() {
    return g.create(m.VALUE);
  }
  asin() {
    return g.create(m.VALUE);
  }
  asinh() {
    return g.create(m.VALUE);
  }
  tan() {
    return g.create(m.VALUE);
  }
  tanh() {
    return g.create(m.VALUE);
  }
  atan() {
    return g.create(m.VALUE);
  }
  atan2(e) {
    return g.create(m.VALUE);
  }
  atan2Inverse(e) {
    return g.create(m.VALUE);
  }
  atanh() {
    return g.create(m.VALUE);
  }
  /**
   * Calculate the mean of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean
   *
   */
  mean() {
    return this;
  }
  /**
   * Calculate the median of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.median.html
   *
   */
  median() {
    return this;
  }
  /**
   * Calculate the variance of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.var.html
   */
  var() {
    return this;
  }
  /**
   * Calculate the standard deviation of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.std.html
   */
  std() {
    return this;
  }
  log() {
    return g.create(m.VALUE);
  }
  log10() {
    return g.create(m.VALUE);
  }
  exp() {
    return g.create(m.VALUE);
  }
  abs() {
    return g.create(m.VALUE);
  }
  round(e) {
    return g.create(m.VALUE);
  }
  roundInverse(e) {
    return g.create(m.VALUE);
  }
  floor(e) {
    return g.create(m.VALUE);
  }
  floorInverse(e) {
    return g.create(m.VALUE);
  }
  ceil(e) {
    return g.create(m.VALUE);
  }
  ceilInverse(e) {
    return g.create(m.VALUE);
  }
  convertToNumberObjectValue() {
    return g.create(m.VALUE);
  }
  convertToBooleanObjectValue() {
    return g.create(m.VALUE);
  }
}
const Ol = 1e3, Ts = new wt(Ol);
class g extends Ht {
  constructor(a, e = "") {
    super(a), this._errorType = a, this._errorContent = e;
  }
  static create(a, e = "") {
    const t = `${a}-${e}`, r = Ts.get(t);
    if (r)
      return r;
    const n = new g(a, e);
    return Ts.set(t, n), n;
  }
  getValue() {
    return this._errorType;
  }
  getErrorType() {
    return this._errorType;
  }
  getErrorContent() {
    return this._errorContent;
  }
  isEqualType(a) {
    return a.getErrorType() === this.getErrorType();
  }
  isError() {
    return !0;
  }
}
function Ml(i) {
  var a;
  if (i === null)
    return 0;
  if (i != null && i.p) {
    const e = i == null ? void 0 : i.p.body;
    if (e == null)
      return 0;
    const t = e.dataStream;
    return rc.transform.getPlainText(t);
  }
  return (a = i == null ? void 0 : i.v) != null ? a : 0;
}
function ry(i, a = !1) {
  return !a && !(dt(i == null ? void 0 : i.f) || Nt(i == null ? void 0 : i.si)) ? null : typeof (i == null ? void 0 : i.v) == "string" && or.has(i.v) ? i.v : null;
}
var Kt = /* @__PURE__ */ ((i) => (i[i.MIN = 0] = "MIN", i[i.MAX = 1] = "MAX", i))(Kt || {}), Le = /* @__PURE__ */ ((i) => (i[i.NORMAL = 0] = "NORMAL", i[i.MIN = 1] = "MIN", i[i.MAX = 2] = "MAX", i))(Le || {});
function An() {
  return Intl && Intl.Collator ? new Intl.Collator(void 0, { numeric: !1 }).compare : (i, a) => i.localeCompare(a);
}
function wl(i) {
  return i.indexOf("*") > -1 || i.indexOf("?") > -1;
}
function Cs(i, a) {
  const e = Dl(a).replace(/~?[*?]/g, (r) => r.startsWith("~") ? `\\${r.substring(1)}` : r === "*" ? ".*" : r === "?" ? "." : r);
  return new RegExp(`^${e}$`).test(i);
}
function di(i) {
  return i.replace(/~?[*?]/g, (a) => a.startsWith("~") ? a.substring(1) : " ");
}
function Sl(i, a, e) {
  let t = !1;
  switch (e) {
    case F.EQUALS:
      t = Cs(i, a);
      break;
    case F.NOT_EQUAL:
      t = !Cs(i, a);
      break;
    case F.GREATER_THAN:
    case F.GREATER_THAN_OR_EQUAL:
      t = Cs(i, a) || i > di(a);
      break;
    case F.LESS_THAN:
    case F.LESS_THAN_OR_EQUAL:
      t = i < di(a);
      break;
  }
  return t;
}
function Dl(i) {
  return i.replace(/[.+^${}()|[\]\\]/g, "\\$&");
}
function Bs(i) {
  switch (i) {
    case 1:
      return 2;
    case 0:
      return 0;
    case -1:
      return 1;
    default:
      return 0;
  }
}
function Is(i) {
  return i === -2 ? 1 : 0;
}
function Aa(i) {
  let a;
  switch (i) {
    case F.EQUALS:
      a = F.EQUALS;
      break;
    case F.GREATER_THAN:
      a = F.LESS_THAN;
      break;
    case F.GREATER_THAN_OR_EQUAL:
      a = F.LESS_THAN_OR_EQUAL;
      break;
    case F.LESS_THAN:
      a = F.GREATER_THAN;
      break;
    case F.LESS_THAN_OR_EQUAL:
      a = F.GREATER_THAN_OR_EQUAL;
      break;
    case F.NOT_EQUAL:
      a = F.NOT_EQUAL;
      break;
  }
  return a;
}
/*!
 *  decimal.js v10.6.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var lr = 9e15, Gt = 1e9, Fs = "0123456789abcdef", En = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", bn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", ks = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -lr,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: lr,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, Eo, Ot, oe = !0, Gn = "[DecimalError] ", kt = Gn + "Invalid argument: ", bo = Gn + "Precision limit exceeded", yo = Gn + "crypto unavailable", Ro = "[object Decimal]", Ie = Math.floor, Pe = Math.pow, Ll = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, Pl = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, xl = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, po = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, lt = 1e7, te = 7, jl = 9007199254740991, Ul = En.length - 1, $s = bn.length - 1, I = { toStringTag: Ro };
I.absoluteValue = I.abs = function() {
  var i = new this.constructor(this);
  return i.s < 0 && (i.s = 1), J(i);
};
I.ceil = function() {
  return J(new this.constructor(this), this.e + 1, 2);
};
I.clampedTo = I.clamp = function(i, a) {
  var e, t = this, r = t.constructor;
  if (i = new r(i), a = new r(a), !i.s || !a.s) return new r(NaN);
  if (i.gt(a)) throw Error(kt + a);
  return e = t.cmp(i), e < 0 ? i : t.cmp(a) > 0 ? a : new r(t);
};
I.comparedTo = I.cmp = function(i) {
  var a, e, t, r, n = this, s = n.d, o = (i = new n.constructor(i)).d, u = n.s, c = i.s;
  if (!s || !o)
    return !u || !c ? NaN : u !== c ? u : s === o ? 0 : !s ^ u < 0 ? 1 : -1;
  if (!s[0] || !o[0]) return s[0] ? u : o[0] ? -c : 0;
  if (u !== c) return u;
  if (n.e !== i.e) return n.e > i.e ^ u < 0 ? 1 : -1;
  for (t = s.length, r = o.length, a = 0, e = t < r ? t : r; a < e; ++a)
    if (s[a] !== o[a]) return s[a] > o[a] ^ u < 0 ? 1 : -1;
  return t === r ? 0 : t > r ^ u < 0 ? 1 : -1;
};
I.cosine = I.cos = function() {
  var i, a, e = this, t = e.constructor;
  return e.d ? e.d[0] ? (i = t.precision, a = t.rounding, t.precision = i + Math.max(e.e, e.sd()) + te, t.rounding = 1, e = vl(t, wo(t, e)), t.precision = i, t.rounding = a, J(Ot == 2 || Ot == 3 ? e.neg() : e, i, a, !0)) : new t(1) : new t(NaN);
};
I.cubeRoot = I.cbrt = function() {
  var i, a, e, t, r, n, s, o, u, c, l = this, f = l.constructor;
  if (!l.isFinite() || l.isZero()) return new f(l);
  for (oe = !1, n = l.s * Pe(l.s * l, 1 / 3), !n || Math.abs(n) == 1 / 0 ? (e = Ue(l.d), i = l.e, (n = (i - e.length + 1) % 3) && (e += n == 1 || n == -2 ? "0" : "00"), n = Pe(e, 1 / 3), i = Ie((i + 1) / 3) - (i % 3 == (i < 0 ? -1 : 2)), n == 1 / 0 ? e = "5e" + i : (e = n.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + i), t = new f(e), t.s = l.s) : t = new f(n.toString()), s = (i = f.precision) + 3; ; )
    if (o = t, u = o.times(o).times(o), c = u.plus(l), t = Ve(c.plus(l).times(o), c.plus(u), s + 2, 1), Ue(o.d).slice(0, s) === (e = Ue(t.d)).slice(0, s))
      if (e = e.slice(s - 3, s + 1), e == "9999" || !r && e == "4999") {
        if (!r && (J(o, i + 1, 0), o.times(o).times(o).eq(l))) {
          t = o;
          break;
        }
        s += 4, r = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (J(t, i + 1, 1), a = !t.times(t).times(t).eq(l));
        break;
      }
  return oe = !0, J(t, i, f.rounding, a);
};
I.decimalPlaces = I.dp = function() {
  var i, a = this.d, e = NaN;
  if (a) {
    if (i = a.length - 1, e = (i - Ie(this.e / te)) * te, i = a[i], i) for (; i % 10 == 0; i /= 10) e--;
    e < 0 && (e = 0);
  }
  return e;
};
I.dividedBy = I.div = function(i) {
  return Ve(this, new this.constructor(i));
};
I.dividedToIntegerBy = I.divToInt = function(i) {
  var a = this, e = a.constructor;
  return J(Ve(a, new e(i), 0, 1, 1), e.precision, e.rounding);
};
I.equals = I.eq = function(i) {
  return this.cmp(i) === 0;
};
I.floor = function() {
  return J(new this.constructor(this), this.e + 1, 3);
};
I.greaterThan = I.gt = function(i) {
  return this.cmp(i) > 0;
};
I.greaterThanOrEqualTo = I.gte = function(i) {
  var a = this.cmp(i);
  return a == 1 || a === 0;
};
I.hyperbolicCosine = I.cosh = function() {
  var i, a, e, t, r, n = this, s = n.constructor, o = new s(1);
  if (!n.isFinite()) return new s(n.s ? 1 / 0 : NaN);
  if (n.isZero()) return o;
  e = s.precision, t = s.rounding, s.precision = e + Math.max(n.e, n.sd()) + 4, s.rounding = 1, r = n.d.length, r < 32 ? (i = Math.ceil(r / 3), a = (1 / Wn(4, i)).toString()) : (i = 16, a = "2.3283064365386962890625e-10"), n = Er(s, 1, n.times(a), new s(1), !0);
  for (var u, c = i, l = new s(8); c--; )
    u = n.times(n), n = o.minus(u.times(l.minus(u.times(l))));
  return J(n, s.precision = e, s.rounding = t, !0);
};
I.hyperbolicSine = I.sinh = function() {
  var i, a, e, t, r = this, n = r.constructor;
  if (!r.isFinite() || r.isZero()) return new n(r);
  if (a = n.precision, e = n.rounding, n.precision = a + Math.max(r.e, r.sd()) + 4, n.rounding = 1, t = r.d.length, t < 3)
    r = Er(n, 2, r, r, !0);
  else {
    i = 1.4 * Math.sqrt(t), i = i > 16 ? 16 : i | 0, r = r.times(1 / Wn(5, i)), r = Er(n, 2, r, r, !0);
    for (var s, o = new n(5), u = new n(16), c = new n(20); i--; )
      s = r.times(r), r = r.times(o.plus(s.times(u.times(s).plus(c))));
  }
  return n.precision = a, n.rounding = e, J(r, a, e, !0);
};
I.hyperbolicTangent = I.tanh = function() {
  var i, a, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (i = t.precision, a = t.rounding, t.precision = i + 7, t.rounding = 1, Ve(e.sinh(), e.cosh(), t.precision = i, t.rounding = a)) : new t(e.s);
};
I.inverseCosine = I.acos = function() {
  var i = this, a = i.constructor, e = i.abs().cmp(1), t = a.precision, r = a.rounding;
  return e !== -1 ? e === 0 ? i.isNeg() ? _t(a, t, r) : new a(0) : new a(NaN) : i.isZero() ? _t(a, t + 4, r).times(0.5) : (a.precision = t + 6, a.rounding = 1, i = new a(1).minus(i).div(i.plus(1)).sqrt().atan(), a.precision = t, a.rounding = r, i.times(2));
};
I.inverseHyperbolicCosine = I.acosh = function() {
  var i, a, e = this, t = e.constructor;
  return e.lte(1) ? new t(e.eq(1) ? 0 : NaN) : e.isFinite() ? (i = t.precision, a = t.rounding, t.precision = i + Math.max(Math.abs(e.e), e.sd()) + 4, t.rounding = 1, oe = !1, e = e.times(e).minus(1).sqrt().plus(e), oe = !0, t.precision = i, t.rounding = a, e.ln()) : new t(e);
};
I.inverseHyperbolicSine = I.asinh = function() {
  var i, a, e = this, t = e.constructor;
  return !e.isFinite() || e.isZero() ? new t(e) : (i = t.precision, a = t.rounding, t.precision = i + 2 * Math.max(Math.abs(e.e), e.sd()) + 6, t.rounding = 1, oe = !1, e = e.times(e).plus(1).sqrt().plus(e), oe = !0, t.precision = i, t.rounding = a, e.ln());
};
I.inverseHyperbolicTangent = I.atanh = function() {
  var i, a, e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.e >= 0 ? new n(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (i = n.precision, a = n.rounding, t = r.sd(), Math.max(t, i) < 2 * -r.e - 1 ? J(new n(r), i, a, !0) : (n.precision = e = t - r.e, r = Ve(r.plus(1), new n(1).minus(r), e + i, 1), n.precision = i + 4, n.rounding = 1, r = r.ln(), n.precision = i, n.rounding = a, r.times(0.5))) : new n(NaN);
};
I.inverseSine = I.asin = function() {
  var i, a, e, t, r = this, n = r.constructor;
  return r.isZero() ? new n(r) : (a = r.abs().cmp(1), e = n.precision, t = n.rounding, a !== -1 ? a === 0 ? (i = _t(n, e + 4, t).times(0.5), i.s = r.s, i) : new n(NaN) : (n.precision = e + 6, n.rounding = 1, r = r.div(new n(1).minus(r.times(r)).sqrt().plus(1)).atan(), n.precision = e, n.rounding = t, r.times(2)));
};
I.inverseTangent = I.atan = function() {
  var i, a, e, t, r, n, s, o, u, c = this, l = c.constructor, f = l.precision, h = l.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new l(c);
    if (c.abs().eq(1) && f + 4 <= $s)
      return s = _t(l, f + 4, h).times(0.25), s.s = c.s, s;
  } else {
    if (!c.s) return new l(NaN);
    if (f + 4 <= $s)
      return s = _t(l, f + 4, h).times(0.5), s.s = c.s, s;
  }
  for (l.precision = o = f + 10, l.rounding = 1, e = Math.min(28, o / te + 2 | 0), i = e; i; --i) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (oe = !1, a = Math.ceil(o / te), t = 1, u = c.times(c), s = new l(c), r = c; i !== -1; )
    if (r = r.times(u), n = s.minus(r.div(t += 2)), r = r.times(u), s = n.plus(r.div(t += 2)), s.d[a] !== void 0) for (i = a; s.d[i] === n.d[i] && i--; ) ;
  return e && (s = s.times(2 << e - 1)), oe = !0, J(s, l.precision = f, l.rounding = h, !0);
};
I.isFinite = function() {
  return !!this.d;
};
I.isInteger = I.isInt = function() {
  return !!this.d && Ie(this.e / te) > this.d.length - 2;
};
I.isNaN = function() {
  return !this.s;
};
I.isNegative = I.isNeg = function() {
  return this.s < 0;
};
I.isPositive = I.isPos = function() {
  return this.s > 0;
};
I.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
I.lessThan = I.lt = function(i) {
  return this.cmp(i) < 0;
};
I.lessThanOrEqualTo = I.lte = function(i) {
  return this.cmp(i) < 1;
};
I.logarithm = I.log = function(i) {
  var a, e, t, r, n, s, o, u, c = this, l = c.constructor, f = l.precision, h = l.rounding, d = 5;
  if (i == null)
    i = new l(10), a = !0;
  else {
    if (i = new l(i), e = i.d, i.s < 0 || !e || !e[0] || i.eq(1)) return new l(NaN);
    a = i.eq(10);
  }
  if (e = c.d, c.s < 0 || !e || !e[0] || c.eq(1))
    return new l(e && !e[0] ? -1 / 0 : c.s != 1 ? NaN : e ? 0 : 1 / 0);
  if (a)
    if (e.length > 1)
      n = !0;
    else {
      for (r = e[0]; r % 10 === 0; ) r /= 10;
      n = r !== 1;
    }
  if (oe = !1, o = f + d, s = vt(c, o), t = a ? yn(l, o + 10) : vt(i, o), u = Ve(s, t, o, 1), Pr(u.d, r = f, h))
    do
      if (o += 10, s = vt(c, o), t = a ? yn(l, o + 10) : vt(i, o), u = Ve(s, t, o, 1), !n) {
        +Ue(u.d).slice(r + 1, r + 15) + 1 == 1e14 && (u = J(u, f + 1, 0));
        break;
      }
    while (Pr(u.d, r += 10, h));
  return oe = !0, J(u, f, h);
};
I.minus = I.sub = function(i) {
  var a, e, t, r, n, s, o, u, c, l, f, h, d = this, _ = d.constructor;
  if (i = new _(i), !d.d || !i.d)
    return !d.s || !i.s ? i = new _(NaN) : d.d ? i.s = -i.s : i = new _(i.d || d.s !== i.s ? d : NaN), i;
  if (d.s != i.s)
    return i.s = -i.s, d.plus(i);
  if (c = d.d, h = i.d, o = _.precision, u = _.rounding, !c[0] || !h[0]) {
    if (h[0]) i.s = -i.s;
    else if (c[0]) i = new _(d);
    else return new _(u === 3 ? -0 : 0);
    return oe ? J(i, o, u) : i;
  }
  if (e = Ie(i.e / te), l = Ie(d.e / te), c = c.slice(), n = l - e, n) {
    for (f = n < 0, f ? (a = c, n = -n, s = h.length) : (a = h, e = l, s = c.length), t = Math.max(Math.ceil(o / te), s) + 2, n > t && (n = t, a.length = 1), a.reverse(), t = n; t--; ) a.push(0);
    a.reverse();
  } else {
    for (t = c.length, s = h.length, f = t < s, f && (s = t), t = 0; t < s; t++)
      if (c[t] != h[t]) {
        f = c[t] < h[t];
        break;
      }
    n = 0;
  }
  for (f && (a = c, c = h, h = a, i.s = -i.s), s = c.length, t = h.length - s; t > 0; --t) c[s++] = 0;
  for (t = h.length; t > n; ) {
    if (c[--t] < h[t]) {
      for (r = t; r && c[--r] === 0; ) c[r] = lt - 1;
      --c[r], c[t] += lt;
    }
    c[t] -= h[t];
  }
  for (; c[--s] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --e;
  return c[0] ? (i.d = c, i.e = Qn(c, e), oe ? J(i, o, u) : i) : new _(u === 3 ? -0 : 0);
};
I.modulo = I.mod = function(i) {
  var a, e = this, t = e.constructor;
  return i = new t(i), !e.d || !i.s || i.d && !i.d[0] ? new t(NaN) : !i.d || e.d && !e.d[0] ? J(new t(e), t.precision, t.rounding) : (oe = !1, t.modulo == 9 ? (a = Ve(e, i.abs(), 0, 3, 1), a.s *= i.s) : a = Ve(e, i, 0, t.modulo, 1), a = a.times(i), oe = !0, e.minus(a));
};
I.naturalExponential = I.exp = function() {
  return Ys(this);
};
I.naturalLogarithm = I.ln = function() {
  return vt(this);
};
I.negated = I.neg = function() {
  var i = new this.constructor(this);
  return i.s = -i.s, J(i);
};
I.plus = I.add = function(i) {
  var a, e, t, r, n, s, o, u, c, l, f = this, h = f.constructor;
  if (i = new h(i), !f.d || !i.d)
    return !f.s || !i.s ? i = new h(NaN) : f.d || (i = new h(i.d || f.s === i.s ? f : NaN)), i;
  if (f.s != i.s)
    return i.s = -i.s, f.minus(i);
  if (c = f.d, l = i.d, o = h.precision, u = h.rounding, !c[0] || !l[0])
    return l[0] || (i = new h(f)), oe ? J(i, o, u) : i;
  if (n = Ie(f.e / te), t = Ie(i.e / te), c = c.slice(), r = n - t, r) {
    for (r < 0 ? (e = c, r = -r, s = l.length) : (e = l, t = n, s = c.length), n = Math.ceil(o / te), s = n > s ? n + 1 : s + 1, r > s && (r = s, e.length = 1), e.reverse(); r--; ) e.push(0);
    e.reverse();
  }
  for (s = c.length, r = l.length, s - r < 0 && (r = s, e = l, l = c, c = e), a = 0; r; )
    a = (c[--r] = c[r] + l[r] + a) / lt | 0, c[r] %= lt;
  for (a && (c.unshift(a), ++t), s = c.length; c[--s] == 0; ) c.pop();
  return i.d = c, i.e = Qn(c, t), oe ? J(i, o, u) : i;
};
I.precision = I.sd = function(i) {
  var a, e = this;
  if (i !== void 0 && i !== !!i && i !== 1 && i !== 0) throw Error(kt + i);
  return e.d ? (a = Vo(e.d), i && e.e + 1 > a && (a = e.e + 1)) : a = NaN, a;
};
I.round = function() {
  var i = this, a = i.constructor;
  return J(new a(i), i.e + 1, a.rounding);
};
I.sine = I.sin = function() {
  var i, a, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (i = t.precision, a = t.rounding, t.precision = i + Math.max(e.e, e.sd()) + te, t.rounding = 1, e = Bl(t, wo(t, e)), t.precision = i, t.rounding = a, J(Ot > 2 ? e.neg() : e, i, a, !0)) : new t(NaN);
};
I.squareRoot = I.sqrt = function() {
  var i, a, e, t, r, n, s = this, o = s.d, u = s.e, c = s.s, l = s.constructor;
  if (c !== 1 || !o || !o[0])
    return new l(!c || c < 0 && (!o || o[0]) ? NaN : o ? s : 1 / 0);
  for (oe = !1, c = Math.sqrt(+s), c == 0 || c == 1 / 0 ? (a = Ue(o), (a.length + u) % 2 == 0 && (a += "0"), c = Math.sqrt(a), u = Ie((u + 1) / 2) - (u < 0 || u % 2), c == 1 / 0 ? a = "5e" + u : (a = c.toExponential(), a = a.slice(0, a.indexOf("e") + 1) + u), t = new l(a)) : t = new l(c.toString()), e = (u = l.precision) + 3; ; )
    if (n = t, t = n.plus(Ve(s, n, e + 2, 1)).times(0.5), Ue(n.d).slice(0, e) === (a = Ue(t.d)).slice(0, e))
      if (a = a.slice(e - 3, e + 1), a == "9999" || !r && a == "4999") {
        if (!r && (J(n, u + 1, 0), n.times(n).eq(s))) {
          t = n;
          break;
        }
        e += 4, r = 1;
      } else {
        (!+a || !+a.slice(1) && a.charAt(0) == "5") && (J(t, u + 1, 1), i = !t.times(t).eq(s));
        break;
      }
  return oe = !0, J(t, u, l.rounding, i);
};
I.tangent = I.tan = function() {
  var i, a, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (i = t.precision, a = t.rounding, t.precision = i + 10, t.rounding = 1, e = e.sin(), e.s = 1, e = Ve(e, new t(1).minus(e.times(e)).sqrt(), i + 10, 0), t.precision = i, t.rounding = a, J(Ot == 2 || Ot == 4 ? e.neg() : e, i, a, !0)) : new t(NaN);
};
I.times = I.mul = function(i) {
  var a, e, t, r, n, s, o, u, c, l = this, f = l.constructor, h = l.d, d = (i = new f(i)).d;
  if (i.s *= l.s, !h || !h[0] || !d || !d[0])
    return new f(!i.s || h && !h[0] && !d || d && !d[0] && !h ? NaN : !h || !d ? i.s / 0 : i.s * 0);
  for (e = Ie(l.e / te) + Ie(i.e / te), u = h.length, c = d.length, u < c && (n = h, h = d, d = n, s = u, u = c, c = s), n = [], s = u + c, t = s; t--; ) n.push(0);
  for (t = c; --t >= 0; ) {
    for (a = 0, r = u + t; r > t; )
      o = n[r] + d[t] * h[r - t - 1] + a, n[r--] = o % lt | 0, a = o / lt | 0;
    n[r] = (n[r] + a) % lt | 0;
  }
  for (; !n[--s]; ) n.pop();
  return a ? ++e : n.shift(), i.d = n, i.e = Qn(n, e), oe ? J(i, f.precision, f.rounding) : i;
};
I.toBinary = function(i, a) {
  return Ea(this, 2, i, a);
};
I.toDecimalPlaces = I.toDP = function(i, a) {
  var e = this, t = e.constructor;
  return e = new t(e), i === void 0 ? e : (He(i, 0, Gt), a === void 0 ? a = t.rounding : He(a, 0, 8), J(e, i + e.e + 1, a));
};
I.toExponential = function(i, a) {
  var e, t = this, r = t.constructor;
  return i === void 0 ? e = bt(t, !0) : (He(i, 0, Gt), a === void 0 ? a = r.rounding : He(a, 0, 8), t = J(new r(t), i + 1, a), e = bt(t, !0, i + 1)), t.isNeg() && !t.isZero() ? "-" + e : e;
};
I.toFixed = function(i, a) {
  var e, t, r = this, n = r.constructor;
  return i === void 0 ? e = bt(r) : (He(i, 0, Gt), a === void 0 ? a = n.rounding : He(a, 0, 8), t = J(new n(r), i + r.e + 1, a), e = bt(t, !1, i + t.e + 1)), r.isNeg() && !r.isZero() ? "-" + e : e;
};
I.toFraction = function(i) {
  var a, e, t, r, n, s, o, u, c, l, f, h, d = this, _ = d.d, C = d.constructor;
  if (!_) return new C(d);
  if (c = e = new C(1), t = u = new C(0), a = new C(t), n = a.e = Vo(_) - d.e - 1, s = n % te, a.d[0] = Pe(10, s < 0 ? te + s : s), i == null)
    i = n > 0 ? a : c;
  else {
    if (o = new C(i), !o.isInt() || o.lt(c)) throw Error(kt + o);
    i = o.gt(a) ? n > 0 ? a : c : o;
  }
  for (oe = !1, o = new C(Ue(_)), l = C.precision, C.precision = n = _.length * te * 2; f = Ve(o, a, 0, 1, 1), r = e.plus(f.times(t)), r.cmp(i) != 1; )
    e = t, t = r, r = c, c = u.plus(f.times(r)), u = r, r = a, a = o.minus(f.times(r)), o = r;
  return r = Ve(i.minus(e), t, 0, 1, 1), u = u.plus(r.times(c)), e = e.plus(r.times(t)), u.s = c.s = d.s, h = Ve(c, t, n, 1).minus(d).abs().cmp(Ve(u, e, n, 1).minus(d).abs()) < 1 ? [c, t] : [u, e], C.precision = l, oe = !0, h;
};
I.toHexadecimal = I.toHex = function(i, a) {
  return Ea(this, 16, i, a);
};
I.toNearest = function(i, a) {
  var e = this, t = e.constructor;
  if (e = new t(e), i == null) {
    if (!e.d) return e;
    i = new t(1), a = t.rounding;
  } else {
    if (i = new t(i), a === void 0 ? a = t.rounding : He(a, 0, 8), !e.d) return i.s ? e : i;
    if (!i.d)
      return i.s && (i.s = e.s), i;
  }
  return i.d[0] ? (oe = !1, e = Ve(e, i, 0, a, 1).times(i), oe = !0, J(e)) : (i.s = e.s, e = i), e;
};
I.toNumber = function() {
  return +this;
};
I.toOctal = function(i, a) {
  return Ea(this, 8, i, a);
};
I.toPower = I.pow = function(i) {
  var a, e, t, r, n, s, o = this, u = o.constructor, c = +(i = new u(i));
  if (!o.d || !i.d || !o.d[0] || !i.d[0]) return new u(Pe(+o, c));
  if (o = new u(o), o.eq(1)) return o;
  if (t = u.precision, n = u.rounding, i.eq(1)) return J(o, t, n);
  if (a = Ie(i.e / te), a >= i.d.length - 1 && (e = c < 0 ? -c : c) <= jl)
    return r = No(u, o, e, t), i.s < 0 ? new u(1).div(r) : J(r, t, n);
  if (s = o.s, s < 0) {
    if (a < i.d.length - 1) return new u(NaN);
    if ((i.d[a] & 1) == 0 && (s = 1), o.e == 0 && o.d[0] == 1 && o.d.length == 1)
      return o.s = s, o;
  }
  return e = Pe(+o, c), a = e == 0 || !isFinite(e) ? Ie(c * (Math.log("0." + Ue(o.d)) / Math.LN10 + o.e + 1)) : new u(e + "").e, a > u.maxE + 1 || a < u.minE - 1 ? new u(a > 0 ? s / 0 : 0) : (oe = !1, u.rounding = o.s = 1, e = Math.min(12, (a + "").length), r = Ys(i.times(vt(o, t + e)), t), r.d && (r = J(r, t + 5, 1), Pr(r.d, t, n) && (a = t + 10, r = J(Ys(i.times(vt(o, a + e)), a), a + 5, 1), +Ue(r.d).slice(t + 1, t + 15) + 1 == 1e14 && (r = J(r, t + 1, 0)))), r.s = s, oe = !0, u.rounding = n, J(r, t, n));
};
I.toPrecision = function(i, a) {
  var e, t = this, r = t.constructor;
  return i === void 0 ? e = bt(t, t.e <= r.toExpNeg || t.e >= r.toExpPos) : (He(i, 1, Gt), a === void 0 ? a = r.rounding : He(a, 0, 8), t = J(new r(t), i, a), e = bt(t, i <= t.e || t.e <= r.toExpNeg, i)), t.isNeg() && !t.isZero() ? "-" + e : e;
};
I.toSignificantDigits = I.toSD = function(i, a) {
  var e = this, t = e.constructor;
  return i === void 0 ? (i = t.precision, a = t.rounding) : (He(i, 1, Gt), a === void 0 ? a = t.rounding : He(a, 0, 8)), J(new t(e), i, a);
};
I.toString = function() {
  var i = this, a = i.constructor, e = bt(i, i.e <= a.toExpNeg || i.e >= a.toExpPos);
  return i.isNeg() && !i.isZero() ? "-" + e : e;
};
I.truncated = I.trunc = function() {
  return J(new this.constructor(this), this.e + 1, 1);
};
I.valueOf = I.toJSON = function() {
  var i = this, a = i.constructor, e = bt(i, i.e <= a.toExpNeg || i.e >= a.toExpPos);
  return i.isNeg() ? "-" + e : e;
};
function Ue(i) {
  var a, e, t, r = i.length - 1, n = "", s = i[0];
  if (r > 0) {
    for (n += s, a = 1; a < r; a++)
      t = i[a] + "", e = te - t.length, e && (n += jt(e)), n += t;
    s = i[a], t = s + "", e = te - t.length, e && (n += jt(e));
  } else if (s === 0)
    return "0";
  for (; s % 10 === 0; ) s /= 10;
  return n + s;
}
function He(i, a, e) {
  if (i !== ~~i || i < a || i > e)
    throw Error(kt + i);
}
function Pr(i, a, e, t) {
  var r, n, s, o;
  for (n = i[0]; n >= 10; n /= 10) --a;
  return --a < 0 ? (a += te, r = 0) : (r = Math.ceil((a + 1) / te), a %= te), n = Pe(10, te - a), o = i[r] % n | 0, t == null ? a < 3 ? (a == 0 ? o = o / 100 | 0 : a == 1 && (o = o / 10 | 0), s = e < 4 && o == 99999 || e > 3 && o == 49999 || o == 5e4 || o == 0) : s = (e < 4 && o + 1 == n || e > 3 && o + 1 == n / 2) && (i[r + 1] / n / 100 | 0) == Pe(10, a - 2) - 1 || (o == n / 2 || o == 0) && (i[r + 1] / n / 100 | 0) == 0 : a < 4 ? (a == 0 ? o = o / 1e3 | 0 : a == 1 ? o = o / 100 | 0 : a == 2 && (o = o / 10 | 0), s = (t || e < 4) && o == 9999 || !t && e > 3 && o == 4999) : s = ((t || e < 4) && o + 1 == n || !t && e > 3 && o + 1 == n / 2) && (i[r + 1] / n / 1e3 | 0) == Pe(10, a - 3) - 1, s;
}
function ln(i, a, e) {
  for (var t, r = [0], n, s = 0, o = i.length; s < o; ) {
    for (n = r.length; n--; ) r[n] *= a;
    for (r[0] += Fs.indexOf(i.charAt(s++)), t = 0; t < r.length; t++)
      r[t] > e - 1 && (r[t + 1] === void 0 && (r[t + 1] = 0), r[t + 1] += r[t] / e | 0, r[t] %= e);
  }
  return r.reverse();
}
function vl(i, a) {
  var e, t, r;
  if (a.isZero()) return a;
  t = a.d.length, t < 32 ? (e = Math.ceil(t / 3), r = (1 / Wn(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), i.precision += e, a = Er(i, 1, a.times(r), new i(1));
  for (var n = e; n--; ) {
    var s = a.times(a);
    a = s.times(s).minus(s).times(8).plus(1);
  }
  return i.precision -= e, a;
}
var Ve = /* @__PURE__ */ (function() {
  function i(t, r, n) {
    var s, o = 0, u = t.length;
    for (t = t.slice(); u--; )
      s = t[u] * r + o, t[u] = s % n | 0, o = s / n | 0;
    return o && t.unshift(o), t;
  }
  function a(t, r, n, s) {
    var o, u;
    if (n != s)
      u = n > s ? 1 : -1;
    else
      for (o = u = 0; o < n; o++)
        if (t[o] != r[o]) {
          u = t[o] > r[o] ? 1 : -1;
          break;
        }
    return u;
  }
  function e(t, r, n, s) {
    for (var o = 0; n--; )
      t[n] -= o, o = t[n] < r[n] ? 1 : 0, t[n] = o * s + t[n] - r[n];
    for (; !t[0] && t.length > 1; ) t.shift();
  }
  return function(t, r, n, s, o, u) {
    var c, l, f, h, d, _, C, E, b, R, p, N, M, w, S, D, L, U, x, k, Q = t.constructor, ne = t.s == r.s ? 1 : -1, z = t.d, G = r.d;
    if (!z || !z[0] || !G || !G[0])
      return new Q(
        // Return NaN if either NaN, or both Infinity or 0.
        !t.s || !r.s || (z ? G && z[0] == G[0] : !G) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          z && z[0] == 0 || !G ? ne * 0 : ne / 0
        )
      );
    for (u ? (d = 1, l = t.e - r.e) : (u = lt, d = te, l = Ie(t.e / d) - Ie(r.e / d)), x = G.length, L = z.length, b = new Q(ne), R = b.d = [], f = 0; G[f] == (z[f] || 0); f++) ;
    if (G[f] > (z[f] || 0) && l--, n == null ? (w = n = Q.precision, s = Q.rounding) : o ? w = n + (t.e - r.e) + 1 : w = n, w < 0)
      R.push(1), _ = !0;
    else {
      if (w = w / d + 2 | 0, f = 0, x == 1) {
        for (h = 0, G = G[0], w++; (f < L || h) && w--; f++)
          S = h * u + (z[f] || 0), R[f] = S / G | 0, h = S % G | 0;
        _ = h || f < L;
      } else {
        for (h = u / (G[0] + 1) | 0, h > 1 && (G = i(G, h, u), z = i(z, h, u), x = G.length, L = z.length), D = x, p = z.slice(0, x), N = p.length; N < x; ) p[N++] = 0;
        k = G.slice(), k.unshift(0), U = G[0], G[1] >= u / 2 && ++U;
        do
          h = 0, c = a(G, p, x, N), c < 0 ? (M = p[0], x != N && (M = M * u + (p[1] || 0)), h = M / U | 0, h > 1 ? (h >= u && (h = u - 1), C = i(G, h, u), E = C.length, N = p.length, c = a(C, p, E, N), c == 1 && (h--, e(C, x < E ? k : G, E, u))) : (h == 0 && (c = h = 1), C = G.slice()), E = C.length, E < N && C.unshift(0), e(p, C, N, u), c == -1 && (N = p.length, c = a(G, p, x, N), c < 1 && (h++, e(p, x < N ? k : G, N, u))), N = p.length) : c === 0 && (h++, p = [0]), R[f++] = h, c && p[0] ? p[N++] = z[D] || 0 : (p = [z[D]], N = 1);
        while ((D++ < L || p[0] !== void 0) && w--);
        _ = p[0] !== void 0;
      }
      R[0] || R.shift();
    }
    if (d == 1)
      b.e = l, Eo = _;
    else {
      for (f = 1, h = R[0]; h >= 10; h /= 10) f++;
      b.e = f + l * d - 1, J(b, o ? n + b.e + 1 : n, s, _);
    }
    return b;
  };
})();
function J(i, a, e, t) {
  var r, n, s, o, u, c, l, f, h, d = i.constructor;
  e: if (a != null) {
    if (f = i.d, !f) return i;
    for (r = 1, o = f[0]; o >= 10; o /= 10) r++;
    if (n = a - r, n < 0)
      n += te, s = a, l = f[h = 0], u = l / Pe(10, r - s - 1) % 10 | 0;
    else if (h = Math.ceil((n + 1) / te), o = f.length, h >= o)
      if (t) {
        for (; o++ <= h; ) f.push(0);
        l = u = 0, r = 1, n %= te, s = n - te + 1;
      } else
        break e;
    else {
      for (l = o = f[h], r = 1; o >= 10; o /= 10) r++;
      n %= te, s = n - te + r, u = s < 0 ? 0 : l / Pe(10, r - s - 1) % 10 | 0;
    }
    if (t = t || a < 0 || f[h + 1] !== void 0 || (s < 0 ? l : l % Pe(10, r - s - 1)), c = e < 4 ? (u || t) && (e == 0 || e == (i.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (e == 4 || t || e == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (n > 0 ? s > 0 ? l / Pe(10, r - s) : 0 : f[h - 1]) % 10 & 1 || e == (i.s < 0 ? 8 : 7)), a < 1 || !f[0])
      return f.length = 0, c ? (a -= i.e + 1, f[0] = Pe(10, (te - a % te) % te), i.e = -a || 0) : f[0] = i.e = 0, i;
    if (n == 0 ? (f.length = h, o = 1, h--) : (f.length = h + 1, o = Pe(10, te - n), f[h] = s > 0 ? (l / Pe(10, r - s) % Pe(10, s) | 0) * o : 0), c)
      for (; ; )
        if (h == 0) {
          for (n = 1, s = f[0]; s >= 10; s /= 10) n++;
          for (s = f[0] += o, o = 1; s >= 10; s /= 10) o++;
          n != o && (i.e++, f[0] == lt && (f[0] = 1));
          break;
        } else {
          if (f[h] += o, f[h] != lt) break;
          f[h--] = 0, o = 1;
        }
    for (n = f.length; f[--n] === 0; ) f.pop();
  }
  return oe && (i.e > d.maxE ? (i.d = null, i.e = NaN) : i.e < d.minE && (i.e = 0, i.d = [0])), i;
}
function bt(i, a, e) {
  if (!i.isFinite()) return Mo(i);
  var t, r = i.e, n = Ue(i.d), s = n.length;
  return a ? (e && (t = e - s) > 0 ? n = n.charAt(0) + "." + n.slice(1) + jt(t) : s > 1 && (n = n.charAt(0) + "." + n.slice(1)), n = n + (i.e < 0 ? "e" : "e+") + i.e) : r < 0 ? (n = "0." + jt(-r - 1) + n, e && (t = e - s) > 0 && (n += jt(t))) : r >= s ? (n += jt(r + 1 - s), e && (t = e - r - 1) > 0 && (n = n + "." + jt(t))) : ((t = r + 1) < s && (n = n.slice(0, t) + "." + n.slice(t)), e && (t = e - s) > 0 && (r + 1 === s && (n += "."), n += jt(t))), n;
}
function Qn(i, a) {
  var e = i[0];
  for (a *= te; e >= 10; e /= 10) a++;
  return a;
}
function yn(i, a, e) {
  if (a > Ul)
    throw oe = !0, e && (i.precision = e), Error(bo);
  return J(new i(En), a, 1, !0);
}
function _t(i, a, e) {
  if (a > $s) throw Error(bo);
  return J(new i(bn), a, e, !0);
}
function Vo(i) {
  var a = i.length - 1, e = a * te + 1;
  if (a = i[a], a) {
    for (; a % 10 == 0; a /= 10) e--;
    for (a = i[0]; a >= 10; a /= 10) e++;
  }
  return e;
}
function jt(i) {
  for (var a = ""; i--; ) a += "0";
  return a;
}
function No(i, a, e, t) {
  var r, n = new i(1), s = Math.ceil(t / te + 4);
  for (oe = !1; ; ) {
    if (e % 2 && (n = n.times(a), _i(n.d, s) && (r = !0)), e = Ie(e / 2), e === 0) {
      e = n.d.length - 1, r && n.d[e] === 0 && ++n.d[e];
      break;
    }
    a = a.times(a), _i(a.d, s);
  }
  return oe = !0, n;
}
function Ci(i) {
  return i.d[i.d.length - 1] & 1;
}
function Oo(i, a, e) {
  for (var t, r, n = new i(a[0]), s = 0; ++s < a.length; ) {
    if (r = new i(a[s]), !r.s) {
      n = r;
      break;
    }
    t = n.cmp(r), (t === e || t === 0 && n.s === e) && (n = r);
  }
  return n;
}
function Ys(i, a) {
  var e, t, r, n, s, o, u, c = 0, l = 0, f = 0, h = i.constructor, d = h.rounding, _ = h.precision;
  if (!i.d || !i.d[0] || i.e > 17)
    return new h(i.d ? i.d[0] ? i.s < 0 ? 0 : 1 / 0 : 1 : i.s ? i.s < 0 ? 0 : i : NaN);
  for (a == null ? (oe = !1, u = _) : u = a, o = new h(0.03125); i.e > -2; )
    i = i.times(o), f += 5;
  for (t = Math.log(Pe(2, f)) / Math.LN10 * 2 + 5 | 0, u += t, e = n = s = new h(1), h.precision = u; ; ) {
    if (n = J(n.times(i), u, 1), e = e.times(++l), o = s.plus(Ve(n, e, u, 1)), Ue(o.d).slice(0, u) === Ue(s.d).slice(0, u)) {
      for (r = f; r--; ) s = J(s.times(s), u, 1);
      if (a == null)
        if (c < 3 && Pr(s.d, u - t, d, c))
          h.precision = u += 10, e = n = o = new h(1), l = 0, c++;
        else
          return J(s, h.precision = _, d, oe = !0);
      else
        return h.precision = _, s;
    }
    s = o;
  }
}
function vt(i, a) {
  var e, t, r, n, s, o, u, c, l, f, h, d = 1, _ = 10, C = i, E = C.d, b = C.constructor, R = b.rounding, p = b.precision;
  if (C.s < 0 || !E || !E[0] || !C.e && E[0] == 1 && E.length == 1)
    return new b(E && !E[0] ? -1 / 0 : C.s != 1 ? NaN : E ? 0 : C);
  if (a == null ? (oe = !1, l = p) : l = a, b.precision = l += _, e = Ue(E), t = e.charAt(0), Math.abs(n = C.e) < 15e14) {
    for (; t < 7 && t != 1 || t == 1 && e.charAt(1) > 3; )
      C = C.times(i), e = Ue(C.d), t = e.charAt(0), d++;
    n = C.e, t > 1 ? (C = new b("0." + e), n++) : C = new b(t + "." + e.slice(1));
  } else
    return c = yn(b, l + 2, p).times(n + ""), C = vt(new b(t + "." + e.slice(1)), l - _).plus(c), b.precision = p, a == null ? J(C, p, R, oe = !0) : C;
  for (f = C, u = s = C = Ve(C.minus(1), C.plus(1), l, 1), h = J(C.times(C), l, 1), r = 3; ; ) {
    if (s = J(s.times(h), l, 1), c = u.plus(Ve(s, new b(r), l, 1)), Ue(c.d).slice(0, l) === Ue(u.d).slice(0, l))
      if (u = u.times(2), n !== 0 && (u = u.plus(yn(b, l + 2, p).times(n + ""))), u = Ve(u, new b(d), l, 1), a == null)
        if (Pr(u.d, l - _, R, o))
          b.precision = l += _, c = s = C = Ve(f.minus(1), f.plus(1), l, 1), h = J(C.times(C), l, 1), r = o = 1;
        else
          return J(u, b.precision = p, R, oe = !0);
      else
        return b.precision = p, u;
    u = c, r += 2;
  }
}
function Mo(i) {
  return String(i.s * i.s / 0);
}
function fn(i, a) {
  var e, t, r;
  for ((e = a.indexOf(".")) > -1 && (a = a.replace(".", "")), (t = a.search(/e/i)) > 0 ? (e < 0 && (e = t), e += +a.slice(t + 1), a = a.substring(0, t)) : e < 0 && (e = a.length), t = 0; a.charCodeAt(t) === 48; t++) ;
  for (r = a.length; a.charCodeAt(r - 1) === 48; --r) ;
  if (a = a.slice(t, r), a) {
    if (r -= t, i.e = e = e - t - 1, i.d = [], t = (e + 1) % te, e < 0 && (t += te), t < r) {
      for (t && i.d.push(+a.slice(0, t)), r -= te; t < r; ) i.d.push(+a.slice(t, t += te));
      a = a.slice(t), t = te - a.length;
    } else
      t -= r;
    for (; t--; ) a += "0";
    i.d.push(+a), oe && (i.e > i.constructor.maxE ? (i.d = null, i.e = NaN) : i.e < i.constructor.minE && (i.e = 0, i.d = [0]));
  } else
    i.e = 0, i.d = [0];
  return i;
}
function Tl(i, a) {
  var e, t, r, n, s, o, u, c, l;
  if (a.indexOf("_") > -1) {
    if (a = a.replace(/(\d)_(?=\d)/g, "$1"), po.test(a)) return fn(i, a);
  } else if (a === "Infinity" || a === "NaN")
    return +a || (i.s = NaN), i.e = NaN, i.d = null, i;
  if (Pl.test(a))
    e = 16, a = a.toLowerCase();
  else if (Ll.test(a))
    e = 2;
  else if (xl.test(a))
    e = 8;
  else
    throw Error(kt + a);
  for (n = a.search(/p/i), n > 0 ? (u = +a.slice(n + 1), a = a.substring(2, n)) : a = a.slice(2), n = a.indexOf("."), s = n >= 0, t = i.constructor, s && (a = a.replace(".", ""), o = a.length, n = o - n, r = No(t, new t(e), n, n * 2)), c = ln(a, e, lt), l = c.length - 1, n = l; c[n] === 0; --n) c.pop();
  return n < 0 ? new t(i.s * 0) : (i.e = Qn(c, l), i.d = c, oe = !1, s && (i = Ve(i, r, o * 4)), u && (i = i.times(Math.abs(u) < 54 ? Pe(2, u) : P.pow(2, u))), oe = !0, i);
}
function Bl(i, a) {
  var e, t = a.d.length;
  if (t < 3)
    return a.isZero() ? a : Er(i, 2, a, a);
  e = 1.4 * Math.sqrt(t), e = e > 16 ? 16 : e | 0, a = a.times(1 / Wn(5, e)), a = Er(i, 2, a, a);
  for (var r, n = new i(5), s = new i(16), o = new i(20); e--; )
    r = a.times(a), a = a.times(n.plus(r.times(s.times(r).minus(o))));
  return a;
}
function Er(i, a, e, t, r) {
  var n, s, o, u, c = i.precision, l = Math.ceil(c / te);
  for (oe = !1, u = e.times(e), o = new i(t); ; ) {
    if (s = Ve(o.times(u), new i(a++ * a++), c, 1), o = r ? t.plus(s) : t.minus(s), t = Ve(s.times(u), new i(a++ * a++), c, 1), s = o.plus(t), s.d[l] !== void 0) {
      for (n = l; s.d[n] === o.d[n] && n--; ) ;
      if (n == -1) break;
    }
    n = o, o = t, t = s, s = n;
  }
  return oe = !0, s.d.length = l + 1, s;
}
function Wn(i, a) {
  for (var e = i; --a; ) e *= i;
  return e;
}
function wo(i, a) {
  var e, t = a.s < 0, r = _t(i, i.precision, 1), n = r.times(0.5);
  if (a = a.abs(), a.lte(n))
    return Ot = t ? 4 : 1, a;
  if (e = a.divToInt(r), e.isZero())
    Ot = t ? 3 : 2;
  else {
    if (a = a.minus(e.times(r)), a.lte(n))
      return Ot = Ci(e) ? t ? 2 : 3 : t ? 4 : 1, a;
    Ot = Ci(e) ? t ? 1 : 4 : t ? 3 : 2;
  }
  return a.minus(r).abs();
}
function Ea(i, a, e, t) {
  var r, n, s, o, u, c, l, f, h, d = i.constructor, _ = e !== void 0;
  if (_ ? (He(e, 1, Gt), t === void 0 ? t = d.rounding : He(t, 0, 8)) : (e = d.precision, t = d.rounding), !i.isFinite())
    l = Mo(i);
  else {
    for (l = bt(i), s = l.indexOf("."), _ ? (r = 2, a == 16 ? e = e * 4 - 3 : a == 8 && (e = e * 3 - 2)) : r = a, s >= 0 && (l = l.replace(".", ""), h = new d(1), h.e = l.length - s, h.d = ln(bt(h), 10, r), h.e = h.d.length), f = ln(l, 10, r), n = u = f.length; f[--u] == 0; ) f.pop();
    if (!f[0])
      l = _ ? "0p+0" : "0";
    else {
      if (s < 0 ? n-- : (i = new d(i), i.d = f, i.e = n, i = Ve(i, h, e, t, 0, r), f = i.d, n = i.e, c = Eo), s = f[e], o = r / 2, c = c || f[e + 1] !== void 0, c = t < 4 ? (s !== void 0 || c) && (t === 0 || t === (i.s < 0 ? 3 : 2)) : s > o || s === o && (t === 4 || c || t === 6 && f[e - 1] & 1 || t === (i.s < 0 ? 8 : 7)), f.length = e, c)
        for (; ++f[--e] > r - 1; )
          f[e] = 0, e || (++n, f.unshift(1));
      for (u = f.length; !f[u - 1]; --u) ;
      for (s = 0, l = ""; s < u; s++) l += Fs.charAt(f[s]);
      if (_) {
        if (u > 1)
          if (a == 16 || a == 8) {
            for (s = a == 16 ? 4 : 3, --u; u % s; u++) l += "0";
            for (f = ln(l, r, a), u = f.length; !f[u - 1]; --u) ;
            for (s = 1, l = "1."; s < u; s++) l += Fs.charAt(f[s]);
          } else
            l = l.charAt(0) + "." + l.slice(1);
        l = l + (n < 0 ? "p" : "p+") + n;
      } else if (n < 0) {
        for (; ++n; ) l = "0" + l;
        l = "0." + l;
      } else if (++n > u) for (n -= u; n--; ) l += "0";
      else n < u && (l = l.slice(0, n) + "." + l.slice(n));
    }
    l = (a == 16 ? "0x" : a == 2 ? "0b" : a == 8 ? "0o" : "") + l;
  }
  return i.s < 0 ? "-" + l : l;
}
function _i(i, a) {
  if (i.length > a)
    return i.length = a, !0;
}
function Il(i) {
  return new this(i).abs();
}
function Fl(i) {
  return new this(i).acos();
}
function kl(i) {
  return new this(i).acosh();
}
function $l(i, a) {
  return new this(i).plus(a);
}
function Yl(i) {
  return new this(i).asin();
}
function Hl(i) {
  return new this(i).asinh();
}
function Gl(i) {
  return new this(i).atan();
}
function Ql(i) {
  return new this(i).atanh();
}
function Wl(i, a) {
  i = new this(i), a = new this(a);
  var e, t = this.precision, r = this.rounding, n = t + 4;
  return !i.s || !a.s ? e = new this(NaN) : !i.d && !a.d ? (e = _t(this, n, 1).times(a.s > 0 ? 0.25 : 0.75), e.s = i.s) : !a.d || i.isZero() ? (e = a.s < 0 ? _t(this, t, r) : new this(0), e.s = i.s) : !i.d || a.isZero() ? (e = _t(this, n, 1).times(0.5), e.s = i.s) : a.s < 0 ? (this.precision = n, this.rounding = 1, e = this.atan(Ve(i, a, n, 1)), a = _t(this, n, 1), this.precision = t, this.rounding = r, e = i.s < 0 ? e.minus(a) : e.plus(a)) : e = this.atan(Ve(i, a, n, 1)), e;
}
function ql(i) {
  return new this(i).cbrt();
}
function Kl(i) {
  return J(i = new this(i), i.e + 1, 2);
}
function Xl(i, a, e) {
  return new this(i).clamp(a, e);
}
function Zl(i) {
  if (!i || typeof i != "object") throw Error(Gn + "Object expected");
  var a, e, t, r = i.defaults === !0, n = [
    "precision",
    1,
    Gt,
    "rounding",
    0,
    8,
    "toExpNeg",
    -lr,
    0,
    "toExpPos",
    0,
    lr,
    "maxE",
    0,
    lr,
    "minE",
    -lr,
    0,
    "modulo",
    0,
    9
  ];
  for (a = 0; a < n.length; a += 3)
    if (e = n[a], r && (this[e] = ks[e]), (t = i[e]) !== void 0)
      if (Ie(t) === t && t >= n[a + 1] && t <= n[a + 2]) this[e] = t;
      else throw Error(kt + e + ": " + t);
  if (e = "crypto", r && (this[e] = ks[e]), (t = i[e]) !== void 0)
    if (t === !0 || t === !1 || t === 0 || t === 1)
      if (t)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[e] = !0;
        else
          throw Error(yo);
      else
        this[e] = !1;
    else
      throw Error(kt + e + ": " + t);
  return this;
}
function zl(i) {
  return new this(i).cos();
}
function Jl(i) {
  return new this(i).cosh();
}
function So(i) {
  var a, e, t;
  function r(n) {
    var s, o, u, c = this;
    if (!(c instanceof r)) return new r(n);
    if (c.constructor = r, Ai(n)) {
      c.s = n.s, oe ? !n.d || n.e > r.maxE ? (c.e = NaN, c.d = null) : n.e < r.minE ? (c.e = 0, c.d = [0]) : (c.e = n.e, c.d = n.d.slice()) : (c.e = n.e, c.d = n.d ? n.d.slice() : n.d);
      return;
    }
    if (u = typeof n, u === "number") {
      if (n === 0) {
        c.s = 1 / n < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (n < 0 ? (n = -n, c.s = -1) : c.s = 1, n === ~~n && n < 1e7) {
        for (s = 0, o = n; o >= 10; o /= 10) s++;
        oe ? s > r.maxE ? (c.e = NaN, c.d = null) : s < r.minE ? (c.e = 0, c.d = [0]) : (c.e = s, c.d = [n]) : (c.e = s, c.d = [n]);
        return;
      }
      if (n * 0 !== 0) {
        n || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return fn(c, n.toString());
    }
    if (u === "string")
      return (o = n.charCodeAt(0)) === 45 ? (n = n.slice(1), c.s = -1) : (o === 43 && (n = n.slice(1)), c.s = 1), po.test(n) ? fn(c, n) : Tl(c, n);
    if (u === "bigint")
      return n < 0 ? (n = -n, c.s = -1) : c.s = 1, fn(c, n.toString());
    throw Error(kt + n);
  }
  if (r.prototype = I, r.ROUND_UP = 0, r.ROUND_DOWN = 1, r.ROUND_CEIL = 2, r.ROUND_FLOOR = 3, r.ROUND_HALF_UP = 4, r.ROUND_HALF_DOWN = 5, r.ROUND_HALF_EVEN = 6, r.ROUND_HALF_CEIL = 7, r.ROUND_HALF_FLOOR = 8, r.EUCLID = 9, r.config = r.set = Zl, r.clone = So, r.isDecimal = Ai, r.abs = Il, r.acos = Fl, r.acosh = kl, r.add = $l, r.asin = Yl, r.asinh = Hl, r.atan = Gl, r.atanh = Ql, r.atan2 = Wl, r.cbrt = ql, r.ceil = Kl, r.clamp = Xl, r.cos = zl, r.cosh = Jl, r.div = ef, r.exp = tf, r.floor = rf, r.hypot = nf, r.ln = sf, r.log = af, r.log10 = uf, r.log2 = of, r.max = cf, r.min = lf, r.mod = ff, r.mul = hf, r.pow = mf, r.random = gf, r.round = df, r.sign = Cf, r.sin = _f, r.sinh = Af, r.sqrt = Ef, r.sub = bf, r.sum = yf, r.tan = Rf, r.tanh = pf, r.trunc = Vf, i === void 0 && (i = {}), i && i.defaults !== !0)
    for (t = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], a = 0; a < t.length; ) i.hasOwnProperty(e = t[a++]) || (i[e] = this[e]);
  return r.config(i), r;
}
function ef(i, a) {
  return new this(i).div(a);
}
function tf(i) {
  return new this(i).exp();
}
function rf(i) {
  return J(i = new this(i), i.e + 1, 3);
}
function nf() {
  var i, a, e = new this(0);
  for (oe = !1, i = 0; i < arguments.length; )
    if (a = new this(arguments[i++]), a.d)
      e.d && (e = e.plus(a.times(a)));
    else {
      if (a.s)
        return oe = !0, new this(1 / 0);
      e = a;
    }
  return oe = !0, e.sqrt();
}
function Ai(i) {
  return i instanceof P || i && i.toStringTag === Ro || !1;
}
function sf(i) {
  return new this(i).ln();
}
function af(i, a) {
  return new this(i).log(a);
}
function of(i) {
  return new this(i).log(2);
}
function uf(i) {
  return new this(i).log(10);
}
function cf() {
  return Oo(this, arguments, -1);
}
function lf() {
  return Oo(this, arguments, 1);
}
function ff(i, a) {
  return new this(i).mod(a);
}
function hf(i, a) {
  return new this(i).mul(a);
}
function mf(i, a) {
  return new this(i).pow(a);
}
function gf(i) {
  var a, e, t, r, n = 0, s = new this(1), o = [];
  if (i === void 0 ? i = this.precision : He(i, 1, Gt), t = Math.ceil(i / te), this.crypto)
    if (crypto.getRandomValues)
      for (a = crypto.getRandomValues(new Uint32Array(t)); n < t; )
        r = a[n], r >= 429e7 ? a[n] = crypto.getRandomValues(new Uint32Array(1))[0] : o[n++] = r % 1e7;
    else if (crypto.randomBytes) {
      for (a = crypto.randomBytes(t *= 4); n < t; )
        r = a[n] + (a[n + 1] << 8) + (a[n + 2] << 16) + ((a[n + 3] & 127) << 24), r >= 214e7 ? crypto.randomBytes(4).copy(a, n) : (o.push(r % 1e7), n += 4);
      n = t / 4;
    } else
      throw Error(yo);
  else for (; n < t; ) o[n++] = Math.random() * 1e7 | 0;
  for (t = o[--n], i %= te, t && i && (r = Pe(10, te - i), o[n] = (t / r | 0) * r); o[n] === 0; n--) o.pop();
  if (n < 0)
    e = 0, o = [0];
  else {
    for (e = -1; o[0] === 0; e -= te) o.shift();
    for (t = 1, r = o[0]; r >= 10; r /= 10) t++;
    t < te && (e -= te - t);
  }
  return s.e = e, s.d = o, s;
}
function df(i) {
  return J(i = new this(i), i.e + 1, this.rounding);
}
function Cf(i) {
  return i = new this(i), i.d ? i.d[0] ? i.s : 0 * i.s : i.s || NaN;
}
function _f(i) {
  return new this(i).sin();
}
function Af(i) {
  return new this(i).sinh();
}
function Ef(i) {
  return new this(i).sqrt();
}
function bf(i, a) {
  return new this(i).sub(a);
}
function yf() {
  var i = 0, a = arguments, e = new this(a[i]);
  for (oe = !1; e.s && ++i < a.length; ) e = e.plus(a[i]);
  return oe = !0, J(e, this.precision, this.rounding);
}
function Rf(i) {
  return new this(i).tan();
}
function pf(i) {
  return new this(i).tanh();
}
function Vf(i) {
  return J(i = new this(i), i.e + 1, 1);
}
I[Symbol.for("nodejs.util.inspect.custom")] = I.toString;
I[Symbol.toStringTag] = "Decimal";
var P = I.constructor = So(ks);
En = new P(En);
bn = new P(bn);
function Nf(i, a) {
  const e = i + a;
  return Number.isSafeInteger(e) ? e : new P(i).add(a).toNumber();
}
function Of(i, a) {
  const e = i - a;
  return Number.isSafeInteger(e) ? e : new P(i).sub(a).toNumber();
}
function Or(i, a) {
  const e = i * a;
  return Number.isSafeInteger(e) ? e : new P(i).mul(a).toNumber();
}
function Mf(i, a) {
  const e = i / a;
  return Number.isSafeInteger(e) ? e : new P(i).div(a).toNumber();
}
function Bt(i, a) {
  const e = 10 ** Math.trunc(a), t = qn(i, e);
  return Math.round(Or(i, e) + t) / e;
}
function Ke(i, a) {
  const e = 10 ** Math.trunc(a), t = qn(i, e);
  return Math.floor(Or(i, e) + t) / e;
}
function Ye(i, a) {
  const e = 10 ** Math.trunc(a), t = qn(i, e);
  return Math.ceil(Or(i, e) - t) / e;
}
function qn(i, a) {
  return Number.EPSILON * Math.max(1, Math.abs(Or(i, a)));
}
function Ei(i, a) {
  return i - a * Math.floor(i / a);
}
function wf(i, a) {
  return i ** a;
}
function Sf(i) {
  return Math.sqrt(i);
}
function bi(i, a) {
  return i === a;
}
function Df(i, a) {
  return i > a;
}
function Lf(i, a) {
  return i >= a;
}
function Pf(i, a) {
  return i < a;
}
function xf(i, a) {
  return i <= a;
}
function yi(i, a = 15) {
  return Math.floor(Math.abs(i)).toString().length >= a ? i : Number.parseFloat(i.toPrecision(a));
}
function jf(i, a, e = Number.EPSILON) {
  return Math.abs(i - a) < e;
}
function ba(i, a = 12, e = 1e-10) {
  const t = yi(i, a);
  return jf(i, t, e) ? t : yi(i);
}
function Uf(i) {
  return i - Math.trunc(i);
}
const $n = class $n extends Ht {
  static create() {
    return this._instance = this._instance || new $n(0), this._instance;
  }
  isNull() {
    return !0;
  }
  plus(a) {
    return y.create(0).plus(a);
  }
  minus(a) {
    return y.create(0).minus(a);
  }
  multiply(a) {
    return y.create(0).multiply(a);
  }
  divided(a) {
    return y.create(0).divided(a);
  }
  mod(a) {
    return y.create(0).mod(a);
  }
  compare(a, e) {
    return a.isString() ? j.create("").compare(a, e) : a.isBoolean() ? T.create(!1).compare(a, e) : y.create(0).compare(a, e);
  }
  concatenateFront(a) {
    return a.isArray() ? a.concatenateBack(j.create("")) : j.create(this.concatenate(a.getValue(), ct.FRONT));
  }
  concatenateBack(a) {
    return a.isArray() ? a.concatenateFront(j.create("")) : j.create(this.concatenate(a.getValue(), ct.BACK));
  }
  plusBy(a) {
    return y.create(0).plusBy(a);
  }
  minusBy(a) {
    return y.create(0).minusBy(a);
  }
  multiplyBy(a) {
    return y.create(0).multiplyBy(a);
  }
  dividedBy(a) {
    return y.create(0).dividedBy(a);
  }
  compareBy(a, e) {
    return typeof a == "string" ? j.create("").compareBy(a, e) : typeof a == "boolean" ? T.create(!1).compareBy(a, e) : y.create(0).compareBy(a, e);
  }
  pow(a) {
    return y.create(0).pow(a);
  }
  sqrt() {
    return y.create(0).sqrt();
  }
  cbrt() {
    return y.create(0).cbrt();
  }
  cos() {
    return y.create(0).cos();
  }
  cosh() {
    return y.create(0).cosh();
  }
  acos() {
    return y.create(0).acos();
  }
  acosh() {
    return y.create(0).acosh();
  }
  sin() {
    return y.create(0).sin();
  }
  sinh() {
    return y.create(0).sinh();
  }
  asin() {
    return y.create(0).asin();
  }
  asinh() {
    return y.create(0).asinh();
  }
  tan() {
    return y.create(0).tan();
  }
  tanh() {
    return y.create(0).tanh();
  }
  atan() {
    return y.create(0).atan();
  }
  atan2(a) {
    return y.create(0).atan2(a);
  }
  atanh() {
    return y.create(0).atanh();
  }
  log() {
    return g.create(m.NUM);
  }
  log10() {
    return g.create(m.NUM);
  }
  exp() {
    return y.create(0).exp();
  }
  abs() {
    return y.create(0).abs();
  }
  round(a) {
    return y.create(0).round(a);
  }
  floor(a) {
    return y.create(0).floor(a);
  }
  ceil(a) {
    return y.create(0).ceil(a);
  }
  convertToNumberObjectValue() {
    return y.create(0);
  }
  convertToBooleanObjectValue() {
    return T.create(!1);
  }
};
A($n, "_instance");
let ce = $n;
const Xt = class Xt extends Ht {
  constructor(e) {
    super(e);
    A(this, "_value", !1);
    this._value = e;
  }
  static create(e) {
    return e ? (this._instanceTrue = this._instanceTrue || new Xt(!0), this._instanceTrue) : (this._instanceFalse = this._instanceFalse || new Xt(!1), this._instanceFalse);
  }
  getValue() {
    return this._value;
  }
  isBoolean() {
    return !0;
  }
  getNegative() {
    const e = this.getValue();
    let t = 0;
    return e && (t = 1), y.create(-t);
  }
  getReciprocal() {
    return this.getValue() ? y.create(1) : g.create(m.DIV_BY_ZERO);
  }
  plus(e) {
    return this._convertToNumber().plus(e);
  }
  minus(e) {
    return this._convertToNumber().minus(e);
  }
  multiply(e) {
    return this._convertToNumber().multiply(e);
  }
  divided(e) {
    return this._convertToNumber().divided(e);
  }
  mod(e) {
    return this._convertToNumber().mod(e);
  }
  compare(e, t) {
    return e.isArray() ? e.compare(this, Aa(t)) : e.isNull() ? this._convertToNumber().compare(e, t) : this.compareBy(e.getValue(), t);
  }
  compareBy(e, t) {
    let r = !1;
    if (typeof e == "string" || typeof e == "number")
      r = this._compareString(t);
    else if (typeof e == "boolean") {
      const n = y.create(e ? 1 : 0);
      return this._convertToNumber().compare(n, t);
    }
    return Xt.create(r);
  }
  _compareString(e) {
    switch (e) {
      case F.GREATER_THAN:
      case F.GREATER_THAN_OR_EQUAL:
        return !0;
      case F.EQUALS:
      case F.LESS_THAN:
      case F.LESS_THAN_OR_EQUAL:
      case F.NOT_EQUAL:
        return !1;
    }
  }
  concatenateFront(e) {
    return this._convertToNumber().concatenateFront(e);
  }
  concatenateBack(e) {
    return this._convertToNumber().concatenateBack(e);
  }
  _convertToNumber() {
    const e = this.getValue();
    let t = 0;
    return e && (t = 1), y.create(t);
  }
  pow(e) {
    return this._convertToNumber().pow(e);
  }
  sqrt() {
    return this._convertToNumber().sqrt();
  }
  cbrt() {
    return this._convertToNumber().cbrt();
  }
  cos() {
    return this._convertToNumber().cos();
  }
  cosh() {
    return this._convertToNumber().cosh();
  }
  acos() {
    return this._convertToNumber().acos();
  }
  acosh() {
    return this._convertToNumber().acosh();
  }
  sin() {
    return this._convertToNumber().sin();
  }
  sinh() {
    return this._convertToNumber().sinh();
  }
  asin() {
    return this._convertToNumber().asin();
  }
  asinh() {
    return this._convertToNumber().asinh();
  }
  tan() {
    return this._convertToNumber().tan();
  }
  tanh() {
    return this._convertToNumber().tanh();
  }
  atan() {
    return this._convertToNumber().atan();
  }
  atan2(e) {
    return this._convertToNumber().atan2(e);
  }
  atanh() {
    return this._convertToNumber().atanh();
  }
  log() {
    return this._convertToNumber().log();
  }
  log10() {
    return this._convertToNumber().log10();
  }
  exp() {
    return this._convertToNumber().exp();
  }
  abs() {
    return this._convertToNumber().abs();
  }
  round(e) {
    return this._convertToNumber().round(e);
  }
  floor(e) {
    return this._convertToNumber().floor(e);
  }
  ceil(e) {
    return this._convertToNumber().ceil(e);
  }
  convertToNumberObjectValue() {
    return xr(this.getValue());
  }
  convertToBooleanObjectValue() {
    return this;
  }
};
A(Xt, "_instanceTrue"), A(Xt, "_instanceFalse");
let T = Xt;
class y extends Ht {
  constructor(e) {
    super(e);
    A(this, "_value", 0);
    this._value = Number(e);
  }
  static create(e, t = "") {
    const r = new y(e);
    return t && r.setPattern(t), r;
  }
  getValue() {
    return this._value;
  }
  setValue(e) {
    this._value = e;
  }
  isNumber() {
    return !0;
  }
  getNegative() {
    return y.create(0).minus(this);
  }
  getReciprocal() {
    return y.create(1).divided(this);
  }
  plus(e) {
    if (e.isArray())
      return e.plus(this);
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.plusBy(t.getValue());
    if (r.isError())
      return r;
    const n = Zr(this.getPattern(), t.getPattern(), X.PLUS);
    return r = y.create(Number(r.getValue()), n), r;
  }
  equalZero() {
    return this._value === 0;
  }
  minus(e) {
    if (e.isArray()) {
      const s = e.getNegative();
      return s.isError() ? s : s.plus(this);
    }
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.minusBy(t.getValue());
    if (r.isError())
      return r;
    const n = Zr(this.getPattern(), t.getPattern(), X.MINUS);
    return r = y.create(Number(r.getValue()), n), r;
  }
  multiply(e) {
    if (e.isArray())
      return e.multiply(this);
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.multiplyBy(t.getValue());
    if (r.isError())
      return r;
    const n = Zr(this.getPattern(), t.getPattern(), X.MULTIPLY);
    return r = y.create(Number(r.getValue()), n), r;
  }
  divided(e) {
    if (e.isArray()) {
      const s = e.getReciprocal();
      return s.isError() ? s : s.multiply(this);
    }
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.dividedBy(t.getValue());
    if (r.isError())
      return r;
    const n = Zr(this.getPattern(), t.getPattern(), X.DIVIDED);
    return r = y.create(Number(r.getValue()), n), r;
  }
  mod(e) {
    if (e.isArray())
      return e.modInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (e.isNull())
      return g.create(m.DIV_BY_ZERO);
    if (typeof r == "string")
      return g.create(m.VALUE);
    if (typeof r == "number") {
      if (r === 0)
        return g.create(m.DIV_BY_ZERO);
      if (!Number.isFinite(t) || !Number.isFinite(r) || Math.abs(r) * 11259e8 <= Math.abs(t))
        return g.create(m.NUM);
      const n = Ei(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
    }
    if (typeof r == "boolean") {
      const n = r ? 1 : 0;
      return n === 0 ? g.create(m.DIV_BY_ZERO) : y.create(Ei(t, n));
    }
    return this;
  }
  concatenateFront(e) {
    return e.isArray() ? e.concatenateBack(this) : j.create(this.concatenate(e.getValue(), ct.FRONT));
  }
  concatenateBack(e) {
    return e.isArray() ? e.concatenateFront(this) : j.create(this.concatenate(e.getValue(), ct.BACK));
  }
  compare(e, t) {
    return e.isArray() ? e.compare(this, Aa(t)) : this.compareBy(e.getValue(), t);
  }
  plusBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(m.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(m.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(m.NUM);
    const n = Nf(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
  }
  minusBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(m.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(m.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(m.NUM);
    const n = Of(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
  }
  multiplyBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(m.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(m.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(m.NUM);
    const n = Or(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
  }
  dividedBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(m.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(m.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(m.NUM);
    if (r === 0)
      return g.create(m.DIV_BY_ZERO);
    const n = Mf(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
  }
  compareBy(e, t) {
    const r = this.getValue();
    let n = !1;
    return typeof e == "string" ? n = this._compareString(t) : typeof e == "number" ? n = this._compareNumber(r, e, t) : typeof e == "boolean" && (n = this._compareBoolean(t)), T.create(n);
  }
  _compareString(e) {
    switch (e) {
      case F.EQUALS:
      case F.GREATER_THAN:
      case F.GREATER_THAN_OR_EQUAL:
        return !1;
      case F.LESS_THAN:
      case F.LESS_THAN_OR_EQUAL:
      case F.NOT_EQUAL:
        return !0;
    }
  }
  _compareNumber(e, t, r) {
    return !Number.isFinite(e) || !Number.isFinite(t) ? this._compareInfinity(e, t, r) : this._compareFiniteNumber(e, t, r);
  }
  _compareFiniteNumber(e, t, r) {
    switch (r) {
      case F.EQUALS:
        return bi(e, t);
      case F.GREATER_THAN:
        return Df(e, t);
      case F.GREATER_THAN_OR_EQUAL:
        return Lf(e, t);
      case F.LESS_THAN:
        return Pf(e, t);
      case F.LESS_THAN_OR_EQUAL:
        return xf(e, t);
      case F.NOT_EQUAL:
        return !bi(e, t);
    }
  }
  _compareBoolean(e) {
    switch (e) {
      case F.EQUALS:
      case F.GREATER_THAN:
      case F.GREATER_THAN_OR_EQUAL:
        return !1;
      case F.LESS_THAN:
      case F.LESS_THAN_OR_EQUAL:
      case F.NOT_EQUAL:
        return !0;
    }
  }
  pow(e) {
    if (e.isArray())
      return e.powInverse(this);
    if (this.isError())
      return this;
    const t = this.getValue();
    let r = e;
    if (e.isString() && (r = e.convertToNumberObjectValue()), r.isError())
      return r;
    const n = +r.getValue();
    if (Number.isNaN(n))
      return g.create(m.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(n))
      return g.create(m.NUM);
    if (t === 0)
      return n < 0 ? g.create(m.DIV_BY_ZERO) : n === 0 ? g.create(m.NUM) : y.create(0);
    const s = wf(t, n);
    return Number.isFinite(s) ? y.create(s) : g.create(m.NUM);
  }
  sqrt() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Sf(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  cbrt() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.cbrt(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  cos() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.cos(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  cosh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.cosh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  acos() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.acos(e);
    return Number.isNaN(t) ? g.create(m.NUM) : y.create(t);
  }
  acosh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.acosh(e);
    return Number.isNaN(t) ? g.create(m.NUM) : y.create(t);
  }
  sin() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.sin(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  sinh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.sinh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  asin() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.asin(e);
    return Number.isNaN(t) ? g.create(m.NUM) : y.create(t);
  }
  asinh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.asinh(e);
    return Number.isNaN(t) ? g.create(m.NUM) : y.create(t);
  }
  tan() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.tan(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  tanh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.tanh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  atan() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.atan(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  atan2(e) {
    if (e.isArray())
      return e.atan2Inverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(m.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(m.NUM);
      if (t === 0 && r === 0)
        return g.create(m.DIV_BY_ZERO);
      const n = Math.atan2(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
    }
    return typeof r == "boolean" ? y.create(Math.atan2(t, r ? 1 : 0)) : this;
  }
  atanh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.atanh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  log() {
    const e = this.getValue();
    if (typeof e == "number" && e <= 0 || !Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.log(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  log10() {
    const e = this.getValue();
    if (typeof e == "number" && e <= 0 || !Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.log10(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  exp() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.exp(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  abs() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(m.NUM);
    const t = Math.abs(e);
    return Number.isFinite(t) ? y.create(t) : g.create(m.NUM);
  }
  round(e) {
    if (e.isArray())
      return e.roundInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(m.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(m.NUM);
      const n = t < 0 ? -Bt(Math.abs(t), r) : Bt(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
    }
    return typeof r == "boolean" ? y.create(Bt(t, r ? 1 : 0)) : this;
  }
  floor(e) {
    if (e.isArray())
      return e.floorInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(m.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(m.NUM);
      const n = t < 0 ? -Ke(Math.abs(t), r) : Ke(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
    }
    return typeof r == "boolean" ? y.create(Ke(t, r ? 1 : 0)) : this;
  }
  ceil(e) {
    if (e.isArray())
      return e.ceilInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(m.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(m.NUM);
      const n = t < 0 ? -Ye(Math.abs(t), r) : Ye(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(m.NUM);
    }
    return typeof r == "boolean" ? y.create(Ye(t, r ? 1 : 0)) : this;
  }
  convertToNumberObjectValue() {
    return this;
  }
  convertToBooleanObjectValue() {
    return Kn(!0);
  }
  _compareInfinity(e, t, r) {
    let n = !1;
    switch (r) {
      case F.EQUALS:
        n = e === t;
        break;
      case F.GREATER_THAN:
        n = e > t;
        break;
      case F.GREATER_THAN_OR_EQUAL:
        n = e >= t;
        break;
      case F.LESS_THAN:
        n = e < t;
        break;
      case F.LESS_THAN_OR_EQUAL:
        n = e <= t;
        break;
      case F.NOT_EQUAL:
        n = e !== t;
        break;
    }
    return n;
  }
}
const vf = 1e5, Hs = new wt(vf);
class j extends Ht {
  constructor(e) {
    super(e);
    A(this, "_value");
    A(this, "_isHyperlink", !1);
    A(this, "_hyperlinkUrl", "");
    this._value = e;
  }
  static create(e, t) {
    var s;
    const r = Hs.get(e);
    if (r && t && this.checkCacheByOptions(r, t))
      return r;
    const n = new j(e);
    return t != null && t.isHyperlink && (n._isHyperlink = t.isHyperlink, n._hyperlinkUrl = (s = t.hyperlinkUrl) != null ? s : ""), Hs.set(e, n), n;
  }
  static checkCacheByOptions(e, t) {
    return !(e.isHyperlink() !== t.isHyperlink || e.getHyperlinkUrl() !== t.hyperlinkUrl);
  }
  getValue() {
    return this._value;
  }
  isString() {
    return !0;
  }
  isHyperlink() {
    return this._isHyperlink;
  }
  getHyperlinkUrl() {
    return this._hyperlinkUrl;
  }
  concatenateFront(e) {
    return e.isArray() ? e.concatenateBack(this) : j.create(this.concatenate(e.getValue(), ct.FRONT));
  }
  concatenateBack(e) {
    return e.isArray() ? e.concatenateFront(this) : j.create(this.concatenate(e.getValue(), ct.BACK));
  }
  plus(e) {
    return this.convertToNumberObjectValue().plus(e);
  }
  minus(e) {
    return this.convertToNumberObjectValue().minus(e);
  }
  multiply(e) {
    return this.convertToNumberObjectValue().multiply(e);
  }
  divided(e) {
    return this.convertToNumberObjectValue().divided(e);
  }
  compare(e, t, r) {
    return e.isArray() ? e.compare(this, Aa(t), r) : this.compareBy(e.getValue(), t, r);
  }
  compareBy(e, t, r = !1) {
    let n = this.getValue(), s = !1;
    if (typeof e == "string") {
      let o = e;
      if (r || (n = n.toLocaleLowerCase(), o = o.toLocaleLowerCase()), wl(o))
        return this._checkWildcard(o, t);
      s = this._compareString(n, o, t);
    } else typeof e == "number" ? s = this._compareNumber(t) : typeof e == "boolean" && (s = this._compareBoolean(t));
    return T.create(s);
  }
  _compareString(e, t, r) {
    switch (r) {
      case F.EQUALS:
        return e === t;
      case F.GREATER_THAN:
        return e > t;
      case F.GREATER_THAN_OR_EQUAL:
        return e >= t;
      case F.LESS_THAN:
        return e < t;
      case F.LESS_THAN_OR_EQUAL:
        return e <= t;
      case F.NOT_EQUAL:
        return e !== t;
    }
  }
  _compareNumber(e) {
    switch (e) {
      case F.NOT_EQUAL:
      case F.GREATER_THAN:
      case F.GREATER_THAN_OR_EQUAL:
        return !0;
      case F.EQUALS:
      case F.LESS_THAN:
      case F.LESS_THAN_OR_EQUAL:
        return !1;
    }
  }
  _compareBoolean(e) {
    switch (e) {
      case F.EQUALS:
      case F.GREATER_THAN:
      case F.GREATER_THAN_OR_EQUAL:
        return !1;
      case F.LESS_THAN:
      case F.LESS_THAN_OR_EQUAL:
      case F.NOT_EQUAL:
        return !0;
    }
  }
  convertToNumberObjectValue() {
    const e = this.getValue(), t = nc(e);
    return t && t.z ? xr(t.v, t.z) : xr(e);
  }
  convertToBooleanObjectValue() {
    return T.create(!0);
  }
  _checkWildcard(e, t) {
    const r = this.getValue().toLocaleLowerCase(), n = Sl(r, e, t);
    return T.create(n);
  }
}
function Kn(i) {
  if (typeof i == "boolean")
    return T.create(i);
  let a = !1;
  if (typeof i == "string") {
    const e = i.toLocaleUpperCase();
    e === rr.TRUE ? a = !0 : e === rr.FALSE && (a = !1);
  } else
    i === 1 ? a = !0 : a = !1;
  return T.create(a);
}
function Tf(i) {
  let a = i.toString();
  return a.charAt(0) === '"' && a.charAt(a.length - 1) === '"' && (a = a.slice(1, -1), a = a.replace(/""/g, '"')), j.create(a);
}
function xr(i, a = "") {
  if (typeof i == "boolean") {
    let e = 0;
    return i && (e = 1), y.create(e, a);
  } else {
    if (typeof i == "number")
      return Number.isFinite(i) ? y.create(i, a) : g.create(m.NUM);
    if (W(i))
      return y.create(Number(i), a);
  }
  return g.create(m.VALUE);
}
function Bf(i) {
  return "";
}
function Do(i = [], a = !1) {
  const e = [];
  for (let t = 0; t < i.length; t++) {
    const r = i[t];
    e[t] == null && (e[t] = []);
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      e[t][n] = Mt.create(s, a);
    }
  }
  return e;
}
function If(i = []) {
  const a = [];
  for (let e = 0; e < i.length; e++) {
    const t = i[e];
    a[e] == null && (a[e] = []);
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      n == null ? a[e][r] = null : n.isError() ? a[e][r] = n.getErrorType() : a[e][r] = n.getValue();
    }
  }
  return a;
}
class q extends Ht {
  constructor(e) {
    super(typeof e == "string" ? e : Bf());
    A(this, "_values", []);
    A(this, "_rowCount", -1);
    A(this, "_columnCount", -1);
    A(this, "_unitId", "");
    A(this, "_sheetId", "");
    A(this, "_currentRow", -1);
    A(this, "_currentColumn", -1);
    A(this, "_sliceCache", /* @__PURE__ */ new Map());
    A(this, "_flattenCache");
    /**
     * The default value of the array, null values in comparison results support setting to false
     */
    A(this, "_defaultValue", null);
    A(this, "_flattenPosition");
    this._values = this._formatValue(e);
  }
  /**
   * Create an array value object based on the string or IArrayValueObject data.
   * @param rawValue
   * @returns
   */
  static create(e) {
    return new q(e);
  }
  /**
   * Create an array value object based on the array data.
   * @param array
   * @returns
   */
  static createByArray(e) {
    const r = {
      calculateValueList: Do(e),
      rowCount: e.length,
      columnCount: e[0].length || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    };
    return new q(r);
  }
  dispose() {
    this._values = [], this._defaultValue = null, this._flattenPosition = null, this._clearCache();
  }
  clone() {
    return this.map((e) => e);
  }
  getRowCount() {
    return this._rowCount;
  }
  setRowCount(e) {
    this._rowCount = e;
  }
  getColumnCount() {
    return this._columnCount;
  }
  setColumnCount(e) {
    this._columnCount = e;
  }
  setCurrent(e, t) {
    this._currentRow = e, this._currentColumn = t;
  }
  setUnitId(e) {
    this._unitId = e;
  }
  getUnitId() {
    return this._unitId;
  }
  setSheetId(e) {
    this._sheetId = e;
  }
  getSheetId() {
    return this._sheetId;
  }
  getCurrentRow() {
    return this._currentRow;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  getArrayValue() {
    return this._values;
  }
  setArrayValue(e) {
    this._clearCache(), this._values = e;
  }
  isArray() {
    return !0;
  }
  setDefaultValue(e) {
    this._defaultValue = e;
  }
  get(e, t) {
    var r;
    return ((r = this._values[e]) == null ? void 0 : r[t]) || this._defaultValue;
  }
  getRealValue(e, t) {
    const r = this._values[e];
    if (r == null)
      return null;
    const n = r[t];
    return n == null ? null : n;
  }
  getValueOrDefault(e, t) {
    return this.get(e, t) || this._defaultValue;
  }
  set(e, t, r) {
    if (e >= this._rowCount || t >= this._columnCount)
      throw new Error("Exceeding array bounds.");
    this._clearCache(), this._values[e][t] = r;
  }
  getRangePosition() {
    const t = this.getRowCount(), r = 0, n = this.getColumnCount();
    return {
      startRow: 0,
      endRow: t - 1,
      startColumn: r,
      endColumn: n - 1
    };
  }
  iterator(e) {
    var u;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = this.getArrayValue();
    for (let c = t; c <= r; c++)
      for (let l = n; l <= s; l++)
        if (e(((u = o[c]) == null ? void 0 : u[l]) || this._defaultValue, c, l) === !1)
          return;
  }
  iteratorReverse(e) {
    var u;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = this.getArrayValue();
    for (let c = r; c >= t; c--)
      for (let l = s; l >= n; l--)
        if (e(((u = o[c]) == null ? void 0 : u[l]) || this._defaultValue, c, l) === !1)
          return;
  }
  getLastTruePosition() {
    let e;
    return this.iteratorReverse((t, r, n) => {
      if (t != null && t.isBoolean() && t.getValue() === !0)
        return e = {
          row: r,
          column: n
        }, !1;
    }), e;
  }
  getFirstTruePosition() {
    let e;
    return this.iterator((t, r, n) => {
      if (t != null && t.isBoolean() && t.getValue() === !0)
        return e = {
          row: r,
          column: n
        }, !1;
    }), e;
  }
  getFirstCell() {
    const { startRow: e, startColumn: t } = this.getRangePosition();
    return this.get(e, t) || this._defaultValue || ce.create();
  }
  getLastCell() {
    const { endRow: e, endColumn: t } = this.getRangePosition();
    return this.get(e, t) || this._defaultValue || ce.create();
  }
  /**
   * Referring to matrix calculations,
   * extract the matching values from a true/false matrix based on parameters and store them in a two-dimensional array.
   * implement x[x<10]
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @param takeArray
   */
  pick(e) {
    const t = this.pickRaw(e);
    return this._createNewArray(t, 1, t[0].length);
  }
  pickRaw(e) {
    const t = e.getRowCount(), r = e.getColumnCount();
    if (t !== this._rowCount || r !== this._columnCount)
      return [[ce.create()]];
    const n = [];
    n[0] = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.get(s, o);
        if (!(u == null || u.isError()) && u.getValue() === !0) {
          const c = this.get(s, o);
          n[0].push(c);
        }
      }
    return n;
  }
  /**
   * Flatten a 2D array.
   * https://numpy.org/doc/stable/reference/generated/numpy.chararray.flatten.html#numpy.chararray.flatten
   */
  flatten() {
    if (this._flattenCache != null)
      return this._flattenCache;
    const e = [];
    e[0] = [];
    for (let r = 0; r < this._rowCount; r++)
      for (let n = 0; n < this._columnCount; n++) {
        const s = this.get(r, n);
        e[0].push(s);
      }
    const t = this._createNewArray(e, 1, e[0].length);
    return t.setDefaultValue(this._defaultValue), this._flattenCache = t, t;
  }
  /**
   * Flatten a 2D array.
   * In Excel, errors and blank cells are ignored, which results in a binary search that cannot strictly adhere to the number of cells.
   */
  flattenPosition() {
    if (this._flattenPosition != null)
      return this._flattenPosition;
    const e = [], t = [], r = [], n = [];
    let s = 0;
    for (let u = 0; u < this._rowCount; u++)
      for (let c = 0; c < this._columnCount; c++) {
        const l = this.get(u, c);
        if (l == null || l.isError() || l.isNull()) {
          s++;
          continue;
        }
        l.isString() ? (e.push(l), r.push(s++)) : (t.push(l), n.push(s++));
      }
    const o = {
      stringArray: e,
      numberArray: t,
      stringPosition: r,
      numberPosition: n
    };
    return this._flattenPosition = o, o;
  }
  /**
   * I'm looking to perform slicing operations on 2D arrays, similar to the functionality provided by NumPy.
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @rowParam start:stop:step
   * @columnParam start:stop:step
   * @param takeArray
   */
  slice(e, t) {
    let r = 0, n = this._rowCount, s = 1, o = 0, u = this._columnCount, c = 1;
    if (e != null && (r = e[0] || 0, n = e[1] || this._rowCount, s = e[2] || 1), t != null && (o = t[0] || 0, u = t[1] || this._columnCount, c = t[2] || 1), r >= this._rowCount || o >= this._columnCount)
      return;
    const l = `${r}_${n}_${s}_${o}_${u}_${c}`, f = this._sliceCache.get(l);
    if (f != null)
      return f;
    const h = [], d = this._values;
    let _ = 0, C = 0;
    for (let p = r; p < n; p += s) {
      C = 0, h[_] == null && (h[_] = []);
      for (let N = o; N < u; N += c) {
        if (!d[p])
          return;
        let M = d[p][N] || this._defaultValue;
        M == null && (M = ce.create()), h[_][C] = M, C++;
      }
      _++;
    }
    if (h.length === 0 || h[0].length === 0)
      return;
    const E = s > 1 ? -1 : r + this._currentRow, b = c > 1 ? -1 : o + this._currentColumn, R = this._createNewArray(h, h.length, h[0].length, E, b);
    return R.setDefaultValue(this._defaultValue), this._sliceCache.set(l, R), R;
  }
  sortByRow(e) {
    const t = this._transposeArray(this._values);
    t.sort(this._sort(e)), this._clearCache(), this._values = this._transposeArray(t);
  }
  sortByColumn(e) {
    this._clearCache(), this._values.sort(this._sort(e));
  }
  transpose() {
    const e = this._transposeArray(this._values), t = this._rowCount, r = this._columnCount, n = this._createNewArray(e, r, t);
    return n.setDefaultValue(this._defaultValue), n;
  }
  /**
   * Due to the inability to effectively utilize the cache,
   * the sequential matching approach is only used for special matches in XLOOKUP and XMATCH.
   * For example, when match_mode is set to 1 and -1 for an exact match. If not found, it returns the next smaller item.
   */
  orderSearch(e, t = Le.MIN, r = !1, n = !1) {
    let s, o, u, c;
    const l = (f, h, d) => {
      if (f == null)
        return !0;
      let _;
      if (n === !0 ? _ = f.compare(e, F.EQUALS) : _ = f.isEqual(e), (_ == null ? void 0 : _.getValue()) === !0)
        return s = f, u = { row: h, column: d }, !1;
      t === Le.MAX ? f.isGreaterThan(e).getValue() === !0 && (o == null || f.minus(e).abs().isLessThanOrEqual(o.minus(e).abs()).getValue() === !0) && (o = f, c = { row: h, column: d }) : t === Le.MIN && f.isLessThan(e).getValue() === !0 && (o == null || f.minus(e).abs().isLessThanOrEqual(o.minus(e).abs()).getValue() === !0) && (o = f, c = { row: h, column: d });
    };
    if (r ? this.iteratorReverse((f, h, d) => l(f, h, d)) : this.iterator((f, h, d) => l(f, h, d)), s != null)
      return u;
    if (o != null)
      return c;
  }
  binarySearch(e, t = Kt.MIN, r = Le.MIN) {
    if (e.isError())
      return;
    const { stringArray: n, stringPosition: s, numberArray: o, numberPosition: u } = this.flattenPosition();
    return e.isString() ? this._binarySearch(e, n, s, t, r) : this._binarySearch(e, o, u, t, r);
  }
  /**
   * searchType defaults to ascending order
   *
   * matchType defaults to the maximum value less than the search value, which is used for the default matching mode of VLOOKUP/LOOKUP/HLOOKUP.
   * @param valueObject
   * @param searchArray
   * @param positionArray
   * @param searchType
   * @param matchType
   * @returns
   */
  _binarySearch(e, t, r, n = Kt.MIN, s = Le.MIN) {
    const o = An(), u = Number(e.getValue()), c = !Number.isNaN(u);
    let l = 0, f = t.length - 1, h = -1, d = -1, _ = -1;
    for (; l <= f; ) {
      const C = Math.floor((l + f) / 2), E = t[C];
      let b;
      if (E.isNull())
        b = n === Kt.MIN ? 1 : -1;
      else {
        const R = E.getValue();
        if (c) {
          const p = Number(R);
          b = Number.isNaN(p) ? 1 : Math.sign(p - u);
        } else
          b = o(R.toString().toLocaleLowerCase(), e.getValue().toString().toLocaleLowerCase());
      }
      if (n === Kt.MAX && (b = -b), b === 0) {
        h = C;
        break;
      }
      b < 0 ? (d = C, l = C + 1) : (_ = C, f = C - 1);
    }
    if (s === Le.NORMAL)
      return h !== -1 ? r[h] : void 0;
    if (s === Le.MIN)
      return h !== -1 ? r[h] : n === Kt.MIN ? r[d] : r[_];
    if (s === Le.MAX)
      return h !== -1 ? r[h] : n === Kt.MIN ? r[_] : r[d];
  }
  sum() {
    let e = y.create(0);
    return this.iterator((t) => {
      if (t == null || t.isString() || t.isBoolean() || t.isNull())
        return !0;
      if (t.isError())
        return e = t, !1;
      e = e.plus(
        t
      );
    }), e;
  }
  max() {
    let e = y.create(Number.NEGATIVE_INFINITY);
    return this.iterator((t) => {
      if (t == null)
        return !0;
      if (t.isError())
        return e = t, !1;
      if (t.isString() || t.isNull() || t.isBoolean())
        return !0;
      e.isLessThan(t).getValue() && (e = t);
    }), e;
  }
  min() {
    let e = y.create(Number.POSITIVE_INFINITY);
    return this.iterator((t) => {
      if (t == null)
        return !0;
      if (t.isError())
        return e = t, !1;
      if (t.isString() || t.isNull() || t.isBoolean())
        return !0;
      e.isGreaterThan(t).getValue() && (e = t);
    }), e;
  }
  count() {
    let e = y.create(0);
    return this.iterator((t) => {
      if (t == null || t.isError() || t.isString() || t.isNull() || t.isBoolean())
        return !0;
      e = e.plusBy(1);
    }), e;
  }
  countA() {
    let e = y.create(0);
    return this.iterator((t) => {
      if (t == null || t.isNull())
        return !0;
      e = e.plusBy(1);
    }), e;
  }
  countBlank() {
    let e = y.create(0);
    return this.iterator((t) => {
      (t == null || t.isNull() || t.getValue() === "") && (e = e.plusBy(1));
    }), e;
  }
  getNegative() {
    return q.create("{0}").minus(this);
  }
  getReciprocal() {
    return q.create("{1}").divided(this);
  }
  plus(e) {
    return this._batchOperator(
      e,
      1
      /* PLUS */
    );
  }
  minus(e) {
    return this._batchOperator(
      e,
      0
      /* MINUS */
    );
  }
  multiply(e) {
    return this._batchOperator(
      e,
      2
      /* MULTIPLY */
    );
  }
  divided(e) {
    return this._batchOperator(
      e,
      3
      /* DIVIDED */
    );
  }
  mod(e) {
    return this._batchOperator(
      e,
      4
      /* MOD */
    );
  }
  modInverse(e) {
    return this.map((t) => t.isError() ? t : e.mod(t));
  }
  compare(e, t, r) {
    return this._batchOperator(e, 5, t, r);
  }
  concatenateFront(e) {
    return this._batchOperator(
      e,
      6
      /* CONCATENATE_FRONT */
    );
  }
  concatenateBack(e) {
    return this._batchOperator(
      e,
      7
      /* CONCATENATE_BACK */
    );
  }
  map(e) {
    const t = (r, n, s) => r == null ? ce.create() : r.isError() ? r : e(r, n, s);
    return this.mapValue(t);
  }
  mapValue(e) {
    var s;
    const t = this._rowCount, r = this._columnCount, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        const l = (s = this._values) == null ? void 0 : s[o];
        if (l == null)
          u[c] = g.create(m.VALUE);
        else {
          const f = l[c] || this._defaultValue;
          f ? u[c] = e(f, o, c) : u[c] = ce.create();
        }
      }
      n.push(u);
    }
    return this._createNewArray(n, t, r);
  }
  pow(e) {
    return this._batchOperator(
      e,
      8
      /* POW */
    );
  }
  /**
   *
   * @param valueObject In the case of an inverse, it is certainly not an array.
   * @returns
   */
  powInverse(e) {
    return this.map((t) => t.isError() ? t : e.pow(t));
  }
  sqrt() {
    return this.map((e) => e.isError() ? e : e.sqrt());
  }
  cbrt() {
    return this.map((e) => e.isError() ? e : e.cbrt());
  }
  cos() {
    return this.map((e) => e.isError() ? e : e.cos());
  }
  cosh() {
    return this.map((e) => e.isError() ? e : e.cosh());
  }
  acos() {
    return this.map((e) => e.isError() ? e : e.acos());
  }
  acosh() {
    return this.map((e) => e.isError() ? e : e.acosh());
  }
  sin() {
    return this.map((e) => e.isError() ? e : e.sin());
  }
  sinh() {
    return this.map((e) => e.isError() ? e : e.sinh());
  }
  asin() {
    return this.map((e) => e.isError() ? e : e.asin());
  }
  asinh() {
    return this.map((e) => e.isError() ? e : e.asinh());
  }
  tan() {
    return this.map((e) => e.isError() ? e : e.tan());
  }
  tanh() {
    return this.map((e) => e.isError() ? e : e.tanh());
  }
  atan() {
    return this.map((e) => e.isError() ? e : e.atan());
  }
  atanh() {
    return this.map((e) => e.isError() ? e : e.atanh());
  }
  atan2(e) {
    return this._batchOperator(
      e,
      12
      /* ATAN2 */
    );
  }
  atan2Inverse(e) {
    return this.map((t) => t.isError() ? t : e.atan2(t));
  }
  mean(e = 0) {
    const t = this.sum(), r = this.count();
    return t.divided(e === 0 ? r : r.minusBy(1));
  }
  median() {
    const e = this.flattenPosition().numberArray, t = this._createNewArray([e], 1, e.length), r = t.getColumnCount();
    if (r <= 1)
      return t.get(0, 0) || ce.create();
    if (t.sortByRow(0), r % 2 === 0) {
      const n = t.get(0, r / 2) || ce.create(), s = t.get(0, r / 2 - 1) || ce.create();
      return n.plus(s).divided(y.create(2));
    }
    return t.get(0, (r - 1) / 2) || ce.create();
  }
  /**
   * ┌──────────────┬────────────────────────────────┬───────────────────┐
   * │ Function     │ Ignore logical values and text │ Type              │
   * ├──────────────┼────────────────────────────────┼───────────────────┤
   * │ VAR.S (VAR)  │ TRUE                           │ sample            │
   * │ VAR.P (VARP) │ TRUE                           │ entire population │
   * │ VARA         │ FALSE                          │ sample            │
   * │ VARPA        │ FALSE                          │ entire population │
   * └──────────────┴────────────────────────────────┴───────────────────┘
   *
   * for VARPA and VARA, strings and FALSE are counted as 0, TRUE is counted as 1
   * for VAR.S/VAR, or VAR.P/VARP, strings,TRUE and FALSE are ignored
   * Since sum ignores strings and booleans, they are ignored here too, and VAR.S and VAR.P are used more
   *
   * VAR.S assumes that its arguments are a sample of the population, like numpy.var(data, ddof=1)
   * VAR.P assumes that its arguments are the entire population, like numpy.var(data, ddof=0)
   * numpy.var uses ddof=0 (Delta Degrees of Freedom) by default, so we use ddof=0 here
   *
   */
  var(e = 0) {
    const t = this.mean(), r = [[]];
    this.iterator((l) => {
      if (l == null || l.isError() || l.isString() || l.isBoolean() || l.isNull())
        return;
      const f = l.minus(t).pow(y.create(2));
      f.isError() || r[0].push(f);
    });
    const { _unitId: n, _sheetId: s, _currentRow: o, _currentColumn: u } = this;
    return q.create({
      calculateValueList: r,
      rowCount: 1,
      columnCount: r[0].length,
      unitId: n,
      sheetId: s,
      row: o,
      column: u
    }).mean(e);
  }
  /**
   * STDEV.P (STDEVP): ddof=0, ignore strings and booleans
   * STDEV.S (STDEV): ddof=1, ignore strings and booleans
   *
   * STDEVPA: ddof=0,
   * STDEVA: ddof=1,
   * @returns
   */
  std(e = 0) {
    const t = this.var(e);
    return t.isError() ? t : t.sqrt();
  }
  log() {
    return this.map((e) => e.isError() ? e : e.log());
  }
  log10() {
    return this.map((e) => e.isError() ? e : e.log10());
  }
  exp() {
    return this.map((e) => e.isError() ? e : e.exp());
  }
  abs() {
    return this.map((e) => e.isError() ? e : e.abs());
  }
  round(e) {
    return this._batchOperator(
      e,
      9
      /* ROUND */
    );
  }
  roundInverse(e) {
    return this.map((t) => t.isError() ? t : e.round(t));
  }
  floor(e) {
    return this._batchOperator(
      e,
      10
      /* FLOOR */
    );
  }
  floorInverse(e) {
    return this.map((t) => t.isError() ? t : e.floor(t));
  }
  ceil(e) {
    return this._batchOperator(
      e,
      11
      /* CEIL */
    );
  }
  ceilInverse(e) {
    return this.map((t) => t.isError() ? t : e.ceil(t));
  }
  toValue() {
    return If(this._values);
  }
  _clearCache() {
    this._flattenCache = null, this._sliceCache.clear();
  }
  _sort(e) {
    const t = An();
    return (r, n) => {
      const s = r[e], o = n[e];
      return s == null ? 1 : o == null ? -1 : s.isError() && s.isError() ? 0 : s.isError() ? 1 : o.isError() ? -1 : t(
        s.getValue(),
        o.getValue()
      );
    };
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
  _batchOperator(e, t, r, n) {
    const s = [];
    let o = this._rowCount, u = this._columnCount;
    if (e.isArray()) {
      const f = e.getRowCount(), h = e.getColumnCount();
      if (o = Math.max(f, o), u = Math.max(h, u), f === 1 && h === 1) {
        const d = e.getFirstCell();
        for (let _ = 0; _ < u; _++)
          s.push(d);
      } else if (f === 1 && this._columnCount > 1) {
        const d = e.getArrayValue();
        for (let _ = 0; _ < u; _++)
          s.push(d[0][_]);
      } else
        return this._batchOperatorArray(e, t, r, n);
    } else
      for (let f = 0; f < u; f++)
        s.push(e);
    const c = [];
    for (let f = 0; f < u; f++) {
      const h = s[f];
      this._batchOperatorValue(
        h,
        f,
        c,
        t,
        r,
        n
      );
    }
    const l = this._createNewArray(c, o, u);
    return l.setDefaultValue(T.create(!1)), l;
  }
  // eslint-disable-next-line max-lines-per-function
  _batchOperatorValue(e, t, r, n, s, o) {
    const u = this._rowCount, c = this.getUnitId(), l = this.getSheetId(), f = this.getCurrentRow(), h = this.getCurrentColumn();
    if (n === 5) {
      const { rowsInCache: d, rowsNotInCache: _ } = We.canUseCache(
        c,
        l,
        t + h,
        f,
        f + u - 1
      );
      if (d.length > 0) {
        let C = !1;
        if (s === F.EQUALS) {
          const E = We.getCellPositions(
            c,
            l,
            t + h,
            e.getValue(),
            d
          );
          E != null && (E.forEach((b) => {
            if (b < f || b > f + u - 1)
              return;
            const R = b - f;
            r[R] == null && (r[R] = []), r[R][t] = T.create(!0);
          }), C = !0);
        } else {
          const E = We.getCellValuePositions(
            c,
            l,
            t + h
          );
          E != null && E.forEach((b, R) => {
            let p = ce.create();
            or.has(R) ? p = g.create(R) : typeof R == "string" ? p = j.create(R) : typeof R == "number" ? p = y.create(R) : typeof R == "boolean" && (p = T.create(R));
            let N;
            p.isError() ? N = p : e.isError() ? N = e : N = p.compare(e, s, o), (N.isError() || N.getValue() === !0) && b.forEach((M) => {
              M >= f && M <= f + u - 1 && (r[M - f] == null && (r[M - f] = []), r[M - f][t] = N);
            });
          });
        }
        if (!(s === F.EQUALS && !C && !o)) {
          if (_.length > 0)
            for (const E of _) {
              const [b, R] = E;
              for (let p = b; p <= R; p++)
                this.__batchOperatorRowValue(
                  e,
                  t,
                  r,
                  n,
                  p - f,
                  c,
                  l,
                  f,
                  h,
                  s,
                  o
                );
              We.setContinueBuildingCache(
                c,
                l,
                t + h,
                b,
                R
              );
            }
          return;
        }
      }
    }
    for (let d = 0; d < u; d++)
      this.__batchOperatorRowValue(
        e,
        t,
        r,
        n,
        d,
        c,
        l,
        f,
        h,
        s,
        o
      );
    We.setContinueBuildingCache(
      c,
      l,
      t + h,
      f,
      f + u - 1
    );
  }
  // eslint-disable-next-line
  __batchOperatorRowValue(e, t, r, n, s, o, u, c, l, f, h) {
    const d = this.getValueOrDefault(s, t);
    if (r[s] == null && (r[s] = []), d && e)
      if (d.isError())
        r[s][t] = d;
      else if (e.isError())
        r[s][t] = e;
      else
        switch (n) {
          case 1:
            r[s][t] = d.plus(e);
            break;
          case 0:
            r[s][t] = d.minus(e);
            break;
          case 2:
            r[s][t] = d.multiply(e);
            break;
          case 3:
            r[s][t] = d.divided(e);
            break;
          case 4:
            r[s][t] = d.mod(e);
            break;
          case 5:
            f ? r[s][t] = d.compare(e, f, h) : r[s][t] = g.create(m.VALUE);
            break;
          case 6:
            r[s][t] = d.concatenateFront(e);
            break;
          case 7:
            r[s][t] = d.concatenateBack(e);
            break;
          case 8:
            r[s][t] = d.pow(e);
            break;
          case 9:
            r[s][t] = d.round(e);
            break;
          case 10:
            r[s][t] = d.floor(e);
            break;
          case 12:
            r[s][t] = d.atan2(e);
            break;
          case 11:
            r[s][t] = d.ceil(e);
            break;
        }
    else
      r[s][t] = g.create(m.NA);
    d != null && (d.isNull() || (d.isError() ? We.set(
      o,
      u,
      t + l,
      d.getErrorType(),
      s + c
    ) : We.set(
      o,
      u,
      t + l,
      d.getValue(),
      s + c
    )));
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _batchOperatorArray(e, t, r, n) {
    let s = e.getRowCount(), o = e.getColumnCount();
    s < this._rowCount && (s = this._rowCount), o < this._columnCount && (o = this._columnCount);
    const u = [], c = this._checkArrayCalculateType(this), l = this._checkArrayCalculateType(e);
    for (let f = 0; f < s; f++) {
      const h = [];
      for (let d = 0; d < o; d++) {
        let _;
        c === 3 ? _ = this.getValueOrDefault(0, 0) : c === 1 ? _ = this.getValueOrDefault(0, d) : c === 2 ? _ = this.getValueOrDefault(f, 0) : _ = this.getValueOrDefault(f, d);
        let C;
        if (l === 3 ? C = e.getValueOrDefault(0, 0) : l === 1 ? C = e.getValueOrDefault(0, d) : l === 2 ? C = e.getValueOrDefault(f, 0) : C = e.getValueOrDefault(f, d), _ && C)
          if (_.isError())
            h[d] = _;
          else if (C.isError())
            h[d] = C;
          else
            switch (t) {
              case 1:
                h[d] = _.plus(C);
                break;
              case 0:
                h[d] = _.minus(C);
                break;
              case 2:
                h[d] = _.multiply(C);
                break;
              case 3:
                h[d] = _.divided(C);
                break;
              case 4:
                h[d] = _.mod(C);
                break;
              case 5:
                r ? h[d] = _.compare(C, r, n) : h[d] = g.create(m.VALUE);
                break;
              case 6:
                h[d] = _.concatenateFront(C);
                break;
              case 7:
                h[d] = _.concatenateBack(C);
                break;
              case 8:
                h[d] = _.pow(C);
                break;
              case 9:
                h[d] = _.round(C);
                break;
              case 12:
                h[d] = _.atan2(C);
                break;
              case 10:
                h[d] = _.floor(C);
                break;
              case 11:
                h[d] = _.ceil(C);
                break;
            }
        else
          h[d] = g.create(m.NA);
      }
      u.push(h);
    }
    return this._createNewArray(u, s, o);
  }
  _checkArrayCalculateType(e) {
    return e.getRowCount() === 1 && e.getColumnCount() === 1 ? 3 : e.getRowCount() === 1 ? 1 : e.getColumnCount() === 1 ? 2 : 0;
  }
  _formatValue(e) {
    if (typeof e != "string")
      return e = e, this._rowCount = e.rowCount, this._columnCount = e.columnCount, this._unitId = e.unitId, this._sheetId = e.sheetId, this._currentRow = e.row, this._currentColumn = e.column, e.calculateValueList;
    e = e.slice(1, -1);
    const t = e.split(";"), r = t.length, n = [];
    let s = 0;
    for (let o = 0; o < r; o++) {
      const c = t[o].split(","), l = c.length;
      s < l && (s = l);
      const f = [];
      for (let h = 0; h < l; h++) {
        const d = c[h].trim();
        f.push(Mt.create(d));
      }
      n.push(f);
    }
    return this._rowCount = r, this._columnCount = s, n;
  }
  _createNewArray(e, t, r, n = -1, s = -1) {
    (this._currentColumn === -1 || this._currentRow === -1) && (n = -1, s = -1);
    const o = {
      calculateValueList: e,
      rowCount: t,
      columnCount: r,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: n,
      column: s
    };
    return q.create(o);
  }
}
class Mt {
  static create(a, e = !1) {
    if (a == null)
      return ce.create();
    if (typeof a == "boolean")
      return T.create(a);
    if (typeof a == "string") {
      const t = a.toLocaleUpperCase().trim();
      if (or.has(t))
        return g.create(t);
      if (t === rr.TRUE || t === rr.FALSE)
        return Kn(a);
      if (W(a))
        return y.create(Number(a));
      if (!e) {
        const { isNumberPattern: n, value: s, pattern: o } = Vl(a);
        if (n)
          return y.create(s, o);
      }
      const r = a.replace(/\n/g, "").replace(/\r/g, "");
      return !Ff(r) && Bc(r) ? q.create(r) : Tf(a);
    }
    return typeof a == "number" ? xr(a) : g.create(m.VALUE);
  }
}
function Ff(i) {
  const a = i.trim();
  return a.startsWith('"') && a.endsWith('"');
}
const kf = 1e4, Rn = new wt(kf);
class Xn extends Hn {
  constructor(e) {
    super();
    A(this, "_forcedSheetId", "");
    A(this, "_forcedSheetName", "");
    A(this, "_defaultSheetId", "");
    A(this, "_rangeData", {
      startColumn: -1,
      startRow: -1,
      endRow: -1,
      endColumn: -1
    });
    A(this, "_unitData", {});
    A(this, "_unitStylesData", {});
    A(this, "_filteredOutRows", []);
    A(this, "_defaultUnitId", "");
    A(this, "_forcedUnitId", "");
    A(this, "_runtimeData", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_runtimeArrayFormulaCellData", {});
    A(this, "_runtimeFeatureCellData", {});
    A(this, "_refOffsetX", 0);
    A(this, "_refOffsetY", 0);
    this._token = e;
  }
  dispose() {
    this._unitData = {}, this._unitStylesData = {}, this._runtimeData = {};
  }
  getToken() {
    return this._token;
  }
  setToken(e) {
    this._token = e;
  }
  isExceedRange() {
    const { startRow: e, endRow: t, startColumn: r, endColumn: n } = this.getRangePosition();
    return e < 0 || r < 0 || t >= this.getActiveSheetRowCount() || n >= this.getActiveSheetColumnCount();
  }
  setRefOffset(e = 0, t = 0) {
    this._refOffsetX = e, this._refOffsetY = t;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
  getRangePosition() {
    let { startRow: e, startColumn: t, endRow: r, endColumn: n } = aa(this._rangeData, this._refOffsetX, this._refOffsetY);
    return Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Number.isNaN(r) && (r = this.getActiveSheetRowCount() - 1), Number.isNaN(n) && (n = this.getActiveSheetColumnCount() - 1), {
      ...this._rangeData,
      startRow: e,
      endRow: r,
      startColumn: t,
      endColumn: n
    };
  }
  isReferenceObject() {
    return !0;
  }
  iterator(e) {
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition();
    if (this._checkIfWorksheetMiss())
      return e(g.create(m.VALUE), t, n);
    const o = this._forcedUnitId || this._defaultUnitId, u = this._forcedSheetId || this._defaultSheetId;
    for (let c = t; c <= r; c++)
      for (let l = n; l <= s; l++) {
        if (c < 0 || l < 0)
          return e(g.create(m.REF), c, l);
        const f = this.getCellData(c, l);
        let h = !1;
        if (cn(f)) {
          h = e(null, c, l);
          continue;
        }
        let d = this.getCellValueObject(f);
        if (c === t && l === n) {
          const _ = this.getCellPattern(o, u, c, l);
          if (_ && d.isNumber()) {
            const C = Number(d.getValue());
            d = y.create(C, _);
          }
        }
        if (h = e(d, c, l), h === !1)
          return;
      }
  }
  getFirstCell() {
    if (this._checkIfWorksheetMiss())
      return g.create(m.VALUE);
    const { startRow: e, startColumn: t } = this.getRangePosition(), r = this.getCellData(e, t);
    if (!r)
      return y.create(0);
    let n = this.getCellValueObject(r);
    const s = this._forcedUnitId || this._defaultUnitId, o = this._forcedSheetId || this._defaultSheetId, u = this.getCellPattern(s, o, e, t);
    if (u && n.isNumber()) {
      const c = Number(n.getValue());
      n = y.create(c, u);
    }
    return n;
  }
  getRangeData() {
    return this._rangeData;
  }
  setRangeData(e) {
    this._rangeData = e;
  }
  getUnitId() {
    return this._forcedUnitId && this._forcedUnitId.length > 0 ? this._forcedUnitId : this._defaultUnitId;
  }
  getSheetId() {
    return this._forcedSheetId && this._forcedSheetId.length > 0 ? this._forcedSheetId : this._defaultSheetId;
  }
  setForcedUnitIdDirect(e) {
    e.length > 0 && (this._forcedUnitId = e);
  }
  getForcedUnitId() {
    return this._forcedUnitId;
  }
  setForcedSheetId(e) {
    var t;
    this._forcedSheetId = (t = e[this.getUnitId()]) == null ? void 0 : t[this._forcedSheetName];
  }
  setForcedSheetIdDirect(e) {
    this._forcedSheetId = e;
  }
  getForcedSheetId() {
    return this._forcedSheetId;
  }
  setForcedSheetName(e) {
    e.length > 0 && (this._forcedSheetName = e);
  }
  getForcedSheetName() {
    return this._forcedSheetName;
  }
  setDefaultSheetId(e) {
    this._defaultSheetId = e;
  }
  getDefaultSheetId() {
    return this._defaultSheetId;
  }
  setDefaultUnitId(e) {
    this._defaultUnitId = e;
  }
  getDefaultUnitId() {
    return this._defaultUnitId;
  }
  getUnitData() {
    return this._unitData;
  }
  setUnitData(e) {
    this._unitData = e;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  setUnitStylesData(e) {
    this._unitStylesData = e;
  }
  getFilteredOutRows() {
    return this._filteredOutRows;
  }
  setFilteredOutRows(e) {
    this._filteredOutRows = e;
  }
  getRuntimeData() {
    return this._runtimeData;
  }
  setRuntimeData(e) {
    this._runtimeData = e;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(e) {
    this._arrayFormulaCellData = e;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  setRuntimeArrayFormulaCellData(e) {
    this._runtimeArrayFormulaCellData = e;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(e) {
    this._runtimeFeatureCellData = e;
  }
  getActiveSheetRowCount() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.rowCount) || 0;
  }
  getActiveSheetColumnCount() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.columnCount) || 0;
  }
  getRowCount() {
    return this._rangeData.endRow - this._rangeData.startRow + 1;
  }
  getColumnCount() {
    return this._rangeData.endColumn - this._rangeData.startColumn + 1;
  }
  getRowData() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.rowData) || {};
  }
  getColumnData() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.columnData) || {};
  }
  isCell() {
    return !1;
  }
  isColumn() {
    return !1;
  }
  isRow() {
    return !1;
  }
  isRange() {
    return !1;
  }
  isTable() {
    return !1;
  }
  unionBy(e) {
    return g.create(m.REF);
  }
  unionRange(e, t) {
    return {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
  }
  getCellValueObject(e) {
    const t = Ml(e);
    if (or.has(t))
      return g.create(t);
    if (e.t === Vt.NUMBER) {
      const r = this._getPatternByCell(e);
      return sc(r) ? j.create(t.toString()) : xr(t, r);
    }
    return e.t === Vt.STRING || e.t === Vt.FORCE_STRING ? j.create(t.toString()) : e.t === Vt.BOOLEAN ? Kn(t) : Mt.create(t);
  }
  _getPatternByCell(e) {
    var n;
    const t = this._unitStylesData[this.getUnitId()];
    if (!t) return "";
    const r = t.getStyleByCell(e);
    return ((n = r == null ? void 0 : r.n) == null ? void 0 : n.pattern) || "";
  }
  getCellByRow(e) {
    return this.getCellByPosition(e);
  }
  getCellByColumn(e) {
    return this.getCellByPosition(void 0, e);
  }
  getCurrentActiveSheetData() {
    var e;
    return (e = this._unitData[this.getUnitId()]) == null ? void 0 : e[this.getSheetId()];
  }
  getCurrentStylesData() {
    return this._unitStylesData[this.getUnitId()];
  }
  getCurrentRuntimeSheetData() {
    var e, t;
    return (t = (e = this._runtimeData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCurrentActiveArrayFormulaCellData() {
    var e, t;
    return (t = (e = this._arrayFormulaCellData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCurrentRuntimeActiveArrayFormulaCellData() {
    var e, t;
    return (t = (e = this._runtimeArrayFormulaCellData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCellData(e, t) {
    const r = this.getCurrentActiveSheetData(), n = this.getCurrentRuntimeSheetData(), s = this.getCurrentActiveArrayFormulaCellData(), o = this.getCurrentRuntimeActiveArrayFormulaCellData();
    return (n == null ? void 0 : n.getValue(e, t)) || (o == null ? void 0 : o.getValue(e, t)) || this.getRuntimeFeatureCellValue(e, t) || (s == null ? void 0 : s.getValue(e, t)) || (r == null ? void 0 : r.cellData.getValue(e, t));
  }
  getRuntimeFeatureCellValue(e, t) {
    return Ao(e, t, this.getSheetId(), this.getUnitId(), this._runtimeFeatureCellData);
  }
  getCellByPosition(e, t) {
    let r = e, n = t;
    r || (r = this._rangeData.startRow), n || (n = this._rangeData.startColumn);
    const s = this.getCellData(r, n);
    return s ? this.getCellValueObject(s) : g.create(m.VALUE);
  }
  /**
   * Get the pattern of the cell
   * @param unitId
   * @param sheetId
   * @param row
   * @param column
   * @returns
   */
  getCellPattern(e, t, r, n) {
    var c, l, f, h;
    const s = this._unitStylesData[e];
    if (!s)
      return "";
    const o = (f = (l = (c = this._unitData[e]) == null ? void 0 : c[t]) == null ? void 0 : l.cellData) == null ? void 0 : f.getValue(r, n);
    if (!o)
      return "";
    const u = s.getStyleByCell(o);
    return ((h = u == null ? void 0 : u.n) == null ? void 0 : h.pattern) || "";
  }
  toArrayValueObject(e = !0) {
    var _;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = `${this.getUnitId()}_${this.getSheetId()}_${t}_${r}_${n}_${s}`, u = Rn.get(o);
    if (u && e)
      return u;
    const c = r - t + 1, l = s - n + 1;
    if (c < 0 || l < 0)
      return this._getBlankArrayValueObject();
    const f = new Array(c);
    this.iterator((C, E, b) => {
      const R = E - t, p = b - n;
      f[R] || (f[R] = new Array(l)), C == null && (C = ce.create()), f[R][p] = C;
    });
    const h = {
      calculateValueList: f,
      rowCount: f.length,
      columnCount: ((_ = f[0]) == null ? void 0 : _.length) || 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: t,
      column: n
    }, d = q.create(h);
    return e && Rn.set(o, d), d;
  }
  toUnitRange() {
    return {
      range: this.getRangePosition(),
      sheetId: this.getSheetId(),
      unitId: this.getUnitId()
    };
  }
  _checkIfWorksheetMiss() {
    return (this._forcedSheetId == null || this._forcedSheetId.length === 0) && this._forcedSheetName.length > 0;
  }
  _getBlankArrayValueObject() {
    const e = {
      calculateValueList: [],
      rowCount: 0,
      columnCount: 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: 0,
      column: 0
    };
    return q.create(e);
  }
}
class $f extends Hn {
  constructor(a) {
    super(), this._promise = a;
  }
  isAsyncObject() {
    return !0;
  }
  async getValue() {
    return this._promise;
  }
}
class Yf extends Hn {
  constructor(a) {
    super(), this._promiseList = a;
  }
  isAsyncArrayObject() {
    return !0;
  }
  async getValue() {
    var t;
    const a = [];
    for (let r = 0; r < this._promiseList.length; r++) {
      const n = this._promiseList[r];
      a[r] == null && (a[r] = []);
      for (let s = 0; s < n.length; s++) {
        const o = n[s];
        o.isAsyncObject() ? a[r][s] = await o.getValue() : a[r][s] = o;
      }
    }
    const e = {
      calculateValueList: a,
      rowCount: a.length,
      columnCount: ((t = a[0]) == null ? void 0 : t.length) || 0,
      unitId: "",
      sheetId: "",
      row: 0,
      column: 0
    };
    return q.create(e);
  }
}
class pn extends Xn {
  constructor(a, e, t) {
    super(""), this.setRangeData(a), e && this.setForcedSheetIdDirect(e), t && this.setForcedUnitIdDirect(t);
  }
  isRange() {
    return !0;
  }
}
class ya extends Xn {
  constructor(a) {
    super(a);
    const e = Cr(a);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName), this.setRangeData(e.range);
  }
  isCell() {
    return !0;
  }
  unionBy(a) {
    if (!a.isCell())
      return g.create(m.REF);
    const e = a, t = this.unionRange(this.getRangeData(), e.getRangeData());
    return this._createRange(t);
  }
  unionRange(a, e) {
    const t = a.startRow, r = a.startColumn, n = e.startRow, s = e.startColumn, o = {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
    return t > n ? (o.startRow = n, o.endRow = t) : (o.startRow = t, o.endRow = n), r > s ? (o.startColumn = s, o.endColumn = r) : (o.startColumn = r, o.endColumn = s), a.startAbsoluteRefType && (o.startAbsoluteRefType = a.startAbsoluteRefType), e.startAbsoluteRefType && (o.endAbsoluteRefType = e.startAbsoluteRefType), o;
  }
  _createRange(a) {
    const e = new pn(
      a,
      this.getForcedSheetId(),
      this.getForcedUnitId()
    );
    e.setUnitData(this.getUnitData()), e.setDefaultSheetId(this.getDefaultSheetId()), e.setDefaultUnitId(this.getDefaultUnitId()), e.setRuntimeData(this.getRuntimeData()), e.setUnitStylesData(this.getUnitStylesData()), e.setArrayFormulaCellData(this.getArrayFormulaCellData()), e.setRuntimeArrayFormulaCellData(this.getRuntimeArrayFormulaCellData()), e.setRuntimeFeatureCellData(this.getRuntimeFeatureCellData());
    const { x: t, y: r } = this.getRefOffset();
    e.setRefOffset(t, r);
    const n = this.getForcedSheetId();
    e.setForcedSheetName(this.getForcedSheetName()), n != null && e.setForcedSheetIdDirect(n);
    const s = this.getForcedUnitId();
    return s && e.setForcedUnitIdDirect(s), e;
  }
}
class Ra extends Xn {
  constructor(a) {
    super(a);
    const e = Cr(a);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName);
    const t = {
      ...e.range,
      startColumn: e.range.startColumn,
      startRow: Number.NaN,
      endColumn: e.range.endColumn,
      endRow: Number.NaN,
      rangeType: et.COLUMN
    };
    this.setRangeData(t);
  }
  isColumn() {
    return !0;
  }
  unionBy(a) {
    if (!a.isColumn())
      return g.create(m.REF);
    const e = a;
    if (e.getForcedSheetName() !== void 0 && e.getForcedSheetName() !== "")
      return g.create(m.REF);
    const t = this.getRangeData(), r = e.getRangeData(), n = r.startColumn;
    if (n >= t.startColumn && n <= t.endColumn)
      return this;
    const s = t.startColumn;
    return n > s ? t.endColumn = n : (t.startColumn = n, t.endColumn = s), r.startAbsoluteRefType && (t.endAbsoluteRefType = r.startAbsoluteRefType), t.rangeType = et.COLUMN, this.setToken(`${this.getToken()}${K.COLON}${e.getToken()}`), this;
  }
}
class pa extends Xn {
  constructor(a) {
    super(a);
    const e = Cr(a);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName);
    const t = {
      ...e.range,
      startColumn: Number.NaN,
      startRow: e.range.startRow,
      endColumn: Number.NaN,
      endRow: e.range.endRow,
      rangeType: et.ROW
    };
    this.setRangeData(t);
  }
  isRow() {
    return !0;
  }
  unionBy(a) {
    if (!a.isRow())
      return g.create(m.REF);
    const e = a;
    if (e.getForcedSheetName() !== void 0 && e.getForcedSheetName() !== "")
      return g.create(m.REF);
    const t = this.getRangeData(), r = e.getRangeData(), n = r.startRow;
    if (n >= t.startRow && n <= t.endRow)
      return this;
    const s = t.startRow;
    return n > s ? t.endRow = n : (t.startRow = n, t.endRow = s), r.startAbsoluteRefType && (t.endAbsoluteRefType = r.startAbsoluteRefType), t.rangeType = et.ROW, this.setToken(`${this.getToken()}${K.COLON}${e.getToken()}`), this;
  }
}
function O(i, a, e, t) {
  const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = [];
  for (let o = 0; o < i; o++) {
    const u = [];
    for (let c = 0; c < a; c++) {
      if (r === 1 && n === 1) {
        const f = e.isArray() ? e.get(0, 0) : e;
        u.push(f);
        continue;
      }
      if (r === 1 && c < n) {
        const f = e.get(0, c);
        u.push(f);
        continue;
      }
      if (n === 1 && o < r) {
        const f = e.get(o, 0);
        u.push(f);
        continue;
      }
      if (o >= r || c >= n) {
        u.push(t != null ? t : ce.create());
        continue;
      }
      const l = e.get(o, c);
      u.push(l);
    }
    s.push(u);
  }
  return Fr(s, i, a);
}
function Fr(i, a, e, t = "", r = "") {
  const n = {
    calculateValueList: i,
    rowCount: a,
    columnCount: e,
    unitId: t,
    sheetId: r,
    row: -1,
    column: -1
  };
  return q.create(n);
}
function Va(i) {
  const a = [
    F.EQUALS,
    F.NOT_EQUAL,
    F.GREATER_THAN_OR_EQUAL,
    F.GREATER_THAN,
    F.LESS_THAN_OR_EQUAL,
    F.LESS_THAN
  ];
  for (const e of a)
    if (i.startsWith(e)) {
      const t = i.substring(e.length);
      return [e, Mt.create(t)];
    }
  return [F.EQUALS, Mt.create(i)];
}
function Zn(i, a, e, t) {
  if (!e)
    if (a.isString()) {
      const r = `${a.getValue()}`, [n, s] = Va(r);
      e = n, a = s;
    } else
      e = F.EQUALS;
  return i.compare(a, e, t);
}
function Hf(i, a) {
  const e = Math.max(i.isArray() ? i.getRowCount() : 1, a.isArray() ? a.getRowCount() : 1), t = Math.max(i.isArray() ? i.getColumnCount() : 1, a.isArray() ? a.getColumnCount() : 1), r = O(e, t, i), n = O(e, t, a);
  return r.mapValue((s, o, u) => {
    const c = n.get(o, u);
    return s != null && s.isError() ? s : c != null && c.isError() ? c : s != null && s.isBoolean() && (c != null && c.isBoolean()) ? Kn(s.getValue() && c.getValue()) : T.create(!1);
  });
}
function Gf(i) {
  const a = i.getValue();
  let e = 0;
  return a && (e = 1), y.create(e);
}
function Ri(i) {
  return i.isArray() && i.getRowCount() === 1 && i.getColumnCount() === 1 ? !0 : i.isReferenceObject() ? !!(i.isCell() || i.getRowCount() === 1 && i.getColumnCount() === 1) : (i = i, !!(i.isString() || i.isNumber() || i.isBoolean() || i.isError() || i.isNull()));
}
function Qf(i) {
  const a = i == null ? void 0 : i.getPattern();
  let e = {}, t = {};
  if (a && (e = {
    s: {
      n: {
        pattern: a
      }
    }
  }), i != null && i.getCustomData() && (t = {
    custom: i.getCustomData()
  }), i == null)
    return {
      v: null,
      ...e
    };
  if (i.isError())
    return {
      v: i.getErrorType(),
      t: Vt.STRING,
      ...e,
      ...t
    };
  if (i.isValueObject()) {
    const r = i, n = r.getValue();
    return r.isNumber() ? {
      v: n,
      t: Vt.NUMBER,
      ...e,
      ...t
    } : r.isBoolean() ? {
      v: n ? 1 : 0,
      t: Vt.BOOLEAN,
      ...e,
      ...t
    } : r.isString() ? {
      v: n,
      t: Vt.STRING,
      ...e,
      ...t
    } : r.isNull() ? {
      v: null,
      ...e,
      ...t
    } : {
      v: n,
      t: Vt.STRING,
      ...e,
      ...t
    };
  }
}
function Wf(i) {
  let a = 0, e = 0;
  return i.forEach((t, r) => {
    if (r % 2 === 1)
      if (t.isArray()) {
        const n = t;
        a = Math.max(a, n.getRowCount()), e = Math.max(e, n.getColumnCount());
      } else
        a = Math.max(a, 1), e = Math.max(e, 1);
  }), { maxRowLength: a, maxColumnLength: e };
}
function kr(i, a) {
  if (i.length === 0 || i.length % 2 !== 0)
    return {
      isError: !0,
      errorObject: g.create(m.VALUE),
      rangeIsDifferentSize: !1,
      criteriaMaxRowLength: 0,
      criteriaMaxColumnLength: 0,
      targetRange: null,
      variants: []
    };
  let e = null, t = -1, r = -1;
  if (a) {
    if (!a.isReferenceObject())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        rangeIsDifferentSize: !1,
        criteriaMaxRowLength: 0,
        criteriaMaxColumnLength: 0,
        targetRange: null,
        variants: []
      };
    e = a.toArrayValueObject(), t = e.getRowCount(), r = e.getColumnCount();
  }
  let n = 0, s = 0, o = !1;
  const u = [];
  for (let c = 0; c < i.length; c++)
    if (c % 2 === 1) {
      const l = i[c - 1], f = i[c];
      if (!l.isReferenceObject())
        return {
          isError: !0,
          errorObject: g.create(m.VALUE),
          rangeIsDifferentSize: !1,
          criteriaMaxRowLength: 0,
          criteriaMaxColumnLength: 0,
          targetRange: null,
          variants: []
        };
      const h = l.toArrayValueObject(), d = h.getRowCount(), _ = h.getColumnCount();
      c === 1 && t === -1 && r === -1 ? (t = d, r = _) : !o && (t !== d || r !== _) && (o = !0);
      let C = f;
      f.isReferenceObject() && (C = f.toArrayValueObject()), n = Math.max(n, C.isArray() ? C.getRowCount() : 1), s = Math.max(s, C.isArray() ? C.getColumnCount() : 1), u.push(h), u.push(C);
    }
  return {
    isError: !1,
    errorObject: null,
    rangeIsDifferentSize: o,
    criteriaMaxRowLength: n,
    criteriaMaxColumnLength: s,
    targetRange: e,
    variants: u
  };
}
function Gs(i) {
  return i.isArray() ? i : q.createByArray([[i.getValue()]]);
}
function $r(i, a, e, t = !1) {
  const r = [];
  for (let n = 0; n < i.length; n++) {
    if (n % 2 === 1) continue;
    const s = i[n], o = i[n + 1];
    O(a, e, o, g.create(m.NA)).iterator((c, l, f) => {
      if (!c)
        return;
      let h = Zn(s, c);
      if (t && (h = zn(h, s, c)), r[l] === void 0 && (r[l] = []), r[l][f] === void 0) {
        r[l][f] = h;
        return;
      }
      r[l][f] = Hf(r[l][f], h);
    });
  }
  return r;
}
function zn(i, a, e) {
  const [t, r] = Va(`${e.getValue()}`);
  return i.mapValue((n, s, o) => {
    const u = a.get(s, o);
    if (u && qf(u, r))
      return n;
    if (u != null && u.isError() && r.isError() && u.getValue() === r.getValue())
      return T.create(!0);
    if (t === F.EQUALS || t === F.NOT_EQUAL) {
      if (u != null && u.isNumber() && r.isString()) {
        const c = r.convertToNumberObjectValue();
        if (c.isNumber())
          return u.compare(c, t);
      }
      if (r.isNumber() && (u != null && u.isString())) {
        const c = u.convertToNumberObjectValue();
        if (c.isNumber())
          return c.compare(r, t);
      }
      if (t === F.EQUALS)
        return T.create(!1);
      if (t === F.NOT_EQUAL)
        return T.create(!0);
    }
    return T.create(!1);
  });
}
function qf(i, a) {
  if (i.isNumber() && a.isNumber() || i.isBoolean() && a.isBoolean())
    return !0;
  const e = i.isString() && i.getValue() === "", t = a.isString() && a.getValue() === "";
  return !!((e || i.isNull()) && (t || a.isNull()) || i.isString() && !e && a.isString() && !t);
}
var hn = /* @__PURE__ */ ((i) => (i[i.CELL = 0] = "CELL", i[i.COLUMN = 1] = "COLUMN", i[i.ROW = 2] = "ROW", i))(hn || {});
function Kf(i, a) {
  let e;
  switch (a) {
    case 0:
      e = new ya(i);
      break;
    case 1:
      e = new Ra(i);
      break;
    case 2:
      e = new pa(i);
      break;
    default:
      throw new Error("Unknown reference object type");
  }
  return e;
}
function Xf(i, a) {
  let e;
  return i.isCell() && a.isCell() || i.isRow() && a.isRow() || i.isColumn() && a.isColumn() ? e = i.unionBy(a) : e = g.create(m.NAME), e;
}
var Zf = Object.getOwnPropertyDescriptor, zf = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Zf(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Jf = (i, a) => (e, t) => a(e, t, i);
let Qs = class extends Ne {
  constructor(i) {
    super(), this._univerInstanceService = i;
  }
  generateCellValue(i, a) {
    if (a.trim() === "")
      return {
        v: ""
      };
    let e = i;
    if (i.startsWith("#") && so(i.slice(1))) {
      const { unitId: t, sheetName: r, range: n } = Dr(i.slice(1)), s = this._univerInstanceService.getCurrentUnitOfType(fr.UNIVER_SHEET);
      if (t === "" || t === s.getUnitId())
        if (r === "")
          e = `#gid=${s.getActiveSheet().getSheetId()}&range=${Ft(n)}`;
        else {
          const o = s.getSheetBySheetName(r);
          o && (e = `#gid=${o.getSheetId()}&range=${Ft(n)}`);
        }
    } else qe.isLegalUrl(i) && (e = qe.normalizeUrl(i));
    return {
      p: ac.create().insertLink(a, e).getData()
    };
  }
};
Qs = zf([
  Jf(0, Yn)
], Qs);
const Lo = Ze(
  "univer.formula.hyperlink-engine-formula.service"
);
var eh = Object.getOwnPropertyDescriptor, th = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? eh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, pi = (i, a) => (e, t) => a(e, t, i), Je = /* @__PURE__ */ ((i) => (i[i.IDLE = 0] = "IDLE", i[i.START = 1] = "START", i[i.START_DEPENDENCY = 2] = "START_DEPENDENCY", i[i.START_CALCULATION = 3] = "START_CALCULATION", i[i.CURRENTLY_CALCULATING = 4] = "CURRENTLY_CALCULATING", i[i.START_DEPENDENCY_ARRAY_FORMULA = 5] = "START_DEPENDENCY_ARRAY_FORMULA", i[i.START_CALCULATION_ARRAY_FORMULA = 6] = "START_CALCULATION_ARRAY_FORMULA", i[i.CURRENTLY_CALCULATING_ARRAY_FORMULA = 7] = "CURRENTLY_CALCULATING_ARRAY_FORMULA", i[i.CALCULATION_COMPLETED = 8] = "CALCULATION_COMPLETED", i))(Je || {}), Sr = /* @__PURE__ */ ((i) => (i[i.INITIAL = 0] = "INITIAL", i[i.STOP_EXECUTION = 1] = "STOP_EXECUTION", i[i.NOT_EXECUTED = 2] = "NOT_EXECUTED", i[i.SUCCESS = 3] = "SUCCESS", i))(Sr || {});
let Ws = class extends Ne {
  constructor(a, e) {
    super();
    A(this, "_formulaExecuteStage", 0);
    A(this, "_stopState", !1);
    A(this, "_currentRow", -1);
    A(this, "_currentColumn", -1);
    A(this, "_currentRowCount", Number.NEGATIVE_INFINITY);
    A(this, "_currentColumnCount", Number.NEGATIVE_INFINITY);
    A(this, "_currentSubUnitId", "");
    A(this, "_currentUnitId", "");
    A(this, "_runtimeData", {});
    A(this, "_runtimeOtherData", {});
    // Data returned by other businesses through formula calculation, excluding the sheet.
    A(this, "_unitArrayFormulaRange", {});
    A(this, "_runtimeArrayFormulaCellData", {});
    A(this, "_runtimeClearArrayFormulaCellData", {});
    A(this, "_runtimeFeatureRange", {});
    A(this, "_runtimeFeatureCellData", {});
    A(this, "_functionsExecutedState", 0);
    // lambdaId: { key: BaseAstNode }
    A(this, "_functionDefinitionPrivacyVar", /* @__PURE__ */ new Map());
    A(this, "_totalFormulasToCalculate", 0);
    A(this, "_completedFormulasCount", 0);
    A(this, "_totalArrayFormulasToCalculate", 0);
    A(this, "_completedArrayFormulasCount", 0);
    A(this, "_formulaCycleIndex", 0);
    A(this, "_isCycleDependency", !1);
    this._currentConfigService = a, this._hyperlinkEngineFormulaService = e;
  }
  get currentRow() {
    return this._currentRow;
  }
  get currentColumn() {
    return this._currentColumn;
  }
  get currentRowCount() {
    return this._currentRowCount;
  }
  get currentColumnCount() {
    return this._currentColumnCount;
  }
  get currentSubUnitId() {
    return this._currentSubUnitId;
  }
  get currentUnitId() {
    return this._currentUnitId;
  }
  dispose() {
    super.dispose(), this.reset(), this._runtimeFeatureCellData = {}, this._runtimeFeatureRange = {}, this.clearReferenceAndNumberformatCache();
  }
  enableCycleDependency() {
    this._isCycleDependency = !0;
  }
  disableCycleDependency() {
    this._isCycleDependency = !1;
  }
  isCycleDependency() {
    return this._isCycleDependency;
  }
  setFormulaCycleIndex(a) {
    this._formulaCycleIndex = a;
  }
  getFormulaCycleIndex() {
    return this._formulaCycleIndex;
  }
  setTotalArrayFormulasToCalculate(a) {
    this._totalArrayFormulasToCalculate = a;
  }
  getTotalArrayFormulasToCalculate() {
    return this._totalArrayFormulasToCalculate;
  }
  setCompletedArrayFormulasCount(a) {
    this._completedArrayFormulasCount = a;
  }
  getCompletedArrayFormulasCount() {
    return this._completedArrayFormulasCount;
  }
  setTotalFormulasToCalculate(a) {
    this._totalFormulasToCalculate = a;
  }
  getTotalFormulasToCalculate() {
    return this._totalFormulasToCalculate;
  }
  setCompletedFormulasCount(a) {
    this._completedFormulasCount = a;
  }
  getCompletedFormulasCount() {
    return this._completedFormulasCount;
  }
  markedAsSuccessfullyExecuted() {
    this._functionsExecutedState = 3;
  }
  markedAsNoFunctionsExecuted() {
    this._functionsExecutedState = 2;
  }
  markedAsStopFunctionsExecuted() {
    this._functionsExecutedState = 1;
  }
  markedAsInitialFunctionsExecuted() {
    this._functionsExecutedState = 0;
  }
  stopExecution() {
    this._stopState = !0, this.setFormulaExecuteStage(
      0
      /* IDLE */
    );
  }
  isStopExecution() {
    return this._stopState;
  }
  setFormulaExecuteStage(a) {
    this._formulaExecuteStage = a;
  }
  getFormulaExecuteStage() {
    return this._formulaExecuteStage;
  }
  reset() {
    this._formulaExecuteStage = 0, this._runtimeData = {}, this._runtimeOtherData = {}, this._unitArrayFormulaRange = {}, this._runtimeArrayFormulaCellData = {}, this._runtimeClearArrayFormulaCellData = {}, this._functionDefinitionPrivacyVar.clear(), this.markedAsInitialFunctionsExecuted(), this._stopState = !1, this._isCycleDependency = !1, this._totalFormulasToCalculate = 0, this._completedFormulasCount = 0, this.clearReferenceAndNumberformatCache();
  }
  clearReferenceAndNumberformatCache() {
    El(), Nl(), al();
  }
  setCurrent(a, e, t, r, n, s) {
    this._currentRow = a, this._currentColumn = e, this._currentRowCount = t, this._currentColumnCount = r, this._currentSubUnitId = n, this._currentUnitId = s;
  }
  clearFunctionDefinitionPrivacyVar() {
    this._functionDefinitionPrivacyVar.clear();
  }
  registerFunctionDefinitionPrivacyVar(a, e) {
    this._functionDefinitionPrivacyVar.set(a, e);
  }
  getFunctionDefinitionPrivacyVar(a) {
    return this._functionDefinitionPrivacyVar.get(a);
  }
  setRuntimeOtherData(a, e, t, r) {
    const n = this._currentSubUnitId, s = this._currentUnitId;
    this._runtimeOtherData[s] === void 0 && (this._runtimeOtherData[s] = {});
    const o = this._runtimeOtherData[s];
    (o[n] === void 0 || o[n] === null) && (o[n] = {});
    const u = o[n];
    let c = [];
    if (r.isReferenceObject() || r.isValueObject() && r.isArray()) {
      const l = r, { startRow: f, startColumn: h } = l.getRangePosition();
      l.iterator((d, _, C) => {
        const E = this._getValueObjectOfRuntimeData(d), b = _ - f, R = C - h;
        c[b] == null && (c[b] = []), c[b][R] = E;
      });
    } else
      c = [[this._getValueObjectOfRuntimeData(r)]];
    (u[a] === void 0 || u[a] === null) && (u[a] = {}), (u[a][t] === void 0 || u[a][t] === null) && (u[a][t] = {}), u[a][t][e] = c;
  }
  // eslint-disable-next-line max-lines-per-function
  setRuntimeData(a) {
    const e = this._currentRow, t = this._currentColumn, r = this._currentRowCount, n = this.currentColumnCount, s = this._currentSubUnitId, o = this._currentUnitId;
    this._runtimeData[o] == null && (this._runtimeData[o] = {});
    const u = this._runtimeData[o];
    u[s] == null && (u[s] = new Ce()), this._unitArrayFormulaRange[o] == null && (this._unitArrayFormulaRange[o] = {});
    const c = this._unitArrayFormulaRange[o];
    (c[s] === null || c[s] === void 0) && (c[s] = {});
    const l = new Ce(c[s]);
    this._runtimeArrayFormulaCellData[o] === void 0 && (this._runtimeArrayFormulaCellData[o] = {});
    const f = this._runtimeArrayFormulaCellData[o];
    f[s] == null && (f[s] = new Ce()), this._runtimeClearArrayFormulaCellData[o] === void 0 && (this._runtimeClearArrayFormulaCellData[o] = {});
    const h = this._runtimeClearArrayFormulaCellData[o];
    h[s] == null && (h[s] = new Ce());
    const d = u[s], _ = f[s], C = h[s];
    if (a.isReferenceObject() || a.isValueObject() && a.isArray()) {
      const E = a, { startRow: b, startColumn: R, endRow: p, endColumn: N } = E.getRangePosition();
      if (b === p && R === N) {
        const w = E.getFirstCell(), S = this._getValueObjectOfRuntimeData(w);
        d.setValue(e, t, S), C.setValue(e, t, S), We.set(
          o,
          s,
          t,
          w.getValue(),
          e,
          !0
        );
        return;
      }
      const M = {
        startRow: e,
        startColumn: t,
        endRow: p - b + e,
        endColumn: N - R + t
      };
      if (l.setValue(e, t, M), this._checkIfArrayFormulaRangeHasData(o, s, e, t, M) || this._checkIfArrayFormulaExceeded(r, n, M)) {
        const w = this._getValueObjectOfRuntimeData(g.create(m.SPILL));
        d.setValue(e, t, w), C.setValue(e, t, w), We.set(
          o,
          s,
          t,
          m.SPILL,
          e,
          !0
        );
        const S = this._currentConfigService.getUnitData();
        E.iterator((D, L, U) => {
          var ne, z;
          const x = L - b + e, k = U - R + t, Q = (z = (ne = S[o]) == null ? void 0 : ne[s]) == null ? void 0 : z.cellData.getValue(x, k);
          if (L === b && U === R)
            _.setValue(e, t, w);
          else if (Q != null)
            Q.v == null && (Q.v = ""), _.setValue(x, k, Q);
          else {
            if (this._isInOtherArrayFormulaRange(o, s, e, t, x, k))
              return !0;
            _.setValue(x, k, { v: "" });
          }
        });
      } else {
        const w = g.create(m.SPILL);
        E.iterator((S, D, L) => {
          We.set(
            o,
            s,
            t - R + L,
            S ? S.getValue() : 0,
            e - b + D,
            !0
          );
          const U = this._getValueObjectOfRuntimeData(S);
          if (D === b && L === R) {
            if (S != null && S.isError() && S.isEqualType(w))
              return C.setValue(e, t, {}), d.setValue(e, t, { ...this._getValueObjectOfRuntimeData(w) }), !1;
            d.setValue(e, t, { ...U });
          }
          const x = D - b + e, k = L - R + t;
          _.setValue(x, k, U);
        });
      }
    } else {
      const E = this._getValueObjectOfRuntimeData(a);
      d.setValue(e, t, E), We.set(
        o,
        s,
        t,
        a.getValue(),
        e,
        !0
      ), C.setValue(e, t, E);
    }
  }
  _getValueObjectOfRuntimeData(a) {
    return a != null && a.isString() && a.isHyperlink() ? this._hyperlinkEngineFormulaService.generateCellValue(
      a.getHyperlinkUrl(),
      a.getValue()
    ) : Qf(a);
  }
  getUnitData() {
    return this._runtimeData;
  }
  getUnitArrayFormula() {
    return this._unitArrayFormulaRange;
  }
  getRuntimeOtherData() {
    return this._runtimeOtherData;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  getRuntimeClearArrayFormulaCellData() {
    return this._runtimeClearArrayFormulaCellData;
  }
  getRuntimeFeatureRange() {
    return this._runtimeFeatureRange;
  }
  setRuntimeFeatureRange(a, e) {
    this._runtimeFeatureRange[a] = e;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(a, e) {
    this._runtimeFeatureCellData[a] = e;
  }
  getAllRuntimeData() {
    return {
      unitData: this.getUnitData(),
      arrayFormulaRange: this.getUnitArrayFormula(),
      unitOtherData: this.getRuntimeOtherData(),
      functionsExecutedState: this._functionsExecutedState,
      arrayFormulaCellData: this.getRuntimeArrayFormulaCellData(),
      clearArrayFormulaCellData: this.getRuntimeClearArrayFormulaCellData(),
      runtimeFeatureRange: this.getRuntimeFeatureRange(),
      runtimeFeatureCellData: this.getRuntimeFeatureCellData()
    };
  }
  getRuntimeState() {
    return {
      totalFormulasToCalculate: this.getTotalFormulasToCalculate(),
      completedFormulasCount: this.getCompletedFormulasCount(),
      totalArrayFormulasToCalculate: this.getTotalArrayFormulasToCalculate(),
      completedArrayFormulasCount: this.getCompletedArrayFormulasCount(),
      stage: this.getFormulaExecuteStage(),
      formulaCycleIndex: this.getFormulaCycleIndex()
    };
  }
  // eslint-disable-next-line complexity
  _checkIfArrayFormulaRangeHasData(a, e, t, r, n) {
    var h, d, _, C, E, b, R, p, N, M, w;
    const { startRow: s, startColumn: o, endRow: u, endColumn: c } = n, l = this._currentConfigService.getUnitData(), f = this._currentConfigService.getArrayFormulaCellData();
    (_ = (d = (h = this._unitArrayFormulaRange[a]) == null ? void 0 : h[e]) == null ? void 0 : d[t]) == null || _[r];
    for (let S = s; S <= u; S++)
      for (let D = o; D <= c; D++) {
        if (S === t && r === D)
          continue;
        const L = (b = (E = (C = this._runtimeData) == null ? void 0 : C[a]) == null ? void 0 : E[e]) == null ? void 0 : b.getValue(S, D);
        (p = (R = f == null ? void 0 : f[a]) == null ? void 0 : R[e]) == null || p.getValue(
          S,
          D
        );
        const U = (w = (M = (N = l == null ? void 0 : l[a]) == null ? void 0 : N[e]) == null ? void 0 : M.cellData) == null ? void 0 : w.getValue(S, D), x = this._getRuntimeFeatureCellValue(S, D, e, a);
        if (!cn(L) || this._isInOtherArrayFormulaRange(a, e, t, r, S, D) || !cn(U) || !cn(x))
          return !0;
      }
    return !1;
  }
  _getRuntimeFeatureCellValue(a, e, t, r) {
    return Ao(a, e, t, r, this._runtimeFeatureCellData);
  }
  _arrayCellHasData(a) {
    return a == null ? !1 : a.v !== void 0;
  }
  /**
   * If the current array formula in the extended area intersects with the existing array formula, a #SPILL! error will be reported. Note that if other array formulas are already #SPILL!, they will not conflict with the current array formula
   * @param formulaUnitId
   * @param formulaSheetId
   * @param formulaRow
   * @param formulaColumn
   * @param r
   * @param c
   * @returns
   */
  _isInOtherArrayFormulaRange(a, e, t, r, n, s) {
    var l;
    const o = (l = this._currentConfigService.getArrayFormulaRange()[a]) == null ? void 0 : l[e];
    if (o == null)
      return !1;
    let u = !1;
    return new Ce(o).forValue((f, h, d) => {
      var E, b;
      if (f === t && h === r)
        return;
      const _ = this._isInArrayFormulaRange(d, n, s), C = (b = (E = this._runtimeData[a]) == null ? void 0 : E[e]) == null ? void 0 : b.getValue(f, h);
      _ && (C == null ? void 0 : C.v) !== m.SPILL && (u = !0);
    }), u;
  }
  _isInArrayFormulaRange(a, e, t) {
    if (a == null)
      return !1;
    const { startRow: r, startColumn: n, endRow: s, endColumn: o } = a;
    return e >= r && e <= s && t >= n && t <= o;
  }
  _checkIfArrayFormulaExceeded(a, e, t) {
    return t.endRow >= a || t.endColumn >= e;
  }
  _isInDirtyRange(a, e, t, r) {
    const n = this._currentConfigService.getDirtyRanges();
    return n.length === 0 ? !0 : bc(n, a, e, t, r);
  }
};
Ws = th([
  pi(0, Yt),
  pi(1, Lo)
], Ws);
const St = Ze("univer.formula.runtime.service");
var ie = /* @__PURE__ */ ((i) => (i[i.REFERENCE = 1] = "REFERENCE", i[i.VALUE = 2] = "VALUE", i[i.OPERATOR = 3] = "OPERATOR", i[i.FUNCTION = 4] = "FUNCTION", i[i.LAMBDA = 5] = "LAMBDA", i[i.LAMBDA_PARAMETER = 6] = "LAMBDA_PARAMETER", i[i.ERROR = 7] = "ERROR", i[i.BASE = 8] = "BASE", i[i.ROOT = 9] = "ROOT", i[i.UNION = 10] = "UNION", i[i.PREFIX = 11] = "PREFIX", i[i.SUFFIX = 12] = "SUFFIX", i[i.NULL = 13] = "NULL", i))(ie || {});
const yt = /* @__PURE__ */ new Map([
  [1, 7],
  [2, 9],
  [3, 8],
  [4, 6],
  [5, 1],
  [6, 2],
  [9, 10],
  [10, 3],
  [11, 4],
  [12, 5]
]);
class Ge {
  constructor(a) {
    A(this, "_children", []);
    A(this, "_definedNames");
    A(this, "_parent");
    A(this, "_valueObject");
    A(this, "_calculateState", !1);
    A(this, "_async", !1);
    A(this, "_address", !1);
    A(this, "_isForcedCalculateFunction", !1);
    this._token = a;
  }
  dispose() {
    var a;
    this._children.forEach((e) => {
      e.dispose();
    }), (a = this._valueObject) == null || a.dispose(), this._valueObject = null, this._children = [], this._definedNames = null, this._parent = null;
  }
  get nodeType() {
    return ie.BASE;
  }
  isAsync() {
    return this._async;
  }
  isAddress() {
    return this._address;
  }
  isForcedCalculateFunction() {
    return this._isForcedCalculateFunction;
  }
  setAsync() {
    this._async = !0;
  }
  setAddress() {
    this._address = !0;
  }
  getParent() {
    return this._parent;
  }
  setParent(a) {
    this._parent = a, a.addChildren(this);
  }
  setForcedCalculateFunction() {
    this._isForcedCalculateFunction = !0;
  }
  getChildren() {
    return this._children;
  }
  addChildren(...a) {
    this._children.push(...a);
  }
  getToken() {
    return this._token;
  }
  setValue(a) {
    this._valueObject = a;
  }
  getValue() {
    return this._valueObject;
  }
  isCalculated() {
    return this._calculateState;
  }
  setCalculated() {
    this._calculateState = !0;
  }
  execute() {
  }
  setNotEmpty(a = !0) {
  }
  async executeAsync() {
    return Promise.resolve(Ut.SUCCESS);
  }
  serialize() {
    const a = this.getToken(), e = this.getChildren(), t = [], r = e.length;
    for (let s = 0; s < r; s++) {
      const o = e[s];
      t.push(o.serialize());
    }
    const n = {
      token: a,
      nodeType: this.nodeType
    };
    return r > 0 && (n.children = t), n;
  }
  hasDefinedName(a) {
    var e;
    return ((e = this._definedNames) == null ? void 0 : e.includes(a)) || !1;
  }
  setDefinedNames(a) {
    this._definedNames = a;
  }
  getDefinedNames() {
    return this._definedNames;
  }
}
class xe extends Ge {
  constructor(e) {
    super(e);
    A(this, "_errorValueObject");
    this._errorValueObject = g.create(e);
  }
  get nodeType() {
    return ie.ERROR;
  }
  static create(e) {
    return new xe(e);
  }
  getValue() {
    return this._errorValueObject;
  }
}
const Rt = 100;
class pt {
  get zIndex() {
    return 0;
  }
  dispose() {
  }
  create(a, e, t) {
    let r;
    return a instanceof ae ? r = a.getToken() : r = a, new Ge(r);
  }
}
class qs extends Ge {
  get nodeType() {
    return ie.ROOT;
  }
  execute() {
    const a = this.getChildren();
    if (a.length > 1) {
      this.setValue(g.create(m.VALUE));
      return;
    }
    const e = a[0];
    e == null ? this.setValue(g.create(m.VALUE)) : this.setValue(e.getValue());
  }
}
class Po extends pt {
  get zIndex() {
    return yt.get(ie.ROOT) || Rt;
  }
  checkAndCreateNodeType(a) {
    if (!(a instanceof ae))
      return;
    if (a.getToken() === Tt)
      return new qs(Tt);
  }
}
const rh = 5e3, jr = new wt(rh);
function Vi(i, a, e, t, r) {
  let n = jr.get(`${i}${a}`);
  if (n && !xo(n, r))
    return n;
  const s = e.treeBuilder(a);
  if (or.has(s))
    return xe.create(s);
  if (n = t.parse(s), n == null)
    throw new Error("astNode is null");
  return jr.set(`${i}${a}`, n), n;
}
function xo(i, a) {
  const e = a.getDirtyDefinedNameMap(), t = a.getExecuteUnitId();
  if (t != null && e[t] != null) {
    const r = Object.keys(e[t]);
    for (let n = 0, s = r.length; n < s; n++) {
      const o = r[n];
      if (i.hasDefinedName(o))
        return !0;
    }
  }
  return !1;
}
function nh(i, a, e) {
  return !!(a != null && xo(a, e));
}
const Qt = Ze("univer.formula-function.service");
class sh extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_functionExecutors", /* @__PURE__ */ new Map());
    A(this, "_functionDescriptions", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._functionExecutors.clear(), this._functionDescriptions.clear();
  }
  registerExecutors(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionExecutors.set(r.name, r);
    }
  }
  getExecutors() {
    return this._functionExecutors;
  }
  getExecutor(e) {
    return this._functionExecutors.get(e);
  }
  hasExecutor(e) {
    return this._functionExecutors.has(e);
  }
  unregisterExecutors(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionExecutors.delete(r);
    }
  }
  registerDescriptions(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionDescriptions.set(r.functionName, r);
    }
    return ic(() => {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        this._functionDescriptions.delete(r.functionName);
      }
    });
  }
  getDescriptions() {
    return this._functionDescriptions;
  }
  getDescription(e) {
    return this._functionDescriptions.get(e);
  }
  hasDescription(e) {
    return this._functionDescriptions.has(e);
  }
  unregisterDescriptions(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionDescriptions.delete(r);
    }
  }
  deleteFormulaAstCacheKey(...e) {
    jr.forEach((t, r) => {
      e.forEach((n) => {
        r.includes(n) && jr.delete(r);
      });
    });
  }
}
var Be = /* @__PURE__ */ ((i) => (i.COMPARE = "COMPARE", i.DIVIDED = "DIVIDED", i.MINUS = "MINUS", i.MULTIPLY = "MULTIPLY", i.PLUS = "PLUS", i.UNION = "UNION", i.CUBE = "CUBE", i))(Be || {}), ah = Object.getOwnPropertyDescriptor, ih = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ah(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Ni = (i, a) => (e, t) => a(e, t, i);
class Vn extends Ge {
  constructor(a, e, t) {
    super(e), this._runtimeService = a, this._operatorString = e, this._functionExecutor = t;
  }
  get nodeType() {
    return ie.PREFIX;
  }
  execute() {
    let e = this.getChildren()[0].getValue(), t;
    if (e == null)
      throw new Error("object is null");
    this._operatorString === Me.MINUS ? (e.isReferenceObject() && (e = e.toArrayValueObject()), t = this._functionExecutor.calculate(
      y.create(0),
      e
    )) : this._operatorString === Me.AT ? t = this._handlerAT(e) : t = g.create(m.VALUE), this.setValue(t);
  }
  _handlerAT(a) {
    if (!a.isReferenceObject())
      return g.create(m.VALUE);
    const e = a;
    if (e.isCell())
      return g.create(m.VALUE);
    const t = this._runtimeService, r = t.currentRow || 0, n = t.currentColumn || 0, s = e.getRangePosition(), { startRow: o, startColumn: u, endRow: c, endColumn: l } = s;
    return l !== u && c !== o || o === c && u === l ? g.create(m.VALUE) : c === o && n >= u && n <= l ? e.getCellByColumn(n) : u === l && r >= o && r <= c ? e.getCellByRow(r) : e.isTable() ? e.getCellByPosition(r) : g.create(m.VALUE);
  }
}
let Nn = class extends pt {
  constructor(i, a) {
    super(), this._functionService = i, this._runtimeService = a;
  }
  get zIndex() {
    return yt.get(ie.PREFIX) || Rt;
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ae))
      return;
    const a = i.getToken(), e = a.trim();
    if (e.charAt(0) === '"' && e.charAt(e.length - 1) === '"')
      return;
    let t = "";
    if (e === Me.MINUS)
      t = Be.MINUS;
    else return e === Me.AT ? new Vn(this._runtimeService, e) : void 0;
    const r = this._functionService.getExecutor(t);
    return r ? new Vn(this._runtimeService, e, r) : (console.error(`No function ${a}`), xe.create(m.NAME));
  }
};
Nn = ih([
  Ni(0, Qt),
  Ni(1, St)
], Nn);
new RegExp(Me.MINUS, "g");
new RegExp(Me.AT, "g");
function jo(i, a, e) {
  let t, r, n = i;
  const s = n.slice(0, 2);
  let o = 0;
  if (s[0] === Me.MINUS) {
    const u = a.getExecutor(Be.MINUS);
    t = new Vn(e, Me.MINUS, u), o++;
  }
  return s[0] === Me.AT && (r = new Vn(e, Me.AT), t && r.setParent(t), o++), o > 0 && (n = n.slice(o)), { tokenTrim: n, minusPrefixNode: t, atPrefixNode: r };
}
var oh = Object.getOwnPropertyDescriptor, uh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? oh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, ur = (i, a) => (e, t) => a(e, t, i);
class ch extends Ge {
  constructor(a, e, t, r, n, s) {
    super(a), this._functionExecutor = e, this._currentConfigService = t, this._runtimeService = r, this._definedNamesService = n, this._formulaDataModel = s, this._functionExecutor.isAsync() && this.setAsync(), this._functionExecutor.isAddress() && this.setAddress(), this._functionExecutor.needsLocale && this._setLocale(), this._functionExecutor.needsSheetsInfo && this._setSheetsInfo(), this._functionExecutor.needsFormulaDataModel && this._functionExecutor.setFormulaDataModel(this._formulaDataModel);
  }
  get nodeType() {
    return ie.FUNCTION;
  }
  async executeAsync() {
    const a = [], e = this.getChildren(), t = e.length;
    this._compatibility();
    for (let s = 0; s < t; s++) {
      const u = e[s].getValue();
      u != null && (u.isReferenceObject() && !this._functionExecutor.needsReferenceObject ? a.push(u.toArrayValueObject()) : a.push(u));
    }
    const r = await this._calculateAsync(a);
    let n;
    return r.isAsyncObject() || r.isAsyncArrayObject() ? n = await r.getValue() : n = r, this._setRefData(n), this.setValue(n), Promise.resolve(Ut.SUCCESS);
  }
  execute() {
    const a = [], e = this.getChildren(), t = e.length;
    this._compatibility();
    for (let n = 0; n < t; n++) {
      const o = e[n].getValue();
      o != null && (o.isReferenceObject() && this._functionExecutor.needsFilteredOutRows && this._setFilteredOutRows(o), o.isReferenceObject() && !this._functionExecutor.needsReferenceObject ? a.push(o.toArrayValueObject()) : a.push(o));
    }
    const r = this._calculate(a);
    this._setRefData(r), this.setValue(r);
  }
  isFunctionExecutorArgumentsIgnoreNumberPattern() {
    return this._functionExecutor.isArgumentsIgnoreNumberPattern();
  }
  /**
   * Compatibility handling for special functions.
   */
  _compatibility() {
    this._lookupCompatibility();
  }
  /**
   * The LOOKUP function follows the following rules when dealing with vectors of different sizes:
   *    If the lookup_vector is larger than the result_vector,
   *    the LOOKUP function will ignore the extra portion of the lookup_vector and only use the portion of the result_vector that is the same size as the lookup_vector for lookup and returning results.
   *    If the lookup_vector is smaller than the result_vector,
   *    the LOOKUP function will continue using the last value of the result_vector for lookup and returning results after the last value of the lookup_vector.
   */
  _lookupCompatibility() {
    const a = this.getChildren(), e = a.length;
    if (!this._functionExecutor.needsExpandParams || e !== 3)
      return;
    const t = a[1].getValue(), r = a[2].getValue();
    if (!(t != null && t.isReferenceObject()) && !(r != null && r.isReferenceObject()))
      return;
    let n, s;
    if (t != null && t.isReferenceObject()) {
      const _ = t.getRangeData(), { startRow: C, startColumn: E, endRow: b, endColumn: R } = _;
      n = b - C + 1, s = R - E + 1;
    } else
      n = t != null && t.isArray() ? t.getRowCount() : 1, s = t != null && t.isArray() ? t.getColumnCount() : 1;
    const o = r.getRangeData(), { startRow: u, startColumn: c, endRow: l, endColumn: f } = o, h = l - u + 1, d = f - c + 1;
    n !== h && (o.endRow += n - h), s !== d && (o.endColumn += s - d);
  }
  /**
   * Transform the result of a custom function to a NodeValueType.
   */
  _handleCustomResult(a) {
    var t;
    if (typeof a != "object" || a == null)
      return Mt.create(a);
    const e = Do(a);
    return q.create({
      calculateValueList: e,
      rowCount: e.length,
      columnCount: ((t = e[0]) == null ? void 0 : t.length) || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    });
  }
  _handleAddressFunction() {
    this._functionExecutor.isAddress() && this._setDefinedNamesForFunction();
  }
  _mapVariantsToValues(a) {
    return a.map((e) => e.isArray() ? e.toValue() : e.isLambda() ? e : e.getValue());
  }
  _calculate(a) {
    const { minParams: e, maxParams: t } = this._functionExecutor;
    if (e !== -1 && t !== -1 && (a.length < e || a.length > t))
      return g.create(m.NA);
    let r;
    if (this._setRefInfo(), this._functionExecutor.isCustom()) {
      const n = this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(a)
      );
      r = this._handleCustomResult(n);
    } else
      this._handleAddressFunction(), r = this._functionExecutor.calculate(...a);
    return r;
  }
  async _calculateAsync(a) {
    const { minParams: e, maxParams: t } = this._functionExecutor;
    if (e !== -1 && t !== -1 && (a.length < e || a.length > t))
      return g.create(m.NA);
    let r;
    if (this._setRefInfo(), this._functionExecutor.isCustom()) {
      const n = await this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(a)
      );
      r = this._handleCustomResult(n);
    } else
      this._handleAddressFunction(), r = this._functionExecutor.calculate(...a);
    return r;
  }
  _setDefinedNamesForFunction() {
    const a = this._currentConfigService.getExecuteUnitId();
    if (a == null)
      return;
    const e = this._definedNamesService.getDefinedNameMap(a);
    e != null && this._functionExecutor.setDefinedNames(e);
  }
  _setRefInfo() {
    const { currentUnitId: a, currentSubUnitId: e, currentRow: t, currentColumn: r } = this._runtimeService;
    if (this._functionExecutor.setRefInfo(a, e, t, r), this._functionExecutor.needsSheetRowColumnCount) {
      const { rowCount: n, columnCount: s } = this._currentConfigService.getSheetRowColumnCount(a, e);
      this._functionExecutor.setSheetRowColumnCount(n, s);
    }
  }
  _setRefData(a) {
    if (!a.isReferenceObject())
      return;
    const e = a;
    e.setForcedSheetId(this._currentConfigService.getSheetNameMap()), e.setUnitData(this._currentConfigService.getUnitData()), e.setArrayFormulaCellData(this._currentConfigService.getArrayFormulaCellData()), e.setRuntimeData(this._runtimeService.getUnitData()), e.setRuntimeArrayFormulaCellData(this._runtimeService.getRuntimeArrayFormulaCellData()), e.setRuntimeFeatureCellData(this._runtimeService.getRuntimeFeatureCellData());
  }
  _setLocale() {
    this._functionExecutor.setLocale(this._currentConfigService.getLocale());
  }
  _setSheetsInfo() {
    this._functionExecutor.setSheetsInfo(this._currentConfigService.getSheetsInfo());
  }
  _setFilteredOutRows(a) {
    const { startRow: e, endRow: t } = a.getRangePosition(), r = this._currentConfigService.getFilteredOutRows(
      a.getUnitId(),
      a.getSheetId(),
      e,
      t
    );
    a.setFilteredOutRows(r);
  }
}
class lh extends Ge {
  constructor(a = "Error") {
    super(a);
  }
  get nodeType() {
    return ie.FUNCTION;
  }
  async executeAsync() {
    return this.setValue(g.create(m.NAME)), Promise.resolve(Ut.SUCCESS);
  }
  execute() {
    this.setValue(g.create(m.NAME));
  }
}
let On = class extends pt {
  constructor(i, a, e, t, r, n) {
    super(), this._functionService = i, this._currentConfigService = a, this._runtimeService = e, this._definedNamesService = t, this._injector = r, this._formulaDataModel = n;
  }
  get zIndex() {
    return yt.get(ie.FUNCTION) || Rt;
  }
  create(i) {
    const a = this._functionService.getExecutor(i);
    return a ? new ch(
      i,
      a,
      this._currentConfigService,
      this._runtimeService,
      this._definedNamesService,
      this._formulaDataModel
    ) : (console.error(`No function ${i}`), xe.create(m.NAME));
  }
  checkAndCreateNodeType(i) {
    if (typeof i == "string")
      return;
    const a = i.getToken(), { tokenTrim: e, minusPrefixNode: t, atPrefixNode: r } = jo(a.trim(), this._functionService, this._runtimeService);
    if (!Number.isNaN(Number(e)) && !this._isParentUnionNode(i))
      return xe.create(m.VALUE);
    const n = e.toUpperCase();
    if (this._functionService.hasExecutor(n)) {
      const s = this.create(n);
      return r ? s.setParent(r) : t && s.setParent(t), s;
    }
  }
  _isParentUnionNode(i) {
    var a, e;
    return ((e = (a = i.getParent()) == null ? void 0 : a.getParent()) == null ? void 0 : e.getToken()) === K.COLON;
  }
};
On = uh([
  ur(0, Qt),
  ur(1, Yt),
  ur(2, St),
  ur(3, Nr),
  ur(4, ye(Ki)),
  ur(5, ye(_r))
], On);
var fh = Object.getOwnPropertyDescriptor, hh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? fh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, mh = (i, a) => (e, t) => a(e, t, i);
let br = class extends Ne {
  constructor(i) {
    super(), this._runtimeService = i;
  }
  async executeAsync(i) {
    if (!i || !i.node)
      return Promise.resolve(g.create(m.VALUE));
    const a = i.node, e = i.refOffsetX, t = i.refOffsetY;
    await this._executeAsync(a, e, t);
    const r = a.getValue();
    return r == null ? Promise.resolve(g.create(m.VALUE)) : Promise.resolve(r);
  }
  execute(i) {
    if (!i || !i.node)
      return g.create(m.VALUE);
    const a = i.node, e = i.refOffsetX, t = i.refOffsetY;
    this._execute(a, e, t);
    const r = a.getValue();
    return r == null ? g.create(m.VALUE) : r;
  }
  executePreCalculateNode(i) {
    return i.execute(), i.getValue();
  }
  checkAsyncNode(i) {
    if (i == null)
      return !1;
    const a = [];
    this._checkAsyncNode(i, a);
    for (let e = 0, t = a.length; e < t; e++)
      if (a[e] === !0)
        return !0;
    return !1;
  }
  _checkAsyncNode(i, a) {
    const e = i.getChildren(), t = e.length;
    for (let r = 0; r < t; r++) {
      const n = e[r];
      a.push(n.isAsync()), this._checkAsyncNode(n, a);
    }
  }
  async _executeAsync(i, a = 0, e = 0) {
    if (this._runtimeService.isStopExecution())
      return Promise.resolve(Ut.ERROR);
    const t = i.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken().toUpperCase() === Lr && s.isEmptyParamFunction()) {
        s.execute();
        continue;
      }
      await this._executeAsync(s, a, e);
    }
    return i.nodeType === ie.REFERENCE && i.setRefOffset(a, e), i.nodeType === ie.FUNCTION && i.isAsync() ? await i.executeAsync() : i.execute(), Promise.resolve(Ut.SUCCESS);
  }
  _execute(i, a = 0, e = 0) {
    if (this._runtimeService.isStopExecution())
      return Ut.ERROR;
    const t = i.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken().toUpperCase() === Lr && s.isEmptyParamFunction()) {
        s.execute();
        continue;
      }
      this._execute(s, a, e);
    }
    return i.nodeType === ie.REFERENCE && i.setRefOffset(a, e), i.execute(), Ut.SUCCESS;
  }
};
br = hh([
  mh(0, St)
], br);
function Uo(i) {
  return i instanceof ae ? i.getToken() === dr : !1;
}
function gh(i) {
  return i instanceof ae ? i.getToken() === mo : !1;
}
function Na(i, a, e) {
  const t = i.getChildren(), r = t.length, n = t[0];
  for (let s = 0; s < r; s++) {
    const o = t[s];
    if (!(Uo(n) && s !== 0))
      if (o instanceof ae)
        Na(o, a, e);
      else {
        const u = o.trim();
        if (e.has(u)) {
          const c = new ae();
          c.setToken(Ir), c.setLambdaId(a), c.setLambdaPrivacyVar(e), c.setLambdaParameter(u), t[s] = c;
        }
      }
  }
}
function dh(i) {
  let a = i;
  for (; a != null && a.getParent(); )
    a = a.getParent();
  return a;
}
function Oi(i, a = 0, e = 0) {
  return {
    node: i,
    refOffsetX: a,
    refOffsetY: e
  };
}
function vo(i) {
  if (!i)
    return;
  if (i.getToken() !== Ir)
    return i;
  const a = i, e = a.getCurrentLambdaPrivacyVar(), t = a.getLambdaParameter();
  if (!e)
    return;
  const r = e.get(t);
  return r == null && i.getValue() ? i : vo(r);
}
class Oa extends Ht {
  constructor(e, t, r) {
    super(0);
    A(this, "_lambdaPrivacyValueMap", /* @__PURE__ */ new Map());
    this._lambdaNode = e, this._interpreter = t, this._lambdaPrivacyVarKeys = r, this._lambdaPrivacyValueMap.clear();
  }
  static create(e, t, r) {
    return new Oa(e, t, r);
  }
  dispose() {
    this._lambdaPrivacyValueMap.clear(), this._lambdaPrivacyValueMap = /* @__PURE__ */ new Map(), this._lambdaNode = null, this._interpreter = null, this._lambdaPrivacyVarKeys = [];
  }
  isLambda() {
    return !0;
  }
  execute(...e) {
    const t = this._lambdaPrivacyVarKeys.length;
    if (e.length !== t || !this._interpreter || !this._lambdaNode)
      return g.create(m.VALUE);
    this._setLambdaPrivacyValueMap(e), this._setLambdaNodeValue(this._lambdaNode), this._lambdaNode.setNotEmpty(!1);
    let r;
    if (this._interpreter.checkAsyncNode(this._lambdaNode))
      r = new $f(this._interpreter.executeAsync(Oi(this._lambdaNode)));
    else {
      const n = this._interpreter.execute(Oi(this._lambdaNode));
      n.isReferenceObject() ? r = n.toArrayValueObject() : r = n;
    }
    return this._lambdaNode.setNotEmpty(!0), r;
  }
  /**
   * Execute custom lambda function, handle basic types
   * @param variants
   */
  executeCustom(...e) {
    const t = e.map((r) => Mt.create(r));
    return this.execute(...t);
  }
  _setLambdaNodeValue(e) {
    if (!e)
      return;
    const t = e.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken() === Ir) {
        const u = s.getLambdaParameter(), c = this._lambdaPrivacyValueMap.get(u);
        if (c)
          s.setValue(c);
        else {
          const l = s.getCurrentLambdaPrivacyVar(), f = vo(l.get(u));
          f != null && s.setValue(f.getValue());
        }
        continue;
      }
      this._setLambdaNodeValue(s);
    }
  }
  _setLambdaPrivacyValueMap(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = this._lambdaPrivacyVarKeys[t];
      this._lambdaPrivacyValueMap.set(n, r);
    }
  }
  getLambdaPrivacyVarKeys() {
    return this._lambdaPrivacyVarKeys;
  }
}
var Ch = Object.getOwnPropertyDescriptor, _h = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Ch(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Mi = (i, a) => (e, t) => a(e, t, i);
class Ah extends Ge {
  constructor(e, t, r, n) {
    super(e);
    A(this, "_isNotEmpty", !0);
    this._lambdaId = t, this._interpreter = r, this._lambdaPrivacyVarKeys = n;
  }
  get nodeType() {
    return ie.LAMBDA;
  }
  setNotEmpty(e = !1) {
    this._isNotEmpty = e;
  }
  isEmptyParamFunction() {
    return this.getChildren().length < 2 && this._isNotEmpty;
  }
  isFunctionParameter() {
    return this._lambdaId === null;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  execute() {
    if (this.isEmptyParamFunction())
      this.setValue(Oa.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
    else {
      const e = this.getChildren(), t = e.length;
      this.setValue(e[t - 1].getValue());
    }
  }
  // override async executeAsync() {
  //     if (this.isEmptyParamFunction()) {
  //         await this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
  //     } else {
  //         const children = this.getChildren();
  //         const childrenCount = children.length;
  //         await this.setValue(children[childrenCount - 1].getValue());
  //     }
  //     return Promise.resolve(AstNodePromiseType.SUCCESS);
  // }
}
let Mn = class extends pt {
  constructor(i, a) {
    super(), this._runtimeService = i, this._interpreter = a;
  }
  get zIndex() {
    return yt.get(ie.LAMBDA) || Rt;
  }
  create(i) {
    const a = i.getChildren(), e = a[0];
    let t = a.slice(1, -1);
    const r = a[a.length - 1];
    if (!(e instanceof ae && r instanceof ae))
      return xe.create(m.NAME);
    if (e.getToken() === dr) {
      const o = e.getChildren();
      if (t.length !== o.length)
        return xe.create(m.VALUE);
    } else
      t = a.slice(0, -1);
    const n = oc(8), s = /* @__PURE__ */ new Map();
    for (let o = 0; o < t.length; o++) {
      const u = t[o];
      if (u instanceof ae) {
        const c = u.getChildren()[0];
        u.setToken(mo), s.set(c.trim(), void 0);
      } else
        return xe.create(m.VALUE);
    }
    return this._runtimeService.registerFunctionDefinitionPrivacyVar(n, s), this._updateLambdaStatement(r, n, s), new Ah(i.getToken(), n, this._interpreter, [...s.keys()]);
  }
  checkAndCreateNodeType(i) {
    if (!(!(i instanceof ae) || i.getToken().trim().toUpperCase() !== Lr))
      return this.create(i);
  }
  _updateLambdaStatement(i, a, e) {
    Na(i, a, e);
  }
};
Mn = _h([
  Mi(0, St),
  Mi(1, ye(br))
], Mn);
function To(i) {
  if (!i)
    return;
  if (i.getToken() !== Ir)
    return i;
  const a = i, e = a.getCurrentLambdaPrivacyVar(), t = a.getLambdaParameter();
  if (e)
    return To(e.get(t));
}
class Eh extends Ge {
  constructor(a, e, t) {
    super(a), this._lambdaParameter = e, this._currentLambdaPrivacyVar = t;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  getCurrentLambdaPrivacyVar() {
    return this._currentLambdaPrivacyVar;
  }
  get nodeType() {
    return ie.LAMBDA_PARAMETER;
  }
  execute() {
    const a = To(this._currentLambdaPrivacyVar.get(this._lambdaParameter));
    if (a)
      this.setValue(a.getValue());
    else {
      const e = this.getValue();
      (e == null || e.isError()) && this.setValue(g.create(m.NAME));
    }
  }
}
class Bo extends pt {
  get zIndex() {
    return yt.get(ie.LAMBDA_PARAMETER) || Rt;
  }
  create(a) {
    const e = a.getFunctionDefinitionPrivacyVar(), t = a.getLambdaParameter();
    return e ? new Eh(a.getToken(), t, e) : new xe(m.NAME);
  }
  checkAndCreateNodeType(a) {
    if (!(!(a instanceof ae) || a.getToken().trim() !== Ir))
      return this.create(a);
  }
}
class bh extends Ge {
  constructor(a) {
    super(a), this._operatorString = a;
  }
  get nodeType() {
    return ie.NULL;
  }
  execute() {
    this.setValue(ce.create());
  }
}
var Y = /* @__PURE__ */ ((i) => (i.ABS = "ABS", i.ACOS = "ACOS", i.ACOSH = "ACOSH", i.ACOT = "ACOT", i.ACOTH = "ACOTH", i.AGGREGATE = "AGGREGATE", i.ARABIC = "ARABIC", i.ASIN = "ASIN", i.ASINH = "ASINH", i.ATAN = "ATAN", i.ATAN2 = "ATAN2", i.ATANH = "ATANH", i.BASE = "BASE", i.CEILING = "CEILING", i.CEILING_MATH = "CEILING.MATH", i.CEILING_PRECISE = "CEILING.PRECISE", i.COMBIN = "COMBIN", i.COMBINA = "COMBINA", i.COS = "COS", i.COSH = "COSH", i.COT = "COT", i.COTH = "COTH", i.CSC = "CSC", i.CSCH = "CSCH", i.DECIMAL = "DECIMAL", i.DEGREES = "DEGREES", i.EVEN = "EVEN", i.EXP = "EXP", i.FACT = "FACT", i.FACTDOUBLE = "FACTDOUBLE", i.FLOOR = "FLOOR", i.FLOOR_MATH = "FLOOR.MATH", i.FLOOR_PRECISE = "FLOOR.PRECISE", i.GCD = "GCD", i.INT = "INT", i.ISO_CEILING = "ISO.CEILING", i.LCM = "LCM", i.LET = "LET", i.LN = "LN", i.LOG = "LOG", i.LOG10 = "LOG10", i.MDETERM = "MDETERM", i.MINVERSE = "MINVERSE", i.MMULT = "MMULT", i.MOD = "MOD", i.MROUND = "MROUND", i.MULTINOMIAL = "MULTINOMIAL", i.MUNIT = "MUNIT", i.ODD = "ODD", i.PI = "PI", i.POWER = "POWER", i.PRODUCT = "PRODUCT", i.QUOTIENT = "QUOTIENT", i.RADIANS = "RADIANS", i.RAND = "RAND", i.RANDARRAY = "RANDARRAY", i.RANDBETWEEN = "RANDBETWEEN", i.ROMAN = "ROMAN", i.ROUND = "ROUND", i.ROUNDBANK = "ROUNDBANK", i.ROUNDDOWN = "ROUNDDOWN", i.ROUNDUP = "ROUNDUP", i.SEC = "SEC", i.SECH = "SECH", i.SERIESSUM = "SERIESSUM", i.SEQUENCE = "SEQUENCE", i.SIGN = "SIGN", i.SIN = "SIN", i.SINH = "SINH", i.SQRT = "SQRT", i.SQRTPI = "SQRTPI", i.SUBTOTAL = "SUBTOTAL", i.SUM = "SUM", i.SUMIF = "SUMIF", i.SUMIFS = "SUMIFS", i.SUMPRODUCT = "SUMPRODUCT", i.SUMSQ = "SUMSQ", i.SUMX2MY2 = "SUMX2MY2", i.SUMX2PY2 = "SUMX2PY2", i.SUMXMY2 = "SUMXMY2", i.TAN = "TAN", i.TANH = "TANH", i.TRUNC = "TRUNC", i))(Y || {}), se = /* @__PURE__ */ ((i) => (i.ASC = "ASC", i.ARRAYTOTEXT = "ARRAYTOTEXT", i.BAHTTEXT = "BAHTTEXT", i.CHAR = "CHAR", i.CLEAN = "CLEAN", i.CODE = "CODE", i.CONCAT = "CONCAT", i.CONCATENATE = "CONCATENATE", i.DBCS = "DBCS", i.DOLLAR = "DOLLAR", i.EXACT = "EXACT", i.FIND = "FIND", i.FINDB = "FINDB", i.FIXED = "FIXED", i.LEFT = "LEFT", i.LEFTB = "LEFTB", i.LEN = "LEN", i.LENB = "LENB", i.LOWER = "LOWER", i.MID = "MID", i.MIDB = "MIDB", i.NUMBERSTRING = "NUMBERSTRING", i.NUMBERVALUE = "NUMBERVALUE", i.PHONETIC = "PHONETIC", i.PROPER = "PROPER", i.REGEXEXTRACT = "REGEXEXTRACT", i.REGEXMATCH = "REGEXMATCH", i.REGEXREPLACE = "REGEXREPLACE", i.REPLACE = "REPLACE", i.REPLACEB = "REPLACEB", i.REPT = "REPT", i.RIGHT = "RIGHT", i.RIGHTB = "RIGHTB", i.SEARCH = "SEARCH", i.SEARCHB = "SEARCHB", i.SUBSTITUTE = "SUBSTITUTE", i.T = "T", i.TEXT = "TEXT", i.TEXTAFTER = "TEXTAFTER", i.TEXTBEFORE = "TEXTBEFORE", i.TEXTJOIN = "TEXTJOIN", i.TEXTSPLIT = "TEXTSPLIT", i.TRIM = "TRIM", i.UNICHAR = "UNICHAR", i.UNICODE = "UNICODE", i.UPPER = "UPPER", i.VALUE = "VALUE", i.VALUETOTEXT = "VALUETOTEXT", i.CALL = "CALL", i.EUROCONVERT = "EUROCONVERT", i.REGISTER_ID = "REGISTER.ID", i))(se || {}), yh = Object.getOwnPropertyDescriptor, Rh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? yh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, ph = (i, a) => (e, t) => a(e, t, i);
class Vh extends Ge {
  constructor(a, e) {
    super(a), this._functionExecutor = e;
  }
  get nodeType() {
    return ie.OPERATOR;
  }
  execute() {
    const a = this.getChildren();
    this._functionExecutor.name === Be.COMPARE && this._functionExecutor.setCompareType(this.getToken());
    const e = a[0], t = a[1];
    let r = e == null ? void 0 : e.getValue(), n = t == null ? void 0 : t.getValue();
    const s = this.getToken();
    if ((r == null || n == null) && s !== X.MINUS && s !== X.PLUS) {
      this.setValue(g.create(m.VALUE));
      return;
    }
    r == null && (r = ce.create()), n == null && (n = ce.create()), r.isReferenceObject() && (r = r.toArrayValueObject()), n.isReferenceObject() && (n = n.toArrayValueObject()), this.setValue(
      this._functionExecutor.calculate(
        r,
        n
      )
    );
  }
}
let wn = class extends pt {
  constructor(i) {
    super(), this._functionService = i;
  }
  get zIndex() {
    return yt.get(ie.OPERATOR) || Rt;
  }
  create(i) {
    let a = "";
    const e = i;
    e === X.PLUS ? a = Be.PLUS : e === X.MINUS ? a = Be.MINUS : e === X.MULTIPLY ? a = Be.MULTIPLY : e === X.DIVIDED ? a = Be.DIVIDED : e === X.CONCATENATE ? a = se.CONCATENATE : e === X.POWER ? a = Y.POWER : Rc.has(e) && (a = Be.COMPARE);
    const t = this._functionService.getExecutor(a);
    return t ? new Vh(e, t) : (console.error(`No function ${i}`), xe.create(m.NAME));
  }
  checkAndCreateNodeType(i) {
    if (i instanceof ae)
      return;
    const a = i.trim();
    if (!(a.charAt(0) === '"' && a.charAt(a.length - 1) === '"') && xt.has(a))
      return this.create(a);
  }
};
wn = Rh([
  ph(0, Qt)
], wn);
var Nh = Object.getOwnPropertyDescriptor, Oh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Nh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, _s = (i, a) => (e, t) => a(e, t, i);
class As extends Ge {
  constructor(e, t, r, n, s = !1) {
    super(r);
    A(this, "_refOffsetX", 0);
    A(this, "_refOffsetY", 0);
    this._currentConfigService = e, this._runtimeService = t, this._referenceObjectType = n, this._isPrepareMerge = s;
  }
  get nodeType() {
    return ie.REFERENCE;
  }
  execute() {
    const e = this._currentConfigService, t = this._runtimeService, r = Kf(this.getToken(), this._referenceObjectType);
    r.setDefaultUnitId(t.currentUnitId), r.setDefaultSheetId(t.currentSubUnitId), r.setForcedSheetId(e.getSheetNameMap()), r.setUnitData(e.getUnitData()), r.setArrayFormulaCellData(e.getArrayFormulaCellData()), r.setRuntimeData(t.getUnitData()), r.setUnitStylesData(e.getUnitStylesData()), r.setRuntimeArrayFormulaCellData(t.getRuntimeArrayFormulaCellData()), r.setRuntimeFeatureCellData(t.getRuntimeFeatureCellData());
    const { x: n, y: s } = this.getRefOffset();
    r.setRefOffset(n, s), !this._isPrepareMerge && r.isExceedRange() ? this.setValue(g.create(m.NAME)) : this.setValue(r);
  }
  setRefOffset(e = 0, t = 0) {
    this._refOffsetX = e, this._refOffsetY = t;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
}
let Sn = class extends pt {
  constructor(i, a, e) {
    super(), this._currentConfigService = i, this._formulaRuntimeService = a, this._functionService = e;
  }
  get zIndex() {
    return yt.get(ie.REFERENCE) || Rt;
  }
  checkAndCreateNodeType(i) {
    var l, f;
    let a = !1, e, t = !1;
    i instanceof ae ? (a = !0, e = i.getToken().trim(), ((f = (l = i.getParent()) == null ? void 0 : l.getParent()) == null ? void 0 : f.getToken().trim()) === K.COLON && (t = !0)) : e = i.trim();
    const r = this._currentConfigService, n = this._formulaRuntimeService, { tokenTrim: s, minusPrefixNode: o, atPrefixNode: u } = jo(e, this._functionService, n);
    if (!a && s.charAt(0) === '"' && s.charAt(s.length - 1) === '"')
      return;
    let c;
    if (Br(s) ? c = new As(r, n, s, hn.CELL, t) : a && this._checkParentIsUnionOperator(i) && (ro(s) ? c = new As(r, n, s, hn.ROW, t) : no(s) && (c = new As(r, n, s, hn.COLUMN, t))), c)
      return u ? c.setParent(u) : o && c.setParent(o), c;
  }
  _checkParentIsUnionOperator(i) {
    var a, e;
    return ((e = (a = i.getParent()) == null ? void 0 : a.getParent()) == null ? void 0 : e.getToken().trim()) === K.COLON;
  }
};
Sn = Oh([
  _s(0, Yt),
  _s(1, St),
  _s(2, Qt)
], Sn);
var Mh = Object.getOwnPropertyDescriptor, wh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Mh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Es = (i, a) => (e, t) => a(e, t, i);
class wi extends Ge {
  constructor(a, e, t, r) {
    super(t), this._currentConfigService = a, this._lexer = e, this._operatorString = t, this._functionExecutor = r;
  }
  get nodeType() {
    return ie.SUFFIX;
  }
  execute() {
    var r;
    let e = (r = this.getChildren()[0]) == null ? void 0 : r.getValue(), t;
    if (e == null) {
      this.setValue(g.create(m.ERROR));
      return;
    }
    if (this._operatorString === tt.PERCENTAGE) {
      if (e.isReferenceObject() && (e = e.toArrayValueObject()), t = this._functionExecutor.calculate(
        e,
        y.create(100)
      ), t.isNumber()) {
        const n = Number(t.getValue());
        t = y.create(n, "0.00%");
      }
    } else this._operatorString === tt.POUND ? t = this._handlerPound(e) : t = g.create(m.VALUE);
    this.setValue(t);
  }
  _handlerPound(a) {
    var u, c, l, f;
    if (!a.isReferenceObject() || !a.isCell())
      return g.create(m.VALUE);
    const e = a, t = e.getRangePosition(), r = e.getUnitId(), n = e.getSheetId(), s = this._currentConfigService.getFormulaData(), o = (f = (l = (c = (u = s == null ? void 0 : s[r]) == null ? void 0 : u[n]) == null ? void 0 : c[t.startRow]) == null ? void 0 : l[t.startColumn]) == null ? void 0 : f.f;
    return o && this._lexer.treeBuilder(o), g.create(m.VALUE);
  }
}
let Dn = class extends pt {
  constructor(i, a, e) {
    super(), this._functionService = i, this._lexer = a, this._currentConfigService = e;
  }
  get zIndex() {
    return yt.get(ie.SUFFIX) || Rt;
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ae))
      return;
    const a = i.getToken().trim();
    if (a.charAt(0) === '"' && a.charAt(a.length - 1) === '"')
      return;
    let e = "";
    if (a === tt.PERCENTAGE)
      e = Be.DIVIDED;
    else return a === tt.POUND ? new wi(this._currentConfigService, this._lexer, a) : void 0;
    const t = this._functionService.getExecutor(e);
    return t ? new wi(this._currentConfigService, this._lexer, a, t) : (console.error(`No function ${i}`), xe.create(m.NAME));
  }
};
Dn = wh([
  Es(0, Qt),
  Es(1, ye(Ar)),
  Es(2, Yt)
], Dn);
var Sh = Object.getOwnPropertyDescriptor, Dh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Sh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Lh = (i, a) => (e, t) => a(e, t, i);
class Ph extends Ge {
  constructor(a) {
    super(a);
  }
  get nodeType() {
    return ie.UNION;
  }
  execute() {
    const a = this.getChildren(), e = a[0], t = a[1], r = e.getValue(), n = t.getValue();
    if (r == null || n == null)
      throw new Error("leftNode and rightNode");
    let s;
    this.getToken() === K.COLON ? s = this._unionFunction(r, n) : s = g.create(m.NAME), this.setValue(s);
  }
  _unionFunction(a, e) {
    return a.isError() || e.isError() || !a.isReferenceObject() || !e.isReferenceObject() ? g.create(m.REF) : (a = a, e = e, Xf(a, e));
  }
}
let Ln = class extends pt {
  constructor(i) {
    super(), this._functionService = i;
  }
  get zIndex() {
    return yt.get(ie.UNION) || Rt;
  }
  create(i) {
    return new Ph(i);
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ae))
      return;
    const e = i.getToken().trim();
    if (!(e.charAt(0) === '"' && e.charAt(e.length - 1) === '"') && e === K.COLON)
      return this.create(e);
  }
};
Ln = Dh([
  Lh(0, Qt)
], Ln);
class xh extends Ge {
  constructor(a) {
    super(a);
  }
  get nodeType() {
    return ie.VALUE;
  }
  execute() {
    var e, t, r;
    const a = ((e = this.getParent()) == null ? void 0 : e.nodeType) === ie.FUNCTION && ((r = (t = this.getParent()) == null ? void 0 : t.isFunctionExecutorArgumentsIgnoreNumberPattern) == null ? void 0 : r.call(t));
    this.setValue(Mt.create(this.getToken(), a));
  }
}
class Io extends pt {
  get zIndex() {
    return yt.get(ie.VALUE) || Rt;
  }
  _checkValueNode(a) {
    if (Number.isNaN(Number(a))) {
      const e = a.trim(), t = e.charAt(0), r = e.charAt(e.length - 1);
      if (or.has(e))
        return this.create(e);
      if (t === '"' && r === '"')
        return this.create(e);
      if (t === "{" && r === "}")
        return this.create(e);
      const n = e.toUpperCase();
      if (n === rr.TRUE || n === rr.FALSE)
        return this.create(n);
    } else
      return this.create(a);
  }
  create(a) {
    return new xh(a);
  }
  checkAndCreateNodeType(a) {
    if (!(a instanceof ae))
      return this._checkValueNode(a);
  }
}
var jh = Object.getOwnPropertyDescriptor, Uh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? jh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, ut = (i, a) => (e, t) => a(e, t, i);
let Ur = class extends Ne {
  constructor(a, e, t, r, n, s, o, u, c, l, f) {
    super();
    A(this, "_astNodeFactoryList", []);
    this._runtimeService = a, this._astRootNodeFactory = e, this._functionNodeFactory = t, this._lambdaNodeFactory = r, this._lambdaParameterNodeFactory = n, this._operatorNodeFactory = s, this._prefixNodeFactory = o, this._referenceNodeFactory = u, this._suffixNodeFactory = c, this._unionNodeFactory = l, this._valueNodeFactory = f, this._initializeAstNode();
  }
  dispose() {
    this._astNodeFactoryList.forEach((a) => {
      a.dispose();
    }), this._astNodeFactoryList = [];
  }
  parse(a) {
    const e = new qs(Tt), t = this._parse(a, e);
    return a.hasDefinedNames() && (t == null || t.setDefinedNames(a.getDefinedNames())), t;
  }
  _lambdaParameterHandler(a, e) {
    if (e.getLambdaId == null)
      return xe.create(m.VALUE);
    const t = e.getLambdaId(), r = new qs(Tt), n = this._runtimeService.getFunctionDefinitionPrivacyVar(t);
    if (!n)
      return !1;
    const s = [...n.keys()], o = a.getChildren(), u = o.length;
    for (let c = 0; c < u; c++) {
      const l = o[c];
      if (l instanceof ae) {
        Na(l, t, n), this._parse(l, r);
        const h = r.getChildren()[c];
        h != null && n.set(s[c], h);
      } else
        return !1;
    }
    return r.setParent(e), e;
  }
  _changeLetToLambda(a) {
    const e = a.getChildren(), t = e.length;
    if (t % 2 !== 1 || t === 0)
      return;
    const r = new ae();
    r.setToken(Lr);
    const n = new ae();
    n.setToken(dr);
    const s = [...e];
    for (let u = 0; u < t; u++) {
      const c = s[u];
      if (!(c instanceof ae))
        return;
      u % 2 === 0 ? c.changeToParent(r) : c.changeToParent(n);
    }
    r.addChildrenFirst(n), n.setParent(r);
    const o = a.getParent();
    return o == null || o.replaceChild(a, r), r;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _parse(a, e) {
    var l;
    const t = a.getChildren(), r = t.length, n = [];
    let s = null;
    const o = a.getToken().trim().toUpperCase();
    if (o === rl) {
      const f = this._changeLetToLambda(a);
      return f != null ? this._parse(f, e) : xe.create(m.ERROR);
    }
    if (o === gt) {
      if (s = e, r === 0)
        return new bh(Tt).setParent(e), s;
    } else {
      if (o === dr) {
        let f = this._lambdaParameterHandler(a, e);
        return f === !1 && (f = xe.create(m.ERROR)), f;
      }
      if (s = this._checkAstNode(a), s == null)
        return xe.create(m.NAME);
    }
    const u = t[0];
    for (let f = 0; f < r; f++) {
      const h = t[f];
      if (Uo(u)) {
        if (f !== 0 && f !== r - 1)
          continue;
      } else if (gh(h) && f !== r - 1)
        continue;
      let d = null;
      if (h instanceof ae) {
        if (h.getToken() === gt && h.getChildren().length === 0) {
          const _ = (l = h.getParent()) == null ? void 0 : l.getChildren();
          if (_ && _.length === 1)
            return xe.create(m.NAME);
        }
        if (d = this._parse(h, s), d === s)
          continue;
      } else
        d = this._checkAstNode(h);
      if (d == null)
        return xe.create(m.NAME);
      if (d = dh(d), d == null || (d == null ? void 0 : d.nodeType) === ie.ERROR)
        return d;
      switch (d.nodeType) {
        // case NodeType.ERROR:
        //     return astNode;
        case ie.FUNCTION: {
          const _ = d.getToken().trim().toUpperCase();
          sl.has(_) && d.setForcedCalculateFunction(), n.push(d);
          break;
        }
        case ie.LAMBDA:
          n.push(d);
          break;
        case ie.LAMBDA_PARAMETER:
          n.push(d);
          break;
        case ie.OPERATOR: {
          const _ = n.pop(), C = n.pop();
          C && C.setParent(d), _ && _.setParent(d), n.push(d);
          break;
        }
        case ie.REFERENCE:
          n.push(d);
          break;
        case ie.ROOT:
          n.push(d);
          break;
        case ie.UNION:
          n.push(d);
          break;
        case ie.VALUE:
          n.push(d);
          break;
        case ie.PREFIX:
          n.push(d);
          break;
        case ie.SUFFIX:
          n.push(d);
          break;
      }
    }
    const c = n.length;
    for (let f = 0; f < c; f++)
      n[f].setParent(s);
    return s;
  }
  // private _setPrefixRefOffset(astNode: BaseAstNode) {
  //     const children = astNode.getChildren();
  //     const childrenCount = children.length;
  //     for (let i = 0; i < childrenCount; i++) {
  //         const item = children[i];
  //         if (item.nodeType === NodeType.REFERENCE) {
  //             item.setRefOffset(this._refOffsetX, this._refOffsetY);
  //         }
  //     }
  // }
  _checkAstNode(a) {
    let e = null;
    const t = this._astNodeFactoryList.length;
    for (let r = 0; r < t && (e = this._astNodeFactoryList[r].checkAndCreateNodeType(a), e == null); r++)
      ;
    return e == null ? new lh() : e;
  }
  _initializeAstNode() {
    this._astNodeFactoryList = [
      this._astRootNodeFactory,
      this._functionNodeFactory,
      this._lambdaNodeFactory,
      this._lambdaParameterNodeFactory,
      this._operatorNodeFactory,
      this._prefixNodeFactory,
      this._referenceNodeFactory,
      this._suffixNodeFactory,
      this._unionNodeFactory,
      this._valueNodeFactory
    ].sort(uc);
  }
};
Ur = Uh([
  ut(0, St),
  ut(1, ye(Po)),
  ut(2, ye(On)),
  ut(3, ye(Mn)),
  ut(4, ye(Bo)),
  ut(5, ye(wn)),
  ut(6, ye(Nn)),
  ut(7, ye(Sn)),
  ut(8, ye(Dn)),
  ut(9, ye(Ln)),
  ut(10, ye(Io))
], Ur);
class vh extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_otherFormulaData", /* @__PURE__ */ new Map());
    //  [unitId: string]: Nullable<{ [sheetId: string]: { [formulaId: string]: Set<number> } }>;
    A(this, "_featureFormulaData", /* @__PURE__ */ new Map());
    // [unitId: string]: Nullable<{ [sheetId: string]: { [featureId: string]: Nullable<number> } }>;
    A(this, "_formulaData", /* @__PURE__ */ new Map());
    // [unitId: string]: Nullable<{ [sheetId: string]: ObjectMatrix<number> }>;
    A(this, "_definedNameMap", /* @__PURE__ */ new Map());
    // unitId -> definedName -> treeId
    A(this, "_otherFormulaDataMainData", /* @__PURE__ */ new Set());
    A(this, "_dependencyRTreeCache", new Os());
    A(this, "_dependencyTreeIdLast", 0);
  }
  buildDependencyTree(e, t) {
    throw new Error("Method not implemented.");
  }
  getTreeById(e) {
    throw new Error("Method not implemented.");
  }
  getAllTree() {
    throw new Error("Method not implemented.");
  }
  reset() {
    throw new Error("Method not implemented.");
  }
  addOtherFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  removeOtherFormulaDependency(e, t, r) {
    throw new Error("Method not implemented.");
  }
  clearOtherFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  addFeatureFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  removeFeatureFormulaDependency(e, t, r) {
    throw new Error("Method not implemented.");
  }
  clearFeatureFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  addFormulaDependency(e, t, r, n, s) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  clearFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependencyByDefinedName(e, t) {
    throw new Error("Method not implemented.");
  }
  searchDependency(e, t) {
    return this._dependencyRTreeCache.bulkSearch(e, t);
  }
  _restDependencyTreeId() {
    this._dependencyTreeIdLast = 0;
  }
  getOtherFormulaDependency(e, t, r) {
    var n, s;
    return (s = (n = this._otherFormulaData.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  addOtherFormulaDependencyMainData(e) {
    this._otherFormulaDataMainData.add(e);
  }
  hasOtherFormulaDataMainData(e) {
    return this._otherFormulaDataMainData.has(e);
  }
  _removeDependencyRTreeCacheById(e, t) {
    this._dependencyRTreeCache.removeById(e, t);
  }
  getFeatureFormulaDependency(e, t, r) {
    var n, s;
    return (s = (n = this._featureFormulaData.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  getFormulaDependency(e, t, r, n) {
    var s, o;
    return (o = (s = this._formulaData.get(e)) == null ? void 0 : s.get(t)) == null ? void 0 : o.getValue(r, n);
  }
  addDependencyRTreeCache(e) {
    const t = [];
    for (let r = 0; r < e.rangeList.length; r++) {
      const n = e.rangeList[r], { unitId: s, sheetId: o, range: u } = n;
      t.push({
        unitId: s,
        sheetId: o,
        range: u,
        id: e.treeId
      });
    }
    this._dependencyRTreeCache.bulkInsert(t), this._addAllTreeMap(e);
  }
  getLastTreeId() {
    const e = this._dependencyTreeIdLast;
    return this._dependencyTreeIdLast++, e;
  }
  _addAllTreeMap(e) {
    throw new Error("Method not implemented.");
  }
  _addDefinedName(e, t, r) {
    this._definedNameMap.has(e) || this._definedNameMap.set(e, /* @__PURE__ */ new Map());
    const n = this._definedNameMap.get(e);
    n.has(t) || n.set(t, /* @__PURE__ */ new Set()), n.get(t).add(r);
  }
  addFormulaDependencyByDefinedName(e, t) {
    const r = e.treeId, n = (t == null ? void 0 : t.getDefinedNames()) || [];
    for (const s of n)
      this._addDefinedName(e.unitId, s, r);
  }
}
class Th extends vh {
  constructor() {
    super(...arguments);
    A(this, "_allTreeMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this.reset();
  }
  buildDependencyTree(e, t = []) {
    const r = this.getAllTree();
    return e.length === 0 ? (this._buildReverseDependency(r, t), r) : (this._buildDependencyTree(r, e), this._buildReverseDependency(r, e), r);
  }
  /**
   * Build the dependency relationship between the trees.
   * @param allTrees  all FormulaDependencyTree
   * @param shouldBeBuildTrees  FormulaDependencyTree[] | FormulaDependencyTreeCache
   */
  _buildDependencyTree(e, t) {
    const r = /* @__PURE__ */ new Map();
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      r.set(s.treeId, s);
    }
    for (let n = 0; n < e.length; n++) {
      const s = e[n], o = s.toRTreeItem(), u = this._dependencyRTreeCache.bulkSearch(o);
      for (const c of u) {
        const l = r.get(c);
        l && s !== l && !l.hasChildren(s.treeId) && l.pushChildren(s);
      }
    }
    r.clear();
  }
  /**
   * Build the reverse dependency relationship between the trees.
   * @param allTrees
   * @param dependencyTrees
   */
  _buildReverseDependency(e, t) {
    const r = /* @__PURE__ */ new Map();
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      r.set(s.treeId, s);
    }
    for (let n = 0; n < t.length; n++) {
      const s = t[n], o = s.toRTreeItem(), u = this._dependencyRTreeCache.bulkSearch(o);
      for (const c of u) {
        const l = r.get(c);
        l && s !== l && !l.hasChildren(s.treeId) && l.pushChildren(s);
      }
    }
    r.clear();
  }
  /**
   * Get all FormulaDependencyTree from _otherFormulaData, _featureFormulaData, _formulaData
   * return FormulaDependencyTree[]
   */
  getAllTree() {
    const e = [];
    return this._allTreeMap.forEach((t) => {
      t.resetState(), e.push(t);
    }), e;
  }
  getTreeById(e) {
    return this._allTreeMap.get(e);
  }
  reset() {
    this._otherFormulaData.clear(), this._featureFormulaData.clear(), this._formulaData.clear(), this._definedNameMap.clear(), this._otherFormulaDataMainData.clear(), this._dependencyRTreeCache.clear(), this._allTreeMap.clear(), this._restDependencyTreeId();
  }
  addOtherFormulaDependency(e, t, r, n) {
    this._otherFormulaData.has(e) || this._otherFormulaData.set(e, /* @__PURE__ */ new Map());
    const s = this._otherFormulaData.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map());
    const o = s.get(t);
    o.has(r) || o.set(r, new Ce()), o.get(r).setValue(n.refOffsetX, n.refOffsetY, n.treeId), this._addAllTreeMap(n);
  }
  removeOtherFormulaDependency(e, t, r) {
    const n = this._otherFormulaData.get(e);
    if (n && n.has(t)) {
      const s = n.get(t);
      r.forEach((o) => {
        const u = s.get(o);
        u != null && (u.forValue((c, l, f) => {
          this._removeDependencyRTreeCache(f), this.clearDependencyForTree(this._allTreeMap.get(f)), this._removeAllTreeMap(f);
        }), s.delete(o), this._otherFormulaDataMainData.delete(o));
      }), s.size === 0 && n.delete(t), n.size === 0 && this._otherFormulaData.delete(e);
    }
  }
  clearOtherFormulaDependency(e, t) {
    const r = this._otherFormulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t);
      for (const s of n.keys()) {
        const o = n.get(s);
        o != null && (o.forValue((u, c, l) => {
          const f = this._allTreeMap.get(l);
          f && (this.clearDependencyForTree(f), this._removeAllTreeMap(l));
        }), this._otherFormulaDataMainData.delete(s));
      }
      n.clear();
    } else if (r) {
      for (const n of r.keys()) {
        const s = r.get(n);
        this._removeDependencyRTreeCacheById(e, n);
        for (const o of s.keys()) {
          const u = s.get(o);
          u != null && (u.forValue((c, l, f) => {
            const h = this._allTreeMap.get(f);
            h && (this.clearDependencyForTree(h), this._removeAllTreeMap(f));
          }), this._otherFormulaDataMainData.delete(o));
        }
      }
      this._otherFormulaData.delete(e);
    }
  }
  addFeatureFormulaDependency(e, t, r, n) {
    this._featureFormulaData.has(e) || this._featureFormulaData.set(e, /* @__PURE__ */ new Map());
    const s = this._featureFormulaData.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map()), s.get(t).set(r, n.treeId), this._addAllTreeMap(n);
  }
  removeFeatureFormulaDependency(e, t, r) {
    const n = this._featureFormulaData.get(e);
    if (n && n.has(t)) {
      const s = n.get(t);
      r.forEach((o) => {
        const u = s.get(o);
        u != null && (this._removeDependencyRTreeCache(u), s.delete(o), this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u));
      });
    }
  }
  clearFeatureFormulaDependency(e, t) {
    const r = this._featureFormulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t), n.forEach((s) => {
        s != null && (this.clearDependencyForTree(this._allTreeMap.get(s)), this._removeAllTreeMap(s));
      }), n.clear();
    } else r && (r.forEach((n, s) => {
      this._removeDependencyRTreeCacheById(e, s), n.forEach((o) => {
        o != null && (this.clearDependencyForTree(this._allTreeMap.get(o)), this._removeAllTreeMap(o));
      });
    }), this._featureFormulaData.delete(e));
  }
  addFormulaDependency(e, t, r, n, s) {
    this._formulaData.has(e) || this._formulaData.set(e, /* @__PURE__ */ new Map());
    const o = this._formulaData.get(e);
    o.has(t) || o.set(t, new Ce()), o.get(t).setValue(r, n, s.treeId), this._addAllTreeMap(s);
  }
  removeFormulaDependency(e, t, r, n) {
    const s = this._formulaData.get(e);
    if (s && s.has(t)) {
      const o = s.get(t), u = o.getValue(r, n);
      if (u == null)
        return;
      this._removeDependencyRTreeCache(u), o.realDeleteValue(r, n), this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u);
    }
  }
  clearFormulaDependency(e, t) {
    const r = this._formulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t), n.forValue((s, o, u) => {
        if (u == null)
          return !0;
        this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u);
      }), n.reset();
    } else r && (r.forEach((n, s) => {
      this._removeDependencyRTreeCacheById(e, s), n.forValue((o, u, c) => {
        if (c == null)
          return !0;
        this.clearDependencyForTree(this._allTreeMap.get(c)), this._removeAllTreeMap(c);
      });
    }), this._formulaData.delete(e));
  }
  /**
   * Clear the dependency relationship of the tree.
   * establish the relationship between the parent and the child.
   * @param shouldBeClearTree
   */
  clearDependencyForTree(e) {
    if (e == null)
      return;
    const t = e.parents, r = e.children, n = this._allTreeMap;
    for (const s of t) {
      const o = n.get(s);
      o == null || o.children.delete(e.treeId);
    }
    for (const s of r) {
      const o = n.get(s);
      o == null || o.parents.delete(e.treeId);
    }
    e.dispose();
  }
  _removeDependencyRTreeCache(e) {
    if (e == null)
      return;
    const t = this._allTreeMap.get(e);
    if (t) {
      const r = [];
      for (let n = 0; n < t.rangeList.length; n++) {
        const s = t.rangeList[n], { unitId: o, sheetId: u, range: c } = s;
        r.push({
          unitId: o,
          sheetId: u,
          range: c,
          id: e
        });
      }
      this._dependencyRTreeCache.bulkRemove(r);
    }
  }
  removeFormulaDependencyByDefinedName(e, t) {
    const r = this._definedNameMap.get(e);
    if (r) {
      const n = r.get(t);
      if (n) {
        for (const s of n)
          this._removeDependencyRTreeCache(s), this.clearDependencyForTree(this._allTreeMap.get(s)), this._removeAllTreeMap(s);
        n.clear();
      }
    }
  }
  _removeAllTreeMap(e) {
    e != null && this._allTreeMap.delete(e);
  }
  _addAllTreeMap(e) {
    this._allTreeMap.set(e.treeId, e);
  }
}
const Jn = Ze(
  "univer.formula.dependency-manager.service"
);
class Bh extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_referenceExecutorMap", /* @__PURE__ */ new Map());
    // unitId -> subUnitId -> featureId -> IFeatureCalculationManagerParam
    A(this, "_onChanged$", new hr());
    A(this, "onChanged$", this._onChanged$.asObservable());
  }
  dispose() {
    super.dispose(), this._referenceExecutorMap.clear(), this._onChanged$.complete();
  }
  remove(e, t, r) {
    r.forEach((n) => {
      var s, o;
      (o = (s = this._referenceExecutorMap.get(e)) == null ? void 0 : s.get(t)) == null || o.delete(n);
    }), this._onChanged$.next({
      unitId: e,
      subUnitId: t,
      featureIds: r
    });
  }
  get(e, t, r) {
    var n, s;
    return (s = (n = this._referenceExecutorMap.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  has(e, t, r) {
    var n, s;
    return !!((s = (n = this._referenceExecutorMap.get(e)) == null ? void 0 : n.get(t)) != null && s.has(r));
  }
  register(e, t, r, n) {
    let s = this._referenceExecutorMap.get(e);
    s || (s = /* @__PURE__ */ new Map(), this._referenceExecutorMap.set(e, s));
    let o = s.get(t);
    o || (o = /* @__PURE__ */ new Map(), s.set(t, o)), this._onChanged$.next({
      unitId: e,
      subUnitId: t,
      featureIds: [r]
    }), o.set(r, n);
  }
  getReferenceExecutorMap() {
    return this._referenceExecutorMap;
  }
}
const vr = Ze(
  "univer.formula.feature-calculation-manager.service"
);
class Ih extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_otherFormulaData", {});
  }
  dispose() {
    super.dispose(), this._otherFormulaData = {};
  }
  remove(e) {
    var s, o, u;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    (u = (o = (s = this._otherFormulaData) == null ? void 0 : s[t]) == null ? void 0 : o[r]) == null || delete u[n];
  }
  get(e) {
    var s, o;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    return (o = (s = this._otherFormulaData[t]) == null ? void 0 : s[r]) == null ? void 0 : o[n];
  }
  has(e) {
    var s, o;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    return ((o = (s = this._otherFormulaData[t]) == null ? void 0 : s[r]) == null ? void 0 : o[n]) != null;
  }
  register(e) {
    const { unitId: t, subUnitId: r, formulaId: n, item: s } = e;
    this._otherFormulaData[t] || (this._otherFormulaData[t] = {}), this._otherFormulaData[t][r] || (this._otherFormulaData[t][r] = {}), this._otherFormulaData[t][r][n] = s;
  }
  batchRegister(e) {
    Object.keys(e).forEach((t) => {
      const r = e[t];
      if (r == null)
        return !0;
      Object.keys(r).forEach((n) => {
        const s = r[n];
        if (s == null)
          return !0;
        Object.keys(s).forEach((o) => {
          const u = s[o];
          if (u == null)
            return !0;
          this.register({
            unitId: t,
            subUnitId: n,
            formulaId: o,
            item: u
          });
        });
      });
    });
  }
  batchRemove(e) {
    Object.keys(e).forEach((t) => {
      const r = e[t];
      if (r == null)
        return !0;
      Object.keys(r).forEach((n) => {
        const s = r[n];
        if (s == null)
          return !0;
        Object.keys(s).forEach((o) => {
          this.remove({
            unitId: t,
            subUnitId: n,
            formulaId: o
          });
        });
      });
    });
  }
  getOtherFormulaData() {
    return this._otherFormulaData;
  }
}
const Ma = Ze(
  "univer.formula.other-formula-manager.service"
);
var Ks = /* @__PURE__ */ ((i) => (i[i.NORMAL_FORMULA = 0] = "NORMAL_FORMULA", i[i.OTHER_FORMULA = 1] = "OTHER_FORMULA", i[i.FEATURE_FORMULA = 2] = "FEATURE_FORMULA", i))(Ks || {});
class Fo {
  constructor() {
    A(this, "_state", 0);
    A(this, "treeId");
    A(this, "children", /* @__PURE__ */ new Set());
    A(this, "parents", /* @__PURE__ */ new Set());
  }
  resetState() {
    this._state = 0;
  }
  setAdded() {
    this._state = 1;
  }
  isAdded() {
    return this._state === 1;
  }
  setSkip() {
    this._state = 2;
  }
  isSkip() {
    return this._state === 2;
  }
  pushChildren(a) {
    this.children.add(a.treeId), a._pushParent(this);
  }
  hasChildren(a) {
    return this.children.has(a);
  }
  _pushParent(a) {
    this.parents.add(a.treeId);
  }
}
class Si extends Fo {
  constructor() {
    super(...arguments);
    A(this, "refTree");
    A(this, "refOffsetX", -1);
    A(this, "refOffsetY", -1);
    A(this, "isCache", !1);
    A(this, "isDirty", !1);
    A(this, "addressFunctionNodes", []);
    A(this, "getDirtyData");
    A(this, "featureId");
  }
  get isVirtual() {
    return !0;
  }
  get row() {
    return this.refTree == null ? -1 : this.refTree.row + this.refOffsetY;
  }
  get column() {
    return this.refTree == null ? -1 : this.refTree.column + this.refOffsetX;
  }
  get rowCount() {
    return this.refTree == null ? 0 : this.refTree.rowCount;
  }
  get columnCount() {
    return this.refTree == null ? 0 : this.refTree.columnCount;
  }
  get unitId() {
    return this.refTree == null ? "" : this.refTree.unitId;
  }
  get subUnitId() {
    return this.refTree == null ? "" : this.refTree.subUnitId;
  }
  get formula() {
    var e, t;
    return (t = (e = this.refTree) == null ? void 0 : e.formula) != null ? t : "";
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  get node() {
    var e;
    return (e = this.refTree) == null ? void 0 : e.node;
  }
  dispose() {
    this.refTree = null;
  }
  get rangeList() {
    const e = [];
    if (this.refTree == null)
      return [];
    for (let t = 0; t < this.refTree.rangeList.length; t++) {
      const r = this.refTree.rangeList[t];
      e.push({
        unitId: r.unitId,
        sheetId: r.sheetId,
        range: aa(r.range, this.refOffsetX, this.refOffsetY)
      });
    }
    return e;
  }
  toRTreeItem() {
    const e = this.row, t = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    }];
  }
  inRangeData(e) {
    const t = e.startRow, r = e.startColumn, n = e.endRow, s = e.endColumn, o = this.row, u = this.column;
    return !(o < t || o > n || u < r || u > s);
  }
  dependencySheetName(e) {
    return this.refTree == null ? !1 : this.refTree.dependencySheetName(e);
  }
  isExcludeRange(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0)
      return !1;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c, range: l } = o, f = (r = e == null ? void 0 : e[u]) == null ? void 0 : r[c];
      let { startRow: h, endRow: d, startColumn: _, endColumn: C } = l;
      Number.isNaN(h) && (h = 0), Number.isNaN(_) && (_ = 0), Number.isNaN(d) && (d = Number.POSITIVE_INFINITY), Number.isNaN(C) && (C = Number.POSITIVE_INFINITY);
      let E = !1;
      if (f == null || f.forValue((b, R) => {
        if (b >= h && b <= d && R >= _ && R <= C)
          return E = !0, !1;
      }), E)
        return !0;
    }
    return !1;
  }
  get formulaId() {
    return this.refTree == null ? "" : this.refTree.formulaId;
  }
}
class bs extends Fo {
  constructor(e) {
    super();
    A(this, "isCache", !1);
    A(this, "featureId");
    A(this, "featureDirtyRanges", []);
    A(this, "refOffsetX", 0);
    A(this, "refOffsetY", 0);
    A(this, "type", 0);
    A(this, "formulaId");
    A(this, "subUnitId", "");
    A(this, "unitId", "");
    A(this, "rangeList", []);
    A(this, "formula", "");
    A(this, "row", -1);
    A(this, "column", -1);
    A(this, "rowCount", Number.NEGATIVE_INFINITY);
    A(this, "columnCount", Number.NEGATIVE_INFINITY);
    A(this, "isDirty", !1);
    A(this, "node");
    A(this, "addressFunctionNodes", []);
    A(this, "getDirtyData");
    this.treeId = e;
  }
  get isVirtual() {
    return !1;
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: 0,
      refOffsetY: 0
    };
  }
  toJson() {
    return {
      formula: this.formula,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  dispose() {
    this.featureDirtyRanges = [], this.rangeList = [], this.addressFunctionNodes = [], this.getDirtyData = null;
  }
  inRangeData(e) {
    const t = e.startRow, r = e.startColumn, n = e.endRow, s = e.endColumn, o = this.row, u = this.column;
    return !(o < t || o > n || u < r || u > s);
  }
  dependencySheetName(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0 || e == null)
      return !1;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c } = o;
      if (((r = e[u]) == null ? void 0 : r[c]) != null)
        return !0;
    }
    return !1;
  }
  isExcludeRange(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0)
      return !1;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c, range: l } = o, f = (r = e == null ? void 0 : e[u]) == null ? void 0 : r[c];
      let { startRow: h, endRow: d, startColumn: _, endColumn: C } = l;
      Number.isNaN(h) && (h = 0), Number.isNaN(_) && (_ = 0), Number.isNaN(d) && (d = Number.POSITIVE_INFINITY), Number.isNaN(C) && (C = Number.POSITIVE_INFINITY);
      let E = !1;
      if (f == null || f.forValue((b, R) => {
        if (b >= h && b <= d && R >= _ && R <= C)
          return E = !0, !1;
      }), E)
        return !0;
    }
    return !1;
  }
  // pushChildren(tree: FormulaDependencyTree) {
  //     this.children.add(tree.treeId);
  //     tree._pushParent(this);
  // }
  /**
   * Add the range corresponding to the current ast node.
   * @param range
   */
  pushRangeList(e) {
    this.rangeList.push(...e);
  }
  shouldBePushRangeList() {
    return this.rangeList.length === 0 && this.type !== 2;
  }
  // hasChildren(treeId: number) {
  //     return this.children.has(treeId);
  // }
  toRTreeItem() {
    if (this.featureId != null)
      return this.featureDirtyRanges;
    const e = this.row, t = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    }];
  }
  /**
   * Determine whether it is dependent on other trees.
   * @param dependenceTree
   */
  // dependency(dependenceTree: FormulaDependencyTree) {
  //     if (this.rangeList.length === 0) {
  //         return false;
  //     }
  //     for (let r = 0, len = this.rangeList.length; r < len; r++) {
  //         const unitRange = this.rangeList[r];
  //         const unitId = unitRange.unitId;
  //         const sheetId = unitRange.sheetId;
  //         const range = unitRange.range;
  //         if (
  //             dependenceTree.unitId === unitId &&
  //             dependenceTree.subUnitId === sheetId &&
  //             dependenceTree.inRangeData(range)
  //         ) {
  //             return true;
  //         }
  //     }
  //     return false;
  // }
  // private _pushParent(tree: FormulaDependencyTree) {
  //     this.parents.add(tree.treeId);
  // }
}
var Fh = Object.getOwnPropertyDescriptor, kh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Fh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Pt = (i, a) => (e, t) => a(e, t, i);
function cr(i) {
  return i.getLastTreeId() || 0;
}
const Xs = Ze("engine-formula.dependency-generator");
let Zs = class extends Ne {
  constructor(a, e, t, r, n, s, o, u) {
    super();
    A(this, "_updateRangeFlattenCache", /* @__PURE__ */ new Map());
    A(this, "_dependencyRTreeCacheForAddressFunction", new Os());
    A(this, "_executedAddressFunctionNodeIds", /* @__PURE__ */ new Set());
    this._currentConfigService = a, this._runtimeService = e, this._otherFormulaManagerService = t, this._featureCalculationManagerService = r, this._interpreter = n, this._astTreeBuilder = s, this._lexer = o, this._dependencyManagerService = u;
  }
  dispose() {
    this._updateRangeFlattenCache.clear(), this._dependencyRTreeCacheForAddressFunction.clear(), jr.clear();
  }
  async generate() {
    this._updateRangeFlatten();
    const a = this._currentConfigService.getFormulaData(), e = this._otherFormulaManagerService.getOtherFormulaData(), t = this._currentConfigService.getClearDependencyTreeCache();
    t != null && Object.keys(t).forEach((l) => {
      l != null && Object.keys(t[l]).forEach((f) => {
        f != null && (this._dependencyManagerService.clearOtherFormulaDependency(l, f), this._dependencyManagerService.clearFeatureFormulaDependency(l, f), this._dependencyManagerService.clearFormulaDependency(l, f));
      });
    });
    const r = this._currentConfigService.getUnitData(), n = await this._generateTreeList(a, e, r), s = this._getUpdateTreeListAndMakeDependency(n);
    let o = this._calculateRunList(s);
    return this._dependencyFeatureCalculation(o) && (o.forEach((l) => {
      l.resetState();
    }), o = this._calculateRunList(o)), this._checkIsCycleDependency(o) && this._runtimeService.enableCycleDependency(), this._dependencyRTreeCacheForAddressFunction.clear(), Promise.resolve(o);
  }
  _dependencyFeatureCalculation(a) {
    const e = this._featureCalculationManagerService.getReferenceExecutorMap();
    if (e.size === 0)
      return;
    this._clearFeatureCalculationNode(a);
    let t = !1;
    return e.forEach((r, n) => {
      r.forEach((s, o) => {
        s.forEach((u, c) => {
          const { unitId: l, subUnitId: f, getDirtyData: h } = u, d = h(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData()), _ = this._convertDirtyRangesToUnitRange(d.dirtyRanges), C = this._intersectFeatureCalculation(_, a, { unitId: l, subUnitId: f, featureId: c });
          if (C.length > 0) {
            let E = this._getExistTreeList({ unitId: l, subUnitId: f, featureId: c }, a);
            E == null && (E = this._getFeatureFormulaTree(c, cr(this._dependencyManagerService), u), a.push(E)), E.parents = /* @__PURE__ */ new Set(), C.forEach((b) => {
              b.hasChildren(E.treeId) || b.pushChildren(E);
            }), t = !0;
          }
        });
      });
    }), t;
  }
  _clearFeatureCalculationNode(a) {
    const e = this._featureCalculationManagerService.getReferenceExecutorMap();
    a.forEach((t) => {
      var s, o, u, c;
      const r = /* @__PURE__ */ new Set();
      for (const l of t.children) {
        const f = this._dependencyManagerService.getTreeById(l);
        f && (f.featureId && (o = (s = e.get(t.unitId)) == null ? void 0 : s.get(t.subUnitId)) != null && o.has(f.featureId) || r.add(l));
      }
      t.children = r;
      const n = /* @__PURE__ */ new Set();
      for (const l of t.parents) {
        const f = this._dependencyManagerService.getTreeById(l);
        f && (f.featureId && (c = (u = e.get(t.unitId)) == null ? void 0 : u.get(t.subUnitId)) != null && c.has(f.featureId) || n.add(l));
      }
      t.parents = n;
    });
  }
  /**
   * TODO @DR-Univer: The next step will be to try changing the incoming dirtyRanges to an array, thus avoiding conversion.
   * @param dirtyRanges
   * @returns
   */
  _convertDirtyRangesToUnitRange(a) {
    const e = [];
    for (const t in a) {
      const r = a[t];
      for (const n in r) {
        const s = r[n];
        for (const o of s)
          e.push({
            unitId: t,
            sheetId: n,
            range: o
          });
      }
    }
    return e;
  }
  _intersectFeatureCalculation(a, e, t) {
    const r = [], n = this._dependencyManagerService.searchDependency(a);
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s];
      if (u.unitId === t.unitId && u.subUnitId === t.subUnitId && u.featureId === t.featureId)
        continue;
      n.has(u.treeId) && r.push(u);
    }
    return r;
  }
  _getExistTreeList(a, e) {
    const { unitId: t, subUnitId: r, featureId: n } = a;
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s];
      if (u.unitId === t && u.subUnitId === r && u.featureId === n)
        return u;
    }
  }
  _isCyclicUtil(a, e, t) {
    const r = this._dependencyManagerService.getTreeById(a);
    if (r == null)
      return !1;
    if (!e.has(r.treeId)) {
      e.add(r.treeId), t.add(r.treeId);
      for (const n of r.children)
        if (!e.has(n) && this._isCyclicUtil(n, e, t) || t.has(n))
          return !0;
    }
    return t.delete(r.treeId), !1;
  }
  _checkIsCycleDependency(a) {
    const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
    for (let r = 0, n = a.length; r < n; r++) {
      const s = a[r];
      if (this._isCyclicUtil(s.treeId, e, t) === !0)
        return !0;
    }
    return !1;
  }
  /**
   * Generate nodes for the dependency tree, where each node contains all the reference data ranges included in each formula.
   * @param formulaData
   */
  async _generateTreeList(a, e, t) {
    const r = Object.keys(a), n = Object.keys(e), s = [];
    this._currentConfigService.isForceCalculate() && this._dependencyManagerService.reset(), this._registerFormulas(r, a, t, s), this._registerOtherFormulas(e, n, s), this._registerFeatureFormulas(s);
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (!l.formula)
        continue;
      const f = this._getTreeNode(l);
      l.isDirty = this._includeTree(l, f);
      const h = this._getAddressFunctionNodeList(f);
      if (h.length > 0 && (l.addressFunctionNodes = h), l.isVirtual)
        continue;
      this._runtimeService.setCurrent(
        l.row,
        l.column,
        l.rowCount,
        l.columnCount,
        l.subUnitId,
        l.unitId
      );
      const d = await this._getRangeListByNode({
        node: f,
        refOffsetX: l.refOffsetX,
        refOffsetY: l.refOffsetY
      });
      l.pushRangeList(d);
    }
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      l.isCache || this._dependencyManagerService.addDependencyRTreeCache(l);
    }
    return await this._calculateListByFunctionRefNode(s), s;
  }
  // private _moveRangeList(tree: FormulaDependencyTree, refOffsetX: number, refOffsetY: number) {
  //     const rangeList = tree.rangeList;
  //     const newRangeList = [];
  //     for (let i = 0, len = rangeList.length; i < len; i++) {
  //         const unitRange = rangeList[i];
  //         const newRange = {
  //             unitId: tree.unitId,
  //             sheetId: tree.subUnitId,
  //             range: moveRangeByOffset(unitRange.range, refOffsetX, refOffsetY),
  //         };
  //         newRangeList.push(newRange);
  //     }
  //     return newRangeList;
  // }
  _registerFeatureFormulas(a) {
    this._featureCalculationManagerService.getReferenceExecutorMap().forEach((t, r) => {
      t.forEach((n, s) => {
        n.forEach((o, u) => {
          const c = this._dependencyManagerService.getFeatureFormulaDependency(o.unitId, o.subUnitId, u);
          a.push(this._getFeatureFormulaTree(u, c, o));
        });
      });
    });
  }
  _getFeatureFormulaTree(a, e, t) {
    const { unitId: r, subUnitId: n, dependencyRanges: s, getDirtyData: o } = t, u = e || cr(this._dependencyManagerService), c = new bs(u);
    c.unitId = r, c.subUnitId = n, c.rangeList = s, c.getDirtyData = o;
    const l = o(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData()), f = this._convertDirtyRangesToUnitRange(l.dirtyRanges);
    return c.featureDirtyRanges = f, c.featureId = a, c.type = Ks.FEATURE_FORMULA, this._dependencyManagerService.addFeatureFormulaDependency(r, n, a, c), this._dependencyManagerService.getFeatureFormulaDependency(t.unitId, t.subUnitId, a) && (c.isCache = !0), c;
  }
  _registerOtherFormulas(a, e, t) {
    for (const r of e) {
      const n = a[r];
      if (n == null)
        continue;
      const s = Object.keys(n);
      for (const o of s) {
        const u = n[o];
        if (u == null)
          continue;
        const c = Object.keys(u);
        for (const l of c) {
          const f = this._dependencyManagerService.hasOtherFormulaDataMainData(l), h = u[l], { f: d, ranges: _ } = h;
          let C = !1;
          f && (C = !0);
          const E = Vi(r, d, this._lexer, this._astTreeBuilder, this._currentConfigService), { firstRow: b, firstColumn: R } = this._getFirstCellOfRange(_), p = this._dependencyManagerService.getOtherFormulaDependency(r, o, l), N = (p == null ? void 0 : p.getValue(0, 0)) || cr(this._dependencyManagerService), M = new bs(N);
          for (let w = 0; w < _.length; w++) {
            const S = _[w], { startRow: D, startColumn: L, endRow: U, endColumn: x } = S;
            for (let k = D; k <= U; k++)
              for (let Q = L; Q <= x; Q++) {
                const ne = Q - R, z = k - b;
                if (ne === 0 && z === 0) {
                  M.node = E, M.formula = d, M.unitId = r, M.subUnitId = o, M.formulaId = l, M.type = Ks.OTHER_FORMULA, M.isCache = C, t.push(M), this._dependencyManagerService.addOtherFormulaDependency(r, o, l, M), this._dependencyManagerService.addFormulaDependencyByDefinedName(M);
                  continue;
                }
                const G = new Si();
                G.treeId = (p == null ? void 0 : p.getValue(ne, z)) || cr(this._dependencyManagerService), G.refTree = M, G.refOffsetX = ne, G.refOffsetY = z, G.isCache = C, this._dependencyManagerService.addOtherFormulaDependency(r, o, l, G), this._dependencyManagerService.addFormulaDependencyByDefinedName(G), t.push(G);
              }
          }
          this._dependencyManagerService.addOtherFormulaDependencyMainData(l);
        }
      }
    }
  }
  _getFirstCellOfRange(a) {
    const e = a[0];
    return {
      firstRow: e.startRow,
      firstColumn: e.startColumn
    };
  }
  _registerFormulas(a, e, t, r) {
    for (const n of a) {
      const s = e[n];
      if (s == null)
        continue;
      const o = Object.keys(s);
      for (const u of o) {
        const c = new Ce(s[u] || {}), l = /* @__PURE__ */ new Map();
        c.forValue((f, h, d) => {
          if (d == null)
            return !0;
          const { x: _ = 0, y: C = 0, si: E } = d;
          if (!(_ === 0 && C === 0 && E != null))
            return !0;
          const b = this._createFDtree(n, u, f, h, t, d), R = this._dependencyManagerService.getFormulaDependency(n, u, f, h);
          R != null ? b.treeId = R : (this._dependencyManagerService.addFormulaDependency(n, u, f, h, b), this._dependencyManagerService.addFormulaDependencyByDefinedName(b)), l.set(E, b), r.push(b);
        }), c.forValue((f, h, d) => {
          if (d == null)
            return !0;
          const { x: _ = 0, y: C = 0, si: E } = d;
          if (_ === 0 && C === 0 && E != null)
            return !0;
          let b;
          if (E && l.has(E)) {
            const p = l.get(E);
            b = this._createVirtualFDtree(p, d);
          } else
            b = this._createFDtree(n, u, f, h, t, d);
          const R = this._dependencyManagerService.getFormulaDependency(n, u, f, h);
          R != null ? b.treeId = R : (this._dependencyManagerService.addFormulaDependency(n, u, f, h, b), this._dependencyManagerService.addFormulaDependencyByDefinedName(b)), r.push(b);
        }), l.clear();
      }
    }
  }
  _createFDtree(a, e, t, r, n, s) {
    const { f: o, x: u = 0, y: c = 0 } = s, l = new bs(cr(this._dependencyManagerService)), f = n[a][e], h = Vi(a, o, this._lexer, this._astTreeBuilder, this._currentConfigService);
    return l.node = h, l.formula = o, l.unitId = a, l.subUnitId = e, l.row = t, l.column = r, l.rowCount = f.rowCount, l.columnCount = f.columnCount, l;
  }
  _createVirtualFDtree(a, e) {
    const { x: t = 0, y: r = 0 } = e, n = new Si();
    return n.treeId = cr(this._dependencyManagerService), n.refTree = a, n.refOffsetX = t, n.refOffsetY = r, n;
  }
  /**
   * Break down the dirty areas into ranges for subsequent matching.
   */
  _updateRangeFlatten() {
    const a = this._currentConfigService.isForceCalculate(), e = this._currentConfigService.getDirtyRanges();
    if (!a) {
      this._updateRangeFlattenCache.clear();
      for (let t = 0; t < e.length; t++) {
        const r = e[t], n = r.range, s = r.sheetId, o = r.unitId;
        this._addFlattenCache(o, s, n);
      }
    }
  }
  _addFlattenCache(a, e, t) {
    let r = this._updateRangeFlattenCache.get(a);
    r == null && (r = /* @__PURE__ */ new Map(), this._updateRangeFlattenCache.set(a, r));
    let n = r.get(e);
    n == null && (n = [], r.set(e, n)), n.push(t);
  }
  _isPreCalculateNode(a) {
    return a.nodeType === ie.UNION || a.nodeType === ie.PREFIX && a.getToken() === Me.AT || a.nodeType === ie.SUFFIX && a.getToken() === tt.POUND;
  }
  _nodeTraversalRef(a, e) {
    const t = a.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (this._isPreCalculateNode(s)) {
        if (e.push(s), s.nodeType === ie.UNION)
          for (const o of s.getChildren())
            o.nodeType === ie.FUNCTION && o.isAddress() && this._nodeTraversalRef(o, e);
        continue;
      } else s.nodeType === ie.REFERENCE && e.push(s);
      this._nodeTraversalRef(s, e);
    }
  }
  _nodeTraversalReferenceFunction(a, e) {
    const t = a.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.nodeType === ie.FUNCTION && s.isAddress()) {
        e.push(s);
        continue;
      }
      this._nodeTraversalReferenceFunction(s, e);
    }
  }
  async _executeNode(a, e = 0, t = 0) {
    let r;
    const n = {
      node: a,
      refOffsetX: e,
      refOffsetY: t
    };
    return this._interpreter.checkAsyncNode(a) ? r = await this._interpreter.executeAsync(n) : r = this._interpreter.execute(n), r;
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  async _getRangeListByNode(a) {
    const e = [], t = a.refOffsetX, r = a.refOffsetY, n = a.node;
    if (n == null)
      return [];
    this._nodeTraversalRef(n, e);
    const s = [];
    for (let o = 0, u = e.length; o < u; o++) {
      const c = e[o], f = (await this._executeNode(c, t, r)).toUnitRange();
      s.push(f), c.setValue(null);
    }
    return s;
  }
  _getAddressFunctionNodeList(a) {
    const e = [];
    return a == null ? [] : (this._nodeTraversalReferenceFunction(a, e), e);
  }
  _getTreeNode(a) {
    return a.node;
  }
  async _buildDirtyRangesByAddressFunction(a, e) {
    const t = e.addressFunctionNodes;
    if (t.length === 0)
      return;
    const r = e.refOffsetX, n = e.refOffsetY, s = await this._getRangeListByFunctionRefNode(t, r, n);
    e.addressFunctionNodes = [], this._addDependencyTreeByAddressFunction(e, s);
    const o = a.bulkSearch(s), u = this._buildTreeNodeById(o);
    u.length !== 0 && await this._calculateAddressFunctionRuntimeData(a, u);
  }
  async _calculateListByFunctionRefNode(a) {
    const e = new Os();
    for (let t = 0, r = a.length; t < r; t++) {
      const n = a[t];
      e.insert({
        unitId: n.unitId,
        sheetId: n.subUnitId,
        range: {
          startRow: n.row,
          startColumn: n.column,
          endRow: n.row,
          endColumn: n.column
        },
        id: n.treeId
      });
    }
    this._executedAddressFunctionNodeIds.clear();
    for (let t = 0, r = a.length; t < r; t++) {
      const n = a[t];
      await this._calculateAddressFunction(e, n);
    }
  }
  async _calculateAddressFunction(a, e) {
    const t = e.addressFunctionNodes;
    if (t.length === 0)
      return;
    const r = e.refOffsetX, n = e.refOffsetY;
    this._runtimeService.setCurrent(
      e.row,
      e.column,
      e.rowCount,
      e.columnCount,
      e.subUnitId,
      e.unitId
    );
    const s = [];
    for (let c = 0, l = t.length; c < l; c++) {
      const f = await this._getRangeListByNode({
        node: t[c],
        refOffsetX: r,
        refOffsetY: n
      });
      s.push(...f);
    }
    const o = /* @__PURE__ */ new Set();
    this._searchDependencyByAddressFunction(a, s, o);
    const u = this._buildTreeNodeById(o);
    if (u.length === 0) {
      await this._buildDirtyRangesByAddressFunction(a, e);
      return;
    }
    await this._calculateAddressFunctionRuntimeData(a, u), await this._buildDirtyRangesByAddressFunction(a, e);
  }
  async _calculateAddressFunctionRuntimeData(a, e) {
    for (; e.length > 0; ) {
      const t = e.pop(), n = {
        node: this._getTreeNode(t),
        refOffsetX: t.refOffsetX,
        refOffsetY: t.refOffsetY
      };
      await this._calculateAddressFunction(a, t), this._runtimeService.setCurrent(
        t.row,
        t.column,
        t.rowCount,
        t.columnCount,
        t.subUnitId,
        t.unitId
      );
      let s;
      this._interpreter.checkAsyncNode(n.node) ? s = await this._interpreter.executeAsync(n) : s = this._interpreter.execute(n), t.formulaId != null ? this._runtimeService.setRuntimeOtherData(t.formulaId, t.refOffsetX, t.refOffsetY, s) : this._runtimeService.setRuntimeData(s);
    }
  }
  _buildTreeNodeById(a) {
    const e = [];
    for (const t of a) {
      const r = this._getTreeById(t);
      !r || this._executedAddressFunctionNodeIds.has(t) || (this._executedAddressFunctionNodeIds.add(t), e.push(r));
    }
    return e;
  }
  _searchDependencyByAddressFunction(a, e, t) {
    const r = a.bulkSearch(e), n = this._dependencyRTreeCacheForAddressFunction.bulkSearch(e);
    for (const o of n)
      t.has(o) || t.add(o);
    const s = [];
    for (const o of r) {
      const u = this._getTreeById(o);
      u && !t.has(o) && (s.push(...u.rangeList), t.add(o));
    }
    return s.length > 0 && this._searchDependencyByAddressFunction(a, s, t), t;
  }
  _getTreeById(a) {
    return this._dependencyManagerService.getTreeById(a);
  }
  _addDependencyTreeByAddressFunction(a, e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], { unitId: s, sheetId: o, range: u } = n;
      t.push({
        unitId: s,
        sheetId: o,
        range: u,
        id: a.treeId
      });
    }
    this._dependencyRTreeCacheForAddressFunction.bulkInsert(t);
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  async _getRangeListByFunctionRefNode(a, e, t) {
    const r = [];
    for (let n = 0, s = a.length; n < s; n++) {
      const o = a[n], c = (await this._executeNode(o, e, t)).toUnitRange();
      r.push(c), o.setValue(null);
    }
    return r;
  }
  /**
   * Build a formula dependency tree based on the dependency relationships.
   * @param treeList
   */
  _getUpdateTreeListAndMakeDependency(a) {
    const e = [], t = /* @__PURE__ */ new Set(), r = this._currentConfigService.isForceCalculate(), n = this._currentConfigService.getDirtyRanges(), s = this._dependencyManagerService.searchDependency(n), o = this._dependencyRTreeCacheForAddressFunction.bulkSearch(n);
    for (const c of o)
      s.add(c);
    const u = this._dependencyManagerService.buildDependencyTree(a);
    for (const c of u) {
      const l = c.treeId;
      (r || c.isDirty || c.dependencySheetName(this._currentConfigService.getDirtyNameMap()) || //O(n) n=tree.rangeList.length
      s.has(l) && !c.isExcludeRange(this._currentConfigService.getExcludedRange())) && !t.has(l) && (e.push(c), t.add(l));
    }
    return e;
  }
  _includeTreeFeature(a) {
    var n, s;
    const e = a.unitId, t = a.subUnitId, r = a.featureId;
    if (r != null) {
      const o = this._currentConfigService.getDirtyUnitFeatureMap();
      if (((s = (n = o == null ? void 0 : o[e]) == null ? void 0 : n[t]) == null ? void 0 : s[r]) != null)
        return !0;
    }
    return !1;
  }
  _includeOtherFormula(a) {
    var n, s;
    const e = a.unitId, t = a.subUnitId, r = a.formulaId;
    if (r != null) {
      const o = this._currentConfigService.getDirtyUnitOtherFormulaMap();
      if (((s = (n = o == null ? void 0 : o[e]) == null ? void 0 : n[t]) == null ? void 0 : s[r]) != null)
        return !0;
    }
    return !1;
  }
  _detectForcedRecalculationNode(a, e) {
    return e == null ? !1 : this._detectForcedRecalculationNodeRecursion(e);
  }
  _detectForcedRecalculationNodeRecursion(a) {
    if (a.isForcedCalculateFunction())
      return !0;
    const e = a.getChildren();
    for (let t = 0, r = e.length; t < r; t++) {
      const n = e[t];
      if (this._detectForcedRecalculationNodeRecursion(n))
        return !0;
    }
    return !1;
  }
  /**
   * Determine whether all ranges of the current node exist within the dirty area.
   * If they are within the dirty area, return true, indicating that this node needs to be calculated.
   * @param tree
   */
  _includeTree(a, e) {
    var c, l, f;
    const t = a.unitId, r = a.subUnitId;
    if (this._detectForcedRecalculationNode(a, e) === !0 || this._includeTreeFeature(a) === !0 || this._includeOtherFormula(a) === !0 || nh(a, e, this._currentConfigService) === !0)
      return !0;
    const n = (l = (c = this._currentConfigService.getExcludedRange()) == null ? void 0 : c[t]) == null ? void 0 : l[r];
    if ((n == null ? void 0 : n.getValue(a.row, a.column)) != null)
      return !1;
    if (((f = this._currentConfigService.getDirtyNameMap()[t]) == null ? void 0 : f[r]) != null)
      return !0;
    if (!this._updateRangeFlattenCache.has(t))
      return !1;
    const o = this._updateRangeFlattenCache.get(t);
    if (!o.has(r))
      return !1;
    const u = o.get(r);
    for (const h of u)
      if (a.inRangeData(h))
        return !0;
    return !1;
  }
  /**
   * Generate the final formula calculation order array by traversing the dependency tree established via depth-first search.
   * @param treeList
   */
  _calculateRunList(a) {
    a.length;
    const e = a, t = [], r = [];
    for (; e.length > 0; ) {
      const n = e.pop();
      if (n === void 0 || n.isSkip())
        continue;
      if (n.isAdded()) {
        t.push(n), n.setSkip();
        continue;
      }
      r.length = 0;
      for (const o of n.parents) {
        const u = this._dependencyManagerService.getTreeById(o);
        if (!u)
          throw new Error("ParentDependencyTree object is null");
        u.isAdded() || n.isSkip() || r.push(u);
      }
      const s = this._dependencyRTreeCacheForAddressFunction.bulkSearch(n.toRTreeItem());
      for (const o of s) {
        const u = this._dependencyManagerService.getTreeById(o);
        if (!u)
          throw new Error("ParentDependencyTree object is null");
        u.isAdded() || n.isSkip() || r.push(u);
      }
      r.length === 0 ? (t.push(n), n.setSkip()) : (n.setAdded(), e.push(n, ...r));
    }
    return t;
  }
};
Zs = kh([
  Pt(0, Yt),
  Pt(1, St),
  Pt(2, Ma),
  Pt(3, vr),
  Pt(4, ye(br)),
  Pt(5, ye(Ur)),
  Pt(6, ye(Ar)),
  Pt(7, Jn)
], Zs);
var $h = Object.getOwnPropertyDescriptor, Yh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? $h(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, qt = (i, a) => (e, t) => a(e, t, i);
const Hh = 500, zs = Ze("engine-formula.calculate-formula.service");
let Js = class extends Ne {
  constructor(a, e, t, r, n, s, o) {
    super();
    A(this, "_executionInProgressListener$", new hr());
    A(this, "executionInProgressListener$", this._executionInProgressListener$.asObservable());
    A(this, "_executionCompleteListener$", new hr());
    A(this, "executionCompleteListener$", this._executionCompleteListener$.asObservable());
    A(this, "_executeLock", new cc());
    this._configService = a, this._lexer = e, this._currentConfigService = t, this._runtimeService = r, this._formulaDependencyGenerator = n, this._interpreter = s, this._astTreeBuilder = o;
  }
  dispose() {
    super.dispose(), this._executionInProgressListener$.complete(), this._executionCompleteListener$.complete(), Rn.clear(), We.clear(), Ts.clear(), Hs.clear();
  }
  /**
   * Stop the execution of the formula.
   */
  stopFormulaExecution() {
    this._runtimeService.stopExecution();
  }
  /**
   * When the feature is loading,
   * the pre-calculated content needs to be input to the formula engine in advance,
   * so that the formula can read the correct values.
   * @param featureId
   * @param featureData
   */
  setRuntimeFeatureCellData(a, e) {
    this._runtimeService.setRuntimeFeatureCellData(a, e);
  }
  setRuntimeFeatureRange(a, e) {
    this._runtimeService.setRuntimeFeatureRange(a, e);
  }
  async execute(a) {
    this._runtimeService.setFormulaExecuteStage(Je.START), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._currentConfigService.load(a), this._runtimeService.reset();
    const e = a.maxIteration || Co;
    this._executeLock.acquire("FORMULA_EXECUTION_LOCK", async () => {
      for (let t = 0; t < e && (this._runtimeService.setFormulaCycleIndex(t), await this._executeStep(), Rn.clear(), !!this._runtimeService.isCycleDependency()); t++)
        ;
      this._runtimeService.setFormulaExecuteStage(Je.CALCULATION_COMPLETED), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData()), We.clear(), this._runtimeService.reset();
    });
  }
  async _executeStep() {
    const a = await this._apply();
    if (a == null)
      return;
    const { arrayFormulaRange: e, runtimeFeatureRange: t } = a, { dirtyRanges: r, excludedCell: n } = this._getArrayFormulaDirtyRangeAndExcludedRange(
      e,
      t
    );
    return r == null || r.length === 0 || (this._currentConfigService.loadDirtyRangesAndExcludedCell(r, n), await this._apply(!0)), !0;
  }
  _getArrayFormulaDirtyRangeAndExcludedRange(a, e) {
    const t = [], r = {};
    return Object.keys(a).forEach((n) => {
      const s = a[n];
      if (s == null)
        return !0;
      Object.keys(s).forEach((o) => {
        const u = new Ce(s[o]);
        if (u == null)
          return !0;
        const c = new Ce();
        u.forValue((l, f, h) => {
          c.setValue(l, f, !0), t.push({ unitId: n, sheetId: o, range: h });
        }), r[n] == null && (r[n] = {}), r[n][o] = c;
      });
    }), Object.keys(e).forEach((n) => {
      const s = e[n];
      Object.keys(s).forEach((o) => {
        const u = s[o];
        if (u == null)
          return !0;
        Object.keys(u).forEach((c) => {
          const l = u[c];
          if (l == null)
            return !0;
          for (const f of l)
            t.push({ unitId: o, sheetId: c, range: f });
        });
      });
    }), { dirtyRanges: t, excludedCell: r };
  }
  // eslint-disable-next-line max-lines-per-function
  async _apply(a = !1) {
    a ? this._runtimeService.setFormulaExecuteStage(Je.START_DEPENDENCY_ARRAY_FORMULA) : this._runtimeService.setFormulaExecuteStage(Je.START_DEPENDENCY), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    const e = (await this._formulaDependencyGenerator.generate()).reverse(), t = this._interpreter;
    a ? (this._runtimeService.setFormulaExecuteStage(Je.START_CALCULATION_ARRAY_FORMULA), this._runtimeService.setTotalArrayFormulasToCalculate(e.length)) : (this._runtimeService.setFormulaExecuteStage(Je.START_CALCULATION), this._runtimeService.setTotalFormulasToCalculate(e.length)), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    let r = [];
    const n = this._configService.getConfig(Ca), s = (n == null ? void 0 : n.intervalCount) || Hh, o = e.length;
    for (let u = 0; u < o; u++) {
      const c = e[u], l = c.nodeData, f = c.getDirtyData;
      if (u % s === 0 && (await new Promise((d) => {
        const _ = lc(d);
        r.push(_);
      }), a ? (this._runtimeService.setFormulaExecuteStage(
        Je.CURRENTLY_CALCULATING_ARRAY_FORMULA
      ), this._runtimeService.setCompletedArrayFormulasCount(u + 1)) : (this._runtimeService.setFormulaExecuteStage(Je.CURRENTLY_CALCULATING), this._runtimeService.setCompletedFormulasCount(u + 1)), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._runtimeService.isStopExecution() || l == null && f == null)) {
        this._runtimeService.setFormulaExecuteStage(Je.IDLE), this._runtimeService.markedAsStopFunctionsExecuted(), this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
        return;
      }
      this._runtimeService.setCurrent(
        c.row,
        c.column,
        c.rowCount,
        c.columnCount,
        c.subUnitId,
        c.unitId
      );
      let h;
      if (f != null && c.featureId != null) {
        const { runtimeCellData: d, dirtyRanges: _ } = f(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData());
        this._runtimeService.setRuntimeFeatureCellData(c.featureId, d), this._runtimeService.setRuntimeFeatureRange(c.featureId, _);
      } else l != null && (t.checkAsyncNode(l.node) ? h = await t.executeAsync(l) : h = t.execute(l), c.formulaId != null ? this._runtimeService.setRuntimeOtherData(c.formulaId, c.refOffsetX, c.refOffsetY, h) : this._runtimeService.setRuntimeData(h));
    }
    return r.forEach((u) => u()), r = [], o > 0 ? this._runtimeService.markedAsSuccessfullyExecuted() : a || this._runtimeService.markedAsNoFunctionsExecuted(), this._runtimeService.getAllRuntimeData();
  }
  calculate(a, e = !0) {
    const t = this._lexer.treeBuilder(a, e);
    if (Object.values(m).includes(t))
      return xe.create(t);
    const r = this._astTreeBuilder.parse(t);
    r == null || r.serialize();
  }
};
Js = Yh([
  qt(0, ia),
  qt(1, ye(Ar)),
  qt(2, Yt),
  qt(3, St),
  qt(4, Xs),
  qt(5, ye(br)),
  qt(6, ye(Ur))
], Js);
var Gh = Object.getOwnPropertyDescriptor, Qh = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Gh(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, ys = (i, a) => (e, t) => a(e, t, i);
let Pn = class extends Ne {
  constructor(i, a, e) {
    super(), this._commandService = i, this._calculateFormulaService = a, this._formulaDataModel = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener(), this._initialExecuteFormulaListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        if (i.id === co.id)
          this._calculateFormulaService.stopFormulaExecution();
        else if (i.id === uo.id)
          this._calculate(i.params);
        else if (i.id === ws.id) {
          const a = i.params;
          if (a == null)
            return;
          const { arrayFormulaRange: e, arrayFormulaCellData: t } = a;
          this._formulaDataModel.setArrayFormulaRange(e), this._formulaDataModel.setArrayFormulaCellData(t);
        }
      })
    );
  }
  async _calculate(i) {
    const { forceCalculation: a = !1, dirtyRanges: e = [], dirtyNameMap: t = {}, dirtyDefinedNameMap: r = {}, dirtyUnitFeatureMap: n = {}, dirtyUnitOtherFormulaMap: s = {}, clearDependencyTreeCache: o = {}, maxIteration: u = Co, rowData: c } = i, l = this._formulaDataModel.getFormulaData(), f = this._formulaDataModel.getArrayFormulaCellData(), h = this._formulaDataModel.getArrayFormulaRange();
    this._calculateFormulaService.execute({
      formulaData: l,
      arrayFormulaCellData: f,
      arrayFormulaRange: h,
      forceCalculate: a,
      dirtyRanges: e,
      dirtyNameMap: t,
      dirtyDefinedNameMap: r,
      dirtyUnitFeatureMap: n,
      dirtyUnitOtherFormulaMap: s,
      clearDependencyTreeCache: o,
      maxIteration: u,
      rowData: c
    });
  }
  // Notification
  _initialExecuteFormulaListener() {
    this._calculateFormulaService.executionCompleteListener$.subscribe((i) => {
      const a = i.functionsExecutedState;
      switch (a) {
        case Sr.NOT_EXECUTED:
          break;
        case Sr.STOP_EXECUTION:
          break;
        case Sr.SUCCESS:
          this._applyResult(i);
          break;
        case Sr.INITIAL:
          break;
      }
      this._commandService.executeCommand(
        _n.id,
        {
          functionsExecutedState: a
        },
        {
          onlyLocal: !0
        }
      );
    }), this._calculateFormulaService.executionInProgressListener$.subscribe((i) => {
      this._commandService.executeCommand(
        _n.id,
        {
          stageInfo: i
        },
        {
          onlyLocal: !0
        }
      );
    });
  }
  async _applyResult(i) {
    const { unitData: a, unitOtherData: e, arrayFormulaRange: t, arrayFormulaCellData: r, clearArrayFormulaCellData: n } = i;
    if (!a) {
      console.error("No sheetData from Formula Engine!");
      return;
    }
    t && (this._formulaDataModel.clearPreviousArrayFormulaCellData(n), this._formulaDataModel.mergeArrayFormulaCellData(r), this._formulaDataModel.mergeArrayFormulaRange(t), this._commandService.executeCommand(
      ws.id,
      {
        arrayFormulaRange: this._formulaDataModel.getArrayFormulaRange(),
        arrayFormulaCellData: this._formulaDataModel.getArrayFormulaCellData()
      },
      {
        onlyLocal: !0
      }
    )), this._commandService.executeCommand(
      lo.id,
      {
        unitData: Fc(a),
        unitOtherData: e
      },
      {
        onlyLocal: !0
      }
    );
  }
};
Pn = Qh([
  ys(0, ir),
  ys(1, zs),
  ys(2, ye(_r))
], Pn);
const Di = /[\[\]]/g;
function Li(i, a) {
  if (Di.test(i)) {
    const e = Number(i.replace(Di, ""));
    return a + e;
  }
  return Number(i) - 1;
}
function Rs(i, a = 0, e = 0) {
  i = i.toLocaleUpperCase();
  const t = i.split(/[RC]/), r = t[1], n = t[2], s = Li(r, a), o = Li(n, e);
  return {
    row: s,
    column: o,
    absoluteRefType: we.NONE
  };
}
function Wh(i, a = 0, e = 0) {
  const { refBody: t, sheetName: r, unitId: n } = ua(i), s = t.indexOf(":");
  if (s === -1) {
    const C = Rs(t, a, e), E = C.row, b = C.column, R = C.absoluteRefType;
    return {
      unitId: n,
      sheetName: r,
      range: {
        startRow: E,
        startColumn: b,
        endRow: E,
        endColumn: b,
        startAbsoluteRefType: R,
        endAbsoluteRefType: R
      }
    };
  }
  const o = t.substring(0, s), u = t.substring(s + 1), c = Rs(o, a, e), l = Rs(u, a, e), f = c.row, h = c.column, d = l.row, _ = l.column;
  return {
    unitId: n,
    sheetName: r,
    range: {
      startRow: f,
      startColumn: h,
      endRow: d,
      endColumn: _,
      startAbsoluteRefType: c.absoluteRefType,
      endAbsoluteRefType: l.absoluteRefType
    }
  };
}
function qh(i) {
  const a = zr(i.startRow, i.startAbsoluteRefType, !0), e = zr(i.startColumn, i.startAbsoluteRefType, !1), t = zr(i.endRow, i.endAbsoluteRefType, !0), r = zr(i.endColumn, i.endAbsoluteRefType, !1);
  return a === t && e === r ? `R${a}C${e}` : `R${a}C${e}:R${t}C${r}`;
}
function zr(i, a = we.ALL, e) {
  switch (i += 1, a) {
    case we.ALL:
      return `${i}`;
    case we.ROW:
      return e ? `${i}` : `[${i}]`;
    case we.COLUMN:
      return e ? `[${i}]` : `${i}`;
    case we.NONE:
      return `[${i}]`;
  }
}
function zt(i) {
  let a = i;
  if (i.isArray()) {
    const e = i.getRowCount(), t = i.getColumnCount();
    if (e > 1 || t > 1)
      return g.create(m.VALUE);
    a = i.get(0, 0);
  }
  return a.isError(), a;
}
function Yr(...i) {
  for (let a = 0; a < i.length; a++) {
    const e = zt(i[a]);
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    i[a] = e;
  }
  return {
    isError: !1,
    variants: i
  };
}
function H(...i) {
  for (let a = 0; a < i.length; a++) {
    const e = zt(i[a]);
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE)
      };
    i[a] = e;
  }
  return {
    isError: !1,
    variants: i
  };
}
function ke(...i) {
  for (let a = 0; a < i.length; a++) {
    let e = i[a];
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (e.isNull())
      return {
        isError: !0,
        errorObject: g.create(m.NA)
      };
    if (e = zt(i[a]), e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE)
      };
    i[a] = e;
  }
  return {
    isError: !1,
    variants: i
  };
}
function B(...i) {
  for (let a = 0; a < i.length; a++) {
    let e = i[a];
    if (e.isString() && (e = e.convertToNumberObjectValue()), e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    i[a] = e;
  }
  return {
    isError: !1,
    variants: i
  };
}
class V {
  constructor(a) {
    A(this, "_unitId");
    A(this, "_subUnitId");
    A(this, "_row", -1);
    A(this, "_column", -1);
    A(this, "_definedNames");
    A(this, "_locale");
    A(this, "_sheetOrder");
    A(this, "_sheetNameMap");
    A(this, "_formulaDataModel");
    A(this, "_rowCount", -1);
    A(this, "_columnCount", -1);
    /**
     * Whether the function needs to expand the parameters
     */
    A(this, "needsExpandParams", !1);
    /**
     * Whether the function needs to pass in reference object
     */
    A(this, "needsReferenceObject", !1);
    /**
     * Whether the function needs handle locale
     */
    A(this, "needsLocale", !1);
    /**
     * Whether the function needs sheets info
     */
    A(this, "needsSheetsInfo", !1);
    /**
     * Whether the function needs function methods in FormulaDataModel
     */
    A(this, "needsFormulaDataModel", !1);
    /**
     * Whether the function needs the number of rows and columns in the sheet
     */
    A(this, "needsSheetRowColumnCount", !1);
    /**
     * Whether the function needs to filter out rows
     */
    A(this, "needsFilteredOutRows", !1);
    /**
     * Minimum number of parameters
     */
    A(this, "minParams", -1);
    /**
     * Maximum number of parameters
     */
    A(this, "maxParams", -1);
    this._name = a;
  }
  get name() {
    return this._name;
  }
  get unitId() {
    return this._unitId;
  }
  get subUnitId() {
    return this._subUnitId;
  }
  get row() {
    return this._row;
  }
  get column() {
    return this._column;
  }
  dispose() {
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  getDefinedName(a) {
    var t;
    const e = this._definedNames;
    return e == null ? null : (t = Array.from(Object.values(e)).filter((r) => r.name === a)) == null ? void 0 : t[0];
  }
  setDefinedNames(a) {
    this._definedNames = a;
  }
  getLocale() {
    return this._locale;
  }
  setLocale(a) {
    this._locale = a;
  }
  getSheetsInfo() {
    return {
      sheetOrder: this._sheetOrder,
      sheetNameMap: this._sheetNameMap
    };
  }
  setSheetsInfo({
    sheetOrder: a,
    sheetNameMap: e
  }) {
    this._sheetOrder = a, this._sheetNameMap = e;
  }
  setFormulaDataModel(a) {
    this._formulaDataModel = a;
  }
  setSheetRowColumnCount(a, e) {
    this._rowCount = a, this._columnCount = e;
  }
  isAsync() {
    return !1;
  }
  isAddress() {
    return !1;
  }
  isCustom() {
    return !1;
  }
  isArgumentsIgnoreNumberPattern() {
    return !1;
  }
  setRefInfo(a, e, t, r) {
    this._unitId = a, this._subUnitId = e, this._row = t, this._column = r;
  }
  calculateCustom(...a) {
    return null;
  }
  calculate(...a) {
    return g.create(m.VALUE);
  }
  checkArrayType(a) {
    return a.isReferenceObject() || a.isValueObject() && a.isArray();
  }
  /**
   * Starting with 1
   * For instance, The column number (starting with 1 for the left-most column of table_array) that contains the return value.
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * @param indexNum
   */
  getIndexNumValue(a, e = 1) {
    let t = a;
    if (t.isArray() && (t = t.getFirstCell()), t.isBoolean())
      return t.getValue() === !1 ? g.create(m.VALUE) : e;
    if (t.isString()) {
      const r = Number(t.getValue());
      return Number.isNaN(r) ? g.create(m.REF) : r;
    } else if (t.isNumber())
      return t.getValue();
    return g.create(m.VALUE);
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, default 1
   * For instance range_lookup, A logical value that specifies whether you want VLOOKUP to find an approximate or an exact match
   * Approximate match - 1/TRUE
   * Exact match - 0/FALSE
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * For instance A1, A logical value that specifies what type of reference is contained in the cell ref_text.
   * If a1 is TRUE or omitted, ref_text is interpreted as an A1-style reference.
   * If a1 is FALSE, ref_text is interpreted as an R1C1-style reference.
   * https://support.microsoft.com/zh-cn/office/indirect-%E5%87%BD%E6%95%B0-474b3a3a-8a26-4f44-b491-92b6306fa261
   * @param logicValueObject
   */
  getZeroOrOneByOneDefault(a) {
    if (a == null)
      return 1;
    let e = 1;
    if (a.isArray() && (a = a.getFirstCell()), a.isBoolean())
      a.getValue() === !1 && (e = 0);
    else {
      if (a.isString())
        return;
      a.isNumber() && a.getValue() === 0 && (e = 0);
    }
    return e;
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, -1, default 1.
   * The difference from getZeroOrOneByOneDefault is that we need to get -1
   * @param logicValueObject
   */
  getMatchTypeValue(a) {
    if (a == null)
      return 1;
    let e = 1;
    if (a.isArray() && (a = a.getFirstCell()), a.isBoolean())
      a.getValue() === !1 && (e = 0);
    else {
      if (a.isString())
        return;
      if (a.isNumber()) {
        const t = a.getValue();
        t <= 0 && (e = t);
      }
    }
    return e;
  }
  binarySearch(a, e, t, r, n) {
    const s = e.binarySearch(a, r, n);
    if (s == null)
      return g.create(m.NA);
    let o;
    return t.getRowCount() === 1 ? o = t.get(0, s) || ce.create() : o = t.get(s, 0) || ce.create(), o.isNull() ? y.create(0) : o;
  }
  _getOneFirstByRaw(a) {
    return a.length === 0 ? g.create(m.NA) : a[0][0] || g.create(m.NA);
  }
  _getOneLastByRaw(a) {
    return a.length === 0 ? g.create(m.NA) : a[a.length - 1][a[0].length - 1] || g.create(m.NA);
  }
  equalSearch(a, e, t, r = !0) {
    const n = t.pickRaw(e.isEqual(a));
    return r ? this._getOneFirstByRaw(n) : this._getOneLastByRaw(n);
  }
  fuzzySearch(a, e, t, r = !0) {
    const n = t.pickRaw(e.compare(a, F.EQUALS));
    return r ? this._getOneFirstByRaw(n) : this._getOneLastByRaw(n);
  }
  orderSearch(a, e, t, r = Le.MIN, n = !1) {
    const s = e.orderSearch(a, r, n);
    if (s == null)
      return g.create(m.NA);
    const o = t.get(s.row, s.column) || ce.create();
    return o.isNull() ? g.create(m.NA) : o;
  }
  binarySearchExpand(a, e, t, r = 0, n, s) {
    const o = e.binarySearch(a, n, s);
    return o == null ? g.create(m.NA) : r === 0 ? t.slice([o, o + 1]) : t.slice(void 0, [o, o + 1]);
  }
  equalSearchExpand(a, e, t, r = !0, n = 0) {
    const s = e.isEqual(a);
    let o;
    return r ? o = s.getFirstTruePosition() : o = s.getLastTruePosition(), o == null ? g.create(m.NA) : n === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  fuzzySearchExpand(a, e, t, r = !0, n = 0) {
    const s = e.compare(a, F.EQUALS);
    let o;
    return r ? o = s.getFirstTruePosition() : o = s.getLastTruePosition(), o == null ? g.create(m.NA) : n === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  orderSearchExpand(a, e, t, r = Le.MIN, n = !1, s = 0) {
    const o = e.orderSearch(a, r, n);
    return o == null ? g.create(m.NA) : s === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  flattenArray(a, e = !0) {
    const t = [];
    t[0] = [];
    for (let r = 0; r < a.length; r++) {
      let n = a[r];
      if ((n.isString() || n.isBoolean() || n.isNull()) && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      if (n.isArray()) {
        let s;
        if (n.iterator((o) => {
          if (o == null || o.isNull() || e && (o.isString() || o.isBoolean()))
            return !0;
          if (o = this._includingLogicalValuesAndText(o), o.isError())
            return s = o, !1;
          t[0].push(o);
        }), s != null && s.isError())
          return s;
      } else
        t[0].push(n);
    }
    return Fr(t, 1, t[0].length);
  }
  _includingLogicalValuesAndText(a) {
    if (a.isBoolean() && (a = Gf(a)), a.isString()) {
      const e = Number(a.getValue());
      a = y.create(Number.isNaN(e) ? 0 : e);
    }
    return a;
  }
  createReferenceObject(a, e) {
    const t = a.getForcedUnitId(), r = a.getForcedSheetId() || "", n = a.getForcedSheetName(), o = Ss({
      unitId: t,
      sheetName: n,
      range: e
    });
    let u;
    return Br(o) ? u = new ya(o) : ro(o) ? u = new pa(o) : no(o) ? u = new Ra(o) : u = new pn(e, r, t), this._setReferenceDefault(a, u);
  }
  _setReferenceDefault(a, e) {
    return this.unitId == null || this.subUnitId == null ? g.create(m.REF) : (e.setDefaultUnitId(this.unitId), e.setDefaultSheetId(this.subUnitId), e.setUnitData(a.getUnitData()), e.setRuntimeData(a.getRuntimeData()), e.setArrayFormulaCellData(a.getArrayFormulaCellData()), e.setRuntimeArrayFormulaCellData(a.getRuntimeArrayFormulaCellData()), e);
  }
}
class Kh extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    const { isError: n, errorObject: s, variants: o } = Yr(t, r);
    if (n)
      return s;
    const { isError: u, errorObject: c, variants: l } = B(...o);
    if (u)
      return c;
    const [f, h] = l, d = Math.floor(+f.getValue()), _ = Math.floor(+h.getValue());
    if (d < 0 || _ < 0)
      return g.create(m.NUM);
    if (d === 0 || _ === 0)
      return g.create(m.REF);
    const C = e.isArray() ? e.getRowCount() : 1, E = e.isArray() ? e.getColumnCount() : 1;
    if (C === 1 && E === 1)
      return e.isArray() ? e.get(0, 0) : e;
    const b = d > C ? C : d, R = _ > E ? E : _;
    return e.slice([0, b], [0, R]);
  }
}
class Xh extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = n.isArray() ? n.getRowCount() : 1, o = n.isArray() ? n.getColumnCount() : 1;
      for (let u = 0; u < s; u++)
        for (let c = 0; c < o; c++) {
          const l = n.isArray() ? n.get(u, c) : n;
          t.push([l]);
        }
    }
    return q.create({
      calculateValueList: t,
      rowCount: t.length,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
var ea = /* @__PURE__ */ ((i) => (i.ARRAY_CONSTRAIN = "ARRAY_CONSTRAIN", i.FLATTEN = "FLATTEN", i))(ea || {});
const Zh = [
  [Kh, ea.ARRAY_CONSTRAIN],
  [Xh, ea.FLATTEN]
];
var yr;
((i) => {
  const a = 0.636619772;
  function e(n, s) {
    let o = 0;
    for (let u = 0; u < n.length; ++u)
      o = s * o + n[u];
    return o;
  }
  function t(n, s, o, u, c) {
    if (s === 0)
      return o;
    if (s === 1)
      return u;
    const l = 2 / n;
    let f = o, h = u, d = u;
    for (let _ = 1; _ < s; ++_)
      d = h * _ * l + c * f, f = h, h = d;
    return d;
  }
  function r(n, s, o, u) {
    return function(l, f) {
      if (o) {
        if (l === 0)
          return o === 1 ? -1 / 0 : 1 / 0;
        if (l < 0)
          return Number.NaN;
      }
      if (f === 0)
        return n(l);
      if (f === 1)
        return s(l);
      if (f < 0)
        return Number.NaN;
      const h = f | 0, d = n(l), _ = s(l);
      return t(l, h, d, _, u);
    };
  }
  i.besselj = /* @__PURE__ */ (() => {
    const n = [-184.9052456, 77392.33017, -1121442418e-2, 6516196407e-1, -13362590354, 57568490574], s = [1, 267.8532712, 59272.64853, 9494680718e-3, 1029532985, 57568490411], o = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1], u = [-934935152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function c(C) {
      let E = 0, b = 0, R = 0, p = C * C;
      if (C < 8)
        b = e(n, p), R = e(s, p), E = b / R;
      else {
        const N = C - 0.785398164;
        p = 64 / p, b = e(o, p), R = e(u, p), E = Math.sqrt(a / C) * (Math.cos(N) * b - Math.sin(N) * R * 8 / C);
      }
      return E;
    }
    const l = [-30.16036606, 15704.4826, -2972611439e-3, 2423968531e-1, -7895059235, 72362614232], f = [1, 376.9991397, 99447.43394, 1858330474e-2, 2300535178, 144725228442], h = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1], d = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function _(C) {
      let E = 0, b = 0, R = 0, p = C * C;
      const N = Math.abs(C) - 2.356194491;
      return Math.abs(C) < 8 ? (b = C * e(l, p), R = e(f, p), E = b / R) : (p = 64 / p, b = e(h, p), R = e(d, p), E = Math.sqrt(a / Math.abs(C)) * (Math.cos(N) * b - Math.sin(N) * R * 8 / Math.abs(C)), C < 0 && (E = -E)), E;
    }
    return function C(E, b) {
      const R = Math.round(b);
      if (!Number.isFinite(E))
        return Number.isNaN(E) ? E : 0;
      if (R < 0)
        return (R % 2 ? -1 : 1) * C(E, -R);
      if (E < 0)
        return (R % 2 ? -1 : 1) * C(-E, R);
      if (R === 0)
        return c(E);
      if (R === 1)
        return _(E);
      if (E === 0)
        return 0;
      let p = 0;
      if (E > R)
        p = t(E, R, c(E), _(E), -1);
      else {
        const N = 2 * Math.floor((R + Math.floor(Math.sqrt(40 * R))) / 2);
        let M = !1, w = 0, S = 0, D = 1, L = 0;
        const U = 2 / E;
        for (let x = N; x > 0; x--)
          if (L = x * U * D - w, w = D, D = L, Math.abs(D) > 1e10 && (D *= 1e-10, w *= 1e-10, p *= 1e-10, S *= 1e-10), M && (S += D), M = !M, x === R && (p = w), N - x > 100 && p === 0)
            return Number.NaN;
        S = 2 * S - D, p /= S;
      }
      return p;
    };
  })(), i.bessely = (() => {
    const n = [228.4622733, -86327.92757, 1087988129e-2, -5123598036e-1, 7062834065, -2957821389], s = [1, 226.1030244, 47447.2647, 7189466438e-3, 7452499648e-1, 40076544269], o = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1], u = [-934945152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function c(C) {
      let E = 0, b = 0, R = 0, p = C * C;
      const N = C - 0.785398164;
      return C < 8 ? (b = e(n, p), R = e(s, p), E = b / R + a * (0, i.besselj)(C, 0) * Math.log(C)) : (p = 64 / p, b = e(o, p), R = e(u, p), E = Math.sqrt(a / C) * (Math.sin(N) * b + Math.cos(N) * R * 8 / C)), E;
    }
    const l = [8511.937935, -4237922726e-3, 7349264551e-1, -51534381390, 127527439e4, -4900604943e3], f = [1, 354.9632885, 102042.605, 2245904002e-2, 3733650367, 424441966400, 249958057e5], h = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1], d = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function _(C) {
      let E = 0, b = 0, R = 0, p = C * C;
      const N = C - 2.356194491;
      return C < 8 ? (b = C * e(l, p), R = e(f, p), E = b / R + a * ((0, i.besselj)(C, 1) * Math.log(C) - 1 / C)) : (p = 64 / p, b = e(h, p), R = e(d, p), E = Math.sqrt(a / C) * (Math.sin(N) * b + Math.cos(N) * R * 8 / C)), E;
    }
    return r(c, _, 1, -1);
  })(), i.besseli = /* @__PURE__ */ (() => {
    const n = [45813e-7, 0.0360768, 0.2659732, 1.2067492, 3.0899424, 3.5156229, 1], s = [392377e-8, -0.01647633, 0.02635537, -0.02057706, 916281e-8, -157565e-8, 225319e-8, 0.01328592, 0.39894228];
    function o(f) {
      return f <= 3.75 ? e(n, f * f / (3.75 * 3.75)) : Math.exp(Math.abs(f)) / Math.sqrt(Math.abs(f)) * e(s, 3.75 / Math.abs(f));
    }
    const u = [32411e-8, 301532e-8, 0.02658733, 0.15084934, 0.51498869, 0.87890594, 0.5], c = [-420059e-8, 0.01787654, -0.02895312, 0.02282967, -0.01031555, 163801e-8, -362018e-8, -0.03988024, 0.39894228];
    function l(f) {
      return f < 3.75 ? f * e(u, f * f / (3.75 * 3.75)) : (f < 0 ? -1 : 1) * Math.exp(Math.abs(f)) / Math.sqrt(Math.abs(f)) * e(c, 3.75 / Math.abs(f));
    }
    return function f(h, d) {
      const _ = Math.round(d);
      if (_ === 0)
        return o(h);
      if (_ === 1)
        return l(h);
      if (_ < 0)
        return Number.NaN;
      if (Math.abs(h) === 0)
        return 0;
      if (h === 1 / 0)
        return 1 / 0;
      let C = 0, E;
      const b = 2 / Math.abs(h);
      let R = 0, p = 1, N = 0;
      const M = 2 * Math.round((_ + Math.round(Math.sqrt(40 * _))) / 2);
      for (E = M; E > 0; E--)
        if (N = E * b * p + R, R = p, p = N, Math.abs(p) > 1e10 && (p *= 1e-10, R *= 1e-10, C *= 1e-10), E === _ && (C = R), M - E > 100 && C === 0)
          return Number.NaN;
      return C *= f(h, 0) / p, h < 0 && _ % 2 ? -C : C;
    };
  })(), i.besselk = (() => {
    const n = [74e-7, 1075e-7, 262698e-8, 0.0348859, 0.23069756, 0.4227842, -0.57721566], s = [53208e-8, -25154e-7, 587872e-8, -0.01062446, 0.02189568, -0.07832358, 1.25331414];
    function o(f) {
      return f <= 2 ? -Math.log(f / 2) * (0, i.besseli)(f, 0) + e(n, f * f / 4) : Math.exp(-f) / Math.sqrt(f) * e(s, 2 / f);
    }
    const u = [-4686e-8, -110404e-8, -0.01919402, -0.18156897, -0.67278579, 0.15443144, 1], c = [-68245e-8, 325614e-8, -780353e-8, 0.01504268, -0.0365562, 0.23498619, 1.25331414];
    function l(f) {
      return f <= 2 ? Math.log(f / 2) * (0, i.besseli)(f, 1) + 1 / f * e(u, f * f / 4) : Math.exp(-f) / Math.sqrt(f) * e(c, 2 / f);
    }
    return r(o, l, 2, 1);
  })();
})(yr || (yr = {}));
function wa(i) {
  return /^[01]{1,10}$/.test(i);
}
function Sa(i) {
  return /^[0-7]{1,10}$/.test(i);
}
function Da(i) {
  return /^[0-9A-Fa-f]{1,10}$/.test(i);
}
function Jt(i) {
  if (i === 0)
    return 0;
  const a = [
    -1.3026537197817094,
    // eslint-disable-next-line no-loss-of-precision
    0.6419697923564902,
    0.019476473204185836,
    -0.00956151478680863,
    -946595344482036e-18,
    366839497852761e-18,
    42523324806907e-18,
    -20278578112534e-18,
    -1624290004647e-18,
    130365583558e-17,
    15626441722e-18,
    -85238095915e-18,
    6529054439e-18,
    5059343495e-18,
    -991364156e-18,
    -227365122e-18,
    96467911e-18,
    2394038e-18,
    -6886027e-18,
    894487e-18,
    313092e-18,
    -112708e-18,
    381e-18,
    7106e-18,
    -1523e-18,
    -94e-18,
    121e-18,
    -28e-18
  ];
  let e = i, t = !1;
  e < 0 && (e = -e, t = !0);
  const r = 2 / (2 + e), n = 4 * r - 2;
  let s = 0, o = 0, u;
  for (let l = a.length - 1; l > 0; l--)
    u = s, s = n * s - o + a[l], o = u;
  const c = r * Math.exp(-e * e + 0.5 * (a[0] + n * s) - o);
  return t ? c - 1 : 1 - c;
}
function La(i) {
  return 1 - Jt(i);
}
function zh(i) {
  if (i >= 2)
    return -100;
  if (i <= 0)
    return 100;
  const a = i < 1 ? i : 2 - i, e = Math.sqrt(-2 * Math.log(a / 2));
  let t = -0.70711 * ((2.30753 + e * 0.27061) / (1 + e * (0.99229 + e * 0.04481)) - e);
  for (let r = 0; r < 2; r++) {
    const n = La(t) - a;
    t += n / (1.1283791670955126 * Math.exp(-t * t) - t * n);
  }
  return i < 1 ? t : -t;
}
function mr(i, a = 1) {
  let e = Math.floor(i);
  if (i < 0)
    return Number.NaN;
  let t = 1;
  for (; e > 1 && Number.isFinite(t); )
    t *= e, e -= a;
  return t;
}
function er(i, a) {
  const e = Math.min(i - a, a);
  let t = 1;
  for (let r = 1; r <= e && Number.isFinite(t); r++)
    t *= i - r + 1, t /= r;
  return t;
}
function ta(i, a) {
  let e = Math.floor(i), t = Math.floor(a);
  for (; t !== 0; ) {
    const r = t;
    t = e % t, e = r;
  }
  return e;
}
function Pi(i, a) {
  const e = ta(i, a);
  return e === 0 ? 0 : Math.abs(i * a) / e;
}
function Pa(i) {
  const a = i.length;
  if (a === 1)
    return i[0][0];
  if (a === 2)
    return i[0][0] * i[1][1] - i[0][1] * i[1][0];
  const { rowSwap: e, smallPivotDetected: t, luMatrix: r, permutation: n } = ko(i);
  if (t)
    return 0;
  let s = e ? 1 : -1;
  for (let o = 0; o < n.length; o++)
    s *= r[o][o];
  return s === 0 ? 0 : s;
}
function Jh(i) {
  const a = Pa(i);
  return a === 0 ? null : i.length === 1 ? [[1 / a]] : tm(i).map((r) => r.map((n) => n / a));
}
function em(i, a, e) {
  return i.filter((t, r) => r !== a).map((t) => t.filter((r, n) => n !== e));
}
function tm(i) {
  const a = i.length, e = Array.from({ length: a }, () => new Array(a).fill(0));
  for (let t = 0; t < a; t++)
    for (let r = 0; r < a; r++) {
      const s = ((t + r) % 2 === 0 ? 1 : -1) * Pa(em(i, t, r));
      e[r][t] = s === 0 ? 0 : s;
    }
  return e;
}
function gr(i, a) {
  return i.map((e) => a[0].map(
    (t, r) => e.reduce((n, s, o) => n + s * a[o][r], 0)
  ));
}
function Ct(i) {
  return i[0].map((a, e) => i.map((t) => t[e]));
}
function rm(i) {
  const { smallPivotDetected: a, luMatrix: e, permutation: t } = ko(i);
  return a ? null : nm(e, t);
}
function ko(i) {
  const a = Ct(i), e = a.length, t = a[0].length;
  let r = !0, n = !1;
  const s = ra(e, t, 0), o = new Array(t).fill(0).map((u, c) => c);
  for (let u = 0; u < t; u++) {
    for (let h = 0; h < u; h++) {
      let d = a[h][u];
      for (let _ = 0; _ < h; _++)
        d -= s[h][_] * s[_][u];
      s[h][u] = d;
    }
    let c = -1 / 0, l = u;
    for (let h = u; h < e; h++) {
      let d = a[h][u];
      for (let C = 0; C < u; C++)
        d -= s[h][C] * s[C][u];
      s[h][u] = d;
      const _ = Math.abs(d);
      _ > c && (c = _, l = h);
    }
    if (Math.abs(s[l][u]) < 1e-11) {
      n = !0;
      break;
    }
    l !== u && ([s[u], s[l]] = [s[l], s[u]], [a[u], a[l]] = [a[l], a[u]], [o[u], o[l]] = [o[l], o[u]], r = !r);
    const f = s[u][u];
    for (let h = u + 1; h < e; h++)
      s[h][u] /= f;
  }
  return {
    rowSwap: r,
    smallPivotDetected: n,
    luMatrix: s,
    permutation: o
  };
}
function nm(i, a) {
  const e = a.length, t = ra(e, e, 0);
  for (let n = 0; n < e; n++)
    t[n][n] = 1;
  const r = ra(e, e, 0);
  for (let n = 0; n < e; n++) {
    const s = a[n];
    for (let o = 0; o < e; o++)
      r[n][o] = t[s][o];
  }
  for (let n = 0; n < e; n++) {
    const s = r[n];
    for (let o = n + 1; o < e; o++) {
      const u = i[o][n];
      for (let c = 0; c < e; c++)
        r[o][c] -= s[c] * u;
    }
  }
  for (let n = e - 1; n >= 0; n--) {
    const s = r[n], o = i[n][n];
    for (let u = 0; u < e; u++)
      s[u] /= o;
    for (let u = 0; u < n; u++) {
      const c = i[u][n];
      for (let l = 0; l < e; l++)
        r[u][l] -= s[l] * c;
    }
  }
  return r;
}
function ra(i, a, e) {
  const t = [];
  for (let r = 0; r < i; r++) {
    t[r] = [];
    for (let n = 0; n < a; n++)
      t[r].push(e);
  }
  return t;
}
function sm(i) {
  const a = am(i);
  if (!a)
    return null;
  const { matrixU: e, matrixS: t, matrixV: r } = a, n = Ct(e), s = Array.from({ length: t.length }, () => new Array(i[0].length).fill(0)), o = Math.max(i.length, i[0].length) * Number.EPSILON * t[0];
  for (let u = 0; u < t.length; u++)
    Math.abs(t[u]) > o && (s[u][u] = 1 / t[u]);
  return gr(r, gr(s, n));
}
function am(i) {
  const a = Ct(i), e = a.length, t = a[0].length;
  if (e < t)
    return null;
  const r = new Array(t).fill(0), n = new Array(t).fill(0), s = Array.from({ length: t }, () => new Array(t).fill(0));
  let o = Number.EPSILON, u = 0, c = 0, l = 0;
  for (let C = 0; C < t; C++) {
    if (r[C] = u, c = ps(a, C, e, C, C), c <= 1e-64 / o)
      u = 0;
    else {
      u = Math.sqrt(c), a[C][C] >= 0 && (u = -u);
      const b = a[C][C] * u - c;
      a[C][C] -= u;
      for (let R = C + 1; R < t; R++) {
        c = ps(a, C, e, C, R);
        for (let p = C; p < e; p++)
          a[p][R] += c / b * a[p][C];
      }
    }
    if (n[C] = u, c = xi(a, C + 1, t, C, C), c <= 1e-64 / o)
      u = 0;
    else {
      u = Math.sqrt(c), a[C][C + 1] >= 0 && (u = -u);
      const b = a[C][C + 1] * u - c;
      a[C][C + 1] -= u;
      for (let R = C + 1; R < t; R++)
        r[R] = a[C][R] / b;
      for (let R = C + 1; R < e; R++) {
        c = xi(a, C + 1, t, R, C);
        for (let p = C + 1; p < t; p++)
          a[R][p] += c * r[p];
      }
    }
    const E = Math.abs(n[C]) + Math.abs(r[C]);
    E > l && (l = E);
  }
  let f = 0;
  for (let C = t - 1; C >= 0; C--) {
    if (u !== 0) {
      for (let E = f; E < t; E++)
        s[E][C] = a[C][E] / (u * a[C][C + 1]);
      for (let E = f; E < t; E++) {
        c = 0;
        for (let b = f; b < t; b++)
          c += a[C][b] * s[b][E];
        for (let b = f; b < t; b++)
          s[b][E] += c * s[b][C];
      }
    }
    for (let E = f; E < t; E++)
      s[C][E] = 0, s[E][C] = 0;
    s[C][C] = 1, u = r[C], f = C;
  }
  for (let C = t - 1; C >= 0; C--) {
    u = n[C];
    for (let E = C + 1; E < t; E++)
      a[C][E] = 0;
    if (u !== 0) {
      for (let E = C + 1; E < t; E++) {
        c = ps(a, C + 1, e, C, E);
        for (let b = C; b < e; b++)
          a[b][E] += c / (a[C][C] * u) * a[b][C];
      }
      for (let E = C; E < e; E++)
        a[E][C] /= u;
    } else
      for (let E = C; E < e; E++)
        a[E][C] = 0;
    a[C][C] += 1;
  }
  o *= l;
  let h = 0, d = 0, _ = 0;
  for (let C = t - 1; C >= 0; C--)
    for (let E = 0; E < 50; E++) {
      let b = !1, R = C;
      for (; R >= 0; R--) {
        if (Math.abs(r[R]) <= o) {
          b = !0;
          break;
        }
        if (Math.abs(n[R - 1]) <= o)
          break;
      }
      if (!b) {
        let w = 0, S = 1;
        for (let D = R; D < C + 1 && (h = S * r[D], d = n[D], r[D] *= w, !(Math.abs(h) <= o)); D++) {
          _ = Jr(h, d), n[D] = _, w = d / _, S = -h / _;
          for (let L = 0; L < e; L++) {
            const U = a[L][R - 1], x = a[L][D];
            a[L][R - 1] = U * w + x * S, a[L][D] = -U * S + x * w;
          }
        }
      }
      if (R === C) {
        if (n[C] < 0) {
          n[C] = -n[C];
          for (let w = 0; w < t; w++)
            s[w][C] = -s[w][C];
        }
        break;
      }
      if (E >= 49)
        return null;
      let p = n[R];
      h = ((n[C - 1] - n[C]) * (n[C - 1] + n[C]) + (r[C - 1] - r[C]) * (r[C - 1] + r[C])) / (2 * r[C] * n[C - 1]), _ = Jr(h, 1), h < 0 ? h = ((p - n[C]) * (p + n[C]) + r[C] * (n[C - 1] / (h - _) - r[C])) / p : h = ((p - n[C]) * (p + n[C]) + r[C] * (n[C - 1] / (h + _) - r[C])) / p;
      let N = 1, M = 1;
      for (let w = R + 1; w < C + 1; w++) {
        let S = r[w], D = n[w];
        d = M * S, S *= N, _ = Jr(h, d), r[w - 1] = _, N = h / _, M = d / _, h = p * N + S * M, d = D * M, S = -p * M + S * N, D *= N;
        for (let L = 0; L < t; L++) {
          const U = s[L][w - 1], x = s[L][w];
          s[L][w - 1] = U * N + x * M, s[L][w] = -U * M + x * N;
        }
        _ = Jr(h, d), n[w - 1] = _, N = h / _, M = d / _, h = N * S + M * D, p = -M * S + N * D;
        for (let L = 0; L < e; L++) {
          const U = a[L][w - 1], x = a[L][w];
          a[L][w - 1] = U * N + x * M, a[L][w] = -U * M + x * N;
        }
      }
      r[R] = 0, r[C] = h, n[C] = p;
    }
  for (let C = 0; C < n.length; C++)
    n[C] < o && (n[C] = 0);
  for (let C = 0; C < t; C++)
    for (let E = C - 1; E >= 0; E--)
      if (n[E] < n[C]) {
        const b = n[E];
        n[E] = n[C], n[C] = b;
        for (let R = 0; R < a.length; R++) {
          const p = a[R][C];
          a[R][C] = a[R][E], a[R][E] = p;
        }
        for (let R = 0; R < s.length; R++) {
          const p = s[R][C];
          s[R][C] = s[R][E], s[R][E] = p;
        }
        C = E;
      }
  return {
    matrixU: a,
    matrixS: n,
    matrixV: s
  };
}
function Jr(i, a) {
  let e = 0;
  return Math.abs(i) > Math.abs(a) ? (e = a / i, Math.abs(i) * Math.sqrt(1 + e * e)) : a !== 0 ? (e = i / a, Math.abs(a) * Math.sqrt(1 + e * e)) : 0;
}
function ps(i, a, e, t, r) {
  let n = 0;
  for (let s = a; s < e; s++)
    n += i[s][t] * i[s][r];
  return n;
}
function xi(i, a, e, t, r) {
  let n = 0;
  for (let s = a; s < e; s++)
    n += i[t][s] * i[r][s];
  return n;
}
const en = /* @__PURE__ */ new Map([
  ["I", 1],
  ["V", 5],
  ["X", 10],
  ["L", 50],
  ["C", 100],
  ["D", 500],
  ["M", 1e3]
]), im = /* @__PURE__ */ new Map([
  [1, "I"],
  [4, "IV"],
  [5, "V"],
  [9, "IX"],
  [10, "X"],
  [40, "XL"],
  [45, "VL"],
  [49, "IL"],
  [50, "L"],
  [90, "XC"],
  [95, "VC"],
  [99, "IC"],
  [100, "C"],
  [400, "CD"],
  [450, "LD"],
  [490, "XD"],
  [495, "VD"],
  [499, "ID"],
  [500, "D"],
  [900, "CM"],
  [950, "LM"],
  [990, "XM"],
  [995, "VM"],
  [999, "IM"],
  [1e3, "M"]
]), om = [
  [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 50, 90, 95, 100, 400, 450, 500, 900, 950, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 500, 900, 950, 990, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 500, 900, 950, 990, 995, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 499, 500, 900, 950, 990, 995, 999, 1e3, 4e3]
];
function $o(i, a, e) {
  return i <= 0 ? 0 : i >= 1 ? 1 : es(i, a, e);
}
function um(i, a, e) {
  return i <= 0 || i >= 1 ? 0 : a === 1 && e === 1 ? 1 : a < 512 && e < 512 ? i ** (a - 1) * (1 - i) ** (e - 1) / ja(a, e) : Math.exp((a - 1) * Math.log(i) + (e - 1) * Math.log(1 - i) - Ua(a, e));
}
function xa(i, a, e) {
  if (i <= 0)
    return 0;
  if (i >= 1)
    return 1;
  const t = 1e-8;
  let r;
  if (a >= 1 && e >= 1) {
    const c = i < 0.5 ? i : 1 - i, l = Math.sqrt(-2 * Math.log(c));
    r = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l, i < 0.5 && (r = -r);
    const f = (r * r - 3) / 6, h = 2 / (1 / (2 * a - 1) + 1 / (2 * e - 1)), d = r * Math.sqrt(f + h) / h - (1 / (2 * e - 1) - 1 / (2 * a - 1)) * (f + 5 / 6 - 2 / (3 * h));
    r = a / (a + e * Math.exp(2 * d));
  } else {
    const c = Math.exp(a * Math.log(a / (a + e))) / a, l = Math.exp(e * Math.log(e / (a + e))) / e, f = c + l;
    i < c / f ? r = (a * f * i) ** (1 / a) : r = 1 - (e * f * (1 - i)) ** (1 / e);
  }
  const n = -Ua(a, e);
  let s, o, u;
  for (let c = 0; c < 10; c++) {
    if (r === 0 || r === 1)
      return r;
    if (s = es(r, a, e) - i, o = Math.exp((a - 1) * Math.log(r) + (e - 1) * Math.log(1 - r) + n), u = s / o, r -= o = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / r - (e - 1) / (1 - r)))), r <= 0 && (r = 0.5 * (r + o)), r >= 1 && (r = 0.5 * (r + o + 1)), Math.abs(o) < t * r && c > 0)
      break;
  }
  return r;
}
function es(i, a, e) {
  const t = i === 0 || i === 1 ? 0 : Math.exp(ft(a + e) - ft(a) - ft(e) + a * Math.log(i) + e * Math.log(1 - i));
  return i < (a + 1) / (a + e + 2) ? t * ji(i, a, e) / a : 1 - t * ji(1 - i, e, a) / e;
}
function ji(i, a, e) {
  let n = 1 - (a + e) * i / (a + 1);
  Math.abs(n) < 1e-8 && (n = 1e-8), n = 1 / n;
  let s = 1, o = n;
  for (let u = 1; u <= 100; u++) {
    let c = u * (e - u) * i / ((a - 1 + u * 2) * (a + u * 2));
    if (n = 1 + c * n, Math.abs(n) < 1e-8 && (n = 1e-8), s = 1 + c / s, Math.abs(s) < 1e-8 && (s = 1e-8), n = 1 / n, o *= n * s, c = -(a + u) * (a + e + u) * i / ((a + u * 2) * (a + 1 + u * 2)), n = 1 + c * n, Math.abs(n) < 1e-8 && (n = 1e-8), s = 1 + c / s, Math.abs(s) < 1e-8 && (s = 1e-8), n = 1 / n, o *= n * s, Math.abs(n * s - 1) < 1e-8)
      break;
  }
  return o;
}
function ja(i, a) {
  return i + a > 170 ? Math.exp(Ua(i, a)) : mn(i) * mn(a) / mn(i + a);
}
function Ua(i, a) {
  return ft(i) + ft(a) - ft(i + a);
}
function Yo(i, a, e) {
  if (i < 0)
    return 0;
  if (i >= a)
    return 1;
  if (e < 0 || e > 1 || a <= 0)
    return Number.NaN;
  let t = 0;
  for (let r = 0; r <= i; r++)
    t += va(r, a, e);
  return t;
}
function va(i, a, e) {
  return e === 0 || e === 1 ? a * e === i ? 1 : 0 : er(a, i) * e ** i * (1 - e) ** (a - i);
}
function Ta(i, a) {
  return i <= 0 ? 0 : Ia(a / 2, i / 2);
}
function cm(i, a) {
  return i < 0 ? 0 : i === 0 && a === 2 ? 0.5 : Math.exp((a / 2 - 1) * Math.log(i) - i / 2 - a / 2 * Math.log(2) - ft(a / 2));
}
function Ho(i, a) {
  return i <= 0 ? 0 : i >= 1 ? 1 / 0 : 2 * Wo(i, a / 2);
}
function Ba(i, a, e) {
  return i < 0 ? 0 : es(a * i / (a * i + e), a / 2, e / 2);
}
function lm(i, a, e) {
  if (i < 0)
    return 0;
  if (i === 0 && a < 2)
    return 1 / 0;
  if (i === 0 && a === 2)
    return 1;
  let t = 1 / ja(a / 2, e / 2);
  return t *= (a / e) ** (a / 2), t *= i ** (a / 2 - 1), t *= (1 + a / e * i) ** (-(a + e) / 2), t;
}
function Go(i, a, e) {
  return i <= 0 ? 0 : i >= 1 ? 1 / 0 : e / (a * (1 / xa(i, a / 2, e / 2) - 1));
}
function fm(i, a) {
  return i < 0 ? 0 : 1 - Math.exp(-a * i);
}
function hm(i, a) {
  return i < 0 ? 0 : a * Math.exp(-a * i);
}
function Qo(i, a, e) {
  const t = a.length;
  let r = 0, n = 0;
  for (let h = 0; h < t; h++)
    r += a[h], n += e[h];
  const s = r / t, o = n / t;
  let u = 0, c = 0;
  for (let h = 0; h < t; h++)
    u += (a[h] - s) * (e[h] - o), c += (e[h] - o) ** 2;
  if (c === 0)
    return 1 / 0;
  const l = u / c;
  return s - l * o + l * i;
}
function mn(i) {
  const a = [
    -1.716185138865495,
    24.76565080557592,
    -379.80425647094563,
    629.3311553128184,
    866.9662027904133,
    -31451.272968848367,
    -36144.413418691176,
    66456.14382024054
  ], e = [
    -30.8402300119739,
    315.35062697960416,
    -1015.1563674902192,
    -3107.771671572311,
    // eslint-disable-next-line no-loss-of-precision
    22538.11842098015,
    // eslint-disable-next-line no-loss-of-precision
    4755.846277527881,
    -134659.9598649693,
    -115132.2596755535
  ];
  let t = 0, r = i;
  if (i > 171.6243769536076)
    return 1 / 0;
  if (r <= 0) {
    const f = r % 1 + 36e-17;
    if (f)
      t = (r & 1 ? -1 : 1) * Math.PI / Math.sin(Math.PI * f), r = 1 - r;
    else
      return 1 / 0;
  }
  const n = r;
  let s = 0, o;
  r < 1 ? o = r++ : o = (r -= s = (r | 0) - 1) - 1;
  let u = 0, c = 0;
  for (let f = 0; f < 8; ++f)
    u = (u + a[f]) * o, c = c * o + e[f];
  let l = u / c + 1;
  if (n < r)
    l /= n;
  else if (n > r)
    for (let f = 0; f < s; ++f)
      l *= r, r++;
  return t && (l = t / l), l;
}
function mm(i, a, e) {
  return i <= 0 ? 0 : Ia(a, i / e);
}
function gm(i, a, e) {
  return i < 0 ? 0 : i === 0 && a === 1 ? 1 / e : Math.exp((a - 1) * Math.log(i) - i / e - ft(a) - a * Math.log(e));
}
function dm(i, a, e) {
  return i <= 0 ? 0 : i >= 1 ? 1 / 0 : e * Wo(i, a);
}
function ft(i) {
  const a = [
    76.18009172947146,
    -86.50532032941678,
    24.01409824083091,
    // eslint-disable-line
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  let e = i, t = i + 5.5;
  t -= (i + 0.5) * Math.log(t);
  let r = 1.000000000190015;
  for (let n = 0; n < 6; n++)
    r += a[n] / ++e;
  return -t + Math.log(2.5066282746310007 * r / i);
}
function Ia(i, a) {
  if (a < 0 || i <= 0)
    return Number.NaN;
  const e = 1e-30, t = -~(Math.log(i >= 1 ? i : 1 / i) * 8.5 + i * 0.4 + 17), r = ft(i), n = Math.exp(-a + i * Math.log(a) - r);
  let s = i, o = 1 / i, u = o;
  if (a < i + 1) {
    if (n === 0)
      return 0;
    for (let d = 1; d <= t && (o += u *= a / ++s, !(Math.abs(u) < Math.abs(o) * e)); d++)
      ;
    return o * n;
  }
  if (n === 0)
    return 1;
  let c = a + 1 - i, l = 1 / e, f = 1 / c, h = f;
  for (let d = 1; d <= t; d++) {
    const _ = -d * (d - i);
    if (c += 2, f = _ * f + c, Math.abs(f) < e && (f = e), l = c + _ / l, Math.abs(l) < e && (l = e), f = 1 / f, h *= f * l, Math.abs(f * l - 1) < e)
      break;
  }
  return 1 - h * n;
}
function Wo(i, a) {
  if (i <= 0)
    return 0;
  if (i >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  let e;
  if (a > 1) {
    const o = i < 0.5 ? i : 1 - i, u = Math.sqrt(-2 * Math.log(o));
    e = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, i < 0.5 && (e = -e), e = Math.max(1e-3, a * (1 - 1 / (9 * a) - e / (3 * Math.sqrt(a))) ** 3);
  } else {
    const o = 1 - a * (0.253 + a * 0.12);
    i < o ? e = (i / o) ** (1 / a) : e = 1 - Math.log(1 - (i - o) / (1 - o));
  }
  const t = 1e-8, r = ft(a);
  let n, s;
  for (let o = 0; o < 12; o++) {
    if (e <= 0)
      return 0;
    if (n = Ia(a, e) - i, a > 1 ? s = Math.exp((a - 1) * (Math.log(a - 1) - 1) - r) * Math.exp(-(e - (a - 1)) + (a - 1) * (Math.log(e) - Math.log(a - 1))) : s = Math.exp(-e + (a - 1) * Math.log(e) - r), s !== 0 && (s = n / s / (1 - 0.5 * Math.min(1, n / s * ((a - 1) / e - 1)))), e -= s, e <= 0 && (e = 0.5 * (e + s)), Math.abs(s) < t * e)
      break;
  }
  return e;
}
function Cm(i, a, e, t) {
  let r = 0;
  for (let n = 0; n <= i; n++)
    r += Fa(n, a, e, t);
  return r;
}
function Fa(i, a, e, t) {
  return a - i > t - e ? 0 : er(e, i) * er(t - e, a - i) / er(t, a);
}
function qo(i, a, e) {
  return i < 0 ? 0 : 0.5 + 0.5 * Jt((Math.log(i) - a) / Math.sqrt(2 * e * e));
}
function _m(i, a, e) {
  return i <= 0 ? 0 : Math.exp(-Math.log(i) - 0.5 * Math.log(2 * Math.PI) - Math.log(e) - (Math.log(i) - a) ** 2 / (2 * e * e));
}
function Am(i, a, e) {
  return Math.exp(ts(i, a, e));
}
function Em(i, a, e) {
  if (i < 0)
    return 0;
  let t = 0;
  for (let r = 0; r <= i; r++)
    t += ka(r, a, e);
  return t;
}
function ka(i, a, e) {
  return i < 0 ? 0 : er(i + a - 1, a - 1) * e ** a * (1 - e) ** i;
}
function Hr(i, a, e) {
  return 0.5 * (1 + Jt((i - a) / Math.sqrt(2 * e * e)));
}
function Ko(i, a, e) {
  return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(e) - (i - a) ** 2 / (2 * e * e));
}
function ts(i, a, e) {
  return -1.4142135623730951 * e * zh(2 * i) + a;
}
function bm(i, a) {
  let e = 0;
  for (let t = 0; t <= i; t++)
    e += Xo(t, a);
  return e;
}
function Xo(i, a) {
  return Math.exp(-a) * a ** i / mr(i);
}
function Gr(i, a) {
  const e = 0.5 * es(a / (i ** 2 + a), a / 2, 0.5);
  return i < 0 ? e : 1 - e;
}
function ym(i, a) {
  const e = (1 + i ** 2 / a) ** (-(a + 1) / 2);
  return 1 / (Math.sqrt(a) * ja(0.5, a / 2)) * e;
}
function rs(i, a) {
  let e = xa(2 * Math.min(i, 1 - i), 0.5 * a, 0.5);
  return e = Math.sqrt(a * (1 - e) / e), i > 0.5 ? e : -e;
}
function rt(i, a, e, t, r) {
  const n = [], s = [];
  let o = !0;
  for (let u = 0; u < e; u++) {
    const c = Math.floor(u / t), l = u % t, f = Math.floor(u / r), h = u % r, d = i.isArray() ? i.get(c, l) : i, _ = a.isArray() ? a.get(f, h) : a;
    if (d.isError())
      return {
        isError: !0,
        errorObject: d,
        array1Values: n,
        array2Values: s,
        noCalculate: o
      };
    if (_.isError())
      return {
        isError: !0,
        errorObject: _,
        array1Values: n,
        array2Values: s,
        noCalculate: o
      };
    if (d.isNull() || _.isNull() || d.isBoolean() || _.isBoolean())
      continue;
    const C = d.getValue(), E = _.getValue();
    !W(C) || !W(E) || (n.push(+C), s.push(+E), o = !1);
  }
  return {
    isError: !1,
    errorObject: null,
    array1Values: n,
    array2Values: s,
    noCalculate: o
  };
}
function ns(i, a, e) {
  const t = i.isArray() ? i.getRowCount() : 1, r = i.isArray() ? i.getColumnCount() : 1;
  let n = t, s = r;
  if (a && !a.isNull() && (n = a.isArray() ? a.getRowCount() : 1, s = a.isArray() ? a.getColumnCount() : 1, t === 1 && s !== r || r === 1 && n !== t || t !== 1 && r !== 1 && (n !== t || s !== r)))
    return {
      isError: !0,
      errorObject: g.create(m.REF)
    };
  if (e && !e.isNull()) {
    const o = e.isArray() ? e.getRowCount() : 1, u = e.isArray() ? e.getColumnCount() : 1;
    if (t === 1 && n > 1 && o !== n || r === 1 && s > 1 && u !== s)
      return {
        isError: !0,
        errorObject: g.create(m.REF)
      };
  }
  return {
    isError: !1,
    errorObject: null
  };
}
function Et(i) {
  const a = i.isArray() ? i.getRowCount() : 1, e = i.isArray() ? i.getColumnCount() : 1, t = [];
  for (let r = 0; r < a; r++) {
    t[r] = [];
    for (let n = 0; n < e; n++) {
      const s = i.isArray() ? i.get(r, n) : i;
      if (s.isError() || s.isNull() || s.isBoolean() || s.isString())
        return g.create(m.VALUE);
      t[r].push(+s.getValue());
    }
  }
  return t;
}
function ss(i, a) {
  const e = [];
  let t = 1;
  for (let r = 0; r < i; r++) {
    e[r] = [];
    for (let n = 0; n < a; n++)
      e[r].push(t++);
  }
  return e;
}
function as(i, a, e, t) {
  let r = a;
  t && (r = a.map((o) => Math.log(o)));
  let n, s;
  return e ? { slope: n, intercept: s } = Rm(i, r) : { slope: n, intercept: s } = pm(i, r), t && (n = Math.exp(n), s = Math.exp(s)), Number.isNaN(n) && !e && (n = 0), { slope: n, intercept: s, Y: r };
}
function Rm(i, a) {
  const e = a.length;
  let t = 0, r = 0, n = 0, s = 0;
  for (let l = 0; l < e; l++)
    t += i[l], r += a[l], n += i[l] * i[l], s += i[l] * a[l];
  const u = (e * s - t * r) / (e * n - t * t), c = 1 / e * r - u * (1 / e) * t;
  return {
    slope: u,
    intercept: c
  };
}
function pm(i, a) {
  const e = [[...i]], t = [...a];
  let r = e.length, n = e[0].length, s = Math.min(r, n);
  const o = new Array(s).fill(0);
  for (let c = 0; c < s; c++) {
    const l = e[c];
    let f = 0;
    for (let d = 0; d < n; d++)
      f += l[d] ** 2;
    const h = l[c] < 0 ? Math.sqrt(f) : -Math.sqrt(f);
    if (o[c] = h, h !== 0) {
      l[c] -= h;
      for (let d = c + 1; d < r; d++) {
        let _ = 0;
        for (let C = c; C < n; C++)
          _ -= e[d][C] * l[C];
        _ /= h * l[c];
        for (let C = c; C < n; C++)
          e[d][C] -= _ * l[C];
      }
    }
  }
  r = e.length, n = e[0].length, s = Math.min(r, n);
  const u = new Array(r).fill(0);
  for (let c = 0; c < s; c++) {
    const l = e[c];
    let f = 0;
    for (let h = 0; h < n; h++)
      f += t[h] * l[h];
    f /= o[c] * l[c];
    for (let h = 0; h < n; h++)
      t[h] += f * l[h];
  }
  for (let c = o.length - 1; c >= 0; c--) {
    t[c] /= o[c];
    const l = t[c], f = e[c];
    u[c] = l;
    for (let h = 0; h < c; h++)
      t[h] -= l * f[h];
  }
  return {
    slope: u[0],
    intercept: 0
  };
}
function is(i, a, e, t, r) {
  const n = i.length === 1 && i[0].length > 1;
  let s = i;
  r && (s = i.map((C) => C.map((E) => Math.log(E))));
  let o = a, u = e;
  n && (s = Ct(s), o = Ct(o), u = Ct(u)), t && (o = o.map((C) => [...C, 1]));
  const c = Ct(o), l = gr(c, o), f = gr(c, s);
  let h = rm(l);
  if (!h && (h = sm(l), !h))
    return g.create(m.NA);
  let d = gr(h, f);
  t || d.push([0]), d = Ct(d);
  const _ = d[0].pop();
  if (d[0].reverse(), d[0].push(_), r)
    for (let C = 0; C < d[0].length; C++)
      d[0][C] = Math.exp(d[0][C]);
  return {
    coefficients: d,
    Y: s,
    X: o,
    newX: u,
    XTXInverse: h
  };
}
class Zo extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = n != null ? n : y.create(0), u = s != null ? s : y.create(1);
    o.isNull() && (o = y.create(0)), u.isNull() && (u = y.create(1));
    const c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(m.NA)), h = O(c, l, t, g.create(m.NA)), d = O(c, l, r, g.create(m.NA)), _ = O(c, l, o, g.create(m.NA)), C = O(c, l, u, g.create(m.NA)), E = f.mapValue((b, R, p) => {
      const N = h.get(R, p), M = d.get(R, p), w = _.get(R, p), S = C.get(R, p);
      return this._handleSingleObject(b, N, M, w, S);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const { isError: o, errorObject: u, variants: c } = B(e, t, r, n, s);
    if (o)
      return u;
    const [l, f, h, d, _] = c, C = +l.getValue(), E = +f.getValue(), b = +h.getValue(), R = +d.getValue(), p = +_.getValue();
    if (E <= 0 || b <= 0 || C <= 0 || C >= 1 || R >= p)
      return g.create(m.NUM);
    const N = xa(C, E, b) * (p - R) + R;
    return y.create(N);
  }
}
class zo extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = Math.floor(+c.getValue()), _ = Math.floor(+l.getValue()), C = +f.getValue(), E = +h.getValue();
    if (d < 0 || d > _ || C < 0 || C > 1)
      return g.create(m.NUM);
    let b;
    return E ? b = Yo(d, _, C) : b = va(d, _, C), y.create(b);
  }
}
class Jo extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = Math.floor(+u.getValue()), h = +c.getValue(), d = +l.getValue();
    if (f < 0 || h <= 0 || h >= 1 || d <= 0 || d >= 1)
      return g.create(m.NUM);
    let _ = 0;
    for (; _ <= f && !(Yo(_, f, h) >= d); )
      _++;
    return y.create(_);
  }
}
class eu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = 1 - Ta(c, l);
    return y.create(f);
  }
}
class tu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = Ho(1 - c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class ru extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(m.VALUE) : g.create(m.NA);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d, r, n);
  }
  _getResult(e, t, r, n) {
    let s = 0;
    for (let c = 0; c < e.length; c++) {
      if (t[c] === 0)
        return g.create(m.DIV_BY_ZERO);
      s += (e[c] - t[c]) ** 2 / t[c];
    }
    let o = (r - 1) * (n - 1);
    r === 1 ? o = n - 1 : n === 1 && (o = r - 1);
    const u = 1 - Ta(s, o);
    return y.create(u);
  }
}
class nu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      if (f.isError())
        return f;
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const { isError: E, errorObject: b, variants: R } = B(f, _, C);
      if (E)
        return b;
      const [p, N, M] = R, w = +p.getValue(), S = +N.getValue(), D = Math.floor(+M.getValue());
      if (w <= 0 || w >= 1 || S <= 0 || D < 1)
        return g.create(m.NUM);
      const L = Math.abs(ts(w / 2, 0, 1) * S / Math.sqrt(D));
      return y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class su extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(m.VALUE);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    if (e.length === 0)
      return g.create(m.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let l = 0; l < r; l++)
      n += e[l], s += t[l];
    const o = n / r, u = s / r;
    let c = 0;
    for (let l = 0; l < r; l++) {
      const f = e[l] - o, h = t[l] - u;
      c += f * h;
    }
    return y.create(c / r);
  }
}
class au extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = +c.getValue(), d = +l.getValue();
    if (f < 0 || h <= 0)
      return g.create(m.NUM);
    let _;
    return d ? _ = fm(f, h) : _ = hm(f, h), y.create(_);
  }
}
class iu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || h < 1 || h > 10 ** 10 || d < 1 || d > 10 ** 10)
      return g.create(m.NUM);
    const _ = 1 - Ba(f, h, d);
    return y.create(_);
  }
}
class ou extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || f > 1 || h < 1 || h > 10 ** 10 || d < 1 || d > 10 ** 10)
      return g.create(m.NUM);
    const _ = Go(1 - f, h, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : y.create(_);
  }
}
class uu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const {
      isError: r,
      errorObject: n,
      variance: s,
      ns1: o
    } = this._getValues(e);
    if (r)
      return n;
    const {
      isError: u,
      errorObject: c,
      variance: l,
      ns1: f
    } = this._getValues(t);
    if (u)
      return c;
    let h = 2 * (1 - Ba(s / l, o, f));
    return h > 1 && (h = 2 - h), y.create(h);
  }
  // eslint-disable-next-line
  _getValues(e) {
    let t = 0, r = 0;
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    if (n === 1 && s === 1) {
      const f = e.isArray() ? e.get(0, 0) : e;
      return f.isError() ? {
        isError: !0,
        errorObject: f,
        variance: t,
        ns1: r
      } : f.isNull() ? {
        isError: !0,
        errorObject: g.create(m.VALUE),
        variance: t,
        ns1: r
      } : {
        isError: !0,
        errorObject: g.create(m.DIV_BY_ZERO),
        variance: t,
        ns1: r
      };
    }
    const o = [];
    let u = 0;
    for (let f = 0; f < n; f++)
      for (let h = 0; h < s; h++) {
        const d = e.isArray() ? e.get(f, h) : e;
        if (d.isError())
          return {
            isError: !0,
            errorObject: d,
            variance: t,
            ns1: r
          };
        if (d.isNull() || d.isBoolean())
          continue;
        const _ = d.getValue();
        W(_) && (o.push(+_), u += +_);
      }
    if (o.length <= 1)
      return {
        isError: !0,
        errorObject: g.create(m.DIV_BY_ZERO),
        variance: t,
        ns1: r
      };
    const c = u / o.length;
    let l = 0;
    for (let f = 0; f < o.length; f++)
      l += (o[f] - c) ** 2;
    return r = o.length - 1, t = l / r, t === 0 ? {
      isError: !0,
      errorObject: g.create(m.DIV_BY_ZERO),
      variance: t,
      ns1: r
    } : {
      isError: !1,
      errorObject: null,
      variance: t,
      ns1: r
    };
  }
}
class cu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +h.getValue();
    if (d < 0 || _ <= 0 || C <= 0)
      return g.create(m.NUM);
    let b;
    return E ? b = mm(d, _, C) : b = gm(d, _, C), y.create(b);
  }
}
class lu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = +c.getValue(), d = +l.getValue();
    if (f < 0 || f > 1 || h <= 0 || d <= 0)
      return g.create(m.NUM);
    const _ = dm(f, h, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : y.create(_);
  }
}
class fu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = +c.getValue(), d = +l.getValue();
    if (f <= 0 || f >= 1 || d <= 0)
      return g.create(m.NUM);
    const _ = Am(f, h, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : y.create(_);
  }
}
class hu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = {};
    let r = 0, n = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o.isError())
        return o;
      if (o.isString()) {
        const l = o.convertToNumberObjectValue();
        if (l.isError())
          return l;
      }
      const u = o.isArray() ? o.getRowCount() : 1, c = o.isArray() ? o.getColumnCount() : 1;
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const h = o.isArray() ? o.get(l, f) : o;
          if (h.isError())
            return h;
          if (h.isNull() || h.isBoolean() || h.isString())
            continue;
          const d = h.getValue();
          W(d) && (t[+d] ? (t[+d].count++, t[+d].count > n && (n = t[+d].count)) : t[+d] = { count: 1, order: r++ });
        }
    }
    return r === 0 || n === 1 ? new g(m.NA) : this._getResult(t, n);
  }
  _getResult(e, t) {
    const r = Object.entries(e).filter(([n, { count: s }]) => s === t).sort((n, s) => n[1].order - s[1].order).map(([n]) => +n);
    return y.create(r[0]);
  }
}
class mu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +h.getValue();
    if (C <= 0)
      return g.create(m.NUM);
    let b;
    return E ? b = Hr(d, _, C) : b = Ko(d, _, C), y.create(b);
  }
}
class gu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = +c.getValue(), d = +l.getValue();
    if (f <= 0 || f >= 1 || d <= 0)
      return g.create(m.NUM);
    const _ = ts(f, h, d);
    return y.create(_);
  }
}
class du extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return e.getRowCount() === 1 && e.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o <= 0 || o >= 1)
      return g.create(m.NUM);
    const u = ts(o, 0, 1);
    return y.create(u);
  }
}
class Cu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue(), c = e.length;
    if (u < 0 || u > 1)
      return g.create(m.NUM);
    const l = u * (c - 1), f = Math.floor(l), h = l - f;
    if (h === 0)
      return y.create(e[f]);
    const d = e[f] + h * (e[f + 1] - e[f]);
    return y.create(d);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => s - o);
  }
}
class _u extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getValues(e);
    let s = r != null ? r : y.create(3);
    s.isNull() && (s = y.create(3));
    const o = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, t, g.create(m.NA)), l = O(o, u, s, g.create(m.NA)), f = c.mapValue((h, d, _) => {
      const C = l.get(d, _);
      return h.isError() ? h : C.isError() ? C : this._handleSingleObject(n, h, C);
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g)
      return e;
    const { isError: n, errorObject: s, variants: o } = B(t, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = Math.floor(+c.getValue()), h = e.length;
    if (h === 0 || l < e[0] || l > e[h - 1])
      return g.create(m.NA);
    if (h === 1)
      return l === e[0] ? y.create(1) : g.create(m.NA);
    let d = 0, _ = !1, C = 0;
    for (; !_ && C < h; )
      l === e[C] ? (d = C / (h - 1), _ = !0) : l > e[C] && C + 1 < h && l < e[C + 1] && (d = (C + (l - e[C]) / (e[C + 1] - e[C])) / (h - 1), _ = !0), C++;
    return _ ? f < 1 ? g.create(m.NUM) : (d = Ke(d, f), y.create(d)) : g.create(m.NA);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.sort((s, o) => s - o);
  }
}
class Au extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = Math.floor(+u.getValue()), h = +c.getValue(), d = +l.getValue();
    if (f < 0 || h < 0)
      return g.create(m.NUM);
    let _;
    return d ? _ = bm(f, h) : _ = Xo(f, h), y.create(_);
  }
}
class Eu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    if (u < 0 || u > 4)
      return g.create(m.NUM);
    const c = u / 4, l = e.length, f = c * (l - 1), h = Math.floor(f), d = f - h;
    if (d === 0)
      return y.create(e[h]);
    const _ = e[h] + d * (e[h + 1] - e[h]);
    return y.create(_);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => s - o);
  }
}
class bu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.std();
  }
}
class yu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.std(1);
  }
}
class Ru extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c <= 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = Math.abs(rs(c / 2, l));
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class pu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  // eslint-disable-next-line
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o, array1Values: u, array2Values: c } = this._handleArray1AndArray2(e, t), l = this._getArrayValues(e), f = this._getArrayValues(t), h = Math.max(
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), d = Math.max(
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), _ = O(h, d, r, g.create(m.NA)), C = O(h, d, n, g.create(m.NA)), E = _.mapValue((b, R, p) => {
      const N = C.get(R, p);
      if (e.isError())
        return e;
      if (t.isError())
        return t;
      if (b.isError())
        return b;
      if (N.isError())
        return N;
      const { isError: M, errorObject: w, variants: S } = B(b, N);
      if (M)
        return w;
      const [D, L] = S, U = Math.floor(+D.getValue()), x = Math.floor(+L.getValue());
      return ![1, 2].includes(U) || ![1, 2, 3].includes(x) ? g.create(m.NUM) : x === 1 && s ? o : x !== 1 && l instanceof g ? l : x !== 1 && f instanceof g ? f : this._handleSingleObject(
        x === 1 ? u : l,
        x === 1 ? c : f,
        U,
        x
      );
    });
    return h === 1 && d === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n) {
    if (e.length < 2 || t.length < 2)
      return g.create(m.DIV_BY_ZERO);
    const { isError: s, errorObject: o, x: u, degFreedom: c } = this._getTDistParamByArrayValues(e, t, n);
    if (s)
      return o;
    let l = Gr(-u, c);
    return r === 2 && (l *= 2), Number.isNaN(l) || !Number.isFinite(l) ? g.create(m.NUM) : y.create(l);
  }
  _getArrayValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull()) {
          if (t * r === 1)
            return g.create(m.VALUE);
          continue;
        }
        u.isBoolean() || u.isString() || n.push(+u.getValue());
      }
    return n;
  }
  // eslint-disable-next-line
  _handleArray1AndArray2(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return {
        isError: !0,
        errorObject: u,
        array1Values: [],
        array2Values: []
      };
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return {
        isError: !0,
        errorObject: c,
        array1Values: [],
        array2Values: []
      };
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        array1Values: [],
        array2Values: []
      };
    if (r * n !== s * o)
      return {
        isError: !0,
        errorObject: g.create(m.NA),
        array1Values: [],
        array2Values: []
      };
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? {
      isError: !0,
      errorObject: f,
      array1Values: [],
      array2Values: []
    } : _ || h.length < 2 ? {
      isError: !0,
      errorObject: g.create(m.DIV_BY_ZERO),
      array1Values: [],
      array2Values: []
    } : {
      isError: !1,
      errorObject: null,
      array1Values: h,
      array2Values: d
    };
  }
  _getTDistParamByArrayValues(e, t, r) {
    return r === 1 ? this._getTDistParamByType1(e, t) : r === 2 ? this._getTDistParamByType2(e, t) : this._getTDistParamByType3(e, t);
  }
  _getTDistParamByType1(e, t) {
    const r = e.length;
    let n = 0, s = 0, o = 0;
    for (let h = 0; h < r; h++)
      n += e[h], s += t[h], o += (e[h] - t[h]) ** 2;
    const u = n - s, c = r * o - u ** 2, l = r - 1;
    return c === 0 ? {
      isError: !0,
      errorObject: g.create(m.DIV_BY_ZERO),
      x: 0,
      degFreedom: l
    } : {
      isError: !1,
      errorObject: null,
      x: Math.abs(u) * Math.sqrt(l / c),
      degFreedom: l
    };
  }
  _getTDistParamByType2(e, t) {
    const r = e.length, n = t.length;
    let s = 0, o = 0;
    for (let E = 0; E < r; E++)
      s += e[E], o += e[E] ** 2;
    let u = 0, c = 0;
    for (let E = 0; E < n; E++)
      u += t[E], c += t[E] ** 2;
    const l = o - s ** 2 / r, f = c - u ** 2 / n, h = Math.sqrt(l + f);
    if (h === 0)
      return {
        isError: !0,
        errorObject: g.create(m.DIV_BY_ZERO),
        x: 0,
        degFreedom: 0
      };
    const d = r - 1 + n - 1, _ = Math.sqrt(r * n * d / (r + n));
    return {
      isError: !1,
      errorObject: null,
      x: Math.abs(s / r - u / n) / h * _,
      degFreedom: d
    };
  }
  _getTDistParamByType3(e, t) {
    const r = e.length, n = t.length;
    let s = 0, o = 0;
    for (let C = 0; C < r; C++)
      s += e[C], o += e[C] ** 2;
    let u = 0, c = 0;
    for (let C = 0; C < n; C++)
      u += t[C], c += t[C] ** 2;
    const l = (o - s ** 2 / r) / (r * (r - 1)), f = (c - u ** 2 / n) / (n * (n - 1));
    if (l + f === 0)
      return {
        isError: !0,
        errorObject: g.create(m.DIV_BY_ZERO),
        x: 0,
        degFreedom: 0
      };
    const h = l / (l + f), d = Math.abs(s / r - u / n) / Math.sqrt(l + f), _ = 1 / (h ** 2 / (r - 1) + (1 - h) ** 2 / (n - 1));
    return {
      isError: !1,
      errorObject: null,
      x: d,
      degFreedom: _
    };
  }
}
class Vu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.var();
  }
}
class Nu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.var(1);
  }
}
class Ou extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +h.getValue();
    if (d < 0 || _ <= 0 || C <= 0)
      return g.create(m.NUM);
    const b = Math.exp(-((d / C) ** _));
    let R;
    return E ? R = 1 - b : R = _ / C ** _ * d ** (_ - 1) * b, Number.isNaN(R) || !Number.isFinite(R) ? g.create(m.NUM) : y.create(R);
  }
}
class Mu extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getArrayValues(e), s = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, t, g.create(m.NA)), c = r ? O(s, o, r, g.create(m.NA)) : void 0, l = u.mapValue((f, h, d) => {
      if (n instanceof g)
        return n;
      if (f.isError())
        return f;
      const _ = r ? c.get(h, d) : void 0;
      return _ != null && _.isError() ? _ : n.length === 0 ? g.create(m.NA) : n.length === 1 ? g.create(m.DIV_BY_ZERO) : this._handleSingleObject(n, f, _);
    });
    return s === 1 && o === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    const [u] = o, c = +u.getValue(), l = e.length;
    let f = 0, h = 0;
    for (let E = 0; E < l; E++)
      f += e[E], h += e[E] ** 2;
    let d = 0;
    if (r !== void 0) {
      const { isError: E, errorObject: b, variants: R } = B(r);
      if (E)
        return b;
      const [p] = R;
      d = +p.getValue();
    } else {
      const E = f / l;
      d = Math.sqrt((h - 2 * E * f + l * E ** 2) / (l - 1));
    }
    if (d <= 0)
      return g.create(m.NUM);
    const _ = (f / l - c) / (d / Math.sqrt(l)), C = 1 - Hr(_, 0, 1);
    return Number.isNaN(C) || !Number.isFinite(C) ? g.create(m.NUM) : y.create(C);
  }
  _getArrayValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        W(c) && t.push(+c);
      }
    return t;
  }
}
class Vm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = n != null ? n : y.create(0), u = s != null ? s : y.create(1);
    o.isNull() && (o = y.create(0)), u.isNull() && (u = y.create(1));
    const c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(m.NA)), h = O(c, l, t, g.create(m.NA)), d = O(c, l, r, g.create(m.NA)), _ = O(c, l, o, g.create(m.NA)), C = O(c, l, u, g.create(m.NA)), E = f.mapValue((b, R, p) => {
      const N = h.get(R, p), M = d.get(R, p), w = _.get(R, p), S = C.get(R, p);
      return this._handleSingleObject(b, N, M, w, S);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const { isError: o, errorObject: u, variants: c } = B(e, t, r, n, s);
    if (o)
      return u;
    const [l, f, h, d, _] = c, C = +l.getValue(), E = +f.getValue(), b = +h.getValue(), R = +d.getValue(), p = +_.getValue();
    if (E <= 0 || b <= 0 || C < R || C > p || R === p)
      return g.create(m.NUM);
    const N = $o((C - R) / (p - R), E, b);
    return y.create(N);
  }
}
var le = /* @__PURE__ */ ((i) => (i.BETADIST = "BETADIST", i.BETAINV = "BETAINV", i.BINOMDIST = "BINOMDIST", i.CHIDIST = "CHIDIST", i.CHIINV = "CHIINV", i.CHITEST = "CHITEST", i.CONFIDENCE = "CONFIDENCE", i.COVAR = "COVAR", i.CRITBINOM = "CRITBINOM", i.EXPONDIST = "EXPONDIST", i.FDIST = "FDIST", i.FINV = "FINV", i.FTEST = "FTEST", i.GAMMADIST = "GAMMADIST", i.GAMMAINV = "GAMMAINV", i.HYPGEOMDIST = "HYPGEOMDIST", i.LOGINV = "LOGINV", i.LOGNORMDIST = "LOGNORMDIST", i.MODE = "MODE", i.NEGBINOMDIST = "NEGBINOMDIST", i.NORMDIST = "NORMDIST", i.NORMINV = "NORMINV", i.NORMSDIST = "NORMSDIST", i.NORMSINV = "NORMSINV", i.PERCENTILE = "PERCENTILE", i.PERCENTRANK = "PERCENTRANK", i.POISSON = "POISSON", i.QUARTILE = "QUARTILE", i.RANK = "RANK", i.STDEV = "STDEV", i.STDEVP = "STDEVP", i.TDIST = "TDIST", i.TINV = "TINV", i.TTEST = "TTEST", i.VAR = "VAR", i.VARP = "VARP", i.WEIBULL = "WEIBULL", i.ZTEST = "ZTEST", i))(le || {});
class Nm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = Math.floor(+c.getValue()), _ = Math.floor(+l.getValue()), C = Math.floor(+f.getValue()), E = Math.floor(+h.getValue());
    if (d < 0 || d > _ || d > C || d < _ - E + C || _ <= 0 || _ > E || C <= 0 || C > E || E <= 0)
      return g.create(m.NUM);
    let b = Fa(d, _, C, E);
    return Number.isNaN(b) && (b = 0), y.create(b);
  }
}
class Om extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = +c.getValue(), d = +l.getValue();
    if (f <= 0 || d <= 0)
      return g.create(m.NUM);
    const _ = qo(f, h, d);
    return y.create(_);
  }
}
class Mm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = Math.floor(+u.getValue()), h = Math.floor(+c.getValue()), d = +l.getValue();
    if (f < 0 || h < 1 || d <= 0 || d >= 1)
      return g.create(m.NUM);
    const _ = ka(f, h, d);
    return y.create(_);
  }
}
class wm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return e.getRowCount() === 1 && e.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Hr(o, 0, 1);
    return y.create(u);
  }
}
class Sm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, n, g.create(m.NA)), d = O(l, f, c, g.create(m.NA)), _ = h.map((C, E, b) => {
      const R = d.get(E, b);
      if (!e.isReferenceObject() && e.isNull())
        return g.create(m.NA);
      if (s)
        return o;
      if (R.isError())
        return R;
      const p = +C.getValue(), N = +R.getValue();
      if (Number.isNaN(p) || Number.isNaN(N))
        return g.create(m.VALUE);
      const w = u.sort((S, D) => N ? S - D : D - S).indexOf(p);
      return w === -1 ? g.create(m.NA) : y.create(w + 1);
    });
    return l === 1 && f === 1 ? _.get(0, 0) : _;
  }
  _checkRefReferenceObject(e) {
    let t = !1, r = g.create(m.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = !0, r = u, !1;
      if (u.isNull() || u.isBoolean())
        return !0;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return !0;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: !0,
      refErrorObject: r,
      refNumbers: n
    };
  }
}
class Dm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || h < 1 || h > 10 ** 10 || d < 1 || d > 2)
      return g.create(m.NUM);
    let _ = Gr(-f, h);
    return d === 2 && (_ *= 2), Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : y.create(_);
  }
}
const Lm = [
  [Vm, le.BETADIST],
  [Zo, le.BETAINV],
  [zo, le.BINOMDIST],
  [eu, le.CHIDIST],
  [tu, le.CHIINV],
  [ru, le.CHITEST],
  [nu, le.CONFIDENCE],
  [su, le.COVAR],
  [Jo, le.CRITBINOM],
  [au, le.EXPONDIST],
  [iu, le.FDIST],
  [ou, le.FINV],
  [uu, le.FTEST],
  [cu, le.GAMMADIST],
  [lu, le.GAMMAINV],
  [Nm, le.HYPGEOMDIST],
  [Om, le.LOGNORMDIST],
  [fu, le.LOGINV],
  [hu, le.MODE],
  [Mm, le.NEGBINOMDIST],
  [mu, le.NORMDIST],
  [gu, le.NORMINV],
  [wm, le.NORMSDIST],
  [du, le.NORMSINV],
  [Cu, le.PERCENTILE],
  [_u, le.PERCENTRANK],
  [Au, le.POISSON],
  [Eu, le.QUARTILE],
  [Sm, le.RANK],
  [yu, le.STDEV],
  [bu, le.STDEVP],
  [Dm, le.TDIST],
  [Ru, le.TINV],
  [pu, le.TTEST],
  [Nu, le.VAR],
  [Vu, le.VARP],
  [Ou, le.WEIBULL],
  [Mu, le.ZTEST]
], Pm = [];
var xm = /* @__PURE__ */ ((i) => (i.CUBEKPIMEMBER = "CUBEKPIMEMBER", i.CUBEMEMBER = "CUBEMEMBER", i.CUBEMEMBERPROPERTY = "CUBEMEMBERPROPERTY", i.CUBERANKEDMEMBER = "CUBERANKEDMEMBER", i.CUBESET = "CUBESET", i.CUBESETCOUNT = "CUBESETCOUNT", i.CUBEVALUE = "CUBEVALUE", i))(xm || {});
class jm extends V {
  isCustom() {
    return !0;
  }
}
class ny extends jm {
  isAsync() {
    return !0;
  }
}
function nt(i) {
  const a = [];
  if (i.isError())
    return {
      isError: !0,
      errorObject: i,
      databaseValues: a
    };
  const e = i.isArray() ? i.getRowCount() : 1, t = i.isArray() ? i.getColumnCount() : 1;
  if (e < 2)
    return {
      isError: !0,
      errorObject: g.create(m.VALUE),
      databaseValues: a
    };
  for (let r = 0; r < e; r++) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = i.get(r, s);
      if (o.isNull()) {
        n.push(null);
        continue;
      }
      let u = `${o.getValue()}`;
      if (o.isBoolean() && (u = u.toLocaleUpperCase()), o.isNumber() || W(u)) {
        n.push(+u);
        continue;
      }
      n.push(u);
    }
    a.push(n);
  }
  return {
    isError: !1,
    errorObject: null,
    databaseValues: a
  };
}
function st(i, a) {
  let e = -1;
  if (i.isError())
    return {
      isError: !0,
      errorObject: i,
      fieldIndex: e
    };
  const t = i.isArray() ? i.getRowCount() : 1, r = i.isArray() ? i.getColumnCount() : 1;
  if (t > 1 || r > 1)
    return {
      isError: !0,
      errorObject: g.create(m.VALUE),
      fieldIndex: e
    };
  const n = i.isArray() ? i.get(0, 0) : i;
  let s = `${n.getValue()}`;
  if (n.isNull() ? s = 0 : n.isBoolean() ? s = n.getValue() ? 1 : 0 : (n.isNumber() || W(s)) && (s = Math.floor(+s)), typeof s == "number") {
    if (s < 1 || s > a[0].length)
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        fieldIndex: e
      };
    e = s - 1;
  } else if (e = a[0].findIndex((o) => o === null ? !1 : `${o}`.toLocaleLowerCase() === s.toLocaleLowerCase()), e === -1)
    return {
      isError: !0,
      errorObject: g.create(m.VALUE),
      fieldIndex: e
    };
  return {
    isError: !1,
    errorObject: null,
    fieldIndex: e
  };
}
function at(i) {
  const a = [];
  if (i.isError())
    return {
      isError: !0,
      errorObject: i,
      criteriaValues: a
    };
  const e = i.isArray() ? i.getRowCount() : 1, t = i.isArray() ? i.getColumnCount() : 1;
  if (e < 2)
    return {
      isError: !0,
      errorObject: g.create(m.VALUE),
      criteriaValues: a
    };
  for (let r = 0; r < e; r++) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = i.get(r, s);
      if (o.isNull()) {
        n.push(null);
        continue;
      }
      const u = `${o.getValue()}`;
      if (o.isBoolean()) {
        n.push(o.getValue() ? 1 : 0);
        continue;
      }
      if (o.isNumber() || W(u)) {
        n.push(+u);
        continue;
      }
      n.push(u);
    }
    a.push(n);
  }
  return {
    isError: !1,
    errorObject: null,
    criteriaValues: a
  };
}
function it(i, a, e) {
  const t = i.length, r = i[0].length, n = {};
  let s = !1;
  for (let o = 1; o < t; o++) {
    let u = !0;
    for (let c = 0; c < r; c++) {
      const l = i[o][c];
      if (l === null)
        continue;
      let f = n[c];
      if (f === void 0) {
        const h = i[0][c];
        f = a[0].findIndex((d) => d === null || h === null ? !1 : `${d}`.toLocaleLowerCase() === `${h}`.toLocaleLowerCase()), n[c] = f;
      }
      if (f === -1 && (typeof l == "string" || l === 0)) {
        u = !1;
        break;
      } else if (f > -1) {
        const h = a[e][f];
        if (h === null) {
          u = !1;
          break;
        }
        const [d, _] = Va(`${l}`);
        if (!Mt.create(`${h}`).compare(_, d).getValue()) {
          u = !1;
          break;
        }
      }
    }
    if (u) {
      s = !0;
      break;
    }
  }
  return s;
}
class Um extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const b = o[E][l];
      typeof b == "number" && it(d, o, E) && (_ += b, C++);
    }
    return C === 0 ? g.create(m.DIV_BY_ZERO) : y.create(_ / C);
  }
}
class vm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 0;
    for (let C = 1; C < o.length; C++)
      typeof o[C][l] == "number" && it(d, o, C) && _++;
    return y.create(_);
  }
}
class Tm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 0;
    for (let C = 1; C < o.length; C++) {
      const E = o[C][l];
      E != null && it(d, o, C) && _++;
    }
    return y.create(_);
  }
}
class Bm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const b = o[E][l];
      b != null && it(d, o, E) && (_++, C = E);
    }
    return _ === 0 ? g.create(m.VALUE) : _ > 1 ? g.create(m.NUM) : e.get(C, l);
  }
}
class Im extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = -1 / 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const b = o[E][l];
      typeof b == "number" && it(d, o, E) && (_ = Math.max(_, b), C++);
    }
    return C === 0 ? y.create(0) : y.create(_);
  }
}
class Fm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 1 / 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const b = o[E][l];
      typeof b == "number" && it(d, o, E) && (_ = Math.min(_, b), C++);
    }
    return C === 0 ? y.create(0) : y.create(_);
  }
}
class km extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 1, C = 0;
    for (let E = 1; E < o.length; E++) {
      const b = o[E][l];
      typeof b == "number" && it(d, o, E) && (_ *= b, C++);
    }
    return C === 0 ? y.create(0) : y.create(_);
  }
}
class $m extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    const _ = [];
    let C = 0, E = 0;
    for (let N = 1; N < o.length; N++) {
      const M = o[N][l];
      typeof M == "number" && it(d, o, N) && (_.push(M), C += M, E++);
    }
    if (E <= 1)
      return g.create(m.DIV_BY_ZERO);
    const b = C / E;
    let R = 0;
    for (let N = 0; N < E; N++)
      R += (_[N] - b) ** 2;
    const p = Math.sqrt(R / (E - 1));
    return y.create(p);
  }
}
class Ym extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    const _ = [];
    let C = 0, E = 0;
    for (let N = 1; N < o.length; N++) {
      const M = o[N][l];
      typeof M == "number" && it(d, o, N) && (_.push(M), C += M, E++);
    }
    if (E === 0)
      return g.create(m.DIV_BY_ZERO);
    const b = C / E;
    let R = 0;
    for (let N = 0; N < E; N++)
      R += (_[N] - b) ** 2;
    const p = Math.sqrt(R / E);
    return y.create(p);
  }
}
class Hm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    let _ = 0;
    for (let C = 1; C < o.length; C++) {
      const E = o[C][l];
      typeof E == "number" && it(d, o, C) && (_ += E);
    }
    return y.create(_);
  }
}
class Gm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    const _ = [];
    let C = 0, E = 0;
    for (let N = 1; N < o.length; N++) {
      const M = o[N][l];
      typeof M == "number" && it(d, o, N) && (_.push(M), C += M, E++);
    }
    if (E <= 1)
      return g.create(m.DIV_BY_ZERO);
    const b = C / E;
    let R = 0;
    for (let N = 0; N < E; N++)
      R += (_[N] - b) ** 2;
    const p = R / (E - 1);
    return y.create(p);
  }
}
class Qm extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = nt(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = st(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: h, criteriaValues: d } = at(r);
    if (f)
      return h;
    const _ = [];
    let C = 0, E = 0;
    for (let N = 1; N < o.length; N++) {
      const M = o[N][l];
      typeof M == "number" && it(d, o, N) && (_.push(M), C += M, E++);
    }
    if (E === 0)
      return g.create(m.DIV_BY_ZERO);
    const b = C / E;
    let R = 0;
    for (let N = 0; N < E; N++)
      R += (_[N] - b) ** 2;
    const p = R / E;
    return y.create(p);
  }
}
var Qe = /* @__PURE__ */ ((i) => (i.DAVERAGE = "DAVERAGE", i.DCOUNT = "DCOUNT", i.DCOUNTA = "DCOUNTA", i.DGET = "DGET", i.DMAX = "DMAX", i.DMIN = "DMIN", i.DPRODUCT = "DPRODUCT", i.DSTDEV = "DSTDEV", i.DSTDEVP = "DSTDEVP", i.DSUM = "DSUM", i.DVAR = "DVAR", i.DVARP = "DVARP", i))(Qe || {});
const Wm = [
  [Um, Qe.DAVERAGE],
  [vm, Qe.DCOUNT],
  [Tm, Qe.DCOUNTA],
  [Bm, Qe.DGET],
  [Im, Qe.DMAX],
  [Fm, Qe.DMIN],
  [km, Qe.DPRODUCT],
  [$m, Qe.DSTDEV],
  [Ym, Qe.DSTDEVP],
  [Hm, Qe.DSUM],
  [Gm, Qe.DVAR],
  [Qm, Qe.DVARP]
], $a = "yyyy/mm/dd;@", qm = "yyyy/mm/dd hh:mm", Km = "h:mm A/P";
function Re(i) {
  const a = new Date(Date.UTC(1900, 0, 1)), e = new Date(Date.UTC(1900, 1, 28)), t = Date.UTC(i.getFullYear(), i.getMonth(), i.getDate());
  let r = (t - a.getTime()) / (1e3 * 3600 * 24);
  return t > e.getTime() && (r += 1), Math.floor(r) + 1;
}
function Qr(i) {
  const a = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), e = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let r = (i.getTime() - a.getTime()) / (1e3 * 3600 * 24);
  return i > e && (r += 1), r + 1;
}
function re(i) {
  const a = new Date(Date.UTC(1900, 0, 1)), e = new Date(Date.UTC(1900, 1, 28));
  let t = Math.floor(i) - 1;
  return t > (e.getTime() - a.getTime()) / (1e3 * 3600 * 24) && (t -= 1), new Date(a.getTime() + t * (1e3 * 3600 * 24));
}
function Ya(i) {
  const a = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), e = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let t = i - 1;
  return t > (e.getTime() - a.getTime()) / (1e3 * 3600 * 24) && (t -= 1), t < 0 && (t = i), new Date(a.getTime() + t * (1e3 * 3600 * 24));
}
function Ha(i) {
  if (!/^\d{4}[-/](0?[1-9]|1[012])[-/](0?[1-9]|[12][0-9]|3[01])$/.test(i))
    return !1;
  const e = i.replace(/-/g, "/").replace(/T.+/, ""), t = /* @__PURE__ */ new Date(`${e}`);
  if (Number.isNaN(t.getTime()))
    return !1;
  const r = t.getFullYear(), n = (t.getMonth() + 1).toString().padStart(2, "0"), s = t.getDate().toString().padStart(2, "0"), o = `${r}-${n}-${s}`;
  return i.replace(/\//g, "-").split("-").map((c) => c.padStart(2, "0")).join("-") === o;
}
function xn(i) {
  return At.parseDate(i);
}
function Xm(i) {
  return At.parseValue(i);
}
function jn(i) {
  return At.parseTime(i);
}
function Ga(i) {
  return At.getFormatInfo(i).isDate;
}
const wu = {
  1: [6, 0],
  // Saturday, Sunday
  2: [0, 1],
  // Sunday, Monday
  3: [1, 2],
  // Monday, Tuesday
  4: [2, 3],
  // Tuesday, Wednesday
  5: [3, 4],
  // Wednesday, Thursday
  6: [4, 5],
  // Thursday, Friday
  7: [5, 6],
  // Friday, Saturday
  11: [0],
  // Sunday only
  12: [1],
  // Monday only
  13: [2],
  // Tuesday only
  14: [3],
  // Wednesday only
  15: [4],
  // Thursday only
  16: [5],
  // Friday only
  17: [6]
  // Saturday only
};
function Tr(i) {
  return !!(typeof i == "string" && /^[0|1]{7}/.test(i) || wu[Number(i)]);
}
function Su(i) {
  if (!Tr(i))
    return [];
  if (typeof i == "string" && /^[0|1]{7}/.test(i)) {
    const a = [];
    for (let e = 1; e <= i.length; e++)
      `${i[e - 1]}` == "1" && (e === i.length ? a.push(0) : a.push(e));
    return a;
  }
  return wu[Number(i)] || [];
}
function Un(i, a, e = 1, t) {
  const r = Su(e), n = Math.floor(i), s = Math.floor(a), o = s > n ? n : s;
  let u = 0;
  const c = Math.abs(Math.floor(a) - Math.floor(i)) + 1;
  for (let l = 0; l < c; l++) {
    const f = o + l;
    if (t && t.length > 0 && t.some((d) => Math.floor(d) === f))
      continue;
    const h = nr(f);
    r.includes(h) || u++;
  }
  return s >= n ? u : -u;
}
function vn(i, a, e = 1, t) {
  const r = Su(e), n = Math.floor(i);
  let s = n, o = Math.abs(a);
  for (let u = 1; u <= o; u++) {
    const c = a < 0 ? n - u : n + u;
    if (c < 0)
      return g.create(m.NUM);
    if (t && t.length > 0 && t.some((f) => Math.floor(f) === c)) {
      o++;
      continue;
    }
    const l = nr(c);
    if (r.includes(l)) {
      o++;
      continue;
    }
    s = c;
  }
  return s;
}
function $(i) {
  if (i.isError())
    return i;
  const a = i.getValue();
  if (i.isString()) {
    let e;
    if (xn(`${a}`))
      e = xn(`${a}`).v;
    else if (jn(`${a}`))
      e = jn(`${a}`).v;
    else if (W(a))
      e = +a;
    else
      return g.create(m.VALUE);
    return e instanceof Date && (e = Qr(e)), +e < 0 || +e > 2958465 ? g.create(m.NUM) : +e;
  } else {
    const e = +i.getValue();
    return e < 0 || e > 2958465 ? g.create(m.NUM) : e;
  }
}
function nr(i) {
  const a = Math.floor(i) === 60;
  let e = re(i);
  const t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())).getTime(), r = new Date(Date.UTC(1900, 1, 28)).getTime();
  return !a && t <= r && (e = new Date(t - 24 * 3600 * 1e3)), new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())).getUTCDay();
}
function _e(i, a, e) {
  switch (e) {
    case 0:
      return Zm(i, a);
    case 1:
      return zm(i, a);
    case 2:
      return {
        days: Math.abs(a - i),
        yearDays: 360
      };
    case 3:
      return {
        days: Math.abs(a - i),
        yearDays: 365
      };
    case 4:
      return Jm(i, a);
    default:
      return {
        days: Math.abs(a - i),
        yearDays: 365
      };
  }
}
function Zm(i, a) {
  const e = re(i), t = i > 0 ? e.getUTCFullYear() : 1900, r = i > 0 ? e.getUTCMonth() + 1 : 1;
  let n = i > 0 ? e.getUTCDate() : 0, s = re(a), o = a > 0 ? s.getUTCFullYear() : 1900, u = a > 0 ? s.getUTCMonth() + 1 : 1, c = a > 0 ? s.getUTCDate() : 0;
  r === 2 ? re(i + 1).getUTCMonth() + 1 === 3 && (n = 30) : n === 31 && (n = 30), c === 31 && (n < 30 ? (s = re(a + 1), o = s.getUTCFullYear(), u = s.getUTCMonth() + 1, c = s.getUTCDate()) : c = 30);
  const l = (o - t) * 360, f = a >= i ? 30 - n : -n, h = a >= i ? c : c - 30, d = (a >= i ? u - r - 1 : u - r + 1) * 30;
  return {
    days: Math.abs(l + f + h + d),
    yearDays: 360
  };
}
function zm(i, a) {
  const e = re(i), t = i > 0 ? e.getUTCFullYear() : 1900, r = re(a), n = a > 0 ? r.getUTCFullYear() : 1900, s = Math.abs(a - i), o = Math.abs(n - t) + 1;
  let u, c;
  if (n < t) {
    const l = new Date(Date.UTC(n, 0, 1)), f = new Date(Date.UTC(t, 11, 31));
    u = Re(l), c = Re(f), n === 1900 && (u += 1);
  } else {
    const l = new Date(Date.UTC(t, 0, 1)), f = new Date(Date.UTC(n, 11, 31));
    u = Re(l), c = Re(f), t === 1900 && (u += 1);
  }
  return {
    days: s,
    yearDays: (c - u + 1) / o
  };
}
function Jm(i, a) {
  const e = re(i), t = i > 0 ? e.getUTCFullYear() : 1900, r = i > 0 ? e.getUTCMonth() + 1 : 1;
  let n = i > 0 ? e.getUTCDate() : 0;
  const s = re(a), o = a > 0 ? s.getUTCFullYear() : 1900, u = a > 0 ? s.getUTCMonth() + 1 : 1;
  let c = a > 0 ? s.getUTCDate() : 0;
  n === 31 && (n = 30), c === 31 && (c = 30);
  const l = (o - t) * 360, f = a >= i ? 30 - n : -n, h = a >= i ? c : c - 30, d = (a >= i ? u - r - 1 : u - r + 1) * 30;
  return {
    days: Math.abs(l + f + h + d),
    yearDays: 360
  };
}
function eg(i) {
  return i % 4 === 0 && i % 100 !== 0 || i % 400 === 0;
}
function tg(i) {
  return i % 4 === 0 && i % 100 !== 0 || i % 400 === 0 || i === 1900;
}
const rg = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ng = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Wr(i, a) {
  return eg(i) ? rg[a] : ng[a];
}
function os(i) {
  return tg(i) ? 366 : 365;
}
function Du(i, a) {
  switch (a) {
    case 0:
    case 2:
    case 4:
      return 360;
    case 1:
      return os(re(i).getUTCFullYear());
    case 3:
      return 365;
    default:
      return -1;
  }
}
function Rr(i, a, e) {
  return Wr(i, a) === e;
}
function pr(i, a) {
  let e = i.getUTCFullYear(), t = i.getUTCMonth();
  const r = i.getUTCDate();
  return Rr(e, t, r) ? (i.setUTCDate(1), i.setUTCMonth(i.getUTCMonth() + a), e = i.getUTCFullYear(), t = i.getUTCMonth(), i.setUTCDate(Wr(e, t))) : i.setUTCMonth(i.getUTCMonth() + a), i;
}
class sg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.map((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      if (f.isError())
        return f;
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const { isError: E, errorObject: b, variants: R } = B(f, _, C);
      if (E)
        return b;
      const [p, N, M] = R;
      let w = Math.floor(+p.getValue());
      const S = Math.floor(+N.getValue()), D = Math.floor(+M.getValue());
      if (w < 0 || w > 9999)
        return g.create(m.NUM);
      w >= 0 && w < 1899 && (w += 1900);
      const L = new Date(w, S - 1, D), U = Re(L);
      return U < 0 ? g.create(m.NUM) : y.create(U, $a);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class ag extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t, o = r;
    if (n.isArray() && (n = n.get(0, 0)), s.isArray() && (s = s.get(0, 0)), o.isArray() && (o = o.get(0, 0)), n.isError())
      return n;
    if (s.isError())
      return s;
    if (o.isError())
      return o;
    const u = $(n);
    if (typeof u != "number")
      return u;
    const c = $(s);
    return typeof c != "number" ? c : c < u || !o.isString() ? g.create(m.NUM) : this._getResultByUnit(u, c, o);
  }
  _getResultByUnit(e, t, r) {
    const n = re(e), s = n.getUTCFullYear(), o = n.getUTCMonth() + 1, u = n.getUTCDate(), c = re(t), l = c.getUTCFullYear(), f = c.getUTCMonth() + 1, h = c.getUTCDate(), d = `${r.getValue()}`.toLocaleUpperCase();
    let _ = 0, C;
    switch (d) {
      case "Y":
        _ = l - s, (f < o || f === o && h < u) && (_ -= 1);
        break;
      case "M":
        _ = (l - s) * 12 + f - o, h < u && (_ -= 1);
        break;
      case "D":
        _ = Math.floor(t) - Math.floor(e);
        break;
      case "MD":
        _ = h - u, h < u && (C = new Date(Date.UTC(l, f - 1, 0)), _ += Wr(C.getUTCFullYear(), C.getUTCMonth()));
        break;
      case "YM":
        _ = f - o, (f < o || f === o && h < u) && (_ += 12), h < u && (_ -= 1);
        break;
      case "YD":
        C = new Date(Date.UTC(s, f - 1, h)), (f < o || f === o && h < u) && (C = new Date(Date.UTC(s + 1, f - 1, h))), _ = Math.floor(Re(C)) - Math.floor(e);
        break;
      default:
        return g.create(m.NUM);
    }
    return y.create(_);
  }
}
class ig extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isString()) {
      const t = `${e.getValue()}`;
      let r = xn(t);
      if (r === null && (r = jn(t)), r) {
        let { v: n, z: s } = r;
        if (s && Ga(s))
          return n instanceof Date && (n = Qr(n)), y.create(Math.trunc(+n));
      }
    }
    return g.create(m.VALUE);
  }
}
class og extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Ha(`${r}`))
        return g.create(m.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +e.getValue();
      if (o < 0)
        return g.create(m.NUM);
      if (o === 0)
        return y.create(0);
      t = re(o);
    }
    const n = t.getDate();
    return y.create(n);
  }
}
class ug extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t), u = s.map((c, l, f) => {
      const h = o.get(l, f);
      if (c.isError())
        return c;
      if (h.isError())
        return h;
      const d = $(c);
      if (typeof d != "number")
        return d;
      const _ = $(h);
      if (typeof _ != "number")
        return _;
      const C = Math.floor(d) - Math.floor(_);
      return y.create(C);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class cg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : T.create(!1);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (n.isError())
      return n;
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, n, g.create(m.NA)), f = u.map((h, d, _) => {
      const C = c.get(d, _);
      let E = l.get(d, _);
      if (h.isError())
        return h;
      const b = $(h);
      if (typeof b != "number")
        return b;
      if (C.isError())
        return C;
      const R = $(C);
      if (typeof R != "number")
        return R;
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      const p = +E.getValue(), { days: N } = _e(b, R, p ? 4 : 0), M = R >= b ? N : -N;
      return y.create(M);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
}
class lg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.map((u, c, l) => {
      const f = o.get(c, l) || ce.create();
      if (u.isError())
        return u;
      if (f.isError())
        return f;
      if (u.isString() || u.isBoolean() || f.isString() || f.isBoolean())
        return g.create(m.VALUE);
      const h = +u.getValue();
      if (h < 0)
        return g.create(m.NUM);
      const d = Math.floor(+f.getValue()), _ = re(h), C = _.getUTCFullYear(), E = _.getUTCMonth() + d, b = _.getUTCDate(), R = new Date(Date.UTC(C, E, b)), p = Re(R);
      return y.create(p, $a);
    });
  }
}
class fg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e, n = t;
    if (r.isArray()) {
      const d = r.getRowCount(), _ = r.getColumnCount();
      if (d > 1 || _ > 1)
        return g.create(m.VALUE);
      r = r.get(0, 0);
    }
    if (n.isArray()) {
      const d = n.getRowCount(), _ = n.getColumnCount();
      if (d > 1 || _ > 1)
        return g.create(m.VALUE);
      n = n.get(0, 0);
    }
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    const s = $(r);
    if (typeof s != "number")
      return s;
    if (n.isBoolean())
      return g.create(m.VALUE);
    const o = re(s), u = s > 0 ? o.getUTCFullYear() : 1900, c = s > 0 ? o.getUTCMonth() : 0, l = Math.floor(+n.getValue());
    if (Number.isNaN(l))
      return g.create(m.VALUE);
    const f = new Date(Date.UTC(u, c + l + 1, 0)), h = Re(f);
    return y.create(h);
  }
}
class hg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), { isError: n, errorObject: s, timestampIsReferenceObject: o, timestampObject: u, unitObject: c } = this._checkVariants(e, r);
    if (n)
      return s;
    if (u.isNull() || u.isBoolean() || u.isString() || !o && u.isNumber() && u.getPattern() !== "")
      return g.create(m.VALUE);
    let l = +u.getValue();
    const { isError: f, errorObject: h, variants: d } = B(c);
    if (f)
      return h;
    const [_] = d, C = Math.floor(+_.getValue());
    if (l < 0 || C < 1 || C > 3)
      return g.create(m.NUM);
    C === 1 && (l = l * 1e3), C === 3 && (l = l / 1e3);
    const E = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, 0) + l);
    if (Number.isNaN(E.getTime())) {
      const b = 25569 + l / 864e5;
      return y.create(b);
    } else {
      const b = Qr(E);
      return y.create(b, "yyyy-MM-dd AM/PM hh:mm:ss");
    }
  }
  _checkVariants(e, t) {
    const r = e.isReferenceObject(), n = t.isReferenceObject();
    let s = e;
    if (r && (s = e.toArrayValueObject()), s.isArray()) {
      const u = s.getRowCount(), c = s.getColumnCount();
      if (u > 1 || c > 1)
        return {
          isError: !0,
          errorObject: g.create(m.VALUE)
        };
      s = s.get(0, 0);
    }
    if (s.isError())
      return {
        isError: !0,
        errorObject: s
      };
    let o = t;
    if (n && (o = t.toArrayValueObject()), o.isArray()) {
      const u = o.getRowCount(), c = o.getColumnCount();
      if (u > 1 || c > 1)
        return {
          isError: !0,
          errorObject: g.create(m.VALUE)
        };
      o = o.get(0, 0);
    }
    return o.isError() ? {
      isError: !0,
      errorObject: o
    } : {
      isError: !1,
      errorObject: null,
      timestampIsReferenceObject: r,
      timestampObject: s,
      unitIsReferenceObject: n,
      unitObject: o
    };
  }
}
var be = /* @__PURE__ */ ((i) => (i.DATE = "DATE", i.DATEDIF = "DATEDIF", i.DATEVALUE = "DATEVALUE", i.DAY = "DAY", i.DAYS = "DAYS", i.DAYS360 = "DAYS360", i.EDATE = "EDATE", i.EOMONTH = "EOMONTH", i.EPOCHTODATE = "EPOCHTODATE", i.HOUR = "HOUR", i.ISOWEEKNUM = "ISOWEEKNUM", i.MINUTE = "MINUTE", i.MONTH = "MONTH", i.NETWORKDAYS = "NETWORKDAYS", i.NETWORKDAYS_INTL = "NETWORKDAYS.INTL", i.NOW = "NOW", i.SECOND = "SECOND", i.TIME = "TIME", i.TIMEVALUE = "TIMEVALUE", i.TO_DATE = "TO_DATE", i.TODAY = "TODAY", i.WEEKDAY = "WEEKDAY", i.WEEKNUM = "WEEKNUM", i.WORKDAY = "WORKDAY", i.WORKDAY_INTL = "WORKDAY.INTL", i.YEAR = "YEAR", i.YEARFRAC = "YEARFRAC", i))(be || {});
class mg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = $(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y.create(0);
    const n = Ya(t).getUTCHours();
    return y.create(n);
  }
}
class gg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = $(e);
    if (typeof t != "number")
      return t;
    const r = re(t), n = t > 0 ? r.getUTCFullYear() : 1900;
    let s = new Date(Date.UTC(n, 0, 1)), o = Re(s), u = nr(o), c;
    u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u), t < c && (s = new Date(Date.UTC(n - 1, 0, 1)), o = Re(s), u = nr(o), u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u));
    const l = Math.ceil((t - c + 1) / 7);
    return y.create(l);
  }
}
class dg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = $(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y.create(0);
    const n = Ya(t).getUTCMinutes();
    return y.create(n);
  }
}
class Cg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Ha(`${r}`))
        return g.create(m.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +e.getValue();
      if (o < 0)
        return g.create(m.NUM);
      if (o === 0)
        return y.create(1);
      t = re(o);
    }
    const n = t.getUTCMonth() + 1;
    return y.create(n);
  }
}
class _g extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t;
    if (n.isArray()) {
      const l = n.getRowCount(), f = n.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(m.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (s.isArray()) {
      const l = s.getRowCount(), f = s.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(m.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (r != null && r.isError())
      return r;
    if (n.isBoolean() || s.isBoolean())
      return g.create(m.VALUE);
    const o = $(n);
    if (typeof o != "number")
      return o;
    const u = $(s);
    if (typeof u != "number")
      return u;
    if (r)
      return this._getResultByHolidays(o, u, r);
    const c = Un(o, u);
    return y.create(c);
  }
  _getResultByHolidays(e, t, r) {
    const n = [];
    if (r != null && r.isArray()) {
      const o = r.getRowCount(), u = r.getColumnCount();
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = r.get(c, l);
          if (f.isBoolean())
            return g.create(m.VALUE);
          const h = $(f);
          if (typeof h != "number")
            return h;
          n.push(h);
        }
    } else {
      if (r.isBoolean())
        return g.create(m.VALUE);
      const o = $(r);
      if (typeof o != "number")
        return o;
      n.push(o);
    }
    const s = Un(e, t, 1, n);
    return y.create(s);
  }
}
class Ag extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    return e.isError() ? e : t.isError() ? t : r != null && r.isError() ? r : n != null && n.isError() ? n : r != null && r.isArray() ? r.map((s) => this._handleSingleObject(e, t, s, n)) : this._handleSingleObject(e, t, r, n);
  }
  _handleSingleObject(e, t, r, n) {
    let s = e, o = t;
    if (s.isArray()) {
      const h = s.getRowCount(), d = s.getColumnCount();
      if (h > 1 || d > 1)
        return g.create(m.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (o.isArray()) {
      const h = o.getRowCount(), d = o.getColumnCount();
      if (h > 1 || d > 1)
        return g.create(m.VALUE);
      o = o.get(0, 0);
    }
    if (o.isError())
      return o;
    let u = 1;
    if (r) {
      if (u = r.getValue(), r.isBoolean() && (u = +u), r.isString() && !Tr(u))
        return g.create(m.VALUE);
      if (!Tr(u))
        return g.create(m.NUM);
    }
    if (s.isBoolean() || o.isBoolean())
      return g.create(m.VALUE);
    const c = $(s);
    if (typeof c != "number")
      return c;
    const l = $(o);
    if (typeof l != "number")
      return l;
    if (n)
      return this._getResultByHolidays(c, l, u, n);
    const f = Un(c, l, u);
    return y.create(f);
  }
  _getResultByHolidays(e, t, r, n) {
    const s = [];
    if (n != null && n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const h = n.get(l, f);
          if (h.isBoolean())
            return g.create(m.VALUE);
          const d = $(h);
          if (typeof d != "number")
            return d;
          s.push(d);
        }
    } else {
      if (n.isBoolean())
        return g.create(m.VALUE);
      const u = $(n);
      if (typeof u != "number")
        return u;
      s.push(u);
    }
    const o = Un(e, t, r, s);
    return y.create(o);
  }
}
class Eg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    const e = /* @__PURE__ */ new Date(), t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds())), r = Qr(t);
    return y.create(r, qm);
  }
}
class bg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = $(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y.create(0);
    const n = Ya(t).getUTCSeconds();
    return y.create(n);
  }
}
class yg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e), u = O(n, s, t), c = O(n, s, r);
    return o.map((l, f, h) => this._calculateTime(l, u, c, f, h));
  }
  _calculateTime(e, t, r, n, s) {
    let o = e, u = t.get(n, s) || ce.create(), c = r.get(n, s) || ce.create();
    if ((o.isString() || o.isBoolean()) && (o = o.convertToNumberObjectValue()), (u.isString() || u.isBoolean()) && (u = u.convertToNumberObjectValue()), (c.isString() || c.isBoolean()) && (c = c.convertToNumberObjectValue()), o.isError())
      return o;
    if (u.isError())
      return u;
    if (c.isError())
      return c;
    let l = Math.floor(+o.getValue()), f = Math.floor(+u.getValue()), h = Math.floor(+c.getValue());
    if (l < 0 || f < 0 || h < 0 || l > 32767 || f > 32767 || h > 32767)
      return g.create(m.NUM);
    f += Math.floor(h / 60), h %= 60, l += Math.floor(f / 60), f %= 60, l %= 24;
    const _ = (l * 3600 + f * 60 + h) / 86400;
    return y.create(_, Km);
  }
}
class Rg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isString()) {
      const t = `${e.getValue()}`, r = Xm(t);
      if (r) {
        let { v: n, z: s } = r;
        if (s && Ga(s))
          return n instanceof Date && (n = Qr(n)), y.create(Uf(+n));
      }
    }
    return g.create(m.VALUE);
  }
}
class pg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    const t = e.isReferenceObject();
    let r = e;
    if (t && (r = e.toArrayValueObject()), r.isArray()) {
      const s = r.getRowCount(), o = r.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(m.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError() || r.isNull() || r.isBoolean() || r.isString() || !t && r.isNumber() && r.getPattern() !== "")
      return r;
    const n = +r.getValue();
    return y.create(n, "yyyy-MM-dd hh:mm:ss AM/PM");
  }
}
class Vg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    const e = Re(/* @__PURE__ */ new Date());
    return y.create(e, $a);
  }
}
class Ng extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "_returnTypeMap", {
      1: [1, 2, 3, 4, 5, 6, 7],
      // Sunday = 1 ~ Saturday = 7
      2: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      3: [6, 0, 1, 2, 3, 4, 5],
      // Monday = 0 ~ Sunday = 6
      11: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      12: [6, 7, 1, 2, 3, 4, 5],
      // Tuesday = 1 ~ Monday = 7
      13: [5, 6, 7, 1, 2, 3, 4],
      // Wednesday = 1 ~ Tuesday = 7
      14: [4, 5, 6, 7, 1, 2, 3],
      // Thursday = 1 ~ Wednesday = 7
      15: [3, 4, 5, 6, 7, 1, 2],
      // Friday = 1 ~ Thursday = 7
      16: [2, 3, 4, 5, 6, 7, 1],
      // Saturday = 1 ~ Friday = 7
      17: [1, 2, 3, 4, 5, 6, 7]
      // Sunday = 1 ~ Saturday = 7
    });
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.map((l, f, h) => {
      const d = u.get(f, h);
      return this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = $(e);
    if (typeof n != "number")
      return n;
    if (r.isString() && (r = r.convertToNumberObjectValue(), r.isError()))
      return r;
    const s = Math.floor(+r.getValue());
    if (!this._returnTypeMap[s])
      return g.create(m.NUM);
    const o = nr(n), u = this._returnTypeMap[s][o];
    return y.create(u);
  }
}
class Og extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "_returnTypeMap", {
      1: 0,
      2: 1,
      11: 1,
      12: 2,
      13: 3,
      14: 4,
      15: 5,
      16: 6,
      17: 0,
      21: 4
    });
  }
  calculate(e, t) {
    let r = e, n = t != null ? t : y.create(1);
    if (r.isArray()) {
      const u = r.getRowCount(), c = r.getColumnCount();
      if (u > 1 || c > 1)
        return g.create(m.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    if (n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      if (u > 1 || c > 1)
        return g.create(m.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean())
      return g.create(m.VALUE);
    const s = $(r);
    if (typeof s != "number")
      return s;
    if (n.isBoolean())
      return g.create(m.VALUE);
    const o = Math.floor(+n.getValue());
    return Number.isNaN(o) ? g.create(m.VALUE) : o in this._returnTypeMap ? this._getResult(s, o) : g.create(m.NUM);
  }
  _getResult(e, t) {
    const r = re(e), n = e > 0 ? r.getUTCFullYear() : 1900;
    let s = new Date(Date.UTC(n, 0, 1)), o = Re(s), u = nr(o), c;
    if (t === 21)
      u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u), e < c && (s = new Date(Date.UTC(n - 1, 0, 1)), o = Re(s), u = nr(o), u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u));
    else {
      const f = this._returnTypeMap[t];
      u < f ? c = o - (u + 7 - f) : c = o - (u - f);
    }
    const l = Math.ceil((e - c + 1) / 7);
    return y.create(l);
  }
}
class Mg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t;
    if (n.isArray()) {
      const l = n.getRowCount(), f = n.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(m.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (s.isArray()) {
      const l = s.getRowCount(), f = s.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(m.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (r != null && r.isError())
      return r;
    if (n.isBoolean() || s.isBoolean())
      return g.create(m.VALUE);
    const o = $(n);
    if (typeof o != "number")
      return o;
    const u = +s.getValue();
    if (Number.isNaN(u))
      return g.create(m.VALUE);
    if (r)
      return this._getResultByHolidays(o, u, r);
    const c = vn(o, u);
    return typeof c != "number" ? c : y.create(c);
  }
  _getResultByHolidays(e, t, r) {
    const n = [];
    if (r != null && r.isArray()) {
      const o = r.getRowCount(), u = r.getColumnCount();
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = r.get(c, l);
          if (f.isBoolean())
            return g.create(m.VALUE);
          const h = $(f);
          if (typeof h != "number")
            return h;
          n.push(h);
        }
    } else {
      if (r.isBoolean())
        return g.create(m.VALUE);
      const o = $(r);
      if (typeof o != "number")
        return o;
      n.push(o);
    }
    const s = vn(e, t, 1, n);
    return typeof s != "number" ? s : y.create(s);
  }
}
class wg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    return e.isError() ? e : t.isError() ? t : r != null && r.isError() ? r : n != null && n.isError() ? n : r != null && r.isArray() ? r.map((s) => this._handleSingleObject(e, t, s, n)) : this._handleSingleObject(e, t, r, n);
  }
  _handleSingleObject(e, t, r, n) {
    const s = r != null ? r : y.create(1), o = this._checkArrayError(e);
    if (o.isError())
      return o;
    const u = this._checkArrayError(t);
    if (u.isError())
      return u;
    if (o.isBoolean() || u.isBoolean())
      return g.create(m.VALUE);
    const c = $(e);
    if (typeof c != "number")
      return c;
    const l = +t.getValue();
    if (Number.isNaN(l))
      return g.create(m.VALUE);
    let f = s.getValue();
    if (s.isBoolean() && (f = +f), s.isString() && (!Tr(f) || f === "1111111"))
      return g.create(m.VALUE);
    if (!Tr(f))
      return g.create(m.NUM);
    if (n)
      return this._getResultByHolidays(c, l, f, n);
    const h = vn(c, l, f);
    return typeof h != "number" ? h : y.create(h);
  }
  _checkArrayError(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    return t.isError(), t;
  }
  _getResultByHolidays(e, t, r, n) {
    const s = [];
    if (n != null && n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const h = n.get(l, f);
          if (h.isBoolean())
            return g.create(m.VALUE);
          const d = $(h);
          if (typeof d != "number")
            return d;
          s.push(d);
        }
    } else {
      if (n.isBoolean())
        return g.create(m.VALUE);
      const u = $(n);
      if (typeof u != "number")
        return u;
      s.push(u);
    }
    const o = vn(e, t, r, s);
    return typeof o != "number" ? o : y.create(o);
  }
}
class Sg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Ha(`${r}`))
        return g.create(m.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +r;
      if (o < 0)
        return g.create(m.NUM);
      if (o === 0)
        return y.create(1900);
      t = re(o);
    }
    const n = t.getUTCFullYear();
    return y.create(n);
  }
}
class Dg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : y.create(0);
    const s = zt(e);
    if (s.isError())
      return s;
    const o = zt(t);
    if (o.isError())
      return o;
    if (n = zt(n), n.isError())
      return n;
    if (s.isBoolean() || o.isBoolean() || n.isBoolean())
      return g.create(m.VALUE);
    const u = $(s);
    if (typeof u != "number")
      return u;
    const c = $(o);
    if (typeof c != "number")
      return c;
    const l = Math.floor(+n.getValue());
    if (Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0 || l > 4)
      return g.create(m.NUM);
    const { days: f, yearDays: h } = _e(u, c, l), d = f / h;
    return y.create(d);
  }
}
const Lg = [
  [sg, be.DATE],
  [ag, be.DATEDIF],
  [ig, be.DATEVALUE],
  [og, be.DAY],
  [ug, be.DAYS],
  [cg, be.DAYS360],
  [lg, be.EDATE],
  [fg, be.EOMONTH],
  [hg, be.EPOCHTODATE],
  [mg, be.HOUR],
  [gg, be.ISOWEEKNUM],
  [dg, be.MINUTE],
  [Cg, be.MONTH],
  [_g, be.NETWORKDAYS],
  [Ag, be.NETWORKDAYS_INTL],
  [Eg, be.NOW],
  [bg, be.SECOND],
  [yg, be.TIME],
  [Rg, be.TIMEVALUE],
  [pg, be.TO_DATE],
  [Vg, be.TODAY],
  [Ng, be.WEEKDAY],
  [Og, be.WEEKNUM],
  [Mg, be.WORKDAY],
  [wg, be.WORKDAY_INTL],
  [Sg, be.YEAR],
  [Dg, be.YEARFRAC]
];
class Pg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0)
      return g.create(m.NUM);
    const f = yr.besseli(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class xg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0)
      return g.create(m.NUM);
    const f = yr.besselj(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class jg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0)
      return g.create(m.NUM);
    const f = yr.besselk(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class Ug extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0)
      return g.create(m.NUM);
    const f = yr.bessely(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class vg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!wa(o))
      return g.create(m.NUM);
    let u;
    return o.length === 10 && o.substring(0, 1) === "1" ? u = Number.parseInt(o.substring(1), 2) - 512 : u = Number.parseInt(o, 2), y.create(u);
  }
}
class Tg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: h, variants: d } = H(t);
      if (f)
        return h;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!wa(c))
      return g.create(m.NUM);
    let l;
    if (c.length === 10 && c.substring(0, 1) === "1")
      l = (1099511627264 + Number.parseInt(c.substring(1), 2)).toString(16);
    else if (l = Number.parseInt(c, 2).toString(16), t) {
      if (r < l.length)
        return g.create(m.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return j.create(l.toLocaleUpperCase());
  }
}
class Bg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: h, variants: d } = H(t);
      if (f)
        return h;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!wa(c))
      return g.create(m.NUM);
    let l;
    if (c.length === 10 && c.substring(0, 1) === "1")
      l = (1073741312 + Number.parseInt(c.substring(1), 2)).toString(8);
    else if (l = Number.parseInt(c, 2).toString(8), t) {
      if (r < l.length)
        return g.create(m.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return j.create(l);
  }
}
class Ig extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = c;
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +h.getValue(), C = +d.getValue();
      if (_ < 0 || C < 0 || Math.floor(_) !== _ || Math.floor(C) !== C || _ > 281474976710655 || C > 281474976710655)
        return g.create(m.NUM);
      const E = _ & C;
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class Fg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = c;
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +h.getValue();
      let C = +d.getValue();
      if (_ < 0 || Math.floor(_) !== _ || _ > 281474976710655 || Math.abs(C) > 53)
        return g.create(m.NUM);
      C = Math.trunc(C);
      const E = Number(C >= 0 ? BigInt(_) << BigInt(C) : BigInt(_) >> BigInt(-C));
      return E > 281474976710655 ? g.create(m.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class kg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = c;
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +h.getValue(), C = +d.getValue();
      if (_ < 0 || C < 0 || Math.floor(_) !== _ || Math.floor(C) !== C || _ > 281474976710655 || C > 281474976710655)
        return g.create(m.NUM);
      const E = Number(BigInt(_) | BigInt(C));
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class $g extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = c;
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +h.getValue();
      let C = +d.getValue();
      if (_ < 0 || Math.floor(_) !== _ || _ > 281474976710655 || Math.abs(C) > 53)
        return g.create(m.NUM);
      C = Math.trunc(C);
      const E = Number(C >= 0 ? BigInt(_) >> BigInt(C) : BigInt(_) << BigInt(-C));
      return E > 281474976710655 ? g.create(m.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class Yg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = c;
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +h.getValue(), C = +d.getValue();
      if (_ < 0 || C < 0 || Math.floor(_) !== _ || Math.floor(C) !== C || _ > 281474976710655 || C > 281474976710655)
        return g.create(m.NUM);
      const E = _ ^ C;
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
P.prototype.cos = function() {
  const i = this.toNumber();
  return new P(Math.cos(i));
};
let he = class ue {
  constructor(a) {
    A(this, "_inumber", "");
    A(this, "_realNum", 0);
    A(this, "_iNum", 0);
    A(this, "_suffix", "");
    A(this, "_isError", !1);
    if (`${a}`.trim() === "") {
      this._isError = !0;
      return;
    }
    this._inumber = a, this._getImReal(), this._getImAginary(), this._getImSuffix();
  }
  static getComplex(a, e, t) {
    const r = new P(a).toSignificantDigits(15).toNumber(), n = new P(e).toSignificantDigits(15).toNumber(), s = t === "" ? "i" : t;
    let o;
    if (r === 0 && n === 0)
      o = 0;
    else if (r === 0)
      o = n === 1 ? s : `${n}${s}`;
    else if (n === 0)
      o = r;
    else {
      const u = n > 0 ? "+" : "", c = n === 1 ? s : `${n}${s}`;
      o = `${r}${u}${c}`;
    }
    return o;
  }
  static createByComplexStr(a, e, t) {
    const r = ue.getComplex(a, e, t);
    return new ue(r);
  }
  _getImReal() {
    if (this._inumber === 0 || this._inumber === "0") {
      this._realNum = 0;
      return;
    }
    const a = `${this._inumber}`;
    if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(a) >= 0) {
      this._realNum = 0;
      return;
    }
    let e = a.indexOf("+"), t = a.indexOf("-");
    e === 0 && (e = a.indexOf("+", 1)), t === 0 && (t = a.indexOf("-", 1));
    const r = a.substring(a.length - 1, a.length), n = r === "i" || r === "j";
    if (e >= 0 || t >= 0) {
      if (!n) {
        this._isError = !0;
        return;
      }
      e >= 0 ? Number.isNaN(+a.substring(0, e)) || Number.isNaN(+a.substring(e + 1, a.length - 1)) ? this._isError = !0 : this._realNum = +a.substring(0, e) : Number.isNaN(+a.substring(0, t)) || Number.isNaN(+a.substring(t + 1, a.length - 1)) ? this._isError = !0 : this._realNum = +a.substring(0, t);
    } else
      n ? Number.isNaN(+a.substring(0, a.length - 1)) ? this._isError = !0 : this._realNum = 0 : Number.isNaN(+a) ? this._isError = !0 : this._realNum = +a;
  }
  _getImAginary() {
    if (this._isError)
      return;
    if (this._inumber === 0 || this._inumber === "0") {
      this._iNum = 0;
      return;
    }
    let a = `${this._inumber}`;
    if (["i", "j"].indexOf(a) >= 0) {
      this._iNum = 1;
      return;
    }
    a = a.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
    let e = a.indexOf("+"), t = a.indexOf("-");
    e === 0 && (e = a.indexOf("+", 1)), t === 0 && (t = a.indexOf("-", 1));
    const r = a.substring(a.length - 1, a.length), n = r === "i" || r === "j";
    if (e >= 0 || t >= 0) {
      if (!n) {
        this._isError = !0;
        return;
      }
      e >= 0 ? Number.isNaN(+a.substring(0, e)) || Number.isNaN(+a.substring(e + 1, a.length - 1)) ? this._isError = !0 : this._iNum = +a.substring(e + 1, a.length - 1) : Number.isNaN(+a.substring(0, t)) || Number.isNaN(+a.substring(t + 1, a.length - 1)) ? this._isError = !0 : this._iNum = -+a.substring(t + 1, a.length - 1);
    } else
      n ? Number.isNaN(+a.substring(0, a.length - 1)) ? this._isError = !0 : this._iNum = +a.substring(0, a.length - 1) : Number.isNaN(+a) ? this._isError = !0 : this._iNum = 0;
  }
  _getImSuffix() {
    const a = `${this._inumber}`, e = a.substring(a.length - 1);
    this._suffix = e === "i" || e === "j" ? e : "";
  }
  getRealNum() {
    return this._realNum;
  }
  getINum() {
    return this._iNum;
  }
  getSuffix() {
    return this._suffix;
  }
  isError() {
    return this._isError;
  }
  toString() {
    return ue.getComplex(this._realNum, this._iNum, this._suffix);
  }
  isDifferentSuffixes(a) {
    const e = a.getSuffix();
    return this._suffix === "" || e === "" ? !1 : this._suffix !== e;
  }
  Abs() {
    return P.sqrt(P.pow(this._realNum, 2).add(P.pow(this._iNum, 2))).toSignificantDigits(16).toNumber();
  }
  Argument() {
    const a = P.sqrt(P.pow(this._realNum, 2).add(P.pow(this._iNum, 2)));
    let e = P.acos(new P(this._realNum).div(a)).toSignificantDigits(16).toNumber();
    return this._iNum < 0 && (e = -e), e;
  }
  Conjugate() {
    return ue.getComplex(this._realNum, -this._iNum, this._suffix);
  }
  Cos() {
    if (this._iNum) {
      const a = P.cos(this._realNum).mul(P.cosh(this._iNum)).toNumber(), e = P.sin(this._realNum).mul(P.sinh(this._iNum)).negated().toNumber();
      return ue.getComplex(a, e, this._suffix);
    } else {
      const a = P.cos(this._realNum).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Cosh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const a = P.cosh(this._realNum).mul(P.cos(this._iNum)).toNumber(), e = P.sinh(this._realNum).mul(P.sin(this._iNum)).toNumber();
      return ue.getComplex(a, e, this._suffix);
    } else {
      const a = P.cosh(this._realNum).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Cot() {
    if (this._iNum) {
      const a = P.cosh(this._iNum * 2).sub(P.cos(this._realNum * 2)), e = P.sin(this._realNum * 2).div(a).toNumber(), t = P.sinh(this._iNum * 2).div(a).negated().toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = new P(1).div(P.tan(this._realNum)).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Coth() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const a = P.cosh(this._realNum * 2).sub(P.cos(this._iNum * 2)), e = P.sinh(this._realNum * 2).div(a).toNumber(), t = P.sin(this._iNum * 2).div(a).negated().toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = new P(1).div(P.tanh(this._realNum)).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Csc() {
    if (this._iNum) {
      const a = P.cosh(this._iNum * 2).sub(P.cos(this._realNum * 2)), e = P.sin(this._realNum).mul(P.cosh(this._iNum)).mul(2).div(a).toNumber(), t = P.cos(this._realNum).mul(P.sinh(this._iNum)).mul(-2).div(a).toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = new P(1).div(P.sin(this._realNum)).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Csch() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return ue.getComplex(0, 0, this._suffix);
    if (this._iNum) {
      const a = P.cosh(this._realNum * 2).sub(P.cos(this._iNum * 2)), e = P.sinh(this._realNum).mul(P.cos(this._iNum)).mul(2).div(a).toNumber(), t = P.cosh(this._realNum).mul(P.sin(this._iNum)).mul(-2).div(a).toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = new P(1).div(P.sinh(this._realNum)).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Div(a) {
    const e = new P(this._realNum), t = new P(this._iNum), r = new P(a.getRealNum()), n = new P(a.getINum()), s = r.mul(r).add(n.mul(n)), o = e.mul(r).add(t.mul(n)).div(s).toNumber(), u = t.mul(r).sub(e.mul(n)).div(s).toNumber(), c = this._suffix === "" ? a.getSuffix() : this._suffix;
    return ue.getComplex(o, u, c);
  }
  Exp() {
    if (!Number.isFinite(Math.exp(this._realNum)))
      return this._isError = !0, "";
    const a = P.exp(this._realNum).mul(P.cos(this._iNum)).toNumber(), e = P.exp(this._realNum).mul(P.sin(this._iNum)).toNumber();
    return ue.getComplex(a, e, this._suffix);
  }
  Ln() {
    const a = P.sqrt(P.pow(this._realNum, 2).add(P.pow(this._iNum, 2))), e = P.ln(a).toNumber(), t = P.acos(new P(this._realNum).div(a)).toNumber();
    return ue.getComplex(e, t, this._suffix);
  }
  Log(a) {
    const e = P.sqrt(P.pow(this._realNum, 2).add(P.pow(this._iNum, 2))), t = P.ln(e);
    let r = P.acos(new P(this._realNum).div(e));
    this._iNum < 0 && (r = r.negated());
    const n = P.ln(a), s = new P(0), o = n.mul(n).add(s.mul(s));
    if (o.eq(0))
      return this._isError = !0, "";
    const u = t.mul(n).add(r.mul(s)).div(o).toNumber(), c = r.mul(n).sub(t.mul(s)).div(o).toNumber();
    return ue.getComplex(u, c, this._suffix);
  }
  Power(a) {
    if (this._realNum === 0 && this._iNum === 0)
      return a > 0 ? ue.getComplex(this._realNum, this._iNum, this._suffix) : (this._isError = !0, "");
    let e = P.sqrt(P.pow(this._realNum, 2).add(P.pow(this._iNum, 2))), t = P.acos(new P(this._realNum).div(e));
    this._iNum < 0 && (t = t.negated()), e = P.pow(e, a), t = t.mul(a);
    const r = P.cos(t).mul(e).toNumber(), n = P.sin(t).mul(e).toNumber();
    return !Number.isFinite(r) || !Number.isFinite(n) ? (this._isError = !0, "") : ue.getComplex(r, n, this._suffix);
  }
  Product(a) {
    const e = new P(this._realNum), t = new P(this._iNum), r = new P(a.getRealNum()), n = new P(a.getINum()), s = e.mul(r).sub(t.mul(n)).toNumber(), o = e.mul(n).add(t.mul(r)).toNumber(), u = this._suffix === "" ? a.getSuffix() : this._suffix;
    return ue.getComplex(s, o, u);
  }
  Sec() {
    if (this._iNum) {
      const a = P.cosh(this._iNum * 2).add(P.cos(this._realNum * 2)), e = P.cos(this._realNum).mul(P.cosh(this._iNum)).mul(2).div(a).toNumber(), t = P.sin(this._realNum).mul(P.sinh(this._iNum)).mul(2).div(a).toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = new P(1).div(P.cos(this._realNum)).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Sech() {
    if (!Number.isFinite(Math.sinh(this._realNum * 2)) || !Number.isFinite(Math.cosh(this._realNum * 2)))
      return ue.getComplex(0, 0, this._suffix);
    if (this._iNum) {
      const a = P.cosh(this._realNum * 2).add(P.cos(this._iNum * 2)), e = P.cosh(this._realNum).mul(P.cos(this._iNum)).mul(2).div(a).toNumber(), t = P.sinh(this._realNum).mul(P.sin(this._iNum)).mul(-2).div(a).toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = new P(1).div(P.cosh(this._realNum)).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Sin() {
    if (this._iNum) {
      const a = P.sin(this._realNum).mul(P.cosh(this._iNum)).toNumber(), e = P.cos(this._realNum).mul(P.sinh(this._iNum)).toNumber();
      return ue.getComplex(a, e, this._suffix);
    } else {
      const a = P.sin(this._realNum).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Sinh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const a = P.sinh(this._realNum).mul(P.cos(this._iNum)).toNumber(), e = P.cosh(this._realNum).mul(P.sin(this._iNum)).toNumber();
      return ue.getComplex(a, e, this._suffix);
    } else {
      const a = P.sinh(this._realNum).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Sqrt() {
    const a = P.sqrt(P.pow(this._realNum, 2).add(P.pow(this._iNum, 2))), e = P.sqrt(a);
    let t = P.acos(new P(this._realNum).div(a));
    this._iNum < 0 && (t = t.negated());
    const r = e.mul(P.cos(t.div(2).toNumber())).toNumber(), n = e.mul(P.sin(t.div(2))).toNumber();
    return ue.getComplex(r, n, this._suffix);
  }
  Sub(a) {
    const e = new P(this._realNum), t = new P(this._iNum), r = new P(a.getRealNum()), n = new P(a.getINum()), s = e.sub(r).toNumber(), o = t.sub(n).toNumber(), u = this._suffix === "" ? a.getSuffix() : this._suffix;
    return ue.getComplex(s, o, u);
  }
  Sum(a) {
    const e = new P(this._realNum), t = new P(this._iNum), r = new P(a.getRealNum()), n = new P(a.getINum()), s = e.add(r).toNumber(), o = t.add(n).toNumber(), u = this._suffix === "" ? a.getSuffix() : this._suffix;
    return ue.getComplex(s, o, u);
  }
  Tan() {
    if (this._iNum) {
      const a = P.cos(this._realNum * 2).add(P.cosh(this._iNum * 2)), e = P.sin(this._realNum * 2).div(a).toNumber(), t = P.sinh(this._iNum * 2).div(a).toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = P.tan(this._realNum).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
  Tanh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const a = P.cosh(this._realNum * 2).add(P.cos(this._iNum * 2)), e = P.sinh(this._realNum * 2).div(a).toNumber(), t = P.sin(this._iNum * 2).div(a).toNumber();
      return ue.getComplex(e, t, this._suffix);
    } else {
      const a = P.tanh(this._realNum).toNumber();
      return ue.getComplex(a, this._iNum, this._suffix);
    }
  }
};
class Hg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : j.create("i"), { isError: s, errorObject: o, variants: u } = H(e, t, n);
    if (s)
      return o;
    const [c, l, f] = u, h = +c.getValue(), d = +l.getValue(), _ = `${f.getValue()}`;
    if (Number.isNaN(h) || Number.isNaN(d) || _ !== "i" && _ !== "j")
      return g.create(m.VALUE);
    const C = he.getComplex(h, d, _);
    return typeof C == "number" ? y.create(C) : j.create(C);
  }
}
class Gg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    // List of units supported by CONVERT and units defined by the International System of Units
    // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
    A(this, "_units", [
      ["a.u. of action", "?", null, "action", !1, !1, 105457168181818e-48],
      ["a.u. of charge", "e", null, "electric_charge", !1, !1, 160217653141414e-33],
      ["a.u. of energy", "Eh", null, "energy", !1, !1, 435974417757576e-32],
      ["a.u. of length", "a?", null, "length", !1, !1, 529177210818182e-25],
      ["a.u. of mass", "m?", null, "mass", !1, !1, 910938261616162e-45],
      ["a.u. of time", "?/Eh", null, "time", !1, !1, 241888432650516e-31],
      ["admiralty knot", "admkn", null, "speed", !1, !0, 0.514773333],
      ["ampere", "A", null, "electric_current", !0, !1, 1],
      ["ampere per meter", "A/m", null, "magnetic_field_intensity", !0, !1, 1],
      ["ångström", "Å", ["ang"], "length", !1, !0, 1e-10],
      ["are", "ar", null, "area", !1, !0, 100],
      ["astronomical unit", "ua", null, "length", !1, !1, 149597870691667e-25],
      ["bar", "bar", null, "pressure", !1, !1, 1e5],
      ["barn", "b", null, "area", !1, !1, 1e-28],
      ["becquerel", "Bq", null, "radioactivity", !0, !1, 1],
      ["bit", "bit", ["b"], "information", !1, !0, 1],
      ["btu", "BTU", ["btu"], "energy", !1, !0, 1055.05585262],
      ["byte", "byte", null, "information", !1, !0, 8],
      ["candela", "cd", null, "luminous_intensity", !0, !1, 1],
      ["candela per square metre", "cd/m?", null, "luminance", !0, !1, 1],
      ["centigrade", "C", ["cel"], "temperature", !0, !1, 1],
      ["cubic ångström", "ang3", ["ang^3"], "volume", !1, !0, 1e-30],
      ["cubic foot", "ft3", ["ft^3"], "volume", !1, !0, 0.028316846592],
      ["cubic inch", "in3", ["in^3"], "volume", !1, !0, 16387064e-12],
      ["cubic light-year", "ly3", ["ly^3"], "volume", !1, !0, 846786664623715e-61],
      ["cubic metre", "m3", ["m^3"], "volume", !0, !0, 1],
      ["cubic mile", "mi3", ["mi^3"], "volume", !1, !0, 416818182544058e-5],
      ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", !1, !0, 6352182208],
      ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", !1, !0, 758660370370369e-22],
      ["cubic yard", "yd3", ["yd^3"], "volume", !1, !0, 0.764554857984],
      ["cup", "cup", null, "volume", !1, !0, 2365882365e-13],
      ["dalton", "Da", ["u"], "mass", !1, !1, 166053886282828e-41],
      ["day", "d", ["day"], "time", !1, !0, 86400],
      ["degree", "°", null, "angle", !1, !1, 0.0174532925199433],
      ["dyne", "dyn", ["dy"], "force", !1, !0, 1e-5],
      ["electronvolt", "eV", ["ev"], "energy", !1, !0, 1.60217656514141],
      ["ell", "ell", null, "length", !1, !0, 1.143],
      ["erg", "erg", ["e"], "energy", !1, !0, 1e-7],
      ["fahrenheit", "F", ["fah"], "temperature", !0, !1, 1],
      ["fluid ounce", "oz", null, "volume", !1, !0, 295735295625e-16],
      ["foot", "ft", null, "length", !1, !0, 0.3048],
      ["foot-pound", "flb", null, "energy", !1, !0, 1.3558179483314],
      ["gal", "Gal", null, "acceleration", !1, !1, 0.01],
      ["gallon", "gal", null, "volume", !1, !0, 0.003785411784],
      ["gauss", "G", ["ga"], "magnetic_flux_density", !1, !0, 1],
      ["grain", "grain", null, "mass", !1, !0, 647989e-10],
      ["gram", "g", null, "mass", !1, !0, 1e-3],
      ["gray", "Gy", null, "absorbed_dose", !0, !1, 1],
      ["gross registered ton", "GRT", ["regton"], "volume", !1, !0, 2.8316846592],
      ["hectare", "ha", null, "area", !1, !0, 1e4],
      ["henry", "H", null, "inductance", !0, !1, 1],
      ["hertz", "Hz", null, "frequency", !0, !1, 1],
      ["horsepower", "HP", ["h"], "power", !1, !0, 745.69987158227],
      ["horsepower-hour", "HPh", ["hh", "hph"], "energy", !1, !0, 2684519538e-3],
      ["hour", "h", ["hr"], "time", !1, !0, 3600],
      ["imperial gallon (U.K.)", "uk_gal", null, "volume", !1, !0, 454609e-8],
      ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", !1, !0, 50.802345],
      ["imperial quart (U.K)", "uk_qt", null, "volume", !1, !0, 0.0011365225],
      ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", !1, !0, 1016.046909],
      ["inch", "in", null, "length", !1, !0, 0.0254],
      ["international acre", "uk_acre", null, "area", !1, !0, 4046.8564224],
      ["IT calorie", "cal", null, "energy", !1, !0, 4.1868],
      ["joule", "J", null, "energy", !0, !0, 1],
      ["katal", "kat", null, "catalytic_activity", !0, !1, 1],
      ["kelvin", "K", ["kel"], "temperature", !0, !0, 1],
      ["kilogram", "kg", null, "mass", !0, !0, 1],
      ["knot", "kn", null, "speed", !1, !0, 0.514444444444444],
      ["light-year", "ly", null, "length", !1, !0, 9460730472580800],
      ["litre", "L", ["l", "lt"], "volume", !1, !0, 1e-3],
      ["lumen", "lm", null, "luminous_flux", !0, !1, 1],
      ["lux", "lx", null, "illuminance", !0, !1, 1],
      ["maxwell", "Mx", null, "magnetic_flux", !1, !1, 1e-18],
      ["measurement ton", "MTON", null, "volume", !1, !0, 1.13267386368],
      ["meter per hour", "m/h", ["m/hr"], "speed", !1, !0, 27777777777778e-17],
      ["meter per second", "m/s", ["m/sec"], "speed", !0, !0, 1],
      ["meter per second squared", "m?s??", null, "acceleration", !0, !1, 1],
      ["parsec", "pc", ["parsec"], "length", !1, !0, 30856775814671900],
      ["meter squared per second", "m?/s", null, "kinematic_viscosity", !0, !1, 1],
      ["metre", "m", null, "length", !0, !0, 1],
      ["miles per hour", "mph", null, "speed", !1, !0, 0.44704],
      ["millimetre of mercury", "mmHg", null, "pressure", !1, !1, 133.322],
      ["minute", "?", null, "angle", !1, !1, 290888208665722e-18],
      ["minute", "min", ["mn"], "time", !1, !0, 60],
      ["modern teaspoon", "tspm", null, "volume", !1, !0, 5e-6],
      ["mole", "mol", null, "amount_of_substance", !0, !1, 1],
      ["morgen", "Morgen", null, "area", !1, !0, 2500],
      ["n.u. of action", "?", null, "action", !1, !1, 105457168181818e-48],
      ["n.u. of mass", "m?", null, "mass", !1, !1, 910938261616162e-45],
      ["n.u. of speed", "c?", null, "speed", !1, !1, 299792458],
      ["n.u. of time", "?/(me?c??)", null, "time", !1, !1, 128808866778687e-35],
      ["nautical mile", "M", ["Nmi"], "length", !1, !0, 1852],
      ["newton", "N", null, "force", !0, !0, 1],
      ["œrsted", "Oe ", null, "magnetic_field_intensity", !1, !1, 79.5774715459477],
      ["ohm", "Ω", null, "electric_resistance", !0, !1, 1],
      ["ounce mass", "ozm", null, "mass", !1, !0, 0.028349523125],
      ["pascal", "Pa", null, "pressure", !0, !1, 1],
      ["pascal second", "Pa?s", null, "dynamic_viscosity", !0, !1, 1],
      ["pferdestärke", "PS", null, "power", !1, !0, 735.49875],
      ["phot", "ph", null, "illuminance", !1, !1, 1e-4],
      ["pica (1/6 inch)", "pica", null, "length", !1, !0, 35277777777778e-17],
      ["pica (1/72 inch)", "Pica", ["Picapt"], "length", !1, !0, 0.00423333333333333],
      ["poise", "P", null, "dynamic_viscosity", !1, !1, 0.1],
      ["pond", "pond", null, "force", !1, !0, 980665e-8],
      ["pound force", "lbf", null, "force", !1, !0, 4.4482216152605],
      ["pound mass", "lbm", null, "mass", !1, !0, 0.45359237],
      ["quart", "qt", null, "volume", !1, !0, 946352946e-12],
      ["radian", "rad", null, "angle", !0, !1, 1],
      ["rankine", "Rank", null, "temperature", !1, !0, 1],
      ["reaumur", "Reau", null, "temperature", !1, !0, 1],
      ["second", "?", null, "angle", !1, !1, 484813681109536e-20],
      ["second", "s", ["sec"], "time", !0, !0, 1],
      ["short hundredweight", "cwt", ["shweight"], "mass", !1, !0, 45.359237],
      ["siemens", "S", null, "electrical_conductance", !0, !1, 1],
      ["sievert", "Sv", null, "equivalent_dose", !0, !1, 1],
      ["slug", "sg", null, "mass", !1, !0, 14.59390294],
      ["square ångström", "ang2", ["ang^2"], "area", !1, !0, 1e-20],
      ["square foot", "ft2", ["ft^2"], "area", !1, !0, 0.09290304],
      ["square inch", "in2", ["in^2"], "area", !1, !0, 64516e-8],
      ["square light-year", "ly2", ["ly^2"], "area", !1, !0, 895054210748189e17],
      ["square meter", "m?", null, "area", !0, !0, 1],
      ["square mile", "mi2", ["mi^2"], "area", !1, !0, 2589988110336e-6],
      ["square nautical mile", "Nmi2", ["Nmi^2"], "area", !1, !0, 3429904],
      ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", !1, !0, 1792111111111e-17],
      ["square yard", "yd2", ["yd^2"], "area", !1, !0, 0.83612736],
      ["statute mile", "mi", null, "length", !1, !0, 1609.344],
      ["steradian", "sr", null, "solid_angle", !0, !1, 1],
      ["stilb", "sb", null, "luminance", !1, !1, 1e-4],
      ["stokes", "St", null, "kinematic_viscosity", !1, !1, 1e-4],
      ["stone", "stone", null, "mass", !1, !0, 6.35029318],
      ["tablespoon", "tbs", null, "volume", !1, !0, 147868e-10],
      ["teaspoon", "tsp", null, "volume", !1, !0, 492892e-11],
      ["tesla", "T", null, "magnetic_flux_density", !0, !0, 1],
      ["thermodynamic calorie", "c", null, "energy", !1, !0, 4.184],
      ["ton", "ton", null, "mass", !1, !0, 907.18474],
      ["tonne", "t", null, "mass", !1, !1, 1e3],
      ["U.K. pint", "uk_pt", null, "volume", !1, !0, 56826125e-11],
      ["U.S. bushel", "bushel", null, "volume", !1, !0, 0.03523907],
      ["U.S. oil barrel", "barrel", null, "volume", !1, !0, 0.158987295],
      ["U.S. pint", "pt", ["us_pt"], "volume", !1, !0, 473176473e-12],
      ["U.S. survey mile", "survey_mi", null, "length", !1, !0, 1609.347219],
      ["U.S. survey/statute acre", "us_acre", null, "area", !1, !0, 4046.87261],
      ["volt", "V", null, "voltage", !0, !1, 1],
      ["watt", "W", null, "power", !0, !0, 1],
      ["watt-hour", "Wh", ["wh"], "energy", !1, !0, 3600],
      ["weber", "Wb", null, "magnetic_flux", !0, !1, 1],
      ["yard", "yd", null, "length", !1, !0, 0.9144],
      ["year", "yr", null, "time", !1, !0, 31557600]
    ]);
    // Binary prefixes
    // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
    A(this, "_binaryPrefixes", {
      Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
      Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
      Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
      Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
      Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
      Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
      Mi: ["mebi", 20, 1048576, "Mi", "mega"],
      ki: ["kibi", 10, 1024, "ki", "kilo"]
    });
    // Unit prefixes
    // [Name, Multiplier, Abbreviation]
    A(this, "_unitPrefixes", {
      Y: ["yotta", 1e24, "Y"],
      Z: ["zetta", 1e21, "Z"],
      E: ["exa", 1e18, "E"],
      P: ["peta", 1e15, "P"],
      T: ["tera", 1e12, "T"],
      G: ["giga", 1e9, "G"],
      M: ["mega", 1e6, "M"],
      k: ["kilo", 1e3, "k"],
      h: ["hecto", 100, "h"],
      e: ["dekao", 10, "e"],
      d: ["deci", 0.1, "d"],
      c: ["centi", 0.01, "c"],
      m: ["milli", 1e-3, "m"],
      u: ["micro", 1e-6, "u"],
      n: ["nano", 1e-9, "n"],
      p: ["pico", 1e-12, "p"],
      f: ["femto", 1e-15, "f"],
      a: ["atto", 1e-18, "a"],
      z: ["zepto", 1e-21, "z"],
      y: ["yocto", 1e-24, "y"]
    });
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = H(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = `${c.getValue()}`, d = `${l.getValue()}`;
    if (Number.isNaN(f))
      return g.create(m.VALUE);
    let _, C = 1, E, b = 1;
    const { _from: R, _to: p } = this._lookupFromAndToUnits(h, d);
    if (_ = R, E = p, _ === null) {
      const { _from: M, _fromMultiplier: w } = this._lookupFromPrefix(h);
      _ = M, C = w;
    }
    if (E === null) {
      const { _to: M, _toMultiplier: w } = this._lookupToPrefix(d);
      E = M, b = w;
    }
    if (_ === null || E === null || _[3] !== E[3])
      return g.create(m.NA);
    let N;
    return _[3] === "temperature" ? (N = this._getTemperatureConversion(f, _[1], E[1]), N = +N.toFixed(2)) : N = f * _[6] * C / (E[6] * b), y.create(N);
  }
  _lookupFromAndToUnits(e, t) {
    let r = null, n = null, s;
    for (let o = 0; o < this._units.length; o++)
      s = this._units[o][2] === null ? [] : this._units[o][2], (this._units[o][1] === e || s.indexOf(e) >= 0) && (r = this._units[o]), (this._units[o][1] === t || s.indexOf(t) >= 0) && (n = this._units[o]);
    return {
      _from: r,
      _to: n
    };
  }
  _lookupFromPrefix(e) {
    let t = null, r = 1, n = e, s;
    const o = this._binaryPrefixes[e.substring(0, 2)];
    let u = this._unitPrefixes[e.substring(0, 1)];
    e.substring(0, 2) === "da" && (u = ["dekao", 10, "da"]), o ? (r = o[2], n = e.substring(2)) : u && (r = u[1], n = e.substring(u[2].length));
    for (let c = 0; c < this._units.length; c++)
      s = this._units[c][2] === null ? [] : this._units[c][2], (this._units[c][1] === n || s.indexOf(n) >= 0) && (t = this._units[c]);
    return {
      _from: t,
      _fromMultiplier: r
    };
  }
  _lookupToPrefix(e) {
    let t = null, r = 1, n = e, s;
    const o = this._binaryPrefixes[e.substring(0, 2)];
    let u = this._unitPrefixes[e.substring(0, 1)];
    e.substring(0, 2) === "da" && (u = ["dekao", 10, "da"]), o ? (r = o[2], n = e.substring(2)) : u && (r = u[1], n = e.substring(u[2].length));
    for (let c = 0; c < this._units.length; c++)
      s = this._units[c][2] === null ? [] : this._units[c][2], (this._units[c][1] === n || s.indexOf(n) >= 0) && (t = this._units[c]);
    return {
      _to: t,
      _toMultiplier: r
    };
  }
  _getTemperatureConversion(e, t, r) {
    switch (t) {
      case "C":
        return this._centigradeConversion(e, r);
      case "F":
        return this._fahrenheitConversion(e, r);
      case "K":
        return this._kelvinConversion(e, r);
      case "Rank":
        return this._rankineConversion(e, r);
      case "Reau":
        return this._reaumurConversion(e, r);
      default:
        return e;
    }
  }
  _centigradeConversion(e, t) {
    switch (t) {
      case "F":
        return e * 9 / 5 + 32;
      case "K":
        return e + 273.15;
      case "Rank":
        return (e + 273.15) * 9 / 5;
      case "Reau":
        return e * 4 / 5;
      default:
        return e;
    }
  }
  _fahrenheitConversion(e, t) {
    switch (t) {
      case "C":
        return (e - 32) * 5 / 9;
      case "K":
        return (e - 32) * 5 / 9 + 273.15;
      case "Rank":
        return e + 459.67;
      case "Reau":
        return (e - 32) * 4 / 9;
      default:
        return e;
    }
  }
  _kelvinConversion(e, t) {
    switch (t) {
      case "C":
        return e - 273.15;
      case "F":
        return (e - 273.15) * 9 / 5 + 32;
      case "Rank":
        return e * 9 / 5;
      case "Reau":
        return (e - 273.15) * 4 / 5;
      default:
        return e;
    }
  }
  _rankineConversion(e, t) {
    switch (t) {
      case "C":
        return (e - 491.67) * 5 / 9;
      case "F":
        return e - 459.67;
      case "K":
        return e * 5 / 9;
      case "Reau":
        return (e - 491.67) * 4 / 9;
      default:
        return e;
    }
  }
  _reaumurConversion(e, t) {
    switch (t) {
      case "C":
        return e * 5 / 4;
      case "F":
        return e * 9 / 4 + 32;
      case "K":
        return e * 5 / 4 + 273.15;
      case "Rank":
        return e * 9 / 4 + 491.67;
      default:
        return e;
    }
  }
}
class Qg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: h, variants: d } = H(t);
      if (f)
        return h;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g.create(m.VALUE);
    if (!/^-?[0-9]{1,3}$/.test(`${c}`) || c < -512 || c > 511)
      return g.create(m.NUM);
    let l;
    if (c < 0) {
      const f = (512 + c).toString(2);
      l = `1${"0".repeat(9 - f.length)}${f}`;
    } else if (l = Number.parseInt(`${c}`, 10).toString(2), t) {
      if (r < l.length)
        return g.create(m.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return j.create(l);
  }
}
class Wg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: h, variants: d } = H(t);
      if (f)
        return h;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g.create(m.VALUE);
    if (!/^-?[0-9]{1,12}$/.test(`${c}`) || c < -549755813888 || c > 549755813887)
      return g.create(m.NUM);
    let l;
    if (c < 0)
      l = (1099511627776 + c).toString(16);
    else if (l = Number.parseInt(`${c}`, 10).toString(16), t) {
      if (r < l.length)
        return g.create(m.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return j.create(l.toLocaleUpperCase());
  }
}
class qg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: h, variants: d } = H(t);
      if (f)
        return h;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g.create(m.VALUE);
    if (!/^-?[0-9]{1,9}$/.test(`${c}`) || c < -536870912 || c > 536870911)
      return g.create(m.NUM);
    let l;
    if (c < 0)
      l = (1073741824 + c).toString(8);
    else if (l = Number.parseInt(`${c}`, 10).toString(8), t) {
      if (r < l.length)
        return g.create(m.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return j.create(l);
  }
}
class Kg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), { isError: n, errorObject: s, variants: o } = H(e, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = +c.getValue();
    if (Number.isNaN(l) || Number.isNaN(f))
      return g.create(m.VALUE);
    const h = l === f ? 1 : 0;
    return y.create(h);
  }
}
class Xg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r;
    if (t) {
      const { isError: n, errorObject: s, variants: o } = H(e, t);
      if (n)
        return s;
      const [u, c] = o, l = +u.getValue(), f = +c.getValue();
      if (Number.isNaN(l) || Number.isNaN(f))
        return g.create(m.VALUE);
      r = Jt(f) - Jt(l);
    } else {
      const { isError: n, errorObject: s, variants: o } = H(e);
      if (n)
        return s;
      const [u] = o, c = +u.getValue();
      if (Number.isNaN(c))
        return g.create(m.VALUE);
      r = Jt(c);
    }
    return y.create(r);
  }
}
class Zg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g.create(m.VALUE);
    const u = Jt(o);
    return y.create(u);
  }
}
class zg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g.create(m.VALUE);
    const u = La(o);
    return y.create(u);
  }
}
class Jg extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g.create(m.VALUE);
    const u = La(o);
    return y.create(u);
  }
}
var Z = /* @__PURE__ */ ((i) => (i.BESSELI = "BESSELI", i.BESSELJ = "BESSELJ", i.BESSELK = "BESSELK", i.BESSELY = "BESSELY", i.BIN2DEC = "BIN2DEC", i.BIN2HEX = "BIN2HEX", i.BIN2OCT = "BIN2OCT", i.BITAND = "BITAND", i.BITLSHIFT = "BITLSHIFT", i.BITOR = "BITOR", i.BITRSHIFT = "BITRSHIFT", i.BITXOR = "BITXOR", i.COMPLEX = "COMPLEX", i.CONVERT = "CONVERT", i.DEC2BIN = "DEC2BIN", i.DEC2HEX = "DEC2HEX", i.DEC2OCT = "DEC2OCT", i.DELTA = "DELTA", i.ERF = "ERF", i.ERF_PRECISE = "ERF.PRECISE", i.ERFC = "ERFC", i.ERFC_PRECISE = "ERFC.PRECISE", i.GESTEP = "GESTEP", i.HEX2BIN = "HEX2BIN", i.HEX2DEC = "HEX2DEC", i.HEX2OCT = "HEX2OCT", i.IMABS = "IMABS", i.IMAGINARY = "IMAGINARY", i.IMARGUMENT = "IMARGUMENT", i.IMCONJUGATE = "IMCONJUGATE", i.IMCOS = "IMCOS", i.IMCOSH = "IMCOSH", i.IMCOT = "IMCOT", i.IMCOTH = "IMCOTH", i.IMCSC = "IMCSC", i.IMCSCH = "IMCSCH", i.IMDIV = "IMDIV", i.IMEXP = "IMEXP", i.IMLN = "IMLN", i.IMLOG = "IMLOG", i.IMLOG10 = "IMLOG10", i.IMLOG2 = "IMLOG2", i.IMPOWER = "IMPOWER", i.IMPRODUCT = "IMPRODUCT", i.IMREAL = "IMREAL", i.IMSEC = "IMSEC", i.IMSECH = "IMSECH", i.IMSIN = "IMSIN", i.IMSINH = "IMSINH", i.IMSQRT = "IMSQRT", i.IMSUB = "IMSUB", i.IMSUM = "IMSUM", i.IMTAN = "IMTAN", i.IMTANH = "IMTANH", i.OCT2BIN = "OCT2BIN", i.OCT2DEC = "OCT2DEC", i.OCT2HEX = "OCT2HEX", i))(Z || {});
class e1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    const r = t != null ? t : y.create(0), { isError: n, errorObject: s, variants: o } = H(e, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = +c.getValue();
    if (Number.isNaN(l) || Number.isNaN(f))
      return g.create(m.VALUE);
    const h = l >= f ? 1 : 0;
    return y.create(h);
  }
}
class t1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: d, errorObject: _, variants: C } = H(t);
      if (d)
        return _;
      const [E] = C;
      if (r = Math.floor(+E.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Da(c))
      return g.create(m.NUM);
    const l = c.length === 10 && c.substring(0, 1).toLocaleUpperCase() === "F", f = l ? Number.parseInt(c, 16) - 1099511627776 : Number.parseInt(c, 16);
    if (f < -512 || f > 511)
      return g.create(m.NUM);
    let h;
    if (l) {
      const d = (512 + f).toString(2);
      h = `1${"0".repeat(9 - d.length)}${d}`;
    } else if (h = f.toString(2), t) {
      if (r < h.length)
        return g.create(m.NUM);
      h = "0".repeat(r - h.length) + h;
    }
    return j.create(h);
  }
}
class r1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!Da(o))
      return g.create(m.NUM);
    let u = Number.parseInt(o, 16);
    return u >= 549755813888 && (u -= 1099511627776), y.create(u);
  }
}
class n1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: h, errorObject: d, variants: _ } = H(t);
      if (h)
        return d;
      const [C] = _;
      if (r = Math.floor(+C.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Da(c))
      return g.create(m.NUM);
    const l = Number.parseInt(c, 16);
    if (l > 536870911 && l < 1098974756864)
      return g.create(m.NUM);
    let f;
    if (l >= 1098974756864)
      f = (l - 1098437885952).toString(8);
    else if (f = l.toString(8), t) {
      if (r < f.length)
        return g.create(m.NUM);
      f = "0".repeat(r - f.length) + f;
    }
    return j.create(f);
  }
}
class s1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Abs();
    return y.create(c);
  }
}
class a1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.getINum();
    return y.create(c);
  }
}
class i1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    if (u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.DIV_BY_ZERO);
    const c = u.Argument();
    return y.create(c);
  }
}
class o1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Conjugate();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class u1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Cos();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class c1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Cosh();
    return u.isError() ? g.create(m.NUM) : typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class l1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Cot();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class f1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Coth();
    return u.isError() ? g.create(m.NUM) : typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class h1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Csc();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class m1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Csch();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class g1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = `${u.getValue()}`, f = new he(c), h = new he(l);
    if (f.isError() || h.isError() || f.isDifferentSuffixes(h) || h.getRealNum() === 0 && h.getINum() === 0)
      return g.create(m.NUM);
    const d = f.Div(h);
    return typeof d == "number" || W(d) ? y.create(+d) : j.create(d);
  }
}
class d1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Exp();
    return u.isError() ? g.create(m.NUM) : typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class C1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Ln();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class _1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e);
    if (r)
      return n;
    const [o] = s;
    let u = t != null ? t : y.create(10);
    if (u.isArray()) {
      const b = u.getRowCount(), R = u.getColumnCount();
      if (b > 1 || R > 1)
        return g.create(m.VALUE);
      u = u.get(0, 0);
    }
    const { isError: c, errorObject: l, variants: f } = B(u);
    if (c)
      return l;
    const [h] = f, d = `${o.getValue()}`, _ = +h.getValue(), C = new he(d);
    if (C.isError() || C.getRealNum() === 0 && C.getINum() === 0 || _ <= 0)
      return g.create(m.NUM);
    const E = C.Log(_);
    return C.isError() ? g.create(m.NUM) : typeof E == "number" || W(E) ? y.create(+E) : j.create(E);
  }
}
class A1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Log(2);
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class E1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(m.NUM);
    const c = u.Log(10);
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class b1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = new he(c);
    if (l.isError())
      return g.create(m.NUM);
    const f = +u.getValue();
    if (Number.isNaN(f))
      return g.create(m.VALUE);
    const h = l.Power(f);
    return l.isError() ? g.create(m.NUM) : typeof h == "number" || W(h) ? y.create(+h) : j.create(h);
  }
}
class y1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "";
    for (let r = 0; r < e.length; r++) {
      if (t instanceof g)
        return t;
      const n = e[r];
      if (n.isArray()) {
        let s = !1, o;
        if (n.iterator((u) => {
          if (t = this._handleSingleObject(u, t), t instanceof g)
            return s = !0, o = t, !1;
        }), s)
          return o;
      } else
        t = this._handleSingleObject(n, t);
    }
    return t instanceof g ? t : typeof t == "number" || W(t) ? y.create(+t) : j.create(t);
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g.create(m.VALUE);
    const n = `${e.getValue()}`;
    if (typeof t != "number" && !t) {
      const s = new he(n);
      if (s.isError())
        return g.create(m.NUM);
      r = s.toString();
    } else {
      const s = new he(t), o = new he(n);
      if (s.isError() || o.isError())
        return g.create(m.NUM);
      if (s.isDifferentSuffixes(o))
        return g.create(m.VALUE);
      r = s.Product(o);
    }
    return r;
  }
}
class R1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.getRealNum();
    return y.create(c);
  }
}
class p1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Sec();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class V1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Sech();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class N1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Sin();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class O1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Sinh();
    return u.isError() ? g.create(m.NUM) : typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class M1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    if (u.getRealNum() === 0 && u.getINum() === 0)
      return y.create(0);
    const c = u.Sqrt();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class w1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = `${u.getValue()}`, f = new he(c), h = new he(l);
    if (f.isError() || h.isError() || f.isDifferentSuffixes(h))
      return g.create(m.NUM);
    const d = f.Sub(h);
    return typeof d == "number" || W(d) ? y.create(+d) : j.create(d);
  }
}
class S1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "";
    for (let r = 0; r < e.length; r++) {
      if (t instanceof g)
        return t;
      const n = e[r];
      if (n.isArray()) {
        let s = !1, o;
        if (n.iterator((u) => {
          if (t = this._handleSingleObject(u, t), t instanceof g)
            return s = !0, o = t, !1;
        }), s)
          return o;
      } else
        t = this._handleSingleObject(n, t);
    }
    return t instanceof g ? t : typeof t == "number" || W(t) ? y.create(+t) : j.create(t);
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g.create(m.VALUE);
    const n = `${e.getValue()}`;
    if (typeof t != "number" && !t) {
      const s = new he(n);
      if (s.isError())
        return g.create(m.NUM);
      r = s.toString();
    } else {
      const s = new he(t), o = new he(n);
      if (s.isError() || o.isError())
        return g.create(m.NUM);
      if (s.isDifferentSuffixes(o))
        return g.create(m.VALUE);
      r = s.Sum(o);
    }
    return r;
  }
}
class D1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Tan();
    return typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class L1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new he(o);
    if (u.isError())
      return g.create(m.NUM);
    const c = u.Tanh();
    return u.isError() ? g.create(m.NUM) : typeof c == "number" || W(c) ? y.create(+c) : j.create(c);
  }
}
class P1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: d, errorObject: _, variants: C } = H(t);
      if (d)
        return _;
      const [E] = C;
      if (r = Math.floor(+E.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Sa(c))
      return g.create(m.NUM);
    const l = c.length === 10 && c.substring(0, 1) === "7", f = l ? Number.parseInt(c, 8) - 1073741824 : Number.parseInt(c, 8);
    if (f < -512 || f > 511)
      return g.create(m.NUM);
    let h;
    if (l) {
      const d = (512 + f).toString(2);
      h = `1${"0".repeat(9 - d.length)}${d}`;
    } else if (h = f.toString(2), t) {
      if (r < h.length)
        return g.create(m.NUM);
      h = "0".repeat(r - h.length) + h;
    }
    return j.create(h);
  }
}
class x1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = H(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!Sa(o))
      return g.create(m.NUM);
    let u = Number.parseInt(o, 8);
    return u >= 536870912 && (u -= 1073741824), y.create(u);
  }
}
class j1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(m.NA);
    let r = 0;
    if (t) {
      const { isError: h, errorObject: d, variants: _ } = H(t);
      if (h)
        return d;
      const [C] = _;
      if (r = Math.floor(+C.getValue()), Number.isNaN(r))
        return g.create(m.VALUE);
      if (r < 0 || r > 10)
        return g.create(m.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Sa(c))
      return g.create(m.NUM);
    const l = Number.parseInt(c, 8);
    let f;
    if (l >= 536870912)
      f = `ff${(l + 3221225472).toString(16)}`;
    else if (f = l.toString(16), t) {
      if (r < f.length)
        return g.create(m.NUM);
      f = "0".repeat(r - f.length) + f;
    }
    return j.create(f.toLocaleUpperCase());
  }
}
const U1 = [
  [Pg, Z.BESSELI],
  [xg, Z.BESSELJ],
  [jg, Z.BESSELK],
  [Ug, Z.BESSELY],
  [vg, Z.BIN2DEC],
  [Tg, Z.BIN2HEX],
  [Bg, Z.BIN2OCT],
  [Ig, Z.BITAND],
  [Fg, Z.BITLSHIFT],
  [kg, Z.BITOR],
  [$g, Z.BITRSHIFT],
  [Yg, Z.BITXOR],
  [Hg, Z.COMPLEX],
  [Gg, Z.CONVERT],
  [Qg, Z.DEC2BIN],
  [Wg, Z.DEC2HEX],
  [qg, Z.DEC2OCT],
  [Kg, Z.DELTA],
  [Xg, Z.ERF],
  [Zg, Z.ERF_PRECISE],
  [zg, Z.ERFC],
  [Jg, Z.ERFC_PRECISE],
  [e1, Z.GESTEP],
  [t1, Z.HEX2BIN],
  [r1, Z.HEX2DEC],
  [n1, Z.HEX2OCT],
  [s1, Z.IMABS],
  [a1, Z.IMAGINARY],
  [i1, Z.IMARGUMENT],
  [o1, Z.IMCONJUGATE],
  [u1, Z.IMCOS],
  [c1, Z.IMCOSH],
  [l1, Z.IMCOT],
  [f1, Z.IMCOTH],
  [h1, Z.IMCSC],
  [m1, Z.IMCSCH],
  [g1, Z.IMDIV],
  [d1, Z.IMEXP],
  [C1, Z.IMLN],
  [_1, Z.IMLOG],
  [E1, Z.IMLOG10],
  [A1, Z.IMLOG2],
  [b1, Z.IMPOWER],
  [y1, Z.IMPRODUCT],
  [R1, Z.IMREAL],
  [p1, Z.IMSEC],
  [V1, Z.IMSECH],
  [N1, Z.IMSIN],
  [O1, Z.IMSINH],
  [M1, Z.IMSQRT],
  [w1, Z.IMSUB],
  [S1, Z.IMSUM],
  [D1, Z.IMTAN],
  [L1, Z.IMTANH],
  [P1, Z.OCT2BIN],
  [x1, Z.OCT2DEC],
  [j1, Z.OCT2HEX]
];
var ee = /* @__PURE__ */ ((i) => (i.ACCRINT = "ACCRINT", i.ACCRINTM = "ACCRINTM", i.AMORDEGRC = "AMORDEGRC", i.AMORLINC = "AMORLINC", i.COUPDAYBS = "COUPDAYBS", i.COUPDAYS = "COUPDAYS", i.COUPDAYSNC = "COUPDAYSNC", i.COUPNCD = "COUPNCD", i.COUPNUM = "COUPNUM", i.COUPPCD = "COUPPCD", i.CUMIPMT = "CUMIPMT", i.CUMPRINC = "CUMPRINC", i.DB = "DB", i.DDB = "DDB", i.DISC = "DISC", i.DOLLARDE = "DOLLARDE", i.DOLLARFR = "DOLLARFR", i.DURATION = "DURATION", i.EFFECT = "EFFECT", i.FV = "FV", i.FVSCHEDULE = "FVSCHEDULE", i.INTRATE = "INTRATE", i.IPMT = "IPMT", i.IRR = "IRR", i.ISPMT = "ISPMT", i.MDURATION = "MDURATION", i.MIRR = "MIRR", i.NOMINAL = "NOMINAL", i.NPER = "NPER", i.NPV = "NPV", i.ODDFPRICE = "ODDFPRICE", i.ODDFYIELD = "ODDFYIELD", i.ODDLPRICE = "ODDLPRICE", i.ODDLYIELD = "ODDLYIELD", i.PDURATION = "PDURATION", i.PMT = "PMT", i.PPMT = "PPMT", i.PRICE = "PRICE", i.PRICEDISC = "PRICEDISC", i.PRICEMAT = "PRICEMAT", i.PV = "PV", i.RATE = "RATE", i.RECEIVED = "RECEIVED", i.RRI = "RRI", i.SLN = "SLN", i.SYD = "SYD", i.TBILLEQ = "TBILLEQ", i.TBILLPRICE = "TBILLPRICE", i.TBILLYIELD = "TBILLYIELD", i.VDB = "VDB", i.XIRR = "XIRR", i.XNPV = "XNPV", i.YIELD = "YIELD", i.YIELDDISC = "YIELDDISC", i.YIELDMAT = "YIELDMAT", i))(ee || {});
function us(i, a, e, t) {
  const r = $t(i, a, e), { days: n } = _e(r, i, t);
  return n;
}
function Xe(i, a, e, t) {
  let r;
  if (t === 1) {
    const n = $t(i, a, e);
    let s = re(n);
    s = pr(s, 12 / e);
    const o = Re(s);
    n < 0 && e === 1 ? r = 365 : r = o - n;
  } else t === 3 ? r = 365 / e : r = 360 / e;
  return r;
}
function Lu(i, a, e) {
  const t = re(i);
  let r = re(a);
  for (r.setUTCFullYear(t.getUTCFullYear()), r < t && r.setUTCFullYear(r.getUTCFullYear() + 1); r > t; )
    r = pr(r, -12 / e);
  return r = pr(r, 12 / e), Re(r);
}
function sr(i, a, e) {
  let t = 0;
  const r = re(i);
  let n = re(a);
  for (; n > r; )
    n = pr(n, -12 / e), t++;
  return t;
}
function $t(i, a, e) {
  const t = re(i);
  let r = re(a);
  for (r.setUTCFullYear(t.getUTCFullYear()), r < t && r.setUTCFullYear(r.getUTCFullYear() + 1); r > t; )
    r = pr(r, -12 / e);
  return Re(r);
}
function Pu(i, a, e, t, r, n) {
  const s = us(i, a, r, n), o = Xe(i, a, r, n), u = sr(i, a, r), c = (o - s) / o - 1, l = t / r + 1, f = e * 100 / r;
  let h = 0, d = 0;
  for (let E = 1; E <= u; E++) {
    const b = E + c, R = f / l ** b;
    h += b * R, d += R;
  }
  const _ = u + c, C = 100 / l ** _;
  return h += _ * C, d += C, h / d / r;
}
function qr(i, a, e, t, r) {
  let n;
  if (i === 0)
    n = (e + t) / a;
  else {
    const s = (1 + i) ** a;
    n = r === 1 ? (t * i / (s - 1) + e * i / (1 - 1 / s)) / (1 + i) : t * i / (s - 1) + e * i / (1 - 1 / s);
  }
  return -n;
}
function ar(i, a, e, t, r) {
  let n;
  if (i === 0)
    n = t + e * a;
  else {
    if (i === -1 && a === 0)
      return Number.NaN;
    const s = (1 + i) ** a;
    n = r === 1 ? t * s + e * (1 + i) * (s - 1) / i : t * s + e * (s - 1) / i;
  }
  return -n;
}
function xu(i, a, e, t, r, n) {
  const s = qr(i, e, t, r, n);
  return (a === 1 ? n === 1 ? 0 : -t : n === 1 ? ar(i, a - 2, s, t, 1) - s : ar(i, a - 1, s, t, 0)) * i;
}
function ju(i, a) {
  let e = 0;
  for (let t = 1; t <= a.length; t++)
    e += a[t - 1] / (1 + i) ** t;
  return e;
}
function Uu(i, a, e, t, r, n, s, o, u) {
  const c = Zt(e, t, u), l = Xe(i, t, o, u);
  return c < l ? v1(
    i,
    a,
    e,
    t,
    r,
    n,
    s,
    o,
    u,
    c,
    l
  ) : T1(
    i,
    a,
    e,
    t,
    r,
    n,
    s,
    o,
    u,
    l
  );
}
function v1(i, a, e, t, r, n, s, o, u, c, l) {
  let f = 0;
  const h = sr(i, a, o), d = Zt(i, t, u);
  f += s / (1 + n / o) ** (h - 1 + d / l), f += 100 * r / o * c / l / (1 + n / o) ** (d / l);
  for (let C = 2; C <= h; C++)
    f += 100 * r / o / (1 + n / o) ** (C - 1 + d / l);
  const _ = Zt(e, i, u);
  return f -= 100 * r / o * _ / l, f;
}
function T1(i, a, e, t, r, n, s, o, u, c) {
  let l = 0;
  const f = sr(t, a, o), h = B1(t, i, 12 / o);
  let d;
  if (u === 2 || u === 3) {
    const R = Lu(i, t, o);
    d = Zt(i, R, u);
  } else {
    const R = $t(i, t, o), { days: p } = _e(R, i, u);
    d = c - p;
  }
  l += s / (1 + n / o) ** (f + h + d / c);
  const _ = sr(e, t, o);
  let C = t, E = 0, b = 0;
  for (let R = _; R >= 1; R--) {
    const p = tr(C, -12 / o, !1), N = u === 1 ? Zt(p, C, u) : c, M = R > 1 ? N : Zt(e, C, u);
    E += M / N;
    const w = e > p ? e : p, S = i < C ? i : C, D = Zt(w, S, u);
    b += D / N, C = p;
  }
  l += 100 * r / o * E / (1 + n / o) ** (h + d / c);
  for (let R = 1; R <= f; R++)
    l += 100 * r / o / (1 + n / o) ** (R + h + d / c);
  return l -= 100 * r / o * b, l;
}
function Zt(i, a, e) {
  const { days: t } = _e(i, a, e);
  return i < a ? t : 0;
}
function vu(i, a, e) {
  const t = re(i), r = t.getUTCFullYear(), n = t.getUTCMonth(), s = t.getUTCDate(), o = Rr(r, n, s), u = re(a), c = u.getUTCFullYear(), l = u.getUTCMonth(), f = u.getUTCDate(), h = Rr(c, l, f);
  return !(s !== f && !(o && h) || Math.abs((c - r) * 12 + (l - n)) % (12 / e) !== 0);
}
function Mr(i, a, e) {
  return $t(i, a, e) >= 0;
}
function tr(i, a, e) {
  let t = re(i);
  if (t = pr(t, a), e) {
    const r = t.getUTCFullYear(), n = t.getUTCMonth(), s = Wr(r, n);
    t.setUTCDate(s);
  }
  return Re(t);
}
function B1(i, a, e, t) {
  const r = re(i), n = re(a), s = r.getUTCFullYear(), o = r.getUTCMonth(), u = r.getUTCDate(), c = n.getUTCFullYear(), l = n.getUTCMonth(), f = n.getUTCDate(), h = Rr(s, o, u), d = !h && o !== 1 && u > 28 && u < Wr(s, o) ? Rr(c, l, f) : h, _ = tr(a, 0, d);
  let C = 1 + +(a < _), E = tr(_, e, d);
  for (; !(e > 0 ? E >= a : E <= a); )
    E = tr(E, e, d), C++;
  return C;
}
function Qa(i, a) {
  let n = 1, s = 0, o = i, u;
  for (; n > 1e-7 && s < 500; ) {
    const c = (a(o + 1e-7) - a(o - 1e-7)) / 2e-7;
    u = o - a(o) / c, s++, n = Math.abs(u - o), o = u;
  }
  return Number.isNaN(o) || Math.abs(o) === 1 / 0 || s === 500 ? I1(i, a) : o;
}
function I1(i, a) {
  const r = Number.MAX_VALUE, n = -1, s = 1.6;
  let o = i - 0.01 <= n ? n + 1e-7 : i - 0.01, u = i + 0.01 >= r ? r - 1e-7 : i + 0.01, c, l, f = 0;
  if (i <= n || i >= r)
    return g.create(m.NUM);
  for (let E = 0; E < 60; E++) {
    c = o <= n ? n + 1e-7 : o, l = u >= r ? r - 1e-7 : u;
    const b = a(c), R = a(l);
    if (b * R <= 0)
      break;
    if (b * R > 0)
      o = c + s * (c - l), u = l + s * (l - c);
    else
      return g.create(m.NUM);
    if (E === 59)
      return g.create(m.NUM);
  }
  c = c, l = l;
  let h = a(c);
  const d = a(l);
  let _, C;
  if (Math.abs(h) < 1e-7 || Math.abs(d) < 1e-7)
    return g.create(m.NUM);
  do
    C = c + (l - c) / 2, _ = a(C), h * _ < 0 ? l = C : c = C, h = a(c), f++;
  while (Math.abs(_) > 1e-7 && f < 60);
  return C;
}
function gn(i, a, e, t, r, n, s) {
  const o = sr(i, a, n), u = Xe(i, a, n, s), c = us(i, a, n, s);
  if (o === 1) {
    const h = u - c, d = 100 * e / n + r, _ = t / n * h / u + 1, C = 100 * e / n * c / u;
    return d / _ - C;
  }
  const l = u - c;
  let f = r / (1 + t / n) ** (o - 1 + l / u);
  for (let h = 1; h <= o; h++)
    f += 100 * e / n / (1 + t / n) ** (h - 1 + l / u);
  return f -= 100 * e / n * c / u, f;
}
function na(i, a, e, t, r) {
  let n = 0, s = r / e;
  s >= 1 ? (s = 1, n = t === 1 ? i : 0) : n = i * (1 - s) ** (t - 1);
  const o = i * (1 - s) ** t;
  let u = 0;
  return o < a ? u = n - a : u = n - o, u < 0 && (u = 0), u;
}
class F1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 8);
  }
  calculate(e, t, r, n, s, o, u, c) {
    const l = u != null ? u : y.create(0), f = c != null ? c : T.create(!0), { isError: h, errorObject: d, variants: _ } = H(e, t, r, n, s, o, l);
    if (h)
      return d;
    const [C, E, b, R, p, N, M] = _, w = $(C);
    if (typeof w != "number")
      return w;
    const S = $(E);
    if (typeof S != "number")
      return S;
    const D = $(b);
    if (typeof D != "number")
      return D;
    const L = +R.getValue(), U = +p.getValue(), x = Math.floor(+N.getValue()), k = Math.floor(+M.getValue()), Q = +f.getValue();
    return Number.isNaN(L) || Number.isNaN(U) || Number.isNaN(x) || Number.isNaN(k) || Number.isNaN(Q) ? g.create(m.VALUE) : L <= 0 || U <= 0 || ![1, 2, 4].includes(x) || k < 0 || k > 4 || Math.floor(w) >= Math.floor(D) ? g.create(m.NUM) : this._getResult(w, S, D, L, U, x, k, Q);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    let l = $t(e, t, o);
    if (l <= 0)
      return y.create(0);
    l = $t(r, t, o);
    const f = 12 / o, h = re(t), d = h.getUTCFullYear(), _ = h.getUTCMonth(), C = h.getUTCDate(), E = Rr(d, _, C);
    let b = tr(t, -f, E);
    if (r > t && c)
      for (b = t; b < r; )
        b = tr(b, f, E);
    let R = e > b ? e : b, { days: p } = _e(R, r, u);
    if (l >= e) {
      const { days: L } = _e(R, r, u ? 4 : 0);
      p = L;
    }
    r < R && (p = -p);
    let N = Xe(b, t, o, u), M = p / N, w = b, S = e;
    for (; w > e; ) {
      S = w, w = tr(w, -f, E), R = e > w ? e : w;
      const { days: L } = _e(R, S, u);
      if (u === 0)
        S >= R || e <= w ? p = L : p = -L, N = Xe(w, S, o, u);
      else if (p = S < R ? -L : L, u === 3)
        N = 365 / o;
      else {
        const { days: U } = _e(w, S, u);
        N = S < w ? -U : U;
      }
      M += e <= w ? c ? 1 : 0 : p / N;
    }
    const D = s * n / o * M;
    return y.create(D);
  }
}
class k1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y.create(0), { isError: u, errorObject: c, variants: l } = H(e, t, r, n, o);
    if (u)
      return c;
    const [f, h, d, _, C] = l, E = $(f);
    if (typeof E != "number")
      return E;
    const b = $(h);
    if (typeof b != "number")
      return b;
    const R = +d.getValue(), p = +_.getValue(), N = Math.floor(+C.getValue());
    if (Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N))
      return g.create(m.VALUE);
    if (R <= 0 || p <= 0 || N < 0 || N > 4 || Math.floor(E) > Math.floor(b))
      return g.create(m.NUM);
    if (Math.floor(E) === Math.floor(b))
      return y.create(0);
    const { days: M, yearDays: w } = _e(E, b, N), S = p * R * M / w;
    return y.create(S);
  }
}
class $1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    const c = u != null ? u : y.create(0), { isError: l, errorObject: f, variants: h } = H(e, t, r, n, s, o, c);
    if (l)
      return f;
    const [d, _, C, E, b, R, p] = h, N = $(_);
    if (typeof N != "number")
      return N;
    const M = $(C);
    if (typeof M != "number")
      return M;
    const w = +d.getValue(), S = +E.getValue();
    let D = +b.getValue();
    const L = +R.getValue(), U = Math.floor(+p.getValue());
    return Number.isNaN(w) || Number.isNaN(S) || Number.isNaN(D) || Number.isNaN(L) || Number.isNaN(U) ? g.create(m.VALUE) : w <= 0 || S < 0 || w < S || Math.floor(N) > Math.floor(M) || D < 0 || L <= 0 || ![0, 1, 3, 4].includes(U) ? g.create(m.NUM) : (D > 1 ? D = Math.floor(D) : D = Math.ceil(D), this._getResult(w, N, M, S, D, L, U));
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = e - n, l = e * o, { days: f, yearDays: h } = _e(t, r, u), d = f / h, _ = Math.ceil(c / l - d);
    if (_ < 0)
      return y.create(0);
    let C = l;
    return s === 0 ? C = l * d : s === _ ? C = c - l * (d + s - 1) : s > _ && (C = 0), y.create(C);
  }
}
class Y1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = H(e, t, r, s);
    if (o)
      return u;
    const [l, f, h, d] = c, _ = $(l);
    if (typeof _ != "number")
      return _;
    const C = $(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+h.getValue()), b = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(b))
      return g.create(m.VALUE);
    if (![1, 2, 4].includes(E) || b < 0 || b > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(m.NUM);
    const R = us(_, C, E, b);
    return y.create(R);
  }
}
class H1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = H(e, t, r, s);
    if (o)
      return u;
    const [l, f, h, d] = c, _ = $(l);
    if (typeof _ != "number")
      return _;
    const C = $(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+h.getValue()), b = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(b))
      return g.create(m.VALUE);
    if (![1, 2, 4].includes(E) || b < 0 || b > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(m.NUM);
    const R = Xe(_, C, E, b);
    return y.create(R);
  }
}
class G1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = H(e, t, r, s);
    if (o)
      return u;
    const [l, f, h, d] = c, _ = $(l);
    if (typeof _ != "number")
      return _;
    const C = $(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+h.getValue()), b = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(b))
      return g.create(m.VALUE);
    if (![1, 2, 4].includes(E) || b < 0 || b > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(m.NUM);
    const R = re(_), p = re(C);
    for (p.setUTCFullYear(R.getUTCFullYear()), p < R && p.setUTCFullYear(p.getUTCFullYear() + 1); p > R; )
      p.setUTCMonth(p.getUTCMonth() - 12 / E);
    p.setUTCMonth(p.getUTCMonth() + 12 / E);
    const N = Re(p), { days: M } = _e(_, N, b);
    return y.create(M);
  }
}
class Q1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = H(e, t, r, s);
    if (o)
      return u;
    const [l, f, h, d] = c, _ = $(l);
    if (typeof _ != "number")
      return _;
    const C = $(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+h.getValue()), b = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(b))
      return g.create(m.VALUE);
    if (![1, 2, 4].includes(E) || b < 0 || b > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(m.NUM);
    const R = Lu(_, C, E);
    return y.create(R);
  }
}
class W1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = H(e, t, r, s);
    if (o)
      return u;
    const [l, f, h, d] = c, _ = $(l);
    if (typeof _ != "number")
      return _;
    const C = $(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+h.getValue()), b = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(b))
      return g.create(m.VALUE);
    if (![1, 2, 4].includes(E) || b < 0 || b > 4 || Math.floor(_) >= Math.floor(C) || $t(_, C, E) < 0)
      return g.create(m.NUM);
    const p = sr(_, C, E);
    return y.create(p);
  }
}
class q1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = H(e, t, r, s);
    if (o)
      return u;
    const [l, f, h, d] = c, _ = $(l);
    if (typeof _ != "number")
      return _;
    const C = $(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+h.getValue()), b = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(b))
      return g.create(m.VALUE);
    if (![1, 2, 4].includes(E) || b < 0 || b > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(m.NUM);
    let R = $t(_, C, E);
    return R < 0 && (R = 0), y.create(R);
  }
}
class K1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = H(e, t, r, n, s, o);
    if (u)
      return c;
    const [f, h, d, _, C, E] = l, b = +f.getValue(), R = +h.getValue(), p = +d.getValue(), N = +_.getValue(), M = +C.getValue(), w = +E.getValue();
    return Number.isNaN(b) || Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N) || Number.isNaN(M) || Number.isNaN(w) ? g.create(m.VALUE) : b <= 0 || R <= 0 || p <= 0 || N < 1 || M < 1 || N > M || N > R || M > R || ![0, 1].includes(w) ? g.create(m.NUM) : Math.trunc(N) !== N && Math.trunc(M) !== M && Math.trunc(N) === Math.trunc(M) ? y.create(0) : this._getResult(b, R, p, N, M, w);
  }
  _getResult(e, t, r, n, s, o) {
    const u = qr(e, t, r, 0, o);
    let c = 0, l = Math.ceil(n);
    l === 1 && (o === 0 && (c = -r), l++);
    let f = !1;
    for (let h = l; h <= s; h++) {
      const d = o === 1 ? ar(e, h - 2, u, r, 1) : ar(e, h - 1, u, r, 0);
      if (d === 0) {
        f = !0;
        break;
      }
      c += o === 1 ? d - u : d;
    }
    return c *= e, (c < u * (s - n + 1) || f) && (c = u * (s - n + 1)), y.create(c);
  }
}
class X1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = H(e, t, r, n, s, o);
    if (u)
      return c;
    const [f, h, d, _, C, E] = l, b = +f.getValue(), R = +h.getValue(), p = +d.getValue(), N = +_.getValue(), M = +C.getValue(), w = +E.getValue();
    return Number.isNaN(b) || Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N) || Number.isNaN(M) || Number.isNaN(w) ? g.create(m.VALUE) : b <= 0 || R <= 0 || p <= 0 || N < 1 || M < 1 || N > M || ![0, 1].includes(w) ? g.create(m.NUM) : Math.trunc(N) !== N && Math.trunc(M) !== M && Math.trunc(N) === Math.trunc(M) ? y.create(0) : this._getResult(b, R, p, N, M, w);
  }
  _getResult(e, t, r, n, s, o) {
    const u = qr(e, t, r, 0, o);
    let c = 0, l = Math.ceil(n);
    l === 1 && (c = o === 0 ? u + r * e : u, l++);
    for (let f = l; f <= s; f++)
      c += o === 1 ? u - (ar(e, f - 2, u, r, 1) - u) * e : u - ar(e, f - 1, u, r, 0) * e;
    return y.create(c);
  }
}
class Z1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(12);
    o.isNull() && (o = y.create(12));
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g.create(m.NA)), f = O(u, c, t, g.create(m.NA)), h = O(u, c, r, g.create(m.NA)), d = O(u, c, n, g.create(m.NA)), _ = O(u, c, o, g.create(m.NA)), C = l.map((E, b, R) => {
      const p = f.get(b, R), N = h.get(b, R), M = d.get(b, R), w = _.get(b, R), { isError: S, errorObject: D, variants: L } = B(E, p, N, M, w);
      if (S)
        return D;
      const [U, x, k, Q, ne] = L, z = +U.getValue(), G = +x.getValue(), ge = +k.getValue();
      let de = +Q.getValue();
      const Ee = Math.floor(+ne.getValue());
      return z < 0 || G < 0 || ge <= 0 || de <= 0 || Math.floor(de) > Math.floor(ge) || Ee < 1 || Ee > 12 ? g.create(m.NUM) : (de < 1 && (de = 1), de = Math.floor(de), this._getResult(z, G, ge, de, Ee, b, R));
    });
    return u === 1 && c === 1 ? C.get(0, 0) : C;
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = +(1 - (t / e) ** (1 / r)).toFixed(3), l = e * c * s / 12;
    let f = l, h = 0;
    const d = n === r ? r - 1 : n;
    for (let C = 2; C <= d; C++)
      h = (e - f) * c, f += h;
    let _;
    return n === 1 ? _ = l : n === r ? _ = (e - f) * c : _ = h, Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : o === 0 && u === 0 ? y.create(_, ze(this.getLocale())) : y.create(_);
  }
}
class z1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(2);
    o.isNull() && (o = y.create(2));
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g.create(m.NA)), f = O(u, c, t, g.create(m.NA)), h = O(u, c, r, g.create(m.NA)), d = O(u, c, n, g.create(m.NA)), _ = O(u, c, o, g.create(m.NA)), C = l.map((E, b, R) => {
      const p = f.get(b, R), N = h.get(b, R), M = d.get(b, R), w = _.get(b, R), { isError: S, errorObject: D, variants: L } = B(E, p, N, M, w);
      if (S)
        return D;
      const [U, x, k, Q, ne] = L, z = +U.getValue(), G = +x.getValue(), ge = +k.getValue(), de = +Q.getValue(), Ee = +ne.getValue();
      if (z < 0 || G < 0 || ge <= 0 || de <= 0 || de > ge || Ee <= 0)
        return g.create(m.NUM);
      const pe = na(z, G, ge, de, Ee);
      return Number.isNaN(pe) || !Number.isFinite(pe) ? g.create(m.NUM) : b === 0 && R === 0 ? y.create(pe, ze(this.getLocale())) : y.create(pe);
    });
    return u === 1 && c === 1 ? C.get(0, 0) : C;
  }
}
class J1 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y.create(0), { isError: u, errorObject: c, variants: l } = H(e, t, r, n, o);
    if (u)
      return c;
    const [f, h, d, _, C] = l, E = $(f);
    if (typeof E != "number")
      return E;
    const b = $(h);
    if (typeof b != "number")
      return b;
    const R = +d.getValue(), p = +_.getValue(), N = Math.floor(+C.getValue());
    if (Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N))
      return g.create(m.VALUE);
    if (R <= 0 || p <= 0 || N < 0 || N > 4 || Math.floor(E) >= Math.floor(b))
      return g.create(m.NUM);
    const { days: M, yearDays: w } = _e(E, b, N), S = (p - R) / p * (w / M);
    return y.create(S);
  }
}
class e0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0)
      return g.create(m.NUM);
    if (l >= 0 && l < 1)
      return g.create(m.DIV_BY_ZERO);
    l = Number.parseInt(`${l}`, 10);
    let f = Number.parseInt(`${c}`, 10);
    f += c % 1 * 10 ** Math.ceil(Math.log(l) / Math.LN10) / l;
    const h = 10 ** (Math.ceil(Math.log(l) / Math.LN2) + 1);
    return f = Math.round(f * h) / h, y.create(f);
  }
}
class t0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l < 0)
      return g.create(m.NUM);
    if (l >= 0 && l < 1)
      return g.create(m.DIV_BY_ZERO);
    l = Number.parseInt(`${l}`, 10);
    let f = Number.parseInt(`${c}`, 10);
    return f += c % 1 * 10 ** -Math.ceil(Math.log(l) / Math.LN10) * l, y.create(f);
  }
}
class r0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = ke(e, t, r, n, s, u);
    if (c)
      return l;
    const [h, d, _, C, E, b] = f, R = $(h);
    if (typeof R != "number")
      return R;
    const p = $(d);
    if (typeof p != "number")
      return p;
    const N = +_.getValue(), M = +C.getValue(), w = Math.floor(+E.getValue()), S = Math.floor(+b.getValue());
    if (Number.isNaN(N) || Number.isNaN(M) || Number.isNaN(w) || Number.isNaN(S))
      return g.create(m.VALUE);
    if (N < 0 || M < 0 || ![1, 2, 4].includes(w) || S < 0 || S > 4 || Math.floor(R) >= Math.floor(p) || R <= 0 || p <= 366)
      return g.create(m.NUM);
    const D = Pu(R, p, N, M, w, S);
    return y.create(D);
  }
}
class n0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (c <= 0 || l < 1)
      return g.create(m.NUM);
    l = Number.parseInt(`${l}`, 10);
    const f = (1 + c / l) ** l - 1;
    return y.create(f);
  }
}
class s0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(m.NA)), h = O(c, l, t, g.create(m.NA)), d = O(c, l, r, g.create(m.NA)), _ = O(c, l, o, g.create(m.NA)), C = O(c, l, u, g.create(m.NA)), E = f.map((b, R, p) => {
      const N = h.get(R, p), M = d.get(R, p), w = _.get(R, p), S = C.get(R, p), { isError: D, errorObject: L, variants: U } = B(b, N, M, w, S);
      if (D)
        return L;
      const [x, k, Q, ne, z] = U, G = +x.getValue(), ge = +k.getValue(), de = +Q.getValue(), Ee = +ne.getValue(), pe = +z.getValue(), me = ar(G, ge, de, Ee, pe ? 1 : 0);
      return Number.isNaN(me) || !Number.isFinite(me) ? g.create(m.NUM) : R === 0 && p === 0 ? y.create(me, ze(this.getLocale())) : y.create(me);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class a0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    if (Number.isNaN(u))
      return g.create(m.VALUE);
    let c = u;
    if (t.isArray()) {
      const l = t.getArrayValue().flat();
      for (let f = 0; f < l.length; f++) {
        const h = l[f];
        if (h.isBoolean())
          return g.create(m.VALUE);
        const d = +h.getValue();
        if (Number.isNaN(d))
          return g.create(m.VALUE);
        c *= 1 + d;
      }
    } else {
      if (t.isBoolean())
        return g.create(m.VALUE);
      const l = +t.getValue();
      if (Number.isNaN(l))
        return g.create(m.VALUE);
      c *= 1 + l;
    }
    return y.create(c);
  }
}
class i0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y.create(0), { isError: u, errorObject: c, variants: l } = H(e, t, r, n, o);
    if (u)
      return c;
    const [f, h, d, _, C] = l, E = $(f);
    if (typeof E != "number")
      return E;
    const b = $(h);
    if (typeof b != "number")
      return b;
    const R = +d.getValue(), p = +_.getValue(), N = Math.floor(+C.getValue());
    if (Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N))
      return g.create(m.VALUE);
    if (R <= 0 || p <= 0 || N < 0 || N > 4 || Math.floor(E) >= Math.floor(b))
      return g.create(m.NUM);
    const { days: M, yearDays: w } = _e(E, b, N), S = (p - R) / R * (w / M);
    return y.create(S);
  }
}
class o0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s, o) {
    const u = s != null ? s : y.create(0), c = o != null ? o : y.create(0), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, e, g.create(m.NA)), d = O(l, f, t, g.create(m.NA)), _ = O(l, f, r, g.create(m.NA)), C = O(l, f, n, g.create(m.NA)), E = O(l, f, u, g.create(m.NA)), b = O(l, f, c, g.create(m.NA)), R = h.map((p, N, M) => {
      const w = d.get(N, M), S = _.get(N, M), D = C.get(N, M), L = E.get(N, M), U = b.get(N, M), { isError: x, errorObject: k, variants: Q } = B(p, w, S, D, L, U);
      if (x)
        return k;
      const [ne, z, G, ge, de, Ee] = Q, pe = +ne.getValue(), me = +z.getValue(), ve = +G.getValue(), ht = +ge.getValue(), Dt = +de.getValue(), Lt = +Ee.getValue();
      if (me < 1 || Math.floor(me) > Math.ceil(ve))
        return g.create(m.NUM);
      const ot = xu(pe, me, ve, ht, Dt, Lt ? 1 : 0);
      return Number.isNaN(ot) || !Number.isFinite(ot) ? g.create(m.NUM) : N === 0 && M === 0 ? y.create(ot, ze(this.getLocale())) : y.create(ot);
    });
    return l === 1 && f === 1 ? R.get(0, 0) : R;
  }
}
class u0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = t != null ? t : y.create(0.1);
    return r.isNull() && (r = y.create(0.1)), r.isArray() ? r.map((n, s, o) => this._handleSingleObject(e, n, s, o)) : this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t, r = 0, n = 0) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (e.isNull())
      return g.create(m.VALUE);
    if (!e.isArray())
      return g.create(m.NUM);
    const { _values: s, valuesHasError: o } = this._getValues(e);
    if (o)
      return g.create(m.VALUE);
    let u = t;
    if (u.isString() && (u = u.convertToNumberObjectValue(), u.isError()))
      return u;
    const c = +u.getValue(), { positive: l, negative: f } = this._checkValues(s);
    if (!l || !f)
      return g.create(m.NUM);
    const h = Qa(c, (d) => ju(d, s));
    return typeof h != "number" ? h : r === 0 && n === 0 ? y.create(h, "0%") : y.create(h);
  }
  _getValues(e) {
    const t = [];
    let r = !1;
    return e.iterator((n) => {
      const s = n;
      if (s.isError())
        return r = !0, !1;
      if (s.isNull() || s.isBoolean())
        return !0;
      const o = +s.getValue();
      if (Number.isNaN(o))
        return !0;
      t.push(o);
    }), {
      _values: t,
      valuesHasError: r
    };
  }
  _checkValues(e) {
    let t = !1, r = !1;
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (t = !0), e[n] < 0 && (r = !0);
    return {
      positive: t,
      negative: r
    };
  }
}
class c0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.map((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C), { isError: p, errorObject: N, variants: M } = B(d, E, b, R);
      if (p)
        return N;
      const [w, S, D, L] = M, U = +w.getValue(), x = +S.getValue(), k = +D.getValue(), Q = +L.getValue();
      if (k === 0)
        return g.create(m.DIV_BY_ZERO);
      const ne = Q * U * (x / k - 1);
      return y.create(ne);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
}
class l0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = ke(e, t, r, n, s, u);
    if (c)
      return l;
    const [h, d, _, C, E, b] = f, R = $(h);
    if (typeof R != "number")
      return R;
    const p = $(d);
    if (typeof p != "number")
      return p;
    const N = +_.getValue(), M = +C.getValue(), w = Math.floor(+E.getValue()), S = Math.floor(+b.getValue());
    if (Number.isNaN(N) || Number.isNaN(M) || Number.isNaN(w) || Number.isNaN(S))
      return g.create(m.VALUE);
    if (N < 0 || M < 0 || ![1, 2, 4].includes(w) || S < 0 || S > 4 || Math.floor(R) >= Math.floor(p))
      return g.create(m.NUM);
    let D = Pu(R, p, N, M, w, S);
    return D /= 1 + M / w, y.create(D);
  }
}
class f0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { _values: n, numberValues: s, positive: o, negative: u } = this._getValues(e), c = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), l = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), f = O(c, l, t, g.create(m.NA)), h = O(c, l, r, g.create(m.NA)), d = f.map((_, C, E) => {
      const b = h.get(C, E);
      if (e.isError())
        return e;
      if (b.isError())
        return b;
      if (n.isError())
        return n;
      if (!o || !u)
        return g.create(m.DIV_BY_ZERO);
      const R = +_.getValue(), p = +b.getValue();
      if (Number.isNaN(R) || Number.isNaN(p))
        return g.create(m.VALUE);
      if (p === -1)
        return g.create(m.DIV_BY_ZERO);
      const N = this._getResult(s, R, p);
      return C === 0 && E === 0 ? y.create(N, "0%") : y.create(N);
    });
    return c === 1 && l === 1 ? d.get(0, 0) : d;
  }
  _getValues(e) {
    let t = e, r = [], n = !1, s = !1;
    if (!e.isError())
      if (e.isNull())
        t = g.create(m.VALUE);
      else if (!e.isArray())
        t = g.create(m.DIV_BY_ZERO);
      else {
        const { numberValues: o, valuesHasError: u, errorObject: c, positive: l, negative: f } = this._checkValues(e);
        u && (t = c), r = o, n = l, s = f;
      }
    return {
      _values: t,
      numberValues: r,
      positive: n,
      negative: s
    };
  }
  _checkValues(e) {
    const t = [];
    let r = !1, n = g.create(m.VALUE), s = !1, o = !1;
    return e.iterator((u) => {
      const c = u;
      if (c.isError())
        return r = !0, n = c, !1;
      if (c.isNull() || c.isBoolean())
        return !0;
      const l = +c.getValue();
      if (Number.isNaN(l))
        return !0;
      l > 0 && (s = !0), l < 0 && (o = !0), t.push(l);
    }), {
      numberValues: t,
      valuesHasError: r,
      errorObject: n,
      positive: s,
      negative: o
    };
  }
  _getResult(e, t, r) {
    const n = e.length, s = [], o = [];
    for (let d = 0; d < n; d++)
      e[d] > 0 ? o.push(e[d]) : e[d] < 0 && s.push(e[d]);
    const u = this._npv(r, e, "positive"), c = this._npv(t, e, "negative"), l = -u * (1 + r) ** n, f = c * (1 + t);
    return (l / f) ** (1 / (n - 1)) - 1;
  }
  _npv(e, t, r) {
    let n = 0;
    for (let s = 1; s <= t.length; s++) {
      const o = t[s - 1];
      (r === "positive" && o > 0 || r === "negative" && o < 0) && (n += o / (1 + e) ** s);
    }
    return n;
  }
}
class h0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (c <= 0 || l < 1)
      return g.create(m.NUM);
    l = Number.parseInt(`${l}`, 10);
    const f = ((c + 1) ** (1 / l) - 1) * l;
    return y.create(f);
  }
}
class m0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(m.NA)), h = O(c, l, t, g.create(m.NA)), d = O(c, l, r, g.create(m.NA)), _ = O(c, l, o, g.create(m.NA)), C = O(c, l, u, g.create(m.NA)), E = f.map((b, R, p) => {
      const N = h.get(R, p), M = d.get(R, p), w = _.get(R, p), S = C.get(R, p), { isError: D, errorObject: L, variants: U } = B(b, N, M, w, S);
      if (D)
        return L;
      const [x, k, Q, ne, z] = U, G = +x.getValue(), ge = +k.getValue(), de = +Q.getValue(), Ee = +ne.getValue();
      let pe = +z.getValue();
      if (pe = pe ? 1 : 0, G === 0 && ge === 0)
        return g.create(m.DIV_BY_ZERO);
      let me;
      if (G === 0)
        me = -(de + Ee) / ge;
      else {
        const ve = ge * (1 + G * pe) - Ee * G, ht = de * G + ge * (1 + G * pe);
        me = Math.log(ve / ht) / Math.log(1 + G);
      }
      return Number.isNaN(me) || !Number.isFinite(me) ? g.create(m.NUM) : y.create(me);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class g0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsLocale", !0);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const { isError: r, errorObject: n, values: s } = this._getValues(t);
    return e.isArray() ? e.map((o, u, c) => this._handleSingleObject(o, r, n, s, u, c)) : this._handleSingleObject(e, r, n, s);
  }
  _handleSingleObject(e, t, r, n, s = 0, o = 0) {
    let u = e;
    if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
      return u;
    if (t)
      return r;
    const c = +e.getValue(), l = ju(c, n);
    return Number.isNaN(l) || Math.abs(l) === 1 / 0 ? g.create(m.DIV_BY_ZERO) : s === 0 && o === 0 ? y.create(l, ze(this.getLocale())) : y.create(l);
  }
  _getValues(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isError())
        return {
          isError: !0,
          errorObject: n
        };
      if (n.isArray()) {
        let s = !1, o = g.create(m.VALUE);
        if (n.iterator((u) => {
          const c = u;
          if (c.isError())
            return s = !0, o = c, !1;
          if (c.isNull() || c.isBoolean())
            return !0;
          const l = +c.getValue();
          if (Number.isNaN(l))
            return !0;
          t.push(l);
        }), s)
          return {
            isError: s,
            errorObject: o
          };
      } else {
        const s = +n.getValue();
        if (Number.isNaN(s))
          return {
            isError: !0,
            errorObject: g.create(m.VALUE)
          };
        t.push(s);
      }
    }
    return {
      isError: !1,
      values: t
    };
  }
}
class d0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c, l) {
    let f = l != null ? l : y.create(0);
    f.isNull() && (f = y.create(0));
    const { isError: h, errorObject: d, variants: _ } = ke(e, t, r, n, s, o, u, c, f);
    if (h)
      return d;
    const [C, E, b, R, p, N, M, w, S] = _, D = $(C);
    if (typeof D != "number")
      return D;
    const L = $(E);
    if (typeof L != "number")
      return L;
    const U = $(b);
    if (typeof U != "number")
      return U;
    const x = $(R);
    if (typeof x != "number")
      return x;
    const k = +p.getValue(), Q = +N.getValue(), ne = +M.getValue(), z = Math.floor(+w.getValue()), G = Math.floor(+S.getValue());
    if (Number.isNaN(k) || Number.isNaN(Q) || Number.isNaN(ne) || Number.isNaN(z) || Number.isNaN(G))
      return g.create(m.VALUE);
    if (k < 0 || Q < 0 || ne <= 0 || ![1, 2, 4].includes(z) || G < 0 || G > 4 || !this._validDate(L, x, D, U, z))
      return g.create(m.NUM);
    const ge = Uu(D, L, U, x, k, Q, ne, z, G);
    return y.create(ge);
  }
  _validDate(e, t, r, n, s) {
    return this._getDateCorrectOrder(e, t, r, n) && vu(e, t, s) && Mr(n, e, s);
  }
  _getDateCorrectOrder(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Math.floor(r) > Math.floor(n);
  }
}
class C0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c, l) {
    let f = l != null ? l : y.create(0);
    f.isNull() && (f = y.create(0));
    const { isError: h, errorObject: d, variants: _ } = ke(e, t, r, n, s, o, u, c, f);
    if (h)
      return d;
    const [C, E, b, R, p, N, M, w, S] = _, D = $(C);
    if (typeof D != "number")
      return D;
    const L = $(E);
    if (typeof L != "number")
      return L;
    const U = $(b);
    if (typeof U != "number")
      return U;
    const x = $(R);
    if (typeof x != "number")
      return x;
    const k = +p.getValue(), Q = +N.getValue(), ne = +M.getValue(), z = Math.floor(+w.getValue()), G = Math.floor(+S.getValue());
    return Number.isNaN(k) || Number.isNaN(Q) || Number.isNaN(ne) || Number.isNaN(z) || Number.isNaN(G) ? g.create(m.VALUE) : k < 0 || Q <= 0 || ne <= 0 || ![1, 2, 4].includes(z) || G < 0 || G > 4 || !this._validDate(L, x, D, U, z) ? g.create(m.NUM) : this._getResult(D, L, U, x, k, Q, ne, z, G);
  }
  _validDate(e, t, r, n, s) {
    return this._getDateCorrectOrder(e, t, r, n) && vu(e, t, s) && Mr(n, e, s);
  }
  _getDateCorrectOrder(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Math.floor(r) > Math.floor(n);
  }
  _getResult(e, t, r, n, s, o, u, c, l) {
    const { days: f } = _e(e, t, l), h = (s * f * 100 - (o - 100)) / ((o - 100) * 0.25 * (1 + 2 * f) + f * 100);
    function d(C) {
      return o - Uu(e, t, r, n, s, C, u, c, l);
    }
    const _ = Qa(h, (C) => d(C));
    return typeof _ != "number" ? _ : y.create(_);
  }
}
class _0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 7);
    A(this, "maxParams", 8);
  }
  calculate(e, t, r, n, s, o, u, c) {
    let l = c != null ? c : y.create(0);
    l.isNull() && (l = y.create(0));
    const { isError: f, errorObject: h, variants: d } = ke(e, t, r, n, s, o, u, l);
    if (f)
      return h;
    const [_, C, E, b, R, p, N, M] = d, w = $(_);
    if (typeof w != "number")
      return w;
    const S = $(C);
    if (typeof S != "number")
      return S;
    const D = $(E);
    if (typeof D != "number")
      return D;
    const L = +b.getValue(), U = +R.getValue(), x = +p.getValue(), k = Math.floor(+N.getValue()), Q = Math.floor(+M.getValue());
    if (Number.isNaN(L) || Number.isNaN(U) || Number.isNaN(x) || Number.isNaN(k) || Number.isNaN(Q))
      return g.create(m.VALUE);
    if (L < 0 || U < 0 || x <= 0 || ![1, 2, 4].includes(k) || Q < 0 || Q > 4 || !this._validDate(S, w, D, k))
      return g.create(m.NUM);
    const ne = this._getResult(w, S, D, L, U, x, k, Q);
    return y.create(ne);
  }
  _validDate(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Mr(r, e, n);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    const l = this._getCoupDate(t, r, u), f = this._getFrac(r, e, l, u, c), h = this._getFrac(r, t, l, u, c), d = this._getFrac(e, t, l, u, c);
    return (o * u + 100 * n * (h - f * (1 + s * d / u))) / (s * d + u);
  }
  _getCoupDate(e, t, r) {
    const n = re(e), s = re(t);
    for (s.setUTCFullYear(n.getUTCFullYear()), s > n && s.setUTCFullYear(s.getUTCFullYear() - 1); s < n; )
      s.setUTCMonth(s.getUTCMonth() + 12 / r);
    return Re(s);
  }
  _getFrac(e, t, r, n, s) {
    const o = re(e), u = re(t), c = re(r);
    for (c.setUTCFullYear(o.getUTCFullYear()), c < o && c.setUTCFullYear(c.getUTCFullYear() + 1); c > o; )
      c.setUTCMonth(c.getUTCMonth() - 12 / n);
    let l = Re(c);
    c.setUTCMonth(c.getUTCMonth() + 12 / n);
    let f = Re(c);
    if (f >= t) {
      const { days: p } = _e(e, t, s), N = Xe(l, f, n, s);
      return p / N;
    }
    const { days: h } = _e(e, f, s), d = Xe(l, f, n, s);
    let _ = h / d;
    const C = re(f), E = re(f);
    for (E.setUTCMonth(E.getUTCMonth() + 12 / n); E < u; )
      C.setUTCMonth(C.getUTCMonth() + 12 / n), E.setUTCMonth(E.getUTCMonth() + 12 / n), _ += 1;
    l = Re(C), f = Re(E);
    const { days: b } = _e(l, t, s), R = Xe(l, f, n, s);
    return _ += b / R, _;
  }
}
class A0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c) {
    let l = c != null ? c : y.create(0);
    l.isNull() && (l = y.create(0));
    const { isError: f, errorObject: h, variants: d } = ke(e, t, r, n, s, o, u, l);
    if (f)
      return h;
    const [_, C, E, b, R, p, N, M] = d, w = $(_);
    if (typeof w != "number")
      return w;
    const S = $(C);
    if (typeof S != "number")
      return S;
    const D = $(E);
    if (typeof D != "number")
      return D;
    const L = +b.getValue(), U = +R.getValue(), x = +p.getValue(), k = Math.floor(+N.getValue()), Q = Math.floor(+M.getValue());
    if (Number.isNaN(L) || Number.isNaN(U) || Number.isNaN(x) || Number.isNaN(k) || Number.isNaN(Q))
      return g.create(m.VALUE);
    if (L < 0 || U <= 0 || x <= 0 || ![1, 2, 4].includes(k) || Q < 0 || Q > 4 || !this._validDate(S, w, D, k))
      return g.create(m.NUM);
    const ne = this._getResult(w, S, D, L, U, x, k, Q);
    return y.create(ne);
  }
  _validDate(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Mr(r, e, n);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    const l = this._getCoupDate(t, r, u), f = this._getFrac(r, e, l, u, c), h = this._getFrac(r, t, l, u, c), d = this._getFrac(e, t, l, u, c);
    return (u * (o - s) + 100 * n * (h - f)) / (d * s + 100 * n * f * d / u);
  }
  _getCoupDate(e, t, r) {
    const n = re(e), s = re(t);
    for (s.setUTCFullYear(n.getUTCFullYear()), s > n && s.setUTCFullYear(s.getUTCFullYear() - 1); s < n; )
      s.setUTCMonth(s.getUTCMonth() + 12 / r);
    return Re(s);
  }
  _getFrac(e, t, r, n, s) {
    const o = re(e), u = re(t), c = re(r);
    for (c.setUTCFullYear(o.getUTCFullYear()), c < o && c.setUTCFullYear(c.getUTCFullYear() + 1); c > o; )
      c.setUTCMonth(c.getUTCMonth() - 12 / n);
    let l = Re(c);
    c.setUTCMonth(c.getUTCMonth() + 12 / n);
    let f = Re(c);
    if (f >= t) {
      const { days: p } = _e(e, t, s), N = Xe(l, f, n, s);
      return p / N;
    }
    const { days: h } = _e(e, f, s), d = Xe(l, f, n, s);
    let _ = h / d;
    const C = re(f), E = re(f);
    for (E.setUTCMonth(E.getUTCMonth() + 12 / n); E < u; )
      C.setUTCMonth(C.getUTCMonth() + 12 / n), E.setUTCMonth(E.getUTCMonth() + 12 / n), _ += 1;
    l = Re(C), f = Re(E);
    const { days: b } = _e(l, t, s), R = Xe(l, f, n, s);
    return _ += b / R, _;
  }
}
class E0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.map((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d), { isError: E, errorObject: b, variants: R } = B(f, _, C);
      if (E)
        return b;
      const [p, N, M] = R, w = +p.getValue(), S = +N.getValue(), D = +M.getValue();
      if (w <= -1)
        return g.create(m.NUM);
      const L = (Math.log(D) - Math.log(S)) / Math.log(1 + w);
      return Number.isNaN(L) || !Number.isFinite(L) ? g.create(m.NUM) : y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class b0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(m.NA)), h = O(c, l, t, g.create(m.NA)), d = O(c, l, r, g.create(m.NA)), _ = O(c, l, o, g.create(m.NA)), C = O(c, l, u, g.create(m.NA)), E = f.map((b, R, p) => {
      const N = h.get(R, p), M = d.get(R, p), w = _.get(R, p), S = C.get(R, p), { isError: D, errorObject: L, variants: U } = B(b, N, M, w, S);
      if (D)
        return L;
      const [x, k, Q, ne, z] = U, G = +x.getValue(), ge = +k.getValue(), de = +Q.getValue(), Ee = +ne.getValue(), pe = +z.getValue();
      if (G <= -1)
        return g.create(m.NUM);
      const me = qr(G, ge, de, Ee, pe ? 1 : 0);
      return Number.isNaN(me) || !Number.isFinite(me) ? g.create(m.NUM) : R === 0 && p === 0 ? y.create(me, ze(this.getLocale())) : y.create(me);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class y0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s, o) {
    const u = s != null ? s : y.create(0), c = o != null ? o : y.create(0), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, e, g.create(m.NA)), d = O(l, f, t, g.create(m.NA)), _ = O(l, f, r, g.create(m.NA)), C = O(l, f, n, g.create(m.NA)), E = O(l, f, u, g.create(m.NA)), b = O(l, f, c, g.create(m.NA)), R = h.map((p, N, M) => {
      const w = d.get(N, M), S = _.get(N, M), D = C.get(N, M), L = E.get(N, M), U = b.get(N, M), { isError: x, errorObject: k, variants: Q } = B(p, w, S, D, L, U);
      if (x)
        return k;
      const [ne, z, G, ge, de, Ee] = Q, pe = +ne.getValue(), me = +z.getValue(), ve = +G.getValue(), ht = +ge.getValue(), Dt = +de.getValue(), Lt = +Ee.getValue();
      if (me < 1 || Math.floor(me) > Math.ceil(ve) || me - ve >= 1)
        return g.create(m.NUM);
      const ot = qr(pe, ve, ht, Dt, Lt ? 1 : 0) - xu(pe, me, ve, ht, Dt, Lt ? 1 : 0);
      return Number.isNaN(ot) || !Number.isFinite(ot) ? g.create(m.NUM) : N === 0 && M === 0 ? y.create(ot, ze(this.getLocale())) : y.create(ot);
    });
    return l === 1 && f === 1 ? R.get(0, 0) : R;
  }
}
class R0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = u != null ? u : y.create(0);
    c.isNull() && (c = y.create(0));
    const { isError: l, errorObject: f, variants: h } = ke(e, t, r, n, s, o, c);
    if (l)
      return f;
    const [d, _, C, E, b, R, p] = h, N = $(d);
    if (typeof N != "number")
      return N;
    const M = $(_);
    if (typeof M != "number")
      return M;
    const w = +C.getValue(), S = +E.getValue(), D = +b.getValue(), L = Math.floor(+R.getValue()), U = Math.floor(+p.getValue());
    if (Number.isNaN(w) || Number.isNaN(S) || Number.isNaN(D) || Number.isNaN(L) || Number.isNaN(U))
      return g.create(m.VALUE);
    if (w < 0 || S < 0 || D <= 0 || ![1, 2, 4].includes(L) || U < 0 || U > 4 || N >= M || !Mr(N, M, L))
      return g.create(m.NUM);
    const x = gn(N, M, w, S, D, L, U);
    return y.create(x);
  }
}
class p0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(0);
    o.isNull() && (o = y.create(0));
    const { isError: u, errorObject: c, variants: l } = ke(e, t, r, n, o);
    if (u)
      return c;
    const [f, h, d, _, C] = l, E = $(f);
    if (typeof E != "number")
      return E;
    const b = $(h);
    if (typeof b != "number")
      return b;
    const R = +d.getValue(), p = +_.getValue(), N = Math.floor(+C.getValue());
    if (Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N))
      return g.create(m.VALUE);
    if (R <= 0 || p <= 0 || N < 0 || N > 4 || E >= b)
      return g.create(m.NUM);
    const { days: M, yearDays: w } = _e(E, b, N), S = p - R * p * M / w;
    return y.create(S);
  }
}
class V0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = ke(e, t, r, n, s, u);
    if (c)
      return l;
    const [h, d, _, C, E, b] = f, R = $(h);
    if (typeof R != "number")
      return R;
    const p = $(d);
    if (typeof p != "number")
      return p;
    const N = $(_);
    if (typeof N != "number")
      return N;
    const M = +C.getValue(), w = +E.getValue(), S = Math.floor(+b.getValue());
    if (Number.isNaN(M) || Number.isNaN(w) || Number.isNaN(S))
      return g.create(m.VALUE);
    const D = this._getDateCorrectOrder(p, R, N);
    if (M < 0 || w < 0 || S < 0 || S > 4 || !D)
      return g.create(m.NUM);
    const L = Du(R, S), { days: U } = _e(R, p, S), { days: x } = _e(N, p, S), { days: k } = _e(N, R, S), Q = (100 + x / L * M * 100) / (1 + U / L * w) - k / L * M * 100;
    return y.create(Q);
  }
  _getDateCorrectOrder(e, t, r) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r);
  }
}
class N0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(m.NA)), h = O(c, l, t, g.create(m.NA)), d = O(c, l, r, g.create(m.NA)), _ = O(c, l, o, g.create(m.NA)), C = O(c, l, u, g.create(m.NA)), E = f.map((b, R, p) => {
      const N = h.get(R, p), M = d.get(R, p), w = _.get(R, p), S = C.get(R, p), { isError: D, errorObject: L, variants: U } = B(b, N, M, w, S);
      if (D)
        return L;
      const [x, k, Q, ne, z] = U, G = +x.getValue(), ge = +k.getValue(), de = +Q.getValue(), Ee = +ne.getValue();
      let pe = +z.getValue();
      pe = pe ? 1 : 0;
      const me = G === 0 ? -de * ge - Ee : ((1 - (1 + G) ** ge) / G * de * (1 + G * pe) - Ee) / (1 + G) ** ge;
      return Number.isNaN(me) || !Number.isFinite(me) ? g.create(m.NUM) : R === 0 && p === 0 ? y.create(me, ze(this.getLocale())) : y.create(me);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class O0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const u = n != null ? n : y.create(0), c = s != null ? s : y.create(0), l = o != null ? o : y.create(0.1), f = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), h = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d = O(f, h, e, g.create(m.NA)), _ = O(f, h, t, g.create(m.NA)), C = O(f, h, r, g.create(m.NA)), E = O(f, h, u, g.create(m.NA)), b = O(f, h, c, g.create(m.NA)), R = O(f, h, l, g.create(m.NA)), p = d.map((N, M, w) => {
      const S = _.get(M, w), D = C.get(M, w), L = E.get(M, w), U = b.get(M, w), x = R.get(M, w), { isError: k, errorObject: Q, variants: ne } = B(N, S, D, L, U, x);
      if (k)
        return Q;
      const [z, G, ge, de, Ee, pe] = ne, me = +z.getValue(), ve = +G.getValue(), ht = +ge.getValue(), Dt = +de.getValue();
      let Lt = +Ee.getValue();
      const ot = +pe.getValue();
      return Lt = Lt ? 1 : 0, me <= 0 || ve >= 0 && ht >= 0 && Dt >= 0 || ve <= 0 && ht <= 0 && Dt <= 0 ? g.create(m.NUM) : this._getResult(me, ve, ht, Dt, Lt, ot, M, w);
    });
    return f === 1 && h === 1 ? p.get(0, 0) : p;
  }
  _getResult(e, t, r, n, s, o, u, c) {
    let h = o;
    for (let d = 0; d < 20; d++) {
      if (h <= -1)
        return g.create(m.NUM);
      let _, C;
      if (Math.abs(h) < 1e-10 ? _ = r * (1 + e * h) + t * (1 + h * s) * e + n : (C = (1 + h) ** e, _ = r * C + t * (1 / h + s) * (C - 1) + n), Math.abs(_) < 1e-10)
        break;
      let E;
      if (Math.abs(h) < 1e-10)
        E = r * e + t * s * e;
      else {
        C = (1 + h) ** e;
        const b = e * (1 + h) ** (e - 1);
        E = r * b + t * (1 / h + s) * b + t * (-1 / (h * h)) * (C - 1);
      }
      h -= _ / E;
    }
    return u === 0 && c === 0 ? y.create(h, "0%") : y.create(h);
  }
}
class M0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(0);
    o.isNull() && (o = y.create(0));
    const { isError: u, errorObject: c, variants: l } = ke(e, t, r, n, o);
    if (u)
      return c;
    const [f, h, d, _, C] = l, E = $(f);
    if (typeof E != "number")
      return E;
    const b = $(h);
    if (typeof b != "number")
      return b;
    const R = +d.getValue(), p = +_.getValue(), N = Math.floor(+C.getValue());
    if (Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N))
      return g.create(m.VALUE);
    if (R <= 0 || p <= 0 || N < 0 || N > 4 || E >= b)
      return g.create(m.NUM);
    const { days: M, yearDays: w } = _e(E, b, N), S = R / (1 - p * M / w);
    return S < 0 ? g.create(m.NUM) : y.create(S);
  }
}
class w0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.map((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d), { isError: E, errorObject: b, variants: R } = B(f, _, C);
      if (E)
        return b;
      const [p, N, M] = R, w = +p.getValue(), S = +N.getValue(), D = +M.getValue();
      if (w <= 0)
        return g.create(m.NUM);
      if (S === 0 && D === 0)
        return y.create(0);
      const L = (D / S) ** (1 / w) - 1;
      return Number.isNaN(L) || !Number.isFinite(L) || D / S < 0 ? g.create(m.NUM) : y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class S0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.map((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const E = +f.getValue(), b = +_.getValue(), R = +C.getValue();
      if (Number.isNaN(E) || Number.isNaN(b) || Number.isNaN(R))
        return g.create(m.VALUE);
      if (R === 0)
        return g.create(m.DIV_BY_ZERO);
      const p = (E - b) / R;
      return h === 0 && d === 0 ? y.create(p, ze(this.getLocale())) : y.create(p);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class D0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.map((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      if (E.isError())
        return E;
      if (b.isError())
        return b;
      if (R.isError())
        return R;
      const p = +d.getValue(), N = +E.getValue(), M = +b.getValue(), w = +R.getValue();
      if (Number.isNaN(p) || Number.isNaN(N) || Number.isNaN(M) || Number.isNaN(w))
        return g.create(m.VALUE);
      if (N < 0 || M <= 0 || w > M)
        return g.create(m.NUM);
      const S = (p - N) * (M - w + 1) * 2 / (M * (M + 1));
      return _ === 0 && C === 0 ? y.create(S, ze(this.getLocale())) : y.create(S);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
}
class L0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = ke(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = $(u);
    if (typeof f != "number")
      return f;
    const h = $(c);
    if (typeof h != "number")
      return h;
    const d = +l.getValue();
    if (Number.isNaN(d))
      return g.create(m.VALUE);
    if (d <= 0 || f >= h)
      return g.create(m.NUM);
    const _ = Math.floor(h) - Math.floor(f), E = re(f).getUTCFullYear(), b = os(E);
    if (_ > b)
      return g.create(m.NUM);
    let R = 365 * d / (360 - d * _);
    if (_ > 182) {
      const p = 100 * (1 - d * _ / 360), N = _ / 365;
      if (R = (-N + Math.sqrt(N * N - (N * 2 - 1) * (1 - 100 / p))) / (N - 0.5), Number.isNaN(R))
        return g.create(m.NUM);
    }
    return R < 0 ? g.create(m.NUM) : y.create(R);
  }
}
class P0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = ke(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = $(u);
    if (typeof f != "number")
      return f;
    const h = $(c);
    if (typeof h != "number")
      return h;
    const d = +l.getValue();
    if (Number.isNaN(d))
      return g.create(m.VALUE);
    if (d <= 0 || f >= h)
      return g.create(m.NUM);
    const _ = Math.floor(h) - Math.floor(f), E = re(f).getUTCFullYear(), b = os(E);
    if (_ > b)
      return g.create(m.NUM);
    const R = 100 * (1 - d * _ / 360);
    return R < 0 ? g.create(m.NUM) : y.create(R, ze(this.getLocale()));
  }
}
class x0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = ke(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = $(u);
    if (typeof f != "number")
      return f;
    const h = $(c);
    if (typeof h != "number")
      return h;
    const d = +l.getValue();
    if (Number.isNaN(d))
      return g.create(m.VALUE);
    if (d <= 0 || f >= h)
      return g.create(m.NUM);
    const _ = Math.floor(h) - Math.floor(f), E = re(f).getUTCFullYear(), b = os(E);
    if (_ > b)
      return g.create(m.NUM);
    const R = (100 - d) / d * 360 / _;
    return y.create(R);
  }
}
class j0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 7);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = o != null ? o : y.create(2);
    c.isNull() && (c = y.create(2));
    let l = u != null ? u : T.create(!1);
    l.isNull() && (l = T.create(!1));
    const f = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), h = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d = O(f, h, e, g.create(m.NA)), _ = O(f, h, t, g.create(m.NA)), C = O(f, h, r, g.create(m.NA)), E = O(f, h, n, g.create(m.NA)), b = O(f, h, s, g.create(m.NA)), R = O(f, h, c, g.create(m.NA)), p = O(f, h, l, g.create(m.NA));
    return this._getResultArray(
      d,
      _,
      C,
      E,
      b,
      R,
      p,
      f,
      h
    );
  }
  _getResultArray(e, t, r, n, s, o, u, c, l) {
    const f = e.map((h, d, _) => {
      const C = t.get(d, _), E = r.get(d, _), b = n.get(d, _), R = s.get(d, _), p = o.get(d, _), N = u.get(d, _), { isError: M, errorObject: w, variants: S } = B(h, C, E, b, R, p, N);
      if (M)
        return w;
      const [D, L, U, x, k, Q, ne] = S, z = +D.getValue(), G = +L.getValue(), ge = +U.getValue(), de = +x.getValue(), Ee = +k.getValue(), pe = +Q.getValue(), me = +ne.getValue();
      if (z < 0 || G < 0 || ge < 0 || de < 0 || Ee < 0 || Ee > ge || de > Ee || pe < 0)
        return g.create(m.NUM);
      if (ge === 0 && de === 0 && Ee === 0)
        return g.create(m.DIV_BY_ZERO);
      const ve = this._getResult(z, G, ge, de, Ee, pe, me);
      return d === 0 && _ === 0 ? y.create(ve, ze(this.getLocale())) : y.create(ve);
    });
    return c === 1 && l === 1 ? f.get(0, 0) : f;
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = Math.floor(n), l = Math.ceil(s);
    let f = 0;
    if (e < t) {
      if (n >= 1 || u)
        return f;
      const h = Math.abs(e - t);
      return f = h * (s - n) > h ? h : h * (s - n), -f;
    }
    if (u)
      for (let h = c + 1; h <= l; h++) {
        let d = na(e, t, r, h, o);
        h === c + 1 ? d *= Math.min(s, c + 1) - n : h === l && (d *= s + 1 - l), f += d;
      }
    else {
      const h = e - this._getVdb(e, t, r, r, n, o);
      f = this._getVdb(h, t, r, r - n, s - n, o);
    }
    return f;
  }
  _getVdb(e, t, r, n, s, o) {
    const u = Math.ceil(s);
    let c = 0, l = e - t, f = 0, h = 0, d = !1;
    for (let _ = 1; _ <= u; _++) {
      if (d)
        h = f;
      else {
        const C = na(e, t, r, _, o);
        f = l / (n - (_ - 1)), f > C ? (h = f, d = !0) : (h = C, l -= C);
      }
      _ === u && (h *= s + 1 - u), c += h;
    }
    return c;
  }
}
class U0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isNull() || t.isNull())
      return g.create(m.NA);
    const { isError: n, errorObejct: s, _values: o, _dates: u } = this._checkErrors(e, t);
    if (n)
      return s;
    let c = r != null ? r : y.create(0.1);
    c.isNull() && (c = y.create(0.1));
    const { isError: l, errorObject: f, variants: h } = H(c);
    if (l)
      return f;
    const [d] = h, _ = +d.getValue();
    if (Number.isNaN(_))
      return g.create(m.VALUE);
    const { positive: C, negative: E } = this._checkValues(o);
    if (!C || !E || (o == null ? void 0 : o.length) !== (u == null ? void 0 : u.length) || _ < 0)
      return g.create(m.NUM);
    const b = Qa(_, (R) => this._iterF(o, u, R));
    return typeof b != "number" ? b : y.create(b);
  }
  _checkErrors(e, t) {
    if (e.isError())
      return {
        isError: !0,
        errorObejct: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObejct: t
      };
    const { isError: r, errorObejct: n, _values: s } = this._checkErrorValues(e);
    if (r)
      return {
        isError: r,
        errorObejct: n
      };
    const { isError: o, errorObejct: u, _dates: c } = this._checkErrorDates(t);
    return o ? {
      isError: o,
      errorObejct: u
    } : {
      isError: !1,
      _values: s,
      _dates: c
    };
  }
  _checkErrorValues(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(m.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        if (o.isBoolean())
          return r = !0, n = g.create(m.VALUE), !1;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = !0, n = g.create(m.VALUE), !1;
        t.push(u);
      }), r ? {
        isError: r,
        errorObejct: n
      } : t.length <= 1 ? {
        isError: !0,
        errorObejct: g.create(m.NA)
      } : {
        isError: r,
        _values: t
      };
    } else {
      const r = e.getValue();
      return e.isBoolean() || e.isString() && !W(r) ? {
        isError: !0,
        errorObejct: g.create(m.VALUE)
      } : {
        isError: !0,
        errorObejct: g.create(m.NA)
      };
    }
  }
  _checkErrorDates(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(m.VALUE);
      return e.iterator((s) => {
        if (s != null && s.isError())
          return r = !0, n = s, !1;
        if (s != null && s.isBoolean())
          return r = !0, n = g.create(m.VALUE), !1;
        const o = +s.getValue();
        if (Number.isNaN(o))
          return r = !0, n = g.create(m.VALUE), !1;
        if (o < 0)
          return r = !0, n = g.create(m.NUM), !1;
        t.push(Math.floor(o));
      }), r ? {
        isError: r,
        errorObejct: n
      } : t.length <= 1 ? {
        isError: !0,
        errorObejct: g.create(m.NA)
      } : {
        isError: r,
        _dates: t
      };
    } else {
      const r = e.getValue();
      return e.isBoolean() || e.isString() && !W(r) ? {
        isError: !0,
        errorObejct: g.create(m.VALUE)
      } : +r < 0 ? {
        isError: !0,
        errorObejct: g.create(m.NUM)
      } : {
        isError: !0,
        errorObejct: g.create(m.NA)
      };
    }
  }
  _checkValues(e) {
    let t = !1, r = !1;
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (t = !0), e[n] < 0 && (r = !0);
    return {
      positive: t,
      negative: r
    };
  }
  _iterF(e, t, r) {
    return e.reduce((n, s, o) => n + s / (1 + r) ** ((t[o] - t[0]) / 365), 0);
  }
}
class v0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isNull() || t.isNull() || r.isNull())
      return g.create(m.NA);
    const { isError: n, errorObject: s, variants: o } = H(e);
    if (n)
      return s;
    const [u] = o, c = +u.getValue();
    if (Number.isNaN(c))
      return g.create(m.VALUE);
    let { isError: l, errorObejct: f, _values: h, _dates: d } = this._checkErrors(t, r);
    if (l)
      return f;
    if (h = h, d = d, c < 0 || h.length !== d.length)
      return g.create(m.NUM);
    let _ = 0;
    const C = d[0];
    for (let E = 0; E < d.length; E++) {
      const b = d[E], R = h[E];
      _ += R / (1 + c) ** ((b - C) / 365);
    }
    return y.create(_);
  }
  _checkErrors(e, t) {
    if (e.isError())
      return {
        isError: !0,
        errorObejct: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObejct: t
      };
    const { isError: r, errorObejct: n, _values: s } = this._checkErrorValues(e);
    if (r)
      return {
        isError: r,
        errorObejct: n
      };
    const { isError: o, errorObejct: u, _dates: c } = this._checkErrorDates(t);
    return o ? {
      isError: o,
      errorObejct: u
    } : {
      isError: !1,
      _values: s,
      _dates: c
    };
  }
  _checkErrorValues(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(m.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        if (o.isNull() || o.isBoolean())
          return r = !0, n = g.create(m.VALUE), !1;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = !0, n = g.create(m.VALUE), !1;
        t.push(u);
      }), r ? {
        isError: r,
        errorObejct: n
      } : {
        isError: r,
        _values: t
      };
    } else {
      if (e.isError())
        return {
          isError: !0,
          errorObejct: e
        };
      if (e.isNull() || e.isBoolean())
        return {
          isError: !0,
          errorObejct: g.create(m.VALUE)
        };
      const r = +e.getValue();
      return Number.isNaN(r) ? {
        isError: !0,
        errorObejct: g.create(m.VALUE)
      } : {
        isError: !1,
        _values: [r]
      };
    }
  }
  _checkErrorDates(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(m.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        if (o.isNull() || o.isBoolean())
          return r = !0, n = g.create(m.VALUE), !1;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = !0, n = g.create(m.VALUE), !1;
        if (u < 0)
          return r = !0, n = g.create(m.NUM), !1;
        t.push(Math.floor(u));
      }), r ? {
        isError: r,
        errorObejct: n
      } : {
        isError: r,
        _dates: t
      };
    } else {
      if (e.isError())
        return {
          isError: !0,
          errorObejct: e
        };
      if (e.isNull() || e.isBoolean())
        return {
          isError: !0,
          errorObejct: g.create(m.VALUE)
        };
      const r = +e.getValue();
      return Number.isNaN(r) ? {
        isError: !0,
        errorObejct: g.create(m.VALUE)
      } : +r < 0 ? {
        isError: !0,
        errorObejct: g.create(m.NUM)
      } : {
        isError: !1,
        _dates: [Math.floor(r)]
      };
    }
  }
}
class T0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = u != null ? u : y.create(0);
    c.isNull() && (c = y.create(0));
    const { isError: l, errorObject: f, variants: h } = ke(e, t, r, n, s, o, c);
    if (l)
      return f;
    const [d, _, C, E, b, R, p] = h, N = $(d);
    if (typeof N != "number")
      return N;
    const M = $(_);
    if (typeof M != "number")
      return M;
    const w = +C.getValue(), S = +E.getValue(), D = +b.getValue(), L = Math.floor(+R.getValue()), U = Math.floor(+p.getValue());
    if (Number.isNaN(w) || Number.isNaN(S) || Number.isNaN(D) || Number.isNaN(L) || Number.isNaN(U))
      return g.create(m.VALUE);
    if (w < 0 || S <= 0 || D <= 0 || ![1, 2, 4].includes(L) || U < 0 || U > 4 || N >= M || !Mr(N, M, L))
      return g.create(m.NUM);
    const x = this._getResult(N, M, w, S, D, L, U);
    return y.create(x);
  }
  _getResult(e, t, r, n, s, o, u) {
    if (sr(e, t, o) > 1) {
      let E = r || 0.01, b = gn(e, t, r, E, s, o, u), R = b - n;
      for (let p = 0; p < 100 && Math.abs(R) > 1e-7; p++)
        b = gn(e, t, r, 1.01 * E, s, o, u), E += -R / (b - n - R) * E * 0.01, R = gn(e, t, r, E, s, o, u) - n;
      return E;
    }
    const l = us(e, t, o, u), f = Xe(e, t, o, u), { days: h } = _e(e, t, u), d = n / 100 + l / f * r / o;
    return (s / 100 + r / o - d) / d * o * f / h;
  }
}
class B0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(0);
    o.isNull() && (o = y.create(0));
    const { isError: u, errorObject: c, variants: l } = ke(e, t, r, n, o);
    if (u)
      return c;
    const [f, h, d, _, C] = l, E = $(f);
    if (typeof E != "number")
      return E;
    const b = $(h);
    if (typeof b != "number")
      return b;
    const R = +d.getValue(), p = +_.getValue(), N = Math.floor(+C.getValue());
    if (Number.isNaN(R) || Number.isNaN(p) || Number.isNaN(N))
      return g.create(m.VALUE);
    if (R <= 0 || p <= 0 || N < 0 || N > 4 || E >= b)
      return g.create(m.NUM);
    const { days: M, yearDays: w } = _e(E, b, N), S = (p / R - 1) / (M / w);
    return y.create(S);
  }
}
class I0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = ke(e, t, r, n, s, u);
    if (c)
      return l;
    const [h, d, _, C, E, b] = f, R = $(h);
    if (typeof R != "number")
      return R;
    const p = $(d);
    if (typeof p != "number")
      return p;
    const N = $(_);
    if (typeof N != "number")
      return N;
    const M = +C.getValue(), w = +E.getValue(), S = Math.floor(+b.getValue());
    if (Number.isNaN(M) || Number.isNaN(w) || Number.isNaN(S))
      return g.create(m.VALUE);
    const D = this._getDateCorrectOrder(p, R, N);
    if (M < 0 || w <= 0 || S < 0 || S > 4 || !D)
      return g.create(m.NUM);
    const L = Du(R, S), { days: U } = _e(R, p, S), { days: x } = _e(N, p, S), { days: k } = _e(N, R, S), Q = ((1 + x / L * M) / (w / 100 + k / L * M) - 1) / (U / L);
    return y.create(Q);
  }
  _getDateCorrectOrder(e, t, r) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r);
  }
}
const F0 = [
  [F1, ee.ACCRINT],
  [k1, ee.ACCRINTM],
  [$1, ee.AMORLINC],
  [Y1, ee.COUPDAYBS],
  [H1, ee.COUPDAYS],
  [G1, ee.COUPDAYSNC],
  [Q1, ee.COUPNCD],
  [W1, ee.COUPNUM],
  [q1, ee.COUPPCD],
  [K1, ee.CUMIPMT],
  [X1, ee.CUMPRINC],
  [Z1, ee.DB],
  [z1, ee.DDB],
  [J1, ee.DISC],
  [e0, ee.DOLLARDE],
  [t0, ee.DOLLARFR],
  [r0, ee.DURATION],
  [n0, ee.EFFECT],
  [s0, ee.FV],
  [a0, ee.FVSCHEDULE],
  [i0, ee.INTRATE],
  [o0, ee.IPMT],
  [u0, ee.IRR],
  [c0, ee.ISPMT],
  [l0, ee.MDURATION],
  [f0, ee.MIRR],
  [h0, ee.NOMINAL],
  [m0, ee.NPER],
  [g0, ee.NPV],
  [d0, ee.ODDFPRICE],
  [C0, ee.ODDFYIELD],
  [_0, ee.ODDLPRICE],
  [A0, ee.ODDLYIELD],
  [E0, ee.PDURATION],
  [b0, ee.PMT],
  [y0, ee.PPMT],
  [R0, ee.PRICE],
  [p0, ee.PRICEDISC],
  [V0, ee.PRICEMAT],
  [N0, ee.PV],
  [O0, ee.RATE],
  [M0, ee.RECEIVED],
  [w0, ee.RRI],
  [S0, ee.SLN],
  [D0, ee.SYD],
  [L0, ee.TBILLEQ],
  [P0, ee.TBILLPRICE],
  [x0, ee.TBILLYIELD],
  [j0, ee.VDB],
  [U0, ee.XIRR],
  [v0, ee.XNPV],
  [T0, ee.YIELD],
  [B0, ee.YIELDDISC],
  [I0, ee.YIELDMAT]
];
class k0 extends V {
  constructor() {
    super(...arguments);
    A(this, "needsReferenceObject", !0);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isError())
      return r;
    if (r.isReferenceObject() && (r = r.toArrayValueObject()), r.isArray()) {
      const n = r.getRowCount(), s = r.getColumnCount();
      if (n === 1 && s === 1) {
        const o = r.get(0, 0);
        return this._handleSingleObject(o, t);
      }
      return r.map((o) => o.isError() ? o : this._handleSingleObject(o, t, !0));
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t, r = !1) {
    let n = t;
    if (n.isError())
      return n;
    if (!n.isReferenceObject())
      return g.create(m.NA);
    const s = n.getCurrentActiveSheetData(), { columnData: o, defaultColumnWidth: u } = s;
    n = n.toArrayValueObject();
    const c = n.getCurrentRow(), l = n.getCurrentColumn();
    n = n.getFirstCell();
    const f = `${e.getValue()}`;
    let h;
    switch (f.toLocaleLowerCase()) {
      case "address":
        return j.create(`$${qe.chatAtABC(l)}$${c + 1}`);
      case "col":
        return y.create(l + 1);
      case "color":
        return y.create(0);
      case "contents":
        return n;
      case "filename":
        return g.create(m.VALUE);
      case "format":
        return j.create("G");
      case "parentheses":
        return y.create(0);
      case "prefix":
        return j.create("");
      case "protect":
        return y.create(1);
      case "row":
        return y.create(c + 1);
      case "type":
        return h = "v", n.isNull() && (h = "b"), n.isString() && (h = "l"), j.create(h);
      case "width":
        return this._getWidthResult(o, u, l, r);
      default:
        return g.create(m.VALUE);
    }
  }
  _getWidthResult(e, t, r, n) {
    var u;
    let s = (u = e[r]) == null ? void 0 : u.w;
    if (!s && s !== 0 && (s = t), n)
      return y.create(s);
    const o = [[s, s === t]];
    return q.createByArray(o);
  }
}
class $0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "_errorTypeValueMap", /* @__PURE__ */ new Map([
      [m.NULL, 1],
      [m.DIV_BY_ZERO, 2],
      [m.VALUE, 3],
      [m.REF, 4],
      [m.NAME, 5],
      [m.NUM, 6],
      [m.NA, 7],
      [m.CONNECT, 8],
      [m.CALC, 14]
    ]));
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = e.getValue(), r = this._errorTypeValueMap.get(t);
    return r ? y.create(r) : g.create(m.NA);
  }
}
var Oe = /* @__PURE__ */ ((i) => (i.CELL = "CELL", i.ERROR_TYPE = "ERROR.TYPE", i.INFO = "INFO", i.ISBETWEEN = "ISBETWEEN", i.ISBLANK = "ISBLANK", i.ISDATE = "ISDATE", i.ISEMAIL = "ISEMAIL", i.ISERR = "ISERR", i.ISERROR = "ISERROR", i.ISEVEN = "ISEVEN", i.ISFORMULA = "ISFORMULA", i.ISLOGICAL = "ISLOGICAL", i.ISNA = "ISNA", i.ISNONTEXT = "ISNONTEXT", i.ISNUMBER = "ISNUMBER", i.ISODD = "ISODD", i.ISOMITTED = "ISOMITTED", i.ISREF = "ISREF", i.ISTEXT = "ISTEXT", i.ISURL = "ISURL", i.N = "N", i.NA = "NA", i.SHEET = "SHEET", i.SHEETS = "SHEETS", i.TYPE = "TYPE", i))(Oe || {});
class Y0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : T.create(!0), u = s != null ? s : T.create(!0), { isError: c, errorObject: l, variants: f } = Yr(e, t, r, o, u);
    if (c)
      return l;
    const [h, d, _, C, E] = f;
    if (C.isString() || E.isString())
      return g.create(m.VALUE);
    if (d.compare(_, ">").getValue() === !0)
      return g.create(m.NUM);
    const R = +C.getValue(), p = +E.getValue(), N = R ? ">=" : ">", M = p ? "<=" : "<";
    return h.compare(d, N).getValue() === !1 || h.compare(_, M).getValue() === !1 ? T.create(!1) : T.create(!0);
  }
}
class H0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isNull() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isNull() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class G0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    return t.isError() ? t : t.isNumber() && t.getPattern() !== "" ? T.create(Ga(t.getPattern())) : t.isString() && (xn(`${t.getValue()}`) || jn(`${t.getValue()}`)) ? T.create(!0) : T.create(!1);
  }
}
class Q0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const o = t.getRowCount(), u = t.getColumnCount();
      if (o > 1 || u > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isNull() || t.isBoolean() || t.isNumber())
      return T.create(!1);
    const r = `${t.getValue()}`;
    if (r.length > 254)
      return T.create(!1);
    const n = qe.topLevelDomainCombiningString(), s = new RegExp(
      `^(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})$`,
      "i"
    );
    return T.create(s.test(r));
  }
}
class W0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.getValue() === m.NA ? T.create(!1) : e.isError() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.getValue() === m.NA ? T.create(!1) : t.isError() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class q0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isError() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class K0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isBoolean())
      return g.create(m.VALUE);
    const r = Math.trunc(+t.getValue());
    if (Number.isNaN(r))
      return g.create(m.VALUE);
    const n = r % 2 === 0;
    return T.create(n);
  }
}
class X0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    var u;
    if (e.isError())
      return e;
    if (!e.isReferenceObject())
      return g.create(m.NA);
    const t = (u = e.getCurrentActiveSheetData()) == null ? void 0 : u.cellData.getMatrix(), { startRow: r, startColumn: n } = e.getRangePosition(), s = e.toArrayValueObject(), o = s.mapValue((c, l, f) => {
      var d;
      const h = (d = t == null ? void 0 : t[r + l]) == null ? void 0 : d[n + f];
      return h != null && h.f || h != null && h.si ? T.create(!0) : T.create(!1);
    });
    return s.getRowCount() === 1 && s.getColumnCount() === 1 ? o.get(0, 0) : o;
  }
}
class Z0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isBoolean() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isBoolean() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class z0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.getValue() === m.NA ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.getValue() === m.NA ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class J0 extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return !e.isArray() && !e.isString() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isString() ? T.create(!1) : T.create(!0)) : T.create(!1);
  }
}
class ed extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isNumber() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isNumber() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class td extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isBoolean())
      return g.create(m.VALUE);
    const r = Math.trunc(+t.getValue());
    if (Number.isNaN(r))
      return g.create(m.VALUE);
    const n = r % 2 !== 0;
    return T.create(n);
  }
}
class rd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    return e.isReferenceObject() ? T.create(!0) : T.create(!1);
  }
}
class nd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isString() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isString() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class sd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const o = t.getRowCount(), u = t.getColumnCount();
      if (o > 1 || u > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isNull() || t.isBoolean() || t.isNumber())
      return T.create(!1);
    const r = `${t.getValue()}`.replace(/^\s+|\s+$/g, "");
    if (r.length > 1e3)
      return T.create(!1);
    const n = qe.topLevelDomainCombiningString(), s = new RegExp(
      `^(?:(?:https?|s?ftp|ftps|nfs|ssh)://+[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|mailto:(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})|(?:news|aim):[%a-z0-9$_\\.+!*(),;/?#:@&~=-]+)$`,
      "i"
    );
    return T.create(s.test(r));
  }
}
class ad extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (e.isArray() && (t = e.get(0, 0)), t.isError())
      return t;
    if (t.isString())
      return y.create(0);
    const r = +t.getValue();
    return y.create(r);
  }
}
class id extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return g.create(m.NA);
  }
}
class od extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
    A(this, "needsSheetsInfo", !0);
  }
  calculate(e) {
    var u;
    if (e != null && e.isError())
      return e;
    const { sheetOrder: t, sheetNameMap: r } = this.getSheetsInfo();
    if (!e) {
      const c = t.findIndex((l) => l === this.subUnitId);
      return y.create(c + 1);
    }
    if (e.isReferenceObject()) {
      const c = e.getForcedSheetId(), l = e.getDefaultSheetId(), f = t.findIndex((h) => c ? h === c : h === l);
      return y.create(f + 1);
    }
    if (e.isArray())
      return g.create(m.NA);
    const n = `${e.getValue()}`.toLocaleLowerCase(), s = (u = Object.entries(r).find(([c, l]) => l.toLocaleLowerCase() === n)) == null ? void 0 : u[0];
    if (!s)
      return g.create(m.NA);
    const o = t.findIndex((c) => c === s);
    return y.create(o + 1);
  }
}
class ud extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
    A(this, "needsSheetsInfo", !0);
  }
  calculate() {
    const { sheetOrder: e } = this.getSheetsInfo();
    return y.create(e.length);
  }
}
class cd extends V {
  constructor() {
    super(...arguments);
    A(this, "needsReferenceObject", !0);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isReferenceObject()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      if (t === 1 && r === 1) {
        const n = e.getFirstCell();
        if (n.isError())
          return y.create(16);
        if (n.isBoolean())
          return y.create(4);
        if (n.isString())
          return y.create(2);
        if (n.isNumber() || n.isNull())
          return y.create(1);
      } else
        return y.create(64);
    } else {
      if (e.isArray())
        return y.create(64);
      if (e.isError())
        return y.create(16);
      if (e.isBoolean())
        return y.create(4);
      if (e.isString())
        return y.create(2);
      if (e.isNumber() || e.isNull())
        return y.create(1);
    }
    return y.create(128);
  }
}
const ld = [
  [k0, Oe.CELL],
  [$0, Oe.ERROR_TYPE],
  [Y0, Oe.ISBETWEEN],
  [H0, Oe.ISBLANK],
  [G0, Oe.ISDATE],
  [Q0, Oe.ISEMAIL],
  [W0, Oe.ISERR],
  [q0, Oe.ISERROR],
  [K0, Oe.ISEVEN],
  [X0, Oe.ISFORMULA],
  [Z0, Oe.ISLOGICAL],
  [z0, Oe.ISNA],
  [J0, Oe.ISNONTEXT],
  [ed, Oe.ISNUMBER],
  [td, Oe.ISODD],
  [rd, Oe.ISREF],
  [nd, Oe.ISTEXT],
  [sd, Oe.ISURL],
  [ad, Oe.N],
  [id, Oe.NA],
  [od, Oe.SHEET],
  [ud, Oe.SHEETS],
  [cd, Oe.TYPE]
];
class fd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = !0, r = !0, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, !1;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (t = t && !!o.getValue(), r = !1);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (t = t && !!s.getValue(), r = !1);
    }
    return r ? g.create(m.VALUE) : T.create(t);
  }
}
class hd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  // eslint-disable-next-line
  calculate(e, t) {
    let r = e, n = null;
    if (e.isReferenceObject() && (r = e.toArrayValueObject(), n = e), r.isError())
      return r;
    if (t.isError())
      return t;
    if (!(t.isValueObject() && t.isLambda() && t.getLambdaPrivacyVarKeys().length === 1))
      return g.create(m.VALUE);
    const s = t, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    r = O(o, u, r);
    const c = [[]];
    for (let l = 0; l < u; l++) {
      const f = [];
      for (let _ = 0; _ < o; _++) {
        const C = r.get(_, l);
        f.push([C]);
      }
      let h = q.create({
        calculateValueList: f,
        rowCount: o,
        columnCount: 1,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (n) {
        const { startRow: _, startColumn: C } = n.getRangePosition(), E = {
          startRow: _,
          startColumn: C + l,
          endRow: _ + o - 1,
          endColumn: C + l
        };
        h = this.createReferenceObject(n, E);
      }
      let d = s.execute(h);
      if (d.isArray()) {
        const _ = d.getRowCount(), C = d.getColumnCount();
        if (_ > 1 || C > 1)
          return g.create(m.CALC);
        d = d.get(0, 0);
      }
      d.isNull() && (d = y.create(0)), c[0].push(d);
    }
    return u === 1 ? c[0][0] : q.create({
      calculateValueList: c,
      rowCount: 1,
      columnCount: u,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class md extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  // eslint-disable-next-line
  calculate(e, t) {
    let r = e, n = null;
    if (e.isReferenceObject() && (r = e.toArrayValueObject(), n = e), r.isError())
      return r;
    if (t.isError())
      return t;
    if (!(t.isValueObject() && t.isLambda() && t.getLambdaPrivacyVarKeys().length === 1))
      return g.create(m.VALUE);
    const s = t, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    r = O(o, u, r);
    const c = [];
    for (let l = 0; l < o; l++) {
      const f = [[]];
      for (let _ = 0; _ < u; _++) {
        const C = r.get(l, _);
        f[0].push(C);
      }
      let h = q.create({
        calculateValueList: f,
        rowCount: 1,
        columnCount: u,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (n) {
        const { startRow: _, startColumn: C } = n.getRangePosition(), E = {
          startRow: _ + l,
          startColumn: C,
          endRow: _ + l,
          endColumn: C + u - 1
        };
        h = this.createReferenceObject(n, E);
      }
      let d = s.execute(h);
      if (d.isArray()) {
        const _ = d.getRowCount(), C = d.getColumnCount();
        if (_ > 1 || C > 1)
          return g.create(m.CALC);
        d = d.get(0, 0);
      }
      d.isNull() && (d = y.create(0)), c.push([d]);
    }
    return o === 1 ? c[0][0] : q.create({
      calculateValueList: c,
      rowCount: o,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class gd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return T.create(!1);
  }
}
var De = /* @__PURE__ */ ((i) => (i.AND = "AND", i.BYCOL = "BYCOL", i.BYROW = "BYROW", i.FALSE = "FALSE", i.IF = "IF", i.IFERROR = "IFERROR", i.IFNA = "IFNA", i.IFS = "IFS", i.LAMBDA = "LAMBDA", i.LET = "LET", i.MAKEARRAY = "MAKEARRAY", i.MAP = "MAP", i.NOT = "NOT", i.OR = "OR", i.REDUCE = "REDUCE", i.SCAN = "SCAN", i.SWITCH = "SWITCH", i.TRUE = "TRUE", i.XOR = "XOR", i))(De || {});
class dd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r = T.create(!1)) {
    let n = e;
    if (e.isArray()) {
      const f = e.getRowCount(), h = e.getColumnCount();
      f === 1 && h === 1 && (n = e.get(0, 0));
    }
    if (!n.isArray())
      return this._handleSingleObject(n, t, r);
    const s = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, n, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA));
    return u.mapValue((f, h, d) => {
      const _ = c.get(h, d), C = l.get(h, d);
      return this._handleSingleObject(f, _, C);
    });
  }
  _handleSingleObject(e, t, r) {
    return e.isError() ? e : e.getValue() ? t.isNull() ? y.create(0) : t : r.isNull() ? y.create(0) : r;
  }
}
class Cd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (!e.isArray())
      return e.isError() ? t : e;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.iterator((u, c, l) => {
      u != null && u.isError() && s.set(c, l, o.get(c, l));
    }), s;
  }
}
class _d extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError() && e.getErrorType() !== m.NA)
      return e;
    if (t.isError())
      return t;
    if (!e.isArray())
      return e.isError() && e.getErrorType() === m.NA ? t : e;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.iterator((u, c, l) => {
      u != null && u.isError() && u.getErrorType() === m.NA && s.set(c, l, o.get(c, l));
    }), s;
  }
}
class Ad extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    if (e.length % 2 !== 0)
      return g.create(m.NA);
    for (let o = 0; o < e.length; o++)
      if (e[o].isError())
        return e[o];
    const t = Math.max(
      ...e.map((o) => o.isArray() ? o.getRowCount() : 1)
    ), r = Math.max(
      ...e.map((o) => o.isArray() ? o.getColumnCount() : 1)
    ), n = e.map(
      (o) => O(t, r, o, g.create(m.NA))
    ), s = n[0].map((o, u, c) => {
      for (let l = 0; l < n.length; l += 2) {
        const f = n[l].get(u, c) || ce.create(), h = n[l + 1].get(u, c) || ce.create();
        if (f.isNull())
          continue;
        if (f.isError())
          return f;
        const d = f.getValue();
        if (f.isString()) {
          if (`${d}`.toLocaleUpperCase() === "TRUE")
            return h;
          if (`${d}`.toLocaleUpperCase() === "FALSE")
            continue;
          return g.create(m.VALUE);
        }
        if (+d)
          return h.isNull() ? g.create(m.NA) : h;
      }
      return g.create(m.NA);
    });
    return t === 1 && r === 1 ? s.get(0, 0) : s;
  }
}
class Ed extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    return g.create(m.VALUE);
  }
}
class bd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    return g.create(m.VALUE);
  }
}
class yd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(...e) {
    const t = this.getIndexNumValue(e[0]);
    if (typeof t != "number")
      return t;
    const r = this.getIndexNumValue(e[1]);
    if (typeof r != "number")
      return r;
    if (!(e[2].isValueObject() && e[2].isLambda()))
      return g.create(m.VALUE);
    const n = e[2], s = [];
    for (let o = 0; o < t; o++) {
      s[o] == null && (s[o] = []);
      for (let u = 0; u < r; u++) {
        let c = n.execute(y.create(o + 1), y.create(u + 1));
        c.isArray() && (c = c.get(0, 0)), s[o][u] = c;
      }
    }
    return new Yf(s);
  }
  isAsync() {
    return !0;
  }
}
let Rd = class extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(...e) {
    const t = [];
    let r = null, n = 0, s = 0;
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      let l = c;
      if (l.isReferenceObject() && (l = c.toArrayValueObject()), l.isError())
        return l;
      if (u === e.length - 1) {
        if (!(c.isValueObject() && c.isLambda()))
          return g.create(m.VALUE);
        r = c;
      } else
        t.push(c), n = Math.max(n, l.isArray() ? l.getRowCount() : 1), s = Math.max(s, l.isArray() ? l.getColumnCount() : 1);
    }
    const o = this._getResultArray(t, r, n, s);
    return o instanceof g ? o : n === 1 && s === 1 ? o[0][0] : q.create({
      calculateValueList: o,
      rowCount: n,
      columnCount: s,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line
  _getResultArray(e, t, r, n) {
    const s = [];
    for (let o = 0; o < r; o++) {
      const u = [];
      for (let c = 0; c < n; c++) {
        const l = [];
        let f = !1;
        for (let d = 0; d < e.length; d++) {
          let _ = e[d], C = null;
          if (_.isReferenceObject() && (C = _, _ = _.toArrayValueObject()), !_.isArray())
            if (o === 0 && c === 0) {
              l.push(C || _);
              continue;
            } else {
              u.push(g.create(m.NA)), f = !0;
              break;
            }
          let E = _.get(o, c);
          if (!E) {
            u.push(g.create(m.NA)), f = !0;
            break;
          }
          if (C) {
            const { startRow: b, startColumn: R } = C.getRangePosition(), p = {
              startRow: b + o,
              startColumn: R + c,
              endRow: b + o,
              endColumn: R + c
            };
            E = this.createReferenceObject(C, p);
          }
          l.push(E);
        }
        if (f || l.length === 0)
          continue;
        let h = t.execute(...l);
        if (h.isArray()) {
          const d = h.getRowCount(), _ = h.getColumnCount();
          if (d > 1 || _ > 1)
            return g.create(m.CALC);
          h = h.get(0, 0);
        }
        h.isNull() && (h = y.create(0)), u.push(h);
      }
      s.push(u);
    }
    return s;
  }
};
class pd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const t = +e.getValue();
    return Number.isNaN(t) ? g.create(m.VALUE) : T.create(!t);
  }
}
class Vd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = !1, r = !0, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, !1;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (t = t || !!o.getValue(), r = !1);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (t = t || !!s.getValue(), r = !1);
    }
    return r ? new g(m.VALUE) : new T(t);
  }
}
class Nd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n, s;
    e.isReferenceObject() ? (n = e.toArrayValueObject(), s = e) : (n = e, s = null);
    let o, u;
    return t.isReferenceObject() ? (o = t.toArrayValueObject(), u = t) : (o = t, u = null), n.isArray() ? n.mapValue((c) => this._handleSingleValueObject(c, o, r, s, u)) : this._handleSingleValueObject(n, o, r, s, u);
  }
  _handleSingleValueObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (!(r.isValueObject() && r.isLambda() && r.getLambdaPrivacyVarKeys().length === 2))
      return g.create(m.VALUE);
    const o = r, u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    let l = e;
    n && (l = n);
    for (let f = 0; f < u; f++)
      for (let h = 0; h < c; h++) {
        let d = t.isArray() ? t.get(f, h) : t;
        if (d.isError())
          return d;
        if (s) {
          const { startRow: C, startColumn: E } = s.getRangePosition(), b = {
            startRow: C + f,
            startColumn: E + h,
            endRow: C + f,
            endColumn: E + h
          };
          d = this.createReferenceObject(s, b);
        }
        let _ = o.execute(l, d);
        if (_.isError())
          return _;
        _.isNull() && (_ = y.create(0)), l = _;
      }
    return l.isReferenceObject() ? l.toArrayValueObject() : l;
  }
}
class Od extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e, s = null;
    e.isReferenceObject() && (n = e.toArrayValueObject(), s = e), n = n;
    let o = t, u = null;
    if (t.isReferenceObject() && (o = t.toArrayValueObject(), u = t), o = o, n.isError())
      return n;
    if (o.isError())
      return o;
    if (r.isError())
      return r;
    if (!(r.isValueObject() && r.isLambda() && r.getLambdaPrivacyVarKeys().length === 2))
      return g.create(m.VALUE);
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(m.CALC);
      n = n.get(0, 0);
    }
    return this._getResult(n, o, r, s, u);
  }
  // eslint-disable-next-line
  _getResult(e, t, r, n, s) {
    const o = [], u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    let l = e;
    n && (l = n);
    for (let f = 0; f < u; f++) {
      const h = [];
      for (let d = 0; d < c; d++) {
        if (l.isError()) {
          h.push(l);
          continue;
        }
        let _ = t.isArray() ? t.get(f, d) : t;
        if (_.isError()) {
          l = _, h.push(_);
          continue;
        }
        if (s) {
          const { startRow: E, startColumn: b } = s.getRangePosition(), R = {
            startRow: E + f,
            startColumn: b + d,
            endRow: E + f,
            endColumn: b + d
          };
          _ = this.createReferenceObject(s, R);
        }
        let C = r.execute(l, _);
        if (C.isArray()) {
          const E = C.getRowCount(), b = C.getColumnCount();
          if (E > 1 || b > 1)
            return g.create(m.CALC);
          C = C.get(0, 0);
        }
        C.isNull() && (C = y.create(0)), l = C, h.push(C);
      }
      o.push(h);
    }
    return u === 1 && c === 1 ? o[0][0] : q.create({
      calculateValueList: o,
      rowCount: u,
      columnCount: c,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class Md extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = t.length % 2 !== 0, n = r ? t[t.length - 1] : ce.create();
    return !e.isArray() && !t.some((s) => s.isArray()) ? this._handleNonArrayInputs(e, t, n, r) : this._handleArrayInputs(e, t, n, r);
  }
  _handleNonArrayInputs(e, t, r, n) {
    for (let s = 0; s < t.length - (n ? 1 : 0); s += 2) {
      const o = t[s], u = t[s + 1];
      if (!o.isNull()) {
        if (o.isError())
          return o;
        if (`${e.getValue()}`.toLocaleLowerCase() === `${o.getValue()}`.toLocaleLowerCase())
          return u.isNull() ? g.create(m.NA) : u;
      }
    }
    return r.isNull() ? g.create(m.NA) : r;
  }
  _handleArrayInputs(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      ...t.map((f) => f.isArray() ? f.getRowCount() : 1),
      r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      ...t.map((f) => f.isArray() ? f.getColumnCount() : 1),
      r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, e), c = t.map(
      (f) => O(s, o, f, g.create(m.NA))
    ), l = O(s, o, r, g.create(m.NA));
    return u.map((f, h, d) => {
      for (let C = 0; C < c.length - (n ? 1 : 0); C += 2) {
        const E = c[C].get(h, d) || ce.create(), b = c[C + 1].get(h, d) || ce.create();
        if (!E.isNull()) {
          if (E.isError() || f.isError())
            return E.isError() ? E : f;
          if (`${f.getValue()}`.toLocaleLowerCase() === `${E.getValue()}`.toLocaleLowerCase())
            return b.isNull() ? g.create(m.NA) : b;
        }
      }
      const _ = l.get(h, d) || ce.create();
      return _.isNull() ? g.create(m.NA) : _;
    });
  }
}
class wd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return T.create(!0);
  }
}
class Sd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = !0, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, !1;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (o.getValue() && t++, r = !1);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (s.getValue() && t++, r = !1);
    }
    return r ? g.create(m.VALUE) : T.create(t % 2 === 1);
  }
}
const Dd = [
  [fd, De.AND],
  [hd, De.BYCOL],
  [md, De.BYROW],
  [gd, De.FALSE],
  [dd, De.IF],
  [Cd, De.IFERROR],
  [_d, De.IFNA],
  [Ad, De.IFS],
  [Ed, De.LAMBDA],
  [bd, De.LET],
  [yd, De.MAKEARRAY],
  [Rd, De.MAP],
  [pd, De.NOT],
  [Vd, De.OR],
  [Nd, De.REDUCE],
  [Od, De.SCAN],
  [Md, De.SWITCH],
  [wd, De.TRUE],
  [Sd, De.XOR]
];
class Ld extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 5);
  }
  // eslint-disable-next-line max-lines-per-function
  calculate(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r != null && r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    const o = r != null ? r : y.create(1), u = n != null ? n : T.create(!0), c = s != null ? s : j.create(""), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, e, g.create(m.NA)), d = O(l, f, t, g.create(m.NA)), _ = O(l, f, o, g.create(m.NA)), C = O(l, f, u, g.create(m.NA)), E = O(l, f, c, g.create(m.NA));
    return h.map((b, R, p) => {
      const N = d.get(R, p) || g.create(m.NA), M = _.get(R, p) || g.create(m.NA), w = C.get(R, p) || g.create(m.NA), S = E.get(R, p) || g.create(m.NA);
      return b.isError() ? b : N.isError() ? N : M.isError() ? M : w.isError() ? w : S.isError() ? S : this._calculateSingleCell(b, N, M, w, S);
    });
  }
  _calculateSingleCell(e, t, r, n, s) {
    const o = Number.parseInt(`${Number(e.getValue()) - 1}`), u = Number.parseInt(`${Number(t.getValue()) - 1}`), c = Number.parseInt(`${Number(r.getValue())}`);
    if (Number.isNaN(o) || Number.isNaN(u) || Number.isNaN(c) || c < 1 || c > 4)
      return g.create(m.VALUE);
    const l = Pd(c), f = this.getZeroOrOneByOneDefault(n), h = `${s.getValue()}`, d = io(h), _ = {
      startRow: o,
      startColumn: u,
      endRow: o,
      endColumn: u,
      startAbsoluteRefType: l,
      endAbsoluteRefType: l
    }, C = n && !f ? qh(_) : Ft(_);
    return j.create(d !== "" ? `${d}!${C}` : C);
  }
}
function Pd(i) {
  switch (i) {
    case 1:
      return we.ALL;
    case 2:
      return we.ROW;
    case 3:
      return we.COLUMN;
    case 4:
      return we.NONE;
    default:
      return we.ALL;
  }
}
class xd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    return e.isReferenceObject() ? y.create(1) : g.create(m.VALUE);
  }
}
class jd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    let r = e;
    if (r.isError())
      return r;
    if (r.isReferenceObject() && (r = r.toArrayValueObject()), !r.isArray()) {
      const c = r.convertToNumberObjectValue();
      return c.isError() ? c : t[Math.trunc(+c.getValue()) - 1] || g.create(m.VALUE);
    }
    let n = r.isArray() ? r.getRowCount() : 1, s = r.isArray() ? r.getColumnCount() : 1;
    t.forEach((c, l) => {
      if (c.isArray()) {
        const f = c;
        n = Math.max(n, f.getRowCount()), s = Math.max(s, f.getColumnCount());
      } else
        n = Math.max(n, 1), s = Math.max(s, 1);
    });
    const o = O(n, s, r, g.create(m.NA)), u = t.map((c) => {
      let l = c;
      return l.isReferenceObject() && (l = l.toArrayValueObject()), O(n, s, l, g.create(m.NA));
    });
    return o.map((c, l, f) => {
      if (c.isError())
        return c;
      const h = c.convertToNumberObjectValue();
      if (h.isError())
        return h;
      const d = u[Math.trunc(+h.getValue()) - 1];
      let _ = (d == null ? void 0 : d.get(l, f)) || g.create(m.VALUE);
      return _ != null && _.isNull() && (_ = y.create(0)), _;
    });
  }
}
class Ud extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (u.isArray()) {
        const f = u.getRowCount(), h = u.getColumnCount();
        if (f > 1 || h > 1)
          return g.create(m.VALUE);
        u = u.get(0, 0);
      }
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      const c = Math.trunc(+u.getValue());
      if (c === 0 || Math.abs(c) > n)
        return g.create(m.VALUE);
      let l = e;
      n > 1 && (c < 0 ? l = e.slice(void 0, [c + n, c + 1 + n]) : l = e.slice(void 0, [c - 1, c]));
      for (let f = 0; f < r; f++)
        s[f] || (s[f] = []), e.isArray() ? s[f].push(l.get(f, 0)) : s[f].push(e);
    }
    return q.create({
      calculateValueList: s,
      rowCount: s.length,
      columnCount: s[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class vd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = e.isArray() ? e.getRowCount() : 1, n = [];
    for (let s = 0; s < t.length; s++) {
      let o = t[s];
      if (o.isArray()) {
        const l = o.getRowCount(), f = o.getColumnCount();
        if (l > 1 || f > 1)
          return g.create(m.VALUE);
        o = o.get(0, 0);
      }
      if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
        return o;
      const u = Math.trunc(+o.getValue());
      if (u === 0 || Math.abs(u) > r)
        return g.create(m.VALUE);
      let c = e;
      r > 1 && (u < 0 ? c = e.slice([u + r, u + 1 + r]) : c = e.slice([u - 1, u])), e.isArray() ? n.push(c.getArrayValue()[0]) : n.push([e]);
    }
    return q.create({
      calculateValueList: n,
      rowCount: n.length,
      columnCount: n[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class Td extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e == null)
      return y.create(this.column + 1);
    if (e.isError())
      return e;
    if (!e.isArray())
      return g.create(m.NA);
    const t = e.getCurrentColumn(), r = e.getColumnCount(), n = [];
    for (let o = 0; o < r; o++)
      n.push(y.create(t + o + 1));
    const s = {
      calculateValueList: [n],
      rowCount: 1,
      columnCount: r,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return q.create(s);
  }
}
class Bd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isString() || e.isNumber() || e.isBoolean())
      return y.create(1);
    if (!e.isArray())
      return g.create(m.NA);
    const t = e.getColumnCount();
    return y.create(t);
  }
}
class Id extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(0), s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g.create(m.NA)), f = O(u, c, n, g.create(m.NA));
    if (u > 1 || c > 1)
      return l.mapValue((R, p, N) => {
        const M = f.get(p, N);
        if (e.isError())
          return e;
        if (e.isNull())
          return g.create(m.VALUE);
        const { isError: w, errorObject: S } = this._checkRowsColumns(R, M, s, o);
        return w ? S : e.isArray() ? g.create(m.VALUE) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(m.VALUE);
    const h = t.isArray() ? t.get(0, 0) : t, d = n.isArray() ? n.get(0, 0) : n, { isError: _, errorObject: C, rowsValue: E, columnsValue: b } = this._checkRowsColumns(h, d, s, o);
    return _ ? C : this._getResultArray(e, E, b, s, o);
  }
  _checkRowsColumns(e, t, r, n) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObject: t
      };
    const s = Math.trunc(+e.getValue()), o = Math.trunc(+t.getValue());
    return Number.isNaN(s) || Number.isNaN(o) ? {
      isError: !0,
      errorObject: g.create(m.VALUE)
    } : Math.abs(s) >= r || Math.abs(o) >= n ? {
      isError: !0,
      errorObject: g.create(m.CALC)
    } : {
      isError: !1,
      rowsValue: s,
      columnsValue: o
    };
  }
  _getResultArray(e, t, r, n, s) {
    const o = t >= 0 ? [t, n] : [0, n + t], u = r >= 0 ? [r, s] : [0, s + r];
    let c;
    return t === 0 && r === 0 ? c = e : t === 0 ? c = e.slice(void 0, u) : r === 0 ? c = e.slice(o, void 0) : c = e.slice(o, u), c = c.map((l) => l.isNull() ? y.create(0) : l), n - t === 1 && s - r === 1 ? c.get(0, 0) : c;
  }
}
class Fd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1;
    let u = t, c = r != null ? r : y.create(o);
    const l = n != null ? n : g.create(m.NA);
    t.isNull() && (u = y.create(s)), c.isNull() && (c = y.create(o));
    const f = Math.max(
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), h = Math.max(
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), d = O(f, h, u, g.create(m.NA)), _ = O(f, h, c, g.create(m.NA));
    if (f > 1 || h > 1)
      return d.mapValue((w, S, D) => {
        const L = _.get(S, D);
        if (e.isError())
          return e;
        if (e.isNull())
          return g.create(m.VALUE);
        const { isError: U, errorObject: x } = this._checkRowsColumnsPadWith(w, L, l, s, o);
        return U ? x : e.isArray() ? e.get(0, 0) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(m.VALUE);
    const C = u.isArray() ? u.get(0, 0) : u, E = c.isArray() ? c.get(0, 0) : c, { isError: b, errorObject: R, rowsValue: p, columnsValue: N, padWithObject: M } = this._checkRowsColumnsPadWith(C, E, l, s, o);
    return b ? R : this._getResultArray(e, p, N, M, s, o);
  }
  _checkRowsColumnsPadWith(e, t, r, n, s) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObject: t
      };
    const o = Math.trunc(+e.getValue()), u = Math.trunc(+t.getValue());
    if (Number.isNaN(o) || Number.isNaN(u))
      return {
        isError: !0,
        errorObject: g.create(m.VALUE)
      };
    if (Math.abs(o) < n || Math.abs(u) < s)
      return {
        isError: !0,
        errorObject: g.create(m.VALUE)
      };
    let c = r;
    if (r.isArray()) {
      const l = r.getRowCount(), f = r.getColumnCount();
      if (l > 1 || f > 1)
        return {
          isError: !0,
          errorObject: g.create(m.VALUE)
        };
      c = r.get(0, 0);
    }
    return {
      isError: !1,
      rowsValue: o,
      columnsValue: u,
      padWithObject: c
    };
  }
  _getResultArray(e, t, r, n, s, o) {
    let u = [];
    e.isArray() ? u = e.map((f) => f.isNull() ? y.create(0) : f).getArrayValue() : u = [[e]];
    const c = Math.max(0, t - s), l = Math.max(0, r - o);
    for (let f = 0; f < c; f++)
      u.push(new Array(o).fill(n));
    for (let f = 0; f < l; f++)
      u.forEach((h) => {
        h.push(n);
      });
    return t === 1 && r === 1 ? u[0][0] : q.create({
      calculateValueList: u,
      rowCount: u.length,
      columnCount: u[0].length,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class kd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : g.create(m.CALC);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    return u > 1 && c > 1 || u === 1 && c !== o || c === 1 && u !== s ? g.create(m.VALUE) : s === 1 && o === 1 ? this._getResultArrayByR1C1(e, t, n) : u === 1 ? c !== o ? g.create(m.VALUE) : this._getResultArrayByR1(s, o, e, t, n) : c === 1 ? u !== s ? g.create(m.VALUE) : this._getResultArrayByC1(s, o, e, t, n) : n;
  }
  _getResultArrayByR1C1(e, t, r) {
    let n = e, s = t;
    return n.isArray() && (n = n.get(0, 0)), s.isArray() && (s = s.get(0, 0)), s.isString() && (s = s.convertToNumberObjectValue()), s.isError() ? s : +s.getValue() ? n : r;
  }
  _getResultArrayByR1(e, t, r, n, s) {
    const o = [];
    for (let u = 0; u < t; u++) {
      let c = n.get(0, u);
      if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
        return c;
      if (+c.getValue())
        for (let f = 0; f < e; f++) {
          o[f] || (o[f] = []);
          const h = r.get(f, u);
          o[f].push(h);
        }
    }
    return o.length === 0 ? s : q.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  _getResultArrayByC1(e, t, r, n, s) {
    const o = [];
    for (let u = 0; u < e; u++) {
      let c = n.get(u, 0);
      if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
        return c;
      if (!+c.getValue())
        continue;
      const f = [];
      for (let h = 0; h < t; h++) {
        const d = r.get(u, h);
        f.push(d);
      }
      o.push(f);
    }
    return o.length === 0 ? s : q.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class $d extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
    A(this, "needsFormulaDataModel", !0);
  }
  calculate(e) {
    var f, h;
    if (!e.isReferenceObject())
      return g.create(m.NA);
    const t = e.getUnitId(), r = e.getSheetId(), s = (h = (f = e.getUnitData()[t]) == null ? void 0 : f[r]) == null ? void 0 : h.cellData, { startRow: o, startColumn: u } = e.getRangePosition(), l = e.toArrayValueObject().mapValue((d, _, C) => {
      const E = s.getValue(o + _, u + C);
      if (E != null && E.f || E != null && E.si) {
        const b = this._formulaDataModel.getFormulaStringByCell(o + _, u + C, r, t);
        return j.create(b);
      }
      return g.create(m.NA);
    });
    return l.getRowCount() === 1 && l.getColumnCount() === 1 ? l.get(0, 0) : l;
  }
}
var fe = /* @__PURE__ */ ((i) => (i.ADDRESS = "ADDRESS", i.AREAS = "AREAS", i.CHOOSE = "CHOOSE", i.CHOOSECOLS = "CHOOSECOLS", i.CHOOSEROWS = "CHOOSEROWS", i.COLUMN = "COLUMN", i.COLUMNS = "COLUMNS", i.DROP = "DROP", i.EXPAND = "EXPAND", i.FILTER = "FILTER", i.FORMULATEXT = "FORMULATEXT", i.GETPIVOTDATA = "GETPIVOTDATA", i.HLOOKUP = "HLOOKUP", i.HSTACK = "HSTACK", i.HYPERLINK = "HYPERLINK", i.IMAGE = "IMAGE", i.INDEX = "INDEX", i.INDIRECT = "INDIRECT", i.LOOKUP = "LOOKUP", i.MATCH = "MATCH", i.OFFSET = "OFFSET", i.ROW = "ROW", i.ROWS = "ROWS", i.RTD = "RTD", i.SORT = "SORT", i.SORTBY = "SORTBY", i.TAKE = "TAKE", i.TOCOL = "TOCOL", i.TOROW = "TOROW", i.TRANSPOSE = "TRANSPOSE", i.UNIQUE = "UNIQUE", i.VLOOKUP = "VLOOKUP", i.VSTACK = "VSTACK", i.WRAPCOLS = "WRAPCOLS", i.WRAPROWS = "WRAPROWS", i.XLOOKUP = "XLOOKUP", i.XMATCH = "XMATCH", i))(fe || {});
class Yd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    if (t.isError())
      return g.create(m.REF);
    if (!t.isArray() || r.isError() || n != null && n.isError())
      return g.create(m.NA);
    const s = this.getZeroOrOneByOneDefault(n);
    if (s == null)
      return g.create(m.VALUE);
    const o = this.getIndexNumValue(r);
    if (o instanceof g)
      return o;
    const u = t.slice([0, 1]), c = t.slice([o - 1, o]);
    return u == null || c == null ? g.create(m.REF) : e.isArray() ? e.map((l) => this._handleSingleObject(l, u, c, s)) : this._handleSingleObject(e, u, c, s);
  }
  _handleSingleObject(e, t, r, n) {
    return n === 0 ? this.equalSearch(e, t, r) : this.binarySearch(e, t, r);
  }
}
class Hd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = Math.max(
      ...e.map((n) => n.isArray() ? n.getRowCount() : 1)
    ), r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < t; c++) {
        r[c] || (r[c] = []);
        for (let l = 0; l < u; l++) {
          let f = s;
          s.isArray() && (f = s.get(c, l)), c > o - 1 || !f ? r[c].push(g.create(m.NA)) : r[c].push(f);
        }
      }
    }
    return q.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class Gd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (e.isArray() && (r = e.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (t != null && t.isArray() && (n = t.get(0, 0)), n != null && n.isError())
      return n;
    let s = `${r.getValue()}`;
    r.isNull() && (s = "");
    let o = s;
    return n && (o = `${n.getValue()}`, n.isNull() ? o = "0" : n.isBoolean() && (o = o.toLocaleUpperCase())), j.create(o, {
      isHyperlink: !0,
      hyperlinkUrl: s
    });
  }
}
class Qd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
    A(this, "needsReferenceObject", !0);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    const s = this._getReferenceCounts(e);
    let o = t;
    t.isReferenceObject() && (o = t.toArrayValueObject());
    let u = r;
    u != null && u.isReferenceObject() && (u = r.toArrayValueObject());
    let c = n != null ? n : y.create(1);
    c.isReferenceObject() && (c = n.toArrayValueObject());
    const l = Math.max(
      o.isArray() ? o.getRowCount() : 1,
      u != null && u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      o.isArray() ? o.getColumnCount() : 1,
      u != null && u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    );
    if (l === 1 && f === 1)
      return this._handleSingleObject(
        e,
        o.isArray() ? o.get(0, 0) : o,
        u ? u.isArray() ? u.get(0, 0) : u : void 0,
        c.isArray() ? c.get(0, 0) : c,
        s
      );
    {
      const h = O(l, f, o, g.create(m.NA)), d = u ? O(l, f, u, g.create(m.NA)) : [], _ = O(l, f, c, g.create(m.NA));
      return h.mapValue((C, E, b) => {
        const R = u ? d.get(E, b) : void 0, p = _.get(E, b), N = this._handleSingleObject(e, C, R, p, s);
        return N.isReferenceObject() ? N.getCellByPosition() : N;
      });
    }
  }
  _handleSingleObject(e, t, r, n, s) {
    let o, u, c;
    if (r) {
      const { isError: C, errorObject: E, variants: b } = B(t, r, n);
      if (C)
        return E;
      o = b[0], u = b[1], c = b[2];
    } else {
      const { isError: C, errorObject: E, variants: b } = B(t, n);
      if (C)
        return E;
      o = b[0], c = b[1];
    }
    const l = Math.floor(+c.getValue());
    if (l < 0)
      return g.create(m.VALUE);
    if (l > s.length)
      return g.create(m.REF);
    const f = s[l - 1];
    let h = 0, d = 0;
    if (f.rowCount === 1 && !r ? d = Math.floor(+o.getValue()) : (h = Math.floor(+o.getValue()), r && (d = Math.floor(+u.getValue()))), h < 0 || d < 0)
      return g.create(m.VALUE);
    if (h > f.rowCount || d > f.columnCount)
      return g.create(m.REF);
    let _ = e;
    return l > 1 && (_ = e.getCubeValues()[l - 1]), _.isReferenceObject() ? this._calculateReferenceObject(_, h, d) : this._calculateArrayObject(_, h, d);
  }
  _getReferenceCounts(e) {
    let t = [
      {
        rowCount: 1,
        columnCount: 1
      }
    ];
    return e.isReferenceObject() ? t = [
      {
        rowCount: e.getRowCount(),
        columnCount: e.getColumnCount()
      }
    ] : e.isCube() ? t = e.getCubeValues().map((r) => ({
      rowCount: r.getRowCount(),
      columnCount: r.getColumnCount()
    })) : e.isArray() && (t = [
      {
        rowCount: e.getRowCount(),
        columnCount: e.getColumnCount()
      }
    ]), t;
  }
  _calculateReferenceObject(e, t, r) {
    const { startRow: n, endRow: s, startColumn: o, endColumn: u } = e.getRangePosition();
    let c = 0, l = 0, f = 0, h = 0;
    if (t === 0 ? (c = n, l = s) : c = l = n + t - 1, r === 0 ? (f = o, h = u) : f = h = o + r - 1, c > s || f > u)
      return g.create(m.REF);
    const d = {
      startRow: c,
      startColumn: f,
      endRow: l,
      endColumn: h
    };
    return this.createReferenceObject(e, d);
  }
  _calculateArrayObject(e, t, r) {
    return !e.isArray() || t === 0 && r === 0 ? e : t === 0 ? e.slice(void 0, [r - 1, r]) : r === 0 ? e.slice([t - 1, t], void 0) : e.get(t - 1, r - 1);
  }
}
class Wd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  isAddress() {
    return !0;
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t != null && t.isError())
      return t;
    let r = this.getZeroOrOneByOneDefault(t);
    r == null && (r = 1);
    let n = e;
    if (e.isArray()) {
      const s = e.getRowCount(), o = e.getColumnCount();
      if (s > 1 || o > 1)
        return e.map(() => g.create(m.VALUE));
      n = e.getFirstCell();
    }
    return this._handleSingleObject(n, r);
  }
  _handleSingleObject(e, t) {
    const r = `${e.getValue()}`;
    if (r.trim() === "")
      return g.create(m.REF);
    const n = this._convertToDefinedName(r);
    if (t === 0) {
      const f = Wh(n), { range: h, sheetName: d, unitId: _ } = f, C = new pn(h);
      return C.setForcedUnitIdDirect(_), C.setForcedSheetName(d), this._setDefault(C);
    }
    if (Br(n))
      return this._setDefault(new ya(n));
    if (eo(n))
      return this._setDefault(new pa(n));
    if (to(n))
      return this._setDefault(new Ra(n));
    const s = Cr(n), { range: o, sheetName: u, unitId: c } = s;
    if (Number.isNaN(o.startRow) || o.endRow + 1 > 1048576 || Number.isNaN(o.startColumn) || o.endColumn + 1 > 16384)
      return g.create(m.REF);
    const l = new pn(o);
    return l.setForcedUnitIdDirect(c), l.setForcedSheetName(u), this._setDefault(l);
  }
  _setDefault(e) {
    return this.unitId == null || this.subUnitId == null ? g.create(m.REF) : (e.setDefaultUnitId(this.unitId), e.setDefaultSheetId(this.subUnitId), e);
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  _convertToDefinedName(e) {
    const t = this.getDefinedName(e);
    if (t == null)
      return e;
    const r = t.formulaOrRefString;
    return r == null ? e : r.startsWith(X.EQUALS) ? r.slice(1) : r;
  }
}
class qd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsExpandParams", !0);
  }
  calculate(e, t, r) {
    return e.isError() ? e : t.isError() ? g.create(m.REF) : t.isArray() ? r != null && r.isError() ? r : t.getColumnCount() === 1 || t.getRowCount() === 1 ? r != null && !r.isArray() ? g.create(m.REF) : this._handleVector(e, t, r) : this._handleArray(e, t) : g.create(m.VALUE);
  }
  _handleVector(e, t, r) {
    let n = r;
    if (n == null)
      n = t;
    else if (n.getRowCount() !== t.getRowCount() || n.getColumnCount() !== t.getColumnCount())
      return g.create(m.REF);
    return e.isArray() ? e.map((s) => this.binarySearch(s, t, n)) : this.binarySearch(e, t, n);
  }
  _handleArray(e, t) {
    const r = t.getRowCount(), n = t.getColumnCount();
    let s, o;
    return n > r ? (s = t.slice([0, 1]), o = t.slice([r - 1, r])) : (s = t.slice(void 0, [0, 1]), o = t.slice(void 0, [n - 1, n])), s == null || o == null ? g.create(m.VALUE) : e.isArray() ? e.map((u) => this.binarySearch(u, s, o)) : this.binarySearch(e, s, o);
  }
}
class Kd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    if (t.isError())
      return g.create(m.REF);
    if (!t.isArray())
      return g.create(m.VALUE);
    const n = t.getRowCount(), s = t.getColumnCount();
    if (n !== 1 && s !== 1 || r != null && r.isError())
      return g.create(m.NA);
    const o = this.getMatchTypeValue(r);
    return o == null ? g.create(m.VALUE) : e.isArray() ? e.map((u) => this._handleSingleObject(
      u,
      t,
      o
    )) : this._handleSingleObject(
      e,
      t,
      o
    );
  }
  _handleSingleObject(e, t, r) {
    const n = this._getSearchModeValue(r), s = t.orderSearch(e, n);
    if (s == null)
      return g.create(m.NA);
    if (s instanceof g)
      return s;
    const o = t.getRowCount() === 1 ? s.column + 1 : s.row + 1;
    return y.create(o);
  }
  _getSearchModeValue(e) {
    switch (e) {
      case 1:
        return Le.MIN;
      case 0:
        return Le.NORMAL;
      case -1:
        return Le.MAX;
    }
  }
}
class Xd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsReferenceObject", !0);
  }
  isAddress() {
    return !0;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    if (!e.isReferenceObject())
      return g.create(m.VALUE);
    const o = e.getRowCount(), u = e.getColumnCount();
    let c = t;
    c.isReferenceObject() && (c = c.toArrayValueObject());
    let l = r;
    l.isReferenceObject() && (l = l.toArrayValueObject());
    let f = n != null ? n : y.create(o);
    f.isReferenceObject() && (f = f.toArrayValueObject()), f.isNull() && (f = y.create(o));
    let h = s != null ? s : y.create(u);
    h.isReferenceObject() && (h = h.toArrayValueObject()), h.isNull() && (h = y.create(u));
    const d = Math.max(
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1,
      f.isArray() ? f.getRowCount() : 1,
      h.isArray() ? h.getRowCount() : 1
    ), _ = Math.max(
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1,
      f.isArray() ? f.getColumnCount() : 1,
      h.isArray() ? h.getColumnCount() : 1
    );
    if (c = c, l = l, f = f, h = h, d === 1 && _ === 1)
      return c = c.isArray() ? c.get(0, 0) : c, l = l.isArray() ? l.get(0, 0) : l, f = f.isArray() ? f.get(0, 0) : f, h = h.isArray() ? h.get(0, 0) : h, this._handleSingleObject(e, c, l, f, h);
    const C = O(d, _, c, g.create(m.NA)), E = O(d, _, l, g.create(m.NA)), b = O(d, _, f, g.create(m.NA)), R = O(d, _, h, g.create(m.NA));
    return C.mapValue((p, N, M) => {
      const w = E.get(N, M), S = b.get(N, M), D = R.get(N, M);
      return p.isError() ? p : w.isError() ? w : S.isError() ? S : D.isError() ? D : this._handleSingleObject(e, p, w, S, D, !0);
    });
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t, r, n, s, o = !1) {
    const { startRow: u, startColumn: c } = e.getRangePosition();
    let l = t;
    if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
      return l;
    let f = r;
    if (f.isString() && (f = f.convertToNumberObjectValue()), f.isError())
      return f;
    const h = +l.getValue(), d = +f.getValue();
    if (typeof h != "number" || typeof d != "number")
      return g.create(m.VALUE);
    const _ = u + h, C = c + d;
    if (_ < 0 || C < 0)
      return g.create(m.REF);
    const E = this.getIndexNumValue(n), b = this.getIndexNumValue(s);
    if (typeof E != "number" || typeof b != "number")
      return g.create(m.VALUE);
    if (E === 0 || b === 0)
      return g.create(m.REF);
    const R = E > 0 ? _ + E - 1 : _ + E + 1, p = b > 0 ? C + b - 1 : C + b + 1;
    if (R < 0 || p < 0)
      return g.create(m.REF);
    if (o)
      return g.create(m.VALUE);
    const N = _ < R ? _ : R, M = C < p ? C : p, w = _ > R ? _ : R, S = C > p ? C : p, D = {
      startRow: N,
      startColumn: M,
      endRow: w,
      endColumn: S
    };
    return this.createReferenceObject(e, D);
  }
}
class Zd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e == null)
      return y.create(this.row + 1);
    if (e.isError())
      return e;
    if (!e.isArray())
      return g.create(m.NA);
    const t = e.getCurrentRow(), r = e.getRowCount(), n = [];
    for (let o = 0; o < r; o++)
      n.push([y.create(t + o + 1)]);
    const s = {
      calculateValueList: n,
      rowCount: r,
      columnCount: 1,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return q.create(s);
  }
}
class zd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isString() || e.isNumber() || e.isBoolean())
      return y.create(1);
    if (!e.isArray())
      return g.create(m.NA);
    const t = e.getRowCount();
    return y.create(t);
  }
}
class Jd extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = t != null ? t : y.create(1), o = r != null ? r : y.create(1), u = n != null ? n : T.create(!1);
    if (u.isArray()) {
      const c = u.getRowCount(), l = u.getColumnCount();
      if (c === 1 && l === 1) {
        const f = u.get(0, 0);
        return this._handleSingleObject(e, s, o, f);
      }
      return u.map((f) => {
        const h = this._handleSingleObject(e, s, o, f);
        return h.isArray() ? h.get(0, 0) : h;
      });
    }
    return this._handleSingleObject(e, s, o, u);
  }
  _handleSingleObject(e, t, r, n) {
    if (e.isError())
      return e;
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = this._checkArrayError(t);
    if (u.isError())
      return u;
    const c = Math.floor(+u.getValue());
    if (c < 1)
      return g.create(m.VALUE);
    const l = this._checkArrayError(r);
    if (l.isError())
      return l;
    const f = Math.floor(+l.getValue());
    if (f !== -1 && f !== 1)
      return g.create(m.VALUE);
    let h = n;
    if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
      return h;
    if (!e.isArray() || s === 1 && o === 1)
      return e;
    const d = +h.getValue();
    return this._getResult(e, c, f, d, s, o);
  }
  _checkArrayError(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    return t.isString() && (t = t.convertToNumberObjectValue()), t;
  }
  _getResult(e, t, r, n, s, o) {
    if (n) {
      if (t > s)
        return g.create(m.VALUE);
      const u = e.transpose().getArrayValue();
      return u.sort(this._sort(t - 1, r)), q.create({
        calculateValueList: u,
        rowCount: u.length,
        columnCount: u[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      }).transpose();
    } else {
      if (t > o)
        return g.create(m.VALUE);
      const u = e.getArrayValue();
      return u.sort(this._sort(t - 1, r)), q.create({
        calculateValueList: u,
        rowCount: u.length,
        columnCount: u[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    }
  }
  _sort(e, t = 1) {
    const r = An();
    return t === 1 ? this._sortAsc(e, r) : this._sortDesc(e, r);
  }
  _sortAsc(e, t) {
    return (r, n) => {
      const s = r[e], o = n[e];
      if (s == null || s.isNull())
        return 1;
      if (o == null || o.isNull())
        return -1;
      if (s.isError() && o.isError())
        return 0;
      if (s.isError())
        return 1;
      if (o.isError())
        return -1;
      const u = s.getValue(), c = o.getValue();
      return s.isBoolean() && u === !0 ? 1 : o.isBoolean() && c === !0 ? -1 : s.isBoolean() && u === !1 ? 1 : o.isBoolean() && c === !1 ? -1 : s.isNumber() && o.isNumber() ? +u - +c : t(
        u,
        c
      );
    };
  }
  _sortDesc(e, t) {
    return (r, n) => {
      const s = r[e], o = n[e];
      if (s == null || s.isNull())
        return 1;
      if (o == null || o.isNull())
        return -1;
      if (s.isError() && o.isError())
        return 0;
      if (s.isError())
        return -1;
      if (o.isError())
        return 1;
      const u = s.getValue(), c = o.getValue();
      return s.isBoolean() && u === !0 ? -1 : o.isBoolean() && c === !0 ? 1 : s.isBoolean() && u === !1 ? -1 : o.isBoolean() && c === !1 ? 1 : s.isNumber() && o.isNumber() ? +c - +u : t(
        c,
        u
      );
    };
  }
}
class eC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    t.length === 1 && t.push(y.create(1));
    const r = this._getVariantsError(e, ...t), { maxRowLength: n, maxColumnLength: s } = Wf(t);
    if (r.isError()) {
      const c = O(n, s, r);
      return n === 1 && s === 1 ? c.get(0, 0) : c;
    }
    const o = t.map((c, l) => l % 2 === 0 ? c : O(n, s, c, g.create(m.NA))), u = this._getResultArray(e, o, n, s);
    return n === 1 && s === 1 ? u[0][0] : q.create({
      calculateValueList: u,
      rowCount: u.length,
      columnCount: u[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line complexity
  _getVariantsError(e, ...t) {
    if (e.isError())
      return e;
    for (let u = 0; u < t.length; u++) {
      const c = t[u];
      if (c.isError())
        return c;
    }
    if (t.length < 2 || t.length % 2 !== 0)
      return g.create(m.VALUE);
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t[0].isArray() ? t[0].getRowCount() : 1, o = t[0].isArray() ? t[0].getColumnCount() : 1;
    if ((s > 1 || o > 1) && (s > 1 && o > 1 || s === 1 && o !== n || o === 1 && s !== r))
      return g.create(m.VALUE);
    for (let u = 2; u < t.length; u++) {
      if (u % 2 === 1)
        continue;
      const c = t[u].isArray() ? t[u].getRowCount() : 1, l = t[u].isArray() ? t[u].getColumnCount() : 1;
      if (c !== s || l !== o)
        return g.create(m.VALUE);
    }
    return T.create(!0);
  }
  _getResultArray(e, t, r, n) {
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = t[0].isArray() ? t[0].getRowCount() : 1, c = t[0].isArray() ? t[0].getColumnCount() : 1, l = [];
    for (let f = 0; f < r; f++) {
      l[f] = [];
      for (let h = 0; h < n; h++) {
        const { isError: d, errorObject: _, byArrays: C, sortOrders: E } = this._getByArraysAndSortOrders(t, f, h, c);
        if (d) {
          l[f].push(_);
          continue;
        }
        if (!e.isArray() || s === 1 && o === 1) {
          l[f].push(e);
          continue;
        }
        let b = e.getArrayValue();
        u === 1 && c === 1 || (u === 1 ? (b = b.concat(C), b = this._transposeArray(b), b.sort(this._sort(s, E)), b = this._transposeArray(b).slice(0, s)) : c === 1 && (b = this._transposeArray(b), b = b.concat(C), b = this._transposeArray(b), b.sort(this._sort(o, E)), b = b.map((p) => p.slice(0, o))));
        const R = q.create({
          calculateValueList: b,
          rowCount: b.length,
          columnCount: b[0].length || 0,
          unitId: this.unitId,
          sheetId: this.subUnitId,
          row: this.row,
          column: this.column
        });
        if (r > 1 || n > 1) {
          l[f].push(R.get(0, 0));
          continue;
        }
        l[f].push(R);
      }
    }
    return l;
  }
  _getByArraysAndSortOrders(e, t, r, n) {
    const s = [], o = [];
    let u = !1, c = null;
    for (let l = 0; l < e.length; l++) {
      if (l % 2 === 1)
        continue;
      const f = e[l];
      let h = e[l + 1].get(t, r);
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError()) {
        u = !0, c = h;
        break;
      }
      const d = Math.floor(+h.getValue());
      if (d !== -1 && d !== 1) {
        u = !0, c = g.create(m.VALUE);
        break;
      }
      if (o.push(d), f.isArray()) {
        let _ = f.getArrayValue();
        n === 1 && (_ = this._transposeArray(_)), s.push(_[0]);
      } else
        s.push([f]);
    }
    return {
      isError: u,
      errorObject: c,
      byArrays: s,
      sortOrders: o
    };
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
  _sort(e, t) {
    const r = An();
    return (n, s) => {
      let o = n[e], u = s[e], c = this._compare(o, u, t[0], r);
      if (c === 0 && t.length > 1) {
        for (let l = 1; l < t.length; l++)
          if (o = n[e + l], u = s[e + l], c = this._compare(o, u, t[l], r), c !== 0)
            return c;
      }
      return c;
    };
  }
  _compare(e, t, r, n) {
    return r === 1 ? this._asc(e, t, n) : this._desc(e, t, n);
  }
  _asc(e, t, r) {
    if (e == null || e.isNull())
      return 1;
    if (t == null || t.isNull())
      return -1;
    if (e.isError() && t.isError())
      return 0;
    if (e.isError())
      return 1;
    if (t.isError())
      return -1;
    const n = e.getValue(), s = t.getValue();
    return e.isBoolean() && n === !0 ? 1 : t.isBoolean() && s === !0 ? -1 : e.isBoolean() && n === !1 ? 1 : t.isBoolean() && s === !1 ? -1 : e.isNumber() && t.isNumber() ? +n - +s : r(
      n,
      s
    );
  }
  _desc(e, t, r) {
    if (e == null || e.isNull())
      return 1;
    if (t == null || t.isNull())
      return -1;
    if (e.isError() && t.isError())
      return 0;
    if (e.isError())
      return -1;
    if (t.isError())
      return 1;
    const n = e.getValue(), s = t.getValue();
    return e.isBoolean() && n === !0 ? -1 : t.isBoolean() && s === !0 ? 1 : e.isBoolean() && n === !1 ? -1 : t.isBoolean() && s === !1 ? 1 : e.isNumber() && t.isNumber() ? +s - +n : r(
      s,
      n
    );
  }
}
class tC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    let o = t, u = r != null ? r : y.create(s);
    t.isNull() && (o = y.create(n)), u.isNull() && (u = y.create(s));
    const c = Math.max(
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, o, g.create(m.NA)), h = O(c, l, u, g.create(m.NA));
    if (c > 1 || l > 1)
      return f.mapValue((p, N, M) => {
        const w = h.get(N, M);
        if (e.isError())
          return e;
        if (e.isNull())
          return g.create(m.VALUE);
        const { isError: S, errorObject: D } = this._checkRowsColumns(p, w, n, s);
        return S ? D : e.isArray() ? g.create(m.VALUE) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(m.VALUE);
    const d = o.isArray() ? o.get(0, 0) : o, _ = u.isArray() ? u.get(0, 0) : u, { isError: C, errorObject: E, rowsValue: b, columnsValue: R } = this._checkRowsColumns(d, _, n, s);
    return C ? E : this._getResultArray(e, b, R, n, s);
  }
  _checkRowsColumns(e, t, r, n) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObject: t
      };
    let s = Math.trunc(+e.getValue()), o = Math.trunc(+t.getValue());
    return Number.isNaN(s) || Number.isNaN(o) ? {
      isError: !0,
      errorObject: g.create(m.VALUE)
    } : Math.abs(s) === 0 || Math.abs(o) === 0 ? {
      isError: !0,
      errorObject: g.create(m.CALC)
    } : (s > r && (s = r), o > n && (o = n), {
      isError: !1,
      rowsValue: s,
      columnsValue: o
    });
  }
  _getResultArray(e, t, r, n, s) {
    if (!e.isArray())
      return e;
    const o = t >= 0 ? [0, t] : [n + t, n], u = r >= 0 ? [0, r] : [s + r, s];
    let c;
    return t === n && r === s ? c = e : t === n ? c = e.slice(void 0, u) : r === s ? c = e.slice(o, void 0) : c = e.slice(o, u), c = c.map((l) => l.isNull() ? y.create(0) : l), t === 1 && r === 1 ? c.get(0, 0) : c;
  }
}
class rC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(0), s = r != null ? r : T.create(!1), o = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, n, g.create(m.NA)), l = O(o, u, s, g.create(m.NA)), f = c.mapValue((h, d, _) => {
      const C = l.get(d, _);
      if (e.isError())
        return e;
      if (e.isNull())
        return g.create(m.VALUE);
      if (h.isError())
        return h;
      if (C.isError())
        return C;
      const E = Math.trunc(+h.getValue()), b = +C.getValue();
      if (Number.isNaN(E) || E < 0 || E > 3 || Number.isNaN(b))
        return g.create(m.VALUE);
      if (!e.isArray())
        return e;
      let R = [];
      return b ? R = this._getArrayValueByColumn(e, E) : R = this._getArrayValueByRow(e, E), R.length === 0 ? g.create(m.CALC) : o > 1 || u > 1 || R.length === 1 ? R[0] : q.create({
        calculateValueList: R.map((p) => [p]),
        rowCount: R.length,
        columnCount: 1,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _getArrayValueByColumn(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < s; u++)
      for (let c = 0; c < n; c++) {
        const l = r.get(c, u);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _getArrayValueByRow(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        const l = r.get(u, c);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _isIgnore(e, t) {
    switch (t) {
      case 0:
        return !1;
      case 1:
        return e.isNull();
      case 2:
        return e.isError();
      case 3:
        return e.isNull() || e.isError();
      default:
        return !1;
    }
  }
}
class nC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(0), s = r != null ? r : T.create(!1), o = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, n, g.create(m.NA)), l = O(o, u, s, g.create(m.NA)), f = c.mapValue((h, d, _) => {
      const C = l.get(d, _);
      if (e.isError())
        return e;
      if (h.isError())
        return h;
      if (C.isError())
        return C;
      const E = Math.trunc(+h.getValue()), b = +C.getValue();
      if (Number.isNaN(E) || E < 0 || E > 3 || Number.isNaN(b) || e.isNull())
        return g.create(m.VALUE);
      if (!e.isArray())
        return e;
      let R = [];
      return b ? R = this._getArrayValueByColumn(e, E) : R = this._getArrayValueByRow(e, E), R.length === 0 ? g.create(m.CALC) : o > 1 || u > 1 || R.length === 1 ? R[0] : q.create({
        calculateValueList: [R],
        rowCount: 1,
        columnCount: R.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _getArrayValueByColumn(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < s; u++)
      for (let c = 0; c < n; c++) {
        const l = r.get(c, u);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _getArrayValueByRow(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        const l = r.get(u, c);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _isIgnore(e, t) {
    switch (t) {
      case 0:
        return !1;
      case 1:
        return e.isNull();
      case 2:
        return e.isError();
      case 3:
        return e.isNull() || e.isError();
      default:
        return !1;
    }
  }
}
class sC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      return t === 1 && r === 1 ? e.get(0, 0) : e.transpose();
    }
    return e;
  }
}
class aC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : T.create(!1), s = r != null ? r : T.create(!1), o = e.isArray() ? e.getRowCount() : 1, u = e.isArray() ? e.getColumnCount() : 1, c = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), l = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), f = O(c, l, n, g.create(m.NA)), h = O(c, l, s, g.create(m.NA)), d = f.map((_, C, E) => {
      let b = _, R = h.get(C, E);
      if (e.isError())
        return e;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      const p = +b.getValue(), N = +R.getValue();
      let M;
      return !p && o === 1 || p && u === 1 ? M = e : M = this._getResult(e, p, N), (c > 1 || l > 1) && (M != null && M.isArray()) ? M.get(0, 0) : M;
    });
    return c === 1 && l === 1 ? d.get(0, 0) : d;
  }
  _getResult(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    let o = e.getArrayValue(), u = n, c = s;
    t && (o = this._transposeArray(o), u = s, c = n);
    const l = this._getRepeatRows(o, u, c);
    if (l.length > 0) {
      const f = [];
      l.forEach((h) => {
        h.forEach((d, _) => {
          (_ !== 0 || r) && f.push(d);
        });
      }), o = o.filter((h, d) => !f.includes(d));
    }
    return o.length === 0 ? g.create(m.CALC) : (t && (o = this._transposeArray(o)), q.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    }));
  }
  _getRepeatRows(e, t, r) {
    let n = [];
    for (let s = 0; s < r; s++)
      if (s === 0) {
        const o = new Array(t).fill(null).map((u, c) => ({
          r: c,
          valueObject: e[c][s]
        }));
        n = this._getRepeatRowsByObjects(o);
      } else {
        if (n.length === 0)
          break;
        let o = [];
        n.forEach((u) => {
          const c = u.map((f) => ({
            r: f,
            valueObject: e[f][s]
          })), l = this._getRepeatRowsByObjects(c);
          o = o.concat(l);
        }), n = o;
      }
    return n;
  }
  _getRepeatRowsByObjects(e) {
    const t = /* @__PURE__ */ new Map();
    return e.forEach((r) => {
      const n = r.r, s = r.valueObject;
      let o = s.getValue();
      if (s.isNull() ? o = null : s.isString() && W(o) && (o = +o), !t.has(o))
        t.set(o, [n]);
      else {
        const u = t.get(o);
        u.push(n), t.set(o, u);
      }
    }), Array.from(t.values()).filter((r) => r.length > 1);
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
}
class iC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (!t.isArray())
      return g.create(m.VALUE);
    if (r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    const s = n != null ? n : T.create(!0);
    return Ri(e) && Ri(s) && r.isArray() ? this._handleArrayColIndexNum(e, t, r, s) : this._handleNonArrayColIndexNum(e, t, r, s);
  }
  _handleArrayColIndexNum(e, t, r, n) {
    const s = e.isArray() ? e.getFirstCell() : e, o = this.getZeroOrOneByOneDefault(n);
    if (o == null)
      return g.create(m.VALUE);
    let u;
    const c = [];
    return r.iterator((l, f, h) => {
      if (l == null)
        return u = g.create(m.VALUE), !1;
      const d = this._handleTableArray(s, t, l, o);
      if (d.isError())
        return u = d, !1;
      c[f] === void 0 && (c[f] = []), c[f][h] = d;
    }), u || Fr(c, c.length, c[0].length, this.unitId || "", this.subUnitId || "");
  }
  _handleNonArrayColIndexNum(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e), c = O(s, o, n);
    return u.map((l, f, h) => {
      if (l.isError())
        return l;
      const d = c.get(f, h);
      if (d == null)
        return g.create(m.VALUE);
      if (d.isError())
        return d;
      const _ = this.getZeroOrOneByOneDefault(d);
      return _ == null ? g.create(m.VALUE) : this._handleTableArray(l, t, r, _);
    });
  }
  _handleTableArray(e, t, r, n) {
    let s = this.getIndexNumValue(r);
    if (s instanceof g)
      return s;
    if (s = Math.floor(s), s < 1)
      return g.create(m.VALUE);
    const o = t.slice(void 0, [0, 1]);
    if (o == null)
      return g.create(m.VALUE);
    const u = t.slice(void 0, [s - 1, s]);
    return u == null ? g.create(m.REF) : this._handleSingleObject(e, o, u, n);
  }
  _handleSingleObject(e, t, r, n) {
    return n === 0 ? this.equalSearch(e, t, r) : this.binarySearch(e, t, r);
  }
}
class oC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = Math.max(
      ...e.map((n) => n.isArray() ? n.getColumnCount() : 1)
    ), r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++) {
        const l = [];
        for (let f = 0; f < t; f++) {
          let h = s;
          s.isArray() && (h = s.get(c, f)), f > u - 1 || !h ? l.push(g.create(m.NA)) : l.push(h);
        }
        r.push(l);
      }
    }
    return q.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class uC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : g.create(m.NA);
    n.isNull() && (n = g.create(m.NA));
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g.create(m.NA)), f = O(u, c, n, g.create(m.NA)), h = l.mapValue((d, _, C) => {
      const E = f.get(_, C);
      if (e.isError())
        return e;
      if (e.isNull())
        return g.create(m.VALUE);
      if (d.isError())
        return d;
      const b = Math.trunc(+d.getValue());
      if (s > 1 && o > 1 || Number.isNaN(b))
        return g.create(m.VALUE);
      if (b < 1)
        return g.create(m.NUM);
      const R = e.isArray() ? e.getArrayValue().flat() : [e], p = this._getWrapArray(R, b, E);
      return u > 1 || c > 1 || p.length === 1 && p[0].length === 1 ? p[0][0] : q.create({
        calculateValueList: p,
        rowCount: p.length,
        columnCount: p[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return u === 1 && c === 1 ? h.get(0, 0) : h;
  }
  _getWrapArray(e, t, r) {
    const n = Math.ceil(e.length / t), s = n > 1 ? t : e.length, o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        o[c] || (o[c] = []);
        const l = u * s + c;
        l < e.length ? o[c].push(e[l].isNull() ? y.create(0) : e[l]) : o[c].push(r);
      }
    return o;
  }
}
class cC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : g.create(m.NA);
    n.isNull() && (n = g.create(m.NA));
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g.create(m.NA)), f = O(u, c, n, g.create(m.NA)), h = l.mapValue((d, _, C) => {
      const E = f.get(_, C);
      if (e.isError())
        return e;
      if (e.isNull())
        return g.create(m.VALUE);
      if (d.isError())
        return d;
      const b = Math.trunc(+d.getValue());
      if (s > 1 && o > 1 || Number.isNaN(b))
        return g.create(m.VALUE);
      if (b < 1)
        return g.create(m.NUM);
      const R = e.isArray() ? e.getArrayValue().flat() : [e], p = this._getWrapArray(R, b, E);
      return u > 1 || c > 1 || p.length === 1 && p[0].length === 1 ? p[0][0] : q.create({
        calculateValueList: p,
        rowCount: p.length,
        columnCount: p[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return u === 1 && c === 1 ? h.get(0, 0) : h;
  }
  _getWrapArray(e, t, r) {
    const n = Math.ceil(e.length / t), s = n > 1 ? t : e.length, o = [];
    for (let u = 0; u < n; u++) {
      const c = [];
      for (let l = 0; l < s; l++) {
        const f = u * s + l;
        f < e.length ? c.push(e[f].isNull() ? y.create(0) : e[f]) : c.push(r);
      }
      o.push(c);
    }
    return o;
  }
}
class lC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  // eslint-disable-next-line
  calculate(e, t, r, n, s, o) {
    let u = n != null ? n : g.create(m.NA);
    n != null && n.isNull() && (u = g.create(m.NA));
    let c = s != null ? s : y.create(0);
    s != null && s.isNull() && (c = y.create(0));
    let l = o != null ? o : y.create(1);
    if (o != null && o.isNull() && (l = y.create(1)), e.isError())
      return e;
    const f = t.isArray() ? t.getRowCount() : 1, h = t.isArray() ? t.getColumnCount() : 1, d = r.isArray() ? r.getRowCount() : 1, _ = r.isArray() ? r.getColumnCount() : 1;
    if (f !== 1 && h !== 1 || f === 1 && h > 1 && h !== _ || h === 1 && f > 1 && f !== d)
      return g.create(m.VALUE);
    if (c.isError())
      return c;
    if (l.isError())
      return l;
    const C = this.getIndexNumValue(c);
    if (C instanceof g)
      return C;
    const E = this.getIndexNumValue(l);
    return E instanceof g ? E : this._getResult(
      e,
      Gs(t),
      Gs(r),
      u,
      C,
      E,
      f,
      h,
      d,
      _
    );
  }
  _getResult(e, t, r, n, s, o, u, c, l, f) {
    const h = e.isArray() ? e.getRowCount() : 1, d = e.isArray() ? e.getColumnCount() : 1;
    if (h > 1 || d > 1) {
      let b;
      return u === 1 ? b = r.slice([0, 1]) : b = r.slice(void 0, [0, 1]), b == null ? g.create(m.NA) : e.map((R) => {
        const p = this._checkErrorCombination(s, o);
        if (p)
          return p;
        const N = this._handleSingleObject(R, t, b, s, o);
        return N.isError() ? n : N;
      });
    }
    const _ = e.isArray() ? e.get(0, 0) : e;
    if (c === f && u === l) {
      const b = this._checkErrorCombination(s, o);
      if (b)
        return b;
      const R = this._handleSingleObject(_, t, r, s, o);
      return R.isError() ? n : R;
    }
    let C = 0;
    c === f && (C = 1);
    const E = this._handleExpandObject(_, t, r, s, o, C);
    return E == null ? g.create(m.NA) : E;
  }
  _handleExpandObject(e, t, r, n, s, o = 0) {
    if ((s === 2 || s === -2) && n !== 2) {
      const u = Is(s), c = Bs(n);
      return this.binarySearchExpand(
        e,
        t,
        r,
        o,
        u,
        c
      );
    }
    return n === 2 ? this.fuzzySearchExpand(e, t, r, s !== -1, o) : n === -1 || n === 1 ? this.orderSearchExpand(
      e,
      t,
      r,
      n === 1 ? Le.MAX : Le.MIN,
      s === -1,
      o
    ) : this.equalSearchExpand(e, t, r, s !== -1, o);
  }
  _handleSingleObject(e, t, r, n, s) {
    if ((s === 2 || s === -2) && n !== 2) {
      const o = Is(s), u = Bs(n);
      return this.binarySearch(e, t, r, o, u);
    }
    return n === 2 ? this.fuzzySearch(e, t, r, s !== -1) : n === -1 || n === 1 ? this.orderSearch(
      e,
      t,
      r,
      n === 1 ? Le.MAX : Le.MIN,
      s === -1
    ) : this.equalSearch(e, t, r, s !== -1);
  }
  /**
   * Wildcard matching and binary search cannot appear at the same time
   * @param matchModeValue
   * @param searchModeValue
   * @returns
   */
  _checkErrorCombination(e, t) {
    return e === 2 && (t === -2 || t === 2) ? g.create(m.VALUE) : null;
  }
}
class fC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = y.create(0);
    r && !r.isNull() && (s = r);
    let o = y.create(1);
    n && !n.isNull() && (o = n);
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g.create(m.NA)), f = O(u, c, s, g.create(m.NA)), h = O(u, c, o, g.create(m.NA)), d = l.mapValue((_, C, E) => {
      if (_.isError())
        return _;
      const b = f.get(C, E), R = h.get(C, E);
      return b.isError() ? b : R.isError() ? R : this._handleSingleObject(_, t, b, R);
    });
    return u === 1 && c === 1 ? d.get(0, 0) : d;
  }
  _handleSingleObject(e, t, r, n) {
    const s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    if (s !== 1 && o !== 1)
      return g.create(m.VALUE);
    let u = r;
    if ((r.isString() || r.isBoolean() || r.isNull()) && (u = r.convertToNumberObjectValue()), u.isError())
      return u;
    let c = n;
    if ((n.isString() || n.isBoolean() || n.isNull()) && (c = n.convertToNumberObjectValue()), c.isError())
      return c;
    const l = u.getValue(), f = c.getValue();
    return ![-1, 0, 1, 2].includes(l) || ![-1, 1, 2].includes(f) ? g.create(m.VALUE) : this._getResult(e, t, l, f);
  }
  _getResult(e, t, r, n) {
    const s = Gs(t);
    let o;
    if ((n === 2 || n === -2) && r !== 2) {
      const u = Is(n), c = Bs(r);
      o = s.binarySearch(e, u, c);
    } else if (r === 2) {
      const u = s.compare(e, F.EQUALS);
      let c;
      if (n !== -1 ? c = u.getFirstTruePosition() : c = u.getLastTruePosition(), c == null)
        return g.create(m.NA);
      o = s.getRowCount() === 1 ? c.column : c.row;
    } else if (r === -1 || r === 1) {
      const u = s.orderSearch(e, r === 1 ? Le.MAX : Le.MIN, n === -1);
      if (u == null)
        return g.create(m.NA);
      if (u instanceof g)
        return u;
      o = s.getRowCount() === 1 ? u.column : u.row;
    } else {
      const u = s.isEqual(e);
      let c;
      if (n !== -1 ? c = u.getFirstTruePosition() : c = u.getLastTruePosition(), c == null)
        return g.create(m.NA);
      o = s.getRowCount() === 1 ? c.column : c.row;
    }
    return o == null ? g.create(m.NA) : y.create(o + 1);
  }
}
const hC = [
  [Ld, fe.ADDRESS],
  [xd, fe.AREAS],
  [jd, fe.CHOOSE],
  [Ud, fe.CHOOSECOLS],
  [vd, fe.CHOOSEROWS],
  [Td, fe.COLUMN],
  [Bd, fe.COLUMNS],
  [Id, fe.DROP],
  [Fd, fe.EXPAND],
  [kd, fe.FILTER],
  [$d, fe.FORMULATEXT],
  [Yd, fe.HLOOKUP],
  [Hd, fe.HSTACK],
  [Gd, fe.HYPERLINK],
  [Qd, fe.INDEX],
  [Wd, fe.INDIRECT],
  [qd, fe.LOOKUP],
  [Kd, fe.MATCH],
  [Xd, fe.OFFSET],
  [Zd, fe.ROW],
  [zd, fe.ROWS],
  [Jd, fe.SORT],
  [eC, fe.SORTBY],
  [tC, fe.TAKE],
  [rC, fe.TOCOL],
  [nC, fe.TOROW],
  [sC, fe.TRANSPOSE],
  [aC, fe.UNIQUE],
  [iC, fe.VLOOKUP],
  [oC, fe.VSTACK],
  [uC, fe.WRAPCOLS],
  [cC, fe.WRAPROWS],
  [lC, fe.XLOOKUP],
  [fC, fe.XMATCH]
];
class mC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.abs();
  }
}
class gC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.acos();
  }
}
class dC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.acosh();
  }
}
class CC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.isArray() ? t.map((r) => r.isError() ? r : Ui(r)) : Ui(t);
  }
}
function Ui(i) {
  let a = i.getValue();
  if (i.isBoolean() && (a = a ? 1 : 0), !Number.isFinite(a))
    return g.create(m.VALUE);
  a = Number(a);
  let e = Math.atan(1 / a);
  return a < 0 && (e += Math.PI), Number.isNaN(e) ? g.create(m.VALUE) : y.create(e);
}
class _C extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.isArray() ? t.map((r) => r.isError() ? r : vi(r)) : vi(t);
  }
}
function vi(i) {
  let a = i.getValue();
  if (i.isBoolean() && (a = a ? 1 : 0), !Number.isFinite(a))
    return g.create(m.VALUE);
  if (a = Number(a), Math.abs(a) <= 1)
    return g.create(m.NUM);
  const e = 1 / 2 * Math.log((a + 1) / (a - 1));
  return Number.isNaN(e) ? g.create(m.VALUE) : y.create(e);
}
class AC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  // eslint-disable-next-line
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return y.create(0);
    if (e.isBoolean() || e.isNumber())
      return g.create(m.VALUE);
    let t = e.getValue().toLocaleString().toLocaleUpperCase();
    if (t.length > 255)
      return g.create(m.VALUE);
    const r = t.startsWith("-");
    r && (t = t.slice(1));
    let n = 0;
    for (let s = 0; s < t.length; s++) {
      const o = en.get(t[s]) || 0, u = en.get(t[s + 1]) || 0, c = en.get(t[s + 2]) || 0, l = en.get(t[s + 3]) || 0;
      if (!o || c >= u && c > o || o === u && o === c && o === l || o === u / 2)
        return g.create(m.VALUE);
      o < u ? n -= o : n += o;
    }
    return y.create(r ? -n : n);
  }
}
class EC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.asin();
  }
}
class bC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.asinh();
  }
}
class yC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.atan();
  }
}
class RC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e, n = t;
    return r.isString() && (r = r.convertToNumberObjectValue()), r.isError() ? r : (n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : n.atan2(r));
  }
}
class pC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.atanh();
  }
}
class VC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(0);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (n.isError())
      return n;
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, n, g.create(m.NA)), f = u.map((h, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return this._handleSingleObject(h, C, E);
    });
    return f.getRowCount() === 1 && f.getColumnCount() === 1 ? f.getArrayValue()[0][0] : f;
  }
  _handleSingleObject(e, t, r) {
    let n = e;
    if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
      return n;
    let s = t;
    if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
      return s;
    let o = r;
    if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
      return o;
    const u = Math.floor(+n.getValue()), c = Math.floor(+s.getValue()), l = Math.floor(+o.getValue());
    if (u < 0 || u >= 2 ** 53 || c < 2 || c > 36 || l < 0)
      return g.create(m.NUM);
    let f = u.toString(c);
    return f.length < l && (f = new Array(l - f.length + 1).join("0") + f), j.create(f.toLocaleUpperCase());
  }
}
class NC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = c, d = o.get(l, f);
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +h.getValue(), C = +d.getValue();
      if (_ > 0 && C < 0)
        return g.create(m.NUM);
      if (_ === 0 || C === 0)
        return y.create(0);
      const E = Ye(_ / C, 0) * C;
      return y.create(E);
    });
    return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.getArrayValue()[0][0] : u;
  }
}
class OC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(1), s = r != null ? r : y.create(0);
    if (e.isError())
      return e;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(m.NA)), l = O(o, u, n, g.create(m.NA)), f = O(o, u, s, g.create(m.NA)), h = c.map((d, _, C) => {
      let E = d, b = l.get(_, C), R = f.get(_, C);
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      const p = +E.getValue(), N = +b.getValue(), M = +R.getValue();
      return p === 0 || N === 0 ? y.create(0) : this._getResult(p, N, M);
    });
    return o === 1 && u === 1 ? h.get(0, 0) : h;
  }
  _getResult(e, t, r) {
    let n;
    return e < 0 && r !== 0 ? n = (t < 0 ? Ye(Math.abs(e) / Math.abs(t), 0) : -Ye(Math.abs(e) / t, 0)) * t : n = (t < 0 ? -Ye(e / Math.abs(t), 0) : Ye(e / t, 0)) * t, y.create(n);
  }
}
class MC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.map((l, f, h) => {
      let d = u.get(f, h), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue();
      if (C === 0 || E === 0)
        return y.create(0);
      const b = (E < 0 ? -Ye(C / Math.abs(E), 0) : Ye(C / E, 0)) * E;
      return y.create(b);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
class wC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      let h = c, d = o.get(l, f);
      if (h.isString() && (h = h.convertToNumberObjectValue()), d.isString() && (d = d.convertToNumberObjectValue()), h.isError())
        return h;
      if (d.isError())
        return d;
      const _ = Math.floor(+h.getValue()), C = Math.floor(+d.getValue());
      if (_ < 0 || C < 0 || _ < C)
        return g.create(m.NUM);
      const E = er(_, C);
      return Number.isNaN(E) || !Number.isFinite(E) ? g.create(m.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class SC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      let h = c, d = o.get(l, f);
      if (h.isString() && (h = h.convertToNumberObjectValue()), d.isString() && (d = d.convertToNumberObjectValue()), h.isError())
        return h;
      if (d.isError())
        return d;
      const _ = Math.floor(+h.getValue()), C = Math.floor(+d.getValue());
      if (_ < 0 || C < 0 || _ === 0 && _ < C)
        return g.create(m.NUM);
      const E = er(_ + C - 1, _ - 1);
      return Number.isNaN(E) || !Number.isFinite(E) ? g.create(m.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class DC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.cos();
  }
}
class LC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.cosh();
  }
}
class PC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= 2 ** 27 ? g.create(m.NUM) : r === 0 ? g.create(m.DIV_BY_ZERO) : t.tan().getReciprocal();
  }
}
class xC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : +t.getValue() === 0 ? g.create(m.DIV_BY_ZERO) : t.tanh().getReciprocal();
  }
}
class jC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= 2 ** 27 ? g.create(m.NUM) : r === 0 ? g.create(m.DIV_BY_ZERO) : t.sin().getReciprocal();
  }
}
class UC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return r === 0 ? g.create(m.DIV_BY_ZERO) : !Number.isNaN(r) && !Number.isFinite(Math.sinh(r)) ? y.create(0) : t.sinh().getReciprocal();
  }
}
class vC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      if (c.isError())
        return c;
      let h = o.get(l, f);
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      const d = `${c.getValue()}`, _ = Math.floor(+h.getValue());
      if (W(d) && (+d < 0 || +d >= 2 ** 53 || !Number.isInteger(+d)) || d.toLocaleLowerCase() === "true" || d.toLocaleLowerCase() === "false" || _ < 2 || _ > 36)
        return g.create(m.NUM);
      if (d.replace(/\s/g, "") === "")
        return y.create(0);
      if (!this._isValidCharForRadix(d, _))
        return g.create(m.NUM);
      const C = Number.parseInt(d, _);
      return Number.isNaN(C) ? g.create(m.NUM) : y.create(C);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _isValidCharForRadix(e, t) {
    for (const r of e) {
      const n = r.toUpperCase().charCodeAt(0);
      if (t <= 10 && !(n >= 48 && n < 48 + t) || t > 10 && !(n >= 48 && n < 58 || n >= 65 && n < 65 + t - 10))
        return !1;
    }
    return !0;
  }
}
class TC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(m.VALUE);
    const n = r * (180 / Math.PI);
    return Number.isNaN(n) ? g.create(m.VALUE) : y.create(n);
  }
}
class BC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(m.VALUE);
    const n = (r < 0 ? -Ye(Math.abs(r) / 2, 0) : Ye(r / 2, 0)) * 2;
    return Number.isNaN(n) ? g.create(m.VALUE) : n === 0 ? y.create(0) : y.create(n);
  }
}
class IC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.exp();
  }
}
class FC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue()), n = mr(r);
    return Number.isNaN(n) || !Number.isFinite(n) ? g.create(m.NUM) : y.create(n);
  }
}
class kC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (e.isArray()) {
      const r = e.getRowCount(), n = e.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(m.VALUE);
      t = e.get(0, 0);
    }
    return this._handleSingleObject(t);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue()), n = mr(r, 2);
    return Number.isNaN(n) || !Number.isFinite(n) ? g.create(m.NUM) : y.create(n);
  }
}
class $C extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = o.get(l, f), d = c;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      if (h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      const _ = +d.getValue(), C = +h.getValue();
      if (_ > 0 && C < 0)
        return g.create(m.NUM);
      if (_ === 0)
        return y.create(0);
      if (C === 0)
        return g.create(m.DIV_BY_ZERO);
      const E = Ke(_ / C, 0) * C;
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class YC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(1), s = r != null ? r : y.create(0), o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(m.NA)), l = O(o, u, n, g.create(m.NA)), f = O(o, u, s, g.create(m.NA)), h = c.map((d, _, C) => {
      let E = d, b = l.get(_, C), R = f.get(_, C);
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      const p = +E.getValue(), N = +b.getValue(), M = +R.getValue();
      if (p === 0 || N === 0)
        return y.create(0);
      let w;
      return p < 0 && M !== 0 ? w = (N < 0 ? Ke(Math.abs(p) / Math.abs(N), 0) : -Ke(Math.abs(p) / N, 0)) * N : w = (N < 0 ? -Ke(p / Math.abs(N), 0) : Ke(p / N, 0)) * N, y.create(w);
    });
    return o === 1 && u === 1 ? h.get(0, 0) : h;
  }
}
class HC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.map((l, f, h) => {
      let d = u.get(f, h), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue();
      if (C === 0 || E === 0)
        return y.create(0);
      const b = (E < 0 ? -Ke(C / Math.abs(E), 0) : Ke(C / E, 0)) * E;
      return y.create(b);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
class GC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (!n.isNull())
        if (n.isArray()) {
          let s = !1, o = g.create(m.VALUE);
          if (n.iterator((u) => {
            if (u != null && u.isNull())
              return !0;
            const { isError: c, errorObject: l, number: f } = this._handleSingleObject(u);
            if (c)
              return s = !0, o = l, !1;
            t = ta(t, f);
          }), s)
            return o;
        } else {
          const { isError: s, errorObject: o, number: u } = this._handleSingleObject(n);
          if (s)
            return o;
          t = ta(t, u);
        }
    }
    return y.create(t);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: !0,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 || r >= 2 ** 53 ? {
      isError: !0,
      errorObject: g.create(m.NUM),
      number: null
    } : {
      isError: !1,
      errorObject: null,
      number: r
    };
  }
}
class QC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue());
    return y.create(r);
  }
}
class WC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 1, r = !0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (!s.isNull())
        if (s.isArray()) {
          let o = !1, u = g.create(m.VALUE);
          if (s.iterator((c) => {
            if (c != null && c.isNull())
              return !0;
            const { isError: l, errorObject: f, number: h } = this._handleSingleObject(c);
            if (l)
              return o = !0, u = f, !1;
            t = Pi(t, h), r = !1;
          }), o)
            return u;
        } else {
          const { isError: o, errorObject: u, number: c } = this._handleSingleObject(s);
          if (o)
            return u;
          t = Pi(t, c), r = !1;
        }
    }
    return r ? y.create(0) : Number.isNaN(t) || !Number.isFinite(t) || t >= 2 ** 53 ? g.create(m.VALUE) : y.create(t);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: !0,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 ? {
      isError: !0,
      errorObject: g.create(m.NUM),
      number: null
    } : {
      isError: !1,
      errorObject: null,
      number: r
    };
  }
}
class qC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.log();
  }
}
class KC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(10);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.map((l, f, h) => {
      let d = u.get(f, h), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue();
      if (C <= 0 || E <= 0)
        return g.create(m.NUM);
      const b = Math.log(E);
      if (b === 0)
        return g.create(m.DIV_BY_ZERO);
      const R = Math.log(C) / b;
      return y.create(R);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
class XC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.log10();
  }
}
class ZC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        let l = e.isArray() ? e.get(o, c) : e;
        if (l.isError())
          return l;
        if (l.isNull() || l.isBoolean())
          return g.create(m.VALUE);
        if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
          return l;
        const f = +l.getValue();
        u.push(f);
      }
      n.push(u);
    }
    if (t !== r)
      return g.create(m.VALUE);
    const s = Pa(n);
    return y.create(s);
  }
}
class zC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        let l = e.isArray() ? e.get(o, c) : e;
        if (l.isError())
          return l;
        if (l.isNull() || l.isBoolean())
          return g.create(m.VALUE);
        if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
          return l;
        const f = +l.getValue();
        u.push(f);
      }
      n.push(u);
    }
    if (t !== r)
      return g.create(m.VALUE);
    const s = Jh(n);
    return s === null ? g.create(m.NUM) : q.createByArray(s);
  }
}
class JC extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    if (n !== s)
      return g.create(m.VALUE);
    const u = this._getMatrix(e, r, n), c = this._getMatrix(t, s, o);
    if (u instanceof g)
      return u;
    if (c instanceof g)
      return c;
    const l = gr(u, c);
    return q.createByArray(l);
  }
  _getMatrix(e, t, r) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = [];
      for (let u = 0; u < r; u++) {
        let c = e.isArray() ? e.get(s, u) : e;
        if (c.isError())
          return c;
        if (c.isNull() || c.isBoolean())
          return g.create(m.VALUE);
        if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
          return c;
        const l = +c.getValue();
        o.push(l);
      }
      n.push(o);
    }
    return n;
  }
}
class e_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.mod(n);
  }
}
class t_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isArray()) {
      const c = r.getRowCount(), l = r.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(m.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    let n = t;
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(m.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean() || n.isBoolean())
      return g.create(m.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (Number.isNaN(s) || Number.isNaN(o))
      return g.create(m.VALUE);
    if (o === 0)
      return y.create(0);
    if (s > 0 && o < 0 || s < 0 && o > 0)
      return g.create(m.NUM);
    const u = Bt(s / o, 0) * o;
    return y.create(u);
  }
}
class r_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (!o.isNull())
        if (o.isArray()) {
          let u = !1, c = g.create(m.VALUE);
          if (o.iterator((l) => {
            if (l != null && l.isNull())
              return !0;
            const { isError: f, errorObject: h, number: d } = this._handleSingleObject(l);
            if (f)
              return u = !0, c = h, !1;
            if (t += d, t > 170)
              return u = !0, c = g.create(m.NUM), !1;
            r *= mr(d);
          }), u)
            return c;
        } else {
          const { isError: u, errorObject: c, number: l } = this._handleSingleObject(o);
          if (u)
            return c;
          if (t += l, t > 170)
            return g.create(m.NUM);
          r *= mr(l);
        }
    }
    const n = mr(t) / r;
    return y.create(n);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: !0,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 ? {
      isError: !0,
      errorObject: g.create(m.NUM),
      number: null
    } : {
      isError: !1,
      errorObject: null,
      number: r
    };
  }
}
class n_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount(), n = e.mapValue((s) => {
        const o = this._handleSingleObject(s);
        return o.isError() ? o : t > 1 || r > 1 ? o.get(0, 0) : o;
      });
      return t === 1 && r === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue());
    if (r <= 0)
      return g.create(m.VALUE);
    const n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < r; o++)
        n[s][o] = s === o ? 1 : 0;
    }
    return q.createByArray(n);
  }
}
class s_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(m.VALUE);
    let n = r < 0 ? -Ye(Math.abs(r), 0) : Ye(r, 0);
    return Number.isNaN(n) ? g.create(m.VALUE) : (Math.abs(n) % 2 === 0 && (r < 0 ? n-- : n++), y.create(n));
  }
}
class a_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return y.create(Math.PI);
  }
}
class i_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.pow(n);
  }
}
class o_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(1), r = !0;
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.isError())
        return s;
      if (s.isArray()) {
        let o = !1, u = null;
        if (s.iterator((c) => {
          if (c != null && c.isError())
            return o = !0, u = c, !1;
          if (!c || c.isNull() || c.isString() || c.isBoolean())
            return !0;
          t = t.multiply(c), r = !1;
        }), o)
          return u;
      } else {
        if (s.isNull())
          continue;
        if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
          return s;
        t = t.multiply(s), r = !1;
      }
      if (t.isError())
        return t;
    }
    return r ? y.create(0) : t;
  }
}
class u_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = H(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = +u.getValue();
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(m.VALUE);
    if (l === 0)
      return g.create(m.DIV_BY_ZERO);
    const f = Math.trunc(c / l);
    return y.create(f);
  }
}
class c_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(m.VALUE);
    const n = r * (Math.PI / 180);
    return Number.isNaN(n) ? g.create(m.VALUE) : y.create(n);
  }
}
class l_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return y.create(Math.random());
  }
}
class f_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 5);
    A(this, "needsSheetRowColumnCount", !0);
  }
  calculate(e, t, r, n, s) {
    if (e != null && e.isError())
      return e;
    if (t != null && t.isError())
      return t;
    if (r != null && r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    const o = e != null ? e : y.create(1), u = t != null ? t : y.create(1), c = r != null ? r : y.create(0), l = n != null ? n : y.create(1), f = s != null ? s : y.create(0);
    return this._calculateResult(o, u, c, l, f);
  }
  _calculateResult(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    );
    if (o === 1 && u === 1)
      return this._calculateSingleCell(e, t, r, n, s);
    const c = O(o, u, e, g.create(m.NA)), l = O(o, u, t, g.create(m.NA)), f = O(o, u, r, g.create(m.NA)), h = O(o, u, n, g.create(m.NA)), d = O(o, u, s, g.create(m.NA));
    return c.map((_, C, E) => {
      const b = l.get(C, E), R = f.get(C, E), p = h.get(C, E), N = d.get(C, E), M = this._handleError(_, b, R, p, N);
      if (M.errorObject)
        return M.errorObject;
      let { minValue: w, maxValue: S, wholeNumberValue: D } = M, L;
      return D ? (w = Math.ceil(w), S = Math.floor(S), L = Math.floor(Math.random() * (S - w + 1)) + w) : L = Math.random() * (S - w) + w, L < w || L > S ? g.create(m.VALUE) : y.create(L);
    });
  }
  _calculateSingleCell(e, t, r, n, s) {
    let o = e;
    o.isArray() && (o = o.get(0, 0));
    let u = t;
    u.isArray() && (u = u.get(0, 0));
    let c = r;
    c.isArray() && (c = c.get(0, 0));
    let l = n;
    l.isArray() && (l = l.get(0, 0));
    let f = s;
    f.isArray() && (f = f.get(0, 0));
    const h = this._handleError(o, u, c, l, f);
    if (h.errorObject)
      return h.errorObject;
    let { rowsValue: d, columnsValue: _, minValue: C, maxValue: E, wholeNumberValue: b } = h;
    if (b && (C = Math.ceil(C), E = Math.floor(E), C > E))
      return g.create(m.VALUE);
    const R = [];
    for (let p = 0; p < d; p++) {
      const N = [];
      for (let M = 0; M < _; M++)
        b ? N.push(Math.floor(Math.random() * (E - C + 1)) + C) : N.push(Math.random() * (E - C) + C);
      R.push(N);
    }
    return d === 1 && _ === 1 ? y.create(R[0][0]) : q.createByArray(R);
  }
  _handleError(e, t, r, n, s) {
    let o = e;
    if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
      return {
        errorObject: o
      };
    let u = t;
    if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
      return {
        errorObject: u
      };
    let c = r;
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return {
        errorObject: c
      };
    let l = n;
    if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
      return {
        errorObject: l
      };
    let f = s;
    return f.isString() && (f = f.convertToNumberObjectValue()), f.isError() ? {
      errorObject: f
    } : this._getValue(o, u, c, l, f);
  }
  _getValue(e, t, r, n, s) {
    const o = Math.floor(+e.getValue()), u = Math.floor(+t.getValue());
    if (o === 0 || u === 0)
      return {
        errorObject: g.create(m.CALC)
      };
    const c = this._rowCount - this.row, l = this._columnCount - this.column;
    if (o < 0 || u < 0 || o * u > 10 ** 7)
      return {
        errorObject: g.create(m.VALUE)
      };
    if (o > c || u > l)
      return {
        errorObject: g.create(m.REF)
      };
    const f = +r.getValue(), h = +n.getValue(), d = +s.getValue();
    return f > h ? {
      errorObject: g.create(m.VALUE)
    } : d && (!Number.isInteger(f) || !Number.isInteger(h)) ? {
      errorObject: g.create(m.VALUE)
    } : {
      rowsValue: o,
      columnsValue: u,
      minValue: f,
      maxValue: h,
      wholeNumberValue: d
    };
  }
}
class h_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isArray()) {
      const c = r.getRowCount(), l = r.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(m.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    let n = t;
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(m.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean() || n.isBoolean())
      return g.create(m.VALUE);
    let s = +r.getValue(), o = +n.getValue();
    if (Number.isNaN(s) || Number.isNaN(o))
      return g.create(m.VALUE);
    if (s > o)
      return g.create(m.NUM);
    s = Math.ceil(s), o = Math.floor(o);
    const u = Math.floor(Math.random() * (o - s + 1)) + s;
    return y.create(u);
  }
}
class m_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e);
    if (r)
      return n;
    const [o] = s;
    let u = Math.floor(+o.getValue()), c = t;
    if (c.isString() && (c = c.convertToNumberObjectValue(), c.isError()))
      return c;
    let l = Math.floor(+c.getValue());
    if (c.isBoolean() && (l = c.getValue() ? 0 : 4), u < 0 || u > 3999 || l < 0 || l > 4)
      return g.create(m.VALUE);
    const f = om[l];
    let h = f.length - 1, d = "";
    for (; u > 0; ) {
      h = this._binarySearch(u, 0, h, f);
      const _ = f[h];
      u -= _, d += im.get(_);
    }
    return j.create(d);
  }
  _binarySearch(e, t, r, n) {
    let s = t, o = r;
    for (; o - s > 1; ) {
      const u = Math.floor((s + o) / 2), c = n[u];
      if (c === e)
        return u;
      c > e ? o = u : s = u;
    }
    return s !== o && n[o] <= e ? o : s;
  }
}
class g_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.round(n);
  }
}
class d_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      if (c.isError())
        return c;
      if (h.isError())
        return h;
      const { isError: d, errorObject: _, variants: C } = B(c, h);
      if (d)
        return _;
      const [E, b] = C, R = +E.getValue(), p = Math.trunc(+b.getValue()), N = this._roundBank(R, p);
      return y.create(N);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _roundBank(e, t) {
    if (t > 16)
      return e;
    if (t < -16)
      return 0;
    const r = 1e-8, n = 10 ** t, s = +(e * n).toFixed(8), o = Math.floor(s), u = s - o;
    let c = Math.round(s);
    return u > 0.5 - r && u < 0.5 + r && (c = o % 2 === 0 ? o : o + 1), t ? c / n : c;
  }
}
class C_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.floor(n);
  }
}
class __ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.ceil(n);
  }
}
class A_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= 2 ** 27 ? g.create(m.NUM) : t.cos().getReciprocal();
  }
}
class E_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Number.isFinite(Math.cosh(r)) ? Math.abs(r) >= 2 ** 27 ? g.create(m.NUM) : t.cosh().getReciprocal() : y.create(0);
  }
}
class b_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
    A(this, "needsSheetRowColumnCount", !0);
  }
  calculate(e, t, r, n) {
    let s = e, o = t != null ? t : y.create(1), u = r != null ? r : y.create(1), c = n != null ? n : y.create(1);
    s.isNull() && (s = y.create(1)), o.isNull() && (o = y.create(1)), u.isNull() && (u = y.create(1)), c.isNull() && (c = y.create(1));
    const l = Math.max(
      s.isArray() ? s.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      s.isArray() ? s.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, s, g.create(m.NA)), d = O(l, f, o, g.create(m.NA)), _ = O(l, f, u, g.create(m.NA)), C = O(l, f, c, g.create(m.NA)), E = h.mapValue((b, R, p) => {
      const N = d.get(R, p), M = _.get(R, p), w = C.get(R, p);
      return b.isError() ? b : N.isError() ? N : M.isError() ? M : w.isError() ? w : this._getResult(b, N, M, w, l, f);
    });
    return l === 1 && f === 1 ? E.get(0, 0) : E;
  }
  _getResult(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = B(e, t, r, n);
    if (u)
      return c;
    const [f, h, d, _] = l, C = Math.floor(+f.getValue()), E = Math.floor(+h.getValue()), b = +d.getValue(), R = +_.getValue();
    if (C < 0 || E < 0 || C * E > 10 ** 7)
      return g.create(m.VALUE);
    if (C === 0 || E === 0)
      return g.create(m.CALC);
    const p = this._rowCount - this.row, N = this._columnCount - this.column;
    if (C > p || E > N)
      return g.create(m.REF);
    const M = [];
    for (let w = 0; w < C; w++) {
      M[w] = [];
      for (let S = 0; S < E; S++)
        M[w][S] = b + (w * E + S) * R;
    }
    return s > 1 || o > 1 ? y.create(M[0][0]) : q.createByArray(M);
  }
}
class y_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isNull() || t.isNull() || r.isNull() || n.isNull())
      return g.create(m.NA);
    const { isError: s, errorObject: o, variants: u } = H(e, t, r);
    if (s)
      return o;
    const { isError: c, errorObject: l, variants: f } = B(...u);
    if (c)
      return l;
    const [h, d, _] = f, C = +h.getValue(), E = +d.getValue(), b = +_.getValue(), R = [];
    if (n.isArray()) {
      let N = !1, M = g.create(m.VALUE);
      if (n.iterator((w) => {
        const { isError: S, errorObject: D, coefficientsObject: L } = this._handleSingleObject(w);
        if (S)
          return N = !0, M = D, !1;
        const U = +L.getValue();
        R.push(U);
      }), N)
        return M;
    } else {
      const { isError: N, errorObject: M, coefficientsObject: w } = this._handleSingleObject(n);
      if (N)
        return M;
      const S = +w.getValue();
      R.push(S);
    }
    let p = 0;
    for (let N = 0; N < R.length; N++)
      p += R[N] * C ** (E + N * b);
    return Number.isNaN(p) || !Number.isFinite(p) ? g.create(m.NUM) : y.create(p);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e,
        coefficientsObject: null
      };
    if (e != null && e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        coefficientsObject: null
      };
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? {
      isError: !0,
      errorObject: t,
      coefficientsObject: null
    } : {
      isError: !1,
      errorObject: null,
      coefficientsObject: t
    };
  }
}
class R_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    return o > 0 ? y.create(1) : o < 0 ? y.create(-1) : y.create(0);
  }
}
class p_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sin();
  }
}
class V_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sinh();
  }
}
class N_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sqrt();
  }
}
class O_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(m.VALUE);
      t = t.get(0, 0);
    }
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (r < 0)
      return g.create(m.NUM);
    const n = Math.sqrt(r * Math.PI);
    return y.create(n);
  }
}
class M_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
    A(this, "needsFilteredOutRows", !0);
    A(this, "needsFormulaDataModel", !0);
  }
  calculate(e, ...t) {
    return e.isError() ? e : e.isReferenceObject() ? e.toArrayValueObject().mapValue((r) => this._handleSingleObject(r, ...t)) : this._handleSingleObject(e, ...t);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _handleSingleObject(e, ...t) {
    const r = this._getIndexNumValue(e);
    let n;
    if (r instanceof g)
      return r;
    switch (r) {
      case 1:
        n = this._average(!1, ...t);
        break;
      case 2:
        n = this._count(!1, ...t);
        break;
      case 3:
        n = this._counta(!1, ...t);
        break;
      case 4:
        n = this._max(!1, ...t);
        break;
      case 5:
        n = this._min(!1, ...t);
        break;
      case 6:
        n = this._product(!1, ...t);
        break;
      case 7:
        n = this._stdev(!1, ...t);
        break;
      case 8:
        n = this._stdevp(!1, ...t);
        break;
      case 9:
        n = this._sum(!1, ...t);
        break;
      case 10:
        n = this._var(!1, ...t);
        break;
      case 11:
        n = this._varp(!1, ...t);
        break;
      case 101:
        n = this._average(!0, ...t);
        break;
      case 102:
        n = this._count(!0, ...t);
        break;
      case 103:
        n = this._counta(!0, ...t);
        break;
      case 104:
        n = this._max(!0, ...t);
        break;
      case 105:
        n = this._min(!0, ...t);
        break;
      case 106:
        n = this._product(!0, ...t);
        break;
      case 107:
        n = this._stdev(!0, ...t);
        break;
      case 108:
        n = this._stdevp(!0, ...t);
        break;
      case 109:
        n = this._sum(!0, ...t);
        break;
      case 110:
        n = this._var(!0, ...t);
        break;
      case 111:
        n = this._varp(!0, ...t);
        break;
      default:
        n = g.create(m.VALUE);
    }
    return n;
  }
  _getIndexNumValue(e) {
    const t = e ? Number(e.getValue()) : 0;
    if (Number.isNaN(t))
      return g.create(m.VALUE);
    const r = Math.floor(t);
    return r >= 1 && r <= 11 || r >= 101 && r <= 111 ? r : g.create(m.VALUE);
  }
  _average(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : r.mean();
  }
  _count(e, ...t) {
    let r = y.create(0);
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      if (!s.isReferenceObject())
        return g.create(m.VALUE);
      const o = s.getFilteredOutRows(), u = s.getRowData();
      s.iterator((c, l) => {
        if (o.includes(l) || e && this._isRowHidden(u, l))
          return !0;
        c != null && c.isNumber() && (r = r.plusBy(1));
      });
    }
    return r;
  }
  _counta(e, ...t) {
    let r = y.create(0);
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      if (!s.isReferenceObject())
        return g.create(m.VALUE);
      const o = s.getFilteredOutRows(), u = s.getRowData();
      s.iterator((c, l) => {
        if (o.includes(l) || e && this._isRowHidden(u, l) || c == null || c.isNull())
          return !0;
        r = r.plusBy(1);
      });
    }
    return r;
  }
  _max(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : this._isBlankArrayObject(r) ? y.create(0) : r.max();
  }
  _min(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : this._isBlankArrayObject(r) ? y.create(0) : r.min();
  }
  _product(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    if (r.isError())
      return r;
    if (this._isBlankArrayObject(r))
      return y.create(0);
    let n = y.create(1);
    return r.iterator((s) => {
      n = n.multiply(
        s
      );
    }), n;
  }
  _stdev(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : this._isBlankArrayObject(r) ? g.create(m.DIV_BY_ZERO) : r.std(1);
  }
  _stdevp(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : this._isBlankArrayObject(r) ? g.create(m.DIV_BY_ZERO) : r.std();
  }
  _sum(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : r.sum();
  }
  _var(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : this._isBlankArrayObject(r) ? g.create(m.DIV_BY_ZERO) : r.var(1);
  }
  _varp(e, ...t) {
    const r = this._flattenRefArray(e, ...t);
    return r.isError() ? r : this._isBlankArrayObject(r) ? g.create(m.DIV_BY_ZERO) : r.var();
  }
  _flattenRefArray(e, ...t) {
    var n, s;
    const r = [];
    r[0] = [];
    for (let o = 0; o < t.length; o++) {
      const u = t[o];
      if (u.isError())
        return u;
      if (!u.isReferenceObject())
        return g.create(m.VALUE);
      const c = u.getFilteredOutRows(), l = u.getRowData(), f = u.getUnitId(), h = u.getSheetId(), _ = (s = (n = u.getUnitData()[f]) == null ? void 0 : n[h]) == null ? void 0 : s.cellData;
      let C;
      if (u.iterator((E, b, R) => {
        if (c.includes(b) || e && this._isRowHidden(l, b))
          return !0;
        const p = _.getValue(b, R);
        if (p != null && p.f || p != null && p.si) {
          const N = this._formulaDataModel.getFormulaStringByCell(b, R, h, f);
          if (N && N.indexOf(`${this.name}(`) > -1)
            return !0;
        }
        if (E == null || E.isNull() || E.isString() || E.isBoolean())
          return !0;
        if (E.isError())
          return C = E, !1;
        r[0].push(E);
      }), C != null && C.isError())
        return C;
    }
    return Fr(r, 1, r[0].length);
  }
  _isRowHidden(e, t) {
    const r = e[t];
    return r ? r.hd === qi.TRUE : !1;
  }
  _isBlankArrayObject(e) {
    return e.getArrayValue()[0].length === 0;
  }
}
class w_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError() || (n.isArray() && (n = n.sum()), n.isError()))
        return n;
      if (t = t.plus(n), t.isError())
        return t;
    }
    return t;
  }
}
class S_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    if (!e.isReferenceObject() || r && !r.isReferenceObject())
      return g.create(m.VALUE);
    let n = t;
    if (t.isReferenceObject() && (n = t.toArrayValueObject()), n.isArray()) {
      const s = n.mapValue((o) => this._handleSingleObject(e, o, r));
      return s.getRowCount() === 1 && s.getColumnCount() === 1 ? s.get(0, 0) : s;
    }
    return this._handleSingleObject(e, n, r);
  }
  _handleSingleObject(e, t, r) {
    const n = e.toArrayValueObject();
    let s = Zn(n, t);
    s = zn(s, n, t);
    const o = n.getRowCount(), u = n.getColumnCount();
    let c = n;
    if (r) {
      c = r.toArrayValueObject();
      const l = c.getRowCount(), f = c.getColumnCount();
      if (o !== l || u !== f) {
        const h = r.getRangeData();
        h.endRow = h.startRow + o - 1, h.endColumn = h.startColumn + u - 1, r.setRangeData(h), c = r.toArrayValueObject();
      }
    }
    return c.pick(s).sum();
  }
}
class D_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(m.VALUE) : O(o, u, g.create(m.VALUE));
    const f = $r(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => e.pick(s).sum()));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : q.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class L_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = this._initArray1(e);
    if (t.length > 0) {
      const n = r.getRowCount(), s = r.getColumnCount();
      let o = this._getResultArrayByArray1(n, s, r);
      if (o instanceof g)
        return o;
      o = o;
      for (let c = 0; c < t.length; c++) {
        if (t[c].isError())
          return t[c];
        let l = 1, f = 1;
        if (t[c].isArray() && (l = t[c].getRowCount(), f = t[c].getColumnCount()), l !== n || f !== s)
          return g.create(m.VALUE);
        for (let h = 0; h < n; h++) {
          const d = [];
          for (let _ = 0; _ < s; _++) {
            let C = t[c];
            if (t[c].isArray() && (C = t[c].get(h, _)), C.isError())
              return C;
            C.isNumber() ? d.push(C.getValue() * o[h][_]) : d.push(0);
          }
          o[h] = d;
        }
      }
      const u = o.reduce((c, l) => c.concat(l)).reduce((c, l) => c + l, 0);
      return y.create(u);
    } else
      return r.sum();
  }
  _initArray1(e) {
    let t = e;
    return t.isArray() || (t = q.create({
      calculateValueList: [[t]],
      rowCount: 1,
      columnCount: 1,
      unitId: "",
      sheetId: "",
      row: 0,
      column: 0
    })), t;
  }
  _getResultArrayByArray1(e, t, r) {
    const n = [];
    for (let s = 0; s < e; s++) {
      const o = [];
      for (let u = 0; u < t; u++) {
        const c = r.get(s, u);
        if (c.isError())
          return c;
        c.isNumber() ? o.push(c.getValue()) : o.push(0);
      }
      n.push(o);
    }
    return n;
  }
}
class P_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    const r = y.create(2);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray() ? s.iterator((o) => {
        if (o == null || o.isString() || o.isBoolean() || o.isNull())
          return !0;
        if (o.isError())
          return t = o, !1;
        t = t.plus(
          o.pow(r)
        );
      }) : t = t.plus(s.pow(r)), t.isError())
        return t;
    }
    return t;
  }
}
class x_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g.create(m.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f = t.flatten();
      let h = ce.create();
      const d = [], _ = [];
      let C = 0;
      return l.iterator((E, b, R) => {
        const p = f.get(b, R);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return !0;
        if (E != null && E.isError())
          return h = E, !1;
        if (p == null || p.isString() || p.isBoolean() || p.isNull())
          return !0;
        if (p != null && p.isError())
          return h = p, !1;
        const N = +E.getValue(), M = +p.getValue();
        d.push(N), _.push(M), C += N ** 2 - M ** 2;
      }), h.isError() ? h : d.length === 0 || _.length === 0 ? g.create(m.DIV_BY_ZERO) : y.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g.create(m.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !W(s) || r.isBoolean() || n.isString() && !W(o) || n.isBoolean())
      return g.create(m.DIV_BY_ZERO);
    const u = s ** 2 - o ** 2;
    return y.create(u);
  }
}
class j_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g.create(m.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f = t.flatten();
      let h = ce.create();
      const d = [], _ = [];
      let C = 0;
      return l.iterator((E, b, R) => {
        const p = f.get(b, R);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return !0;
        if (E != null && E.isError())
          return h = E, !1;
        if (p == null || p.isString() || p.isBoolean() || p.isNull())
          return !0;
        if (p != null && p.isError())
          return h = p, !1;
        const N = +E.getValue(), M = +p.getValue();
        d.push(N), _.push(M), C += N ** 2 + M ** 2;
      }), h.isError() ? h : d.length === 0 || _.length === 0 ? g.create(m.DIV_BY_ZERO) : y.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g.create(m.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !W(s) || r.isBoolean() || n.isString() && !W(o) || n.isBoolean())
      return g.create(m.DIV_BY_ZERO);
    const u = s ** 2 + o ** 2;
    return y.create(u);
  }
}
class U_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g.create(m.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f = t.flatten();
      let h = ce.create();
      const d = [], _ = [];
      let C = 0;
      return l.iterator((E, b, R) => {
        const p = f.get(b, R);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return !0;
        if (E != null && E.isError())
          return h = E, !1;
        if (p == null || p.isString() || p.isBoolean() || p.isNull())
          return !0;
        if (p != null && p.isError())
          return h = p, !1;
        const N = +E.getValue(), M = +p.getValue();
        d.push(N), _.push(M), C += (N - M) ** 2;
      }), h.isError() ? h : d.length === 0 || _.length === 0 ? g.create(m.DIV_BY_ZERO) : y.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g.create(m.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !W(s) || r.isBoolean() || n.isString() && !W(o) || n.isBoolean())
      return g.create(m.DIV_BY_ZERO);
    const u = (s - o) ** 2;
    return y.create(u);
  }
}
class v_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.tan();
  }
}
class T_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.tanh();
  }
}
class B_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.map((l, f, h) => {
      let d = u.get(f, h), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue(), b = 10 ** Math.trunc(E), R = qn(C, b), p = Math.trunc(Or(C, b) + R) / b;
      return y.create(p);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
const I_ = [
  [mC, Y.ABS],
  [gC, Y.ACOS],
  [dC, Y.ACOSH],
  [CC, Y.ACOT],
  [_C, Y.ACOTH],
  [AC, Y.ARABIC],
  [EC, Y.ASIN],
  [bC, Y.ASINH],
  [yC, Y.ATAN],
  [RC, Y.ATAN2],
  [pC, Y.ATANH],
  [VC, Y.BASE],
  [NC, Y.CEILING],
  [OC, Y.CEILING_MATH],
  [MC, Y.CEILING_PRECISE],
  [wC, Y.COMBIN],
  [SC, Y.COMBINA],
  [DC, Y.COS],
  [LC, Y.COSH],
  [PC, Y.COT],
  [xC, Y.COTH],
  [jC, Y.CSC],
  [UC, Y.CSCH],
  [vC, Y.DECIMAL],
  [TC, Y.DEGREES],
  [BC, Y.EVEN],
  [IC, Y.EXP],
  [FC, Y.FACT],
  [kC, Y.FACTDOUBLE],
  [$C, Y.FLOOR],
  [YC, Y.FLOOR_MATH],
  [HC, Y.FLOOR_PRECISE],
  [GC, Y.GCD],
  [QC, Y.INT],
  [WC, Y.LCM],
  [qC, Y.LN],
  [KC, Y.LOG],
  [XC, Y.LOG10],
  [ZC, Y.MDETERM],
  [zC, Y.MINVERSE],
  [JC, Y.MMULT],
  [e_, Y.MOD],
  [t_, Y.MROUND],
  [r_, Y.MULTINOMIAL],
  [n_, Y.MUNIT],
  [s_, Y.ODD],
  [a_, Y.PI],
  [i_, Y.POWER],
  [o_, Y.PRODUCT],
  [u_, Y.QUOTIENT],
  [c_, Y.RADIANS],
  [l_, Y.RAND],
  [f_, Y.RANDARRAY],
  [h_, Y.RANDBETWEEN],
  [m_, Y.ROMAN],
  [g_, Y.ROUND],
  [d_, Y.ROUNDBANK],
  [C_, Y.ROUNDDOWN],
  [__, Y.ROUNDUP],
  [A_, Y.SEC],
  [E_, Y.SECH],
  [y_, Y.SERIESSUM],
  [b_, Y.SEQUENCE],
  [R_, Y.SIGN],
  [p_, Y.SIN],
  [V_, Y.SINH],
  [N_, Y.SQRT],
  [O_, Y.SQRTPI],
  [M_, Y.SUBTOTAL],
  [w_, Y.SUM],
  [S_, Y.SUMIF],
  [D_, Y.SUMIFS],
  [L_, Y.SUMPRODUCT],
  [P_, Y.SUMSQ],
  [x_, Y.SUMX2MY2],
  [j_, Y.SUMX2PY2],
  [U_, Y.SUMXMY2],
  [v_, Y.TAN],
  [T_, Y.TANH],
  [B_, Y.TRUNC]
];
class F_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "_compareType", F.EQUALS);
  }
  setCompareType(e) {
    this._compareType = e;
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.compare(t, this._compareType);
  }
}
class Wa extends Ht {
  constructor(e) {
    super("");
    A(this, "_values", []);
    this._values = e;
  }
  static create(e) {
    return new Wa(e);
  }
  isCube() {
    return !0;
  }
  dispose() {
    this._values.forEach((e) => {
      e.dispose();
    }), this._values = [];
  }
  getCubeValues() {
    return this._values;
  }
  getCubeCount() {
    return this._values.length;
  }
  sum() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.sum());
    }), e;
  }
  max() {
    let e = y.create(Number.NEGATIVE_INFINITY);
    return this._values.forEach((t) => {
      const r = t.max();
      e.isLessThan(r) && (e = r);
    }), e;
  }
  min() {
    let e = y.create(Number.POSITIVE_INFINITY);
    return this._values.forEach((t) => {
      const r = t.max();
      e.isGreaterThan(r) && (e = r);
    }), e;
  }
  count() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.count());
    }), e;
  }
  countA() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.countA());
    }), e;
  }
  countBlank() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.countBlank());
    }), e;
  }
}
class k_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isError())
        return n;
      if (!n.isArray())
        return g.create(m.VALUE);
      t.push(n);
    }
    return Wa.create(t);
  }
}
class $_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : !t.isArray() && t.getValue() === 0 ? g.create(m.DIV_BY_ZERO) : e.divided(t);
  }
}
class Y_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.minus(t);
  }
}
class H_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.multiply(t);
  }
}
class G_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.plus(t);
  }
}
const Q_ = [
  [F_, Be.COMPARE],
  [$_, Be.DIVIDED],
  [Y_, Be.MINUS],
  [H_, Be.MULTIPLY],
  [G_, Be.PLUS],
  [k_, Be.CUBE]
];
class W_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0), r = y.create(0);
    for (let o = 0; o < e.length; o++) {
      let u = e[o];
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      if (u.isArray()) {
        if (u = q_(u), u.isError())
          return u;
        if (e[o] = u, t = t.plus(u.sum()), t.isError())
          return t;
        r = r.plus(u.count());
      } else u.isNull() || (t = t.plus(u), r = r.plus(y.create(1)));
    }
    if (r.getValue() === 0)
      return g.create(m.NUM);
    const n = t.divided(r);
    if (n.isError())
      return n;
    let s = y.create(0);
    for (let o = 0; o < e.length; o++) {
      let u = e[o];
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      if (u.isArray()) {
        if (s = s.plus(u.minus(n).abs().sum()), s.isError())
          return s;
      } else u.isNull() || (s = s.plus(u.minus(n).abs()));
    }
    return s.divided(r);
  }
}
function q_(i) {
  const a = [];
  a[0] = [];
  let e = null;
  return i.iterator((t, r, n) => {
    if (t != null && t.isError())
      return e = t, !1;
    t != null && t.isNumber() && a[0].push(t);
  }), e || Fr(a, 1, a[0].length);
}
class K_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0), r = y.create(0);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if ((s.isString() || s.isBoolean()) && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray()) {
        if (t = t.plus(s.sum()), t.isError())
          return t;
        r = r.plus(s.count());
      } else s.isNull() || (t = t.plus(s), r = r.plus(y.create(1)));
    }
    return t.divided(r);
  }
}
class X_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 254);
  }
  // eslint-disable-next-line
  calculate(...e) {
    let t = !1, r;
    e.length % 2 !== 0 && (t = !0, r = g.create(m.NA));
    const n = [], s = [];
    for (let o = 0; o < e.length; o += 2) {
      const u = e[o], c = u.isArray() ? u.getRowCount() : 1, l = u.isArray() ? u.getColumnCount() : 1;
      for (let _ = 0; _ < c; _++)
        for (let C = 0; C < l; C++) {
          const E = u.isArray() ? u.get(_, C) : u;
          if (E.isError())
            return E;
          if (t)
            continue;
          const b = E.isNull() ? "" : E.getValue();
          n.push(b);
        }
      if (o + 1 >= e.length)
        continue;
      const f = e[o + 1], h = f.isArray() ? f.getRowCount() : 1, d = f.isArray() ? f.getColumnCount() : 1;
      (h !== c || d !== l) && (t = !0, r = g.create(m.VALUE));
      for (let _ = 0; _ < h; _++)
        for (let C = 0; C < d; C++) {
          const E = f.isArray() ? f.get(_, C) : f;
          if (E.isError())
            return E;
          if (t)
            continue;
          const b = E.isNull() ? "" : E.getValue();
          s.push(b);
        }
    }
    return t ? r : this._getResult(n, s);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let u = 0; u < r; u++) {
      const c = e[u], l = t[u];
      if (!(typeof c != "number" && typeof l != "number")) {
        if (typeof c != "number" || typeof l != "number" || l < 0)
          return g.create(m.VALUE);
        n += c * l, s += l;
      }
    }
    if (s === 0)
      return g.create(m.DIV_BY_ZERO);
    const o = n / s;
    return y.create(o);
  }
}
class Z_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0), r = y.create(0);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if ((s.isString() || s.isBoolean()) && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o == null || o.isNull())
            return !0;
          let u = o;
          if (u.isString() && (u = u.convertToNumberObjectValue(), u.isError() && (u = y.create(0))), u.isBoolean() && (u = u.convertToNumberObjectValue()), u.isError())
            return t = u, !1;
          t = t.plus(u), r = r.plus(y.create(1));
        }), t.isError())
          return t;
      } else s.isNull() || (t = t.plus(s), r = r.plus(y.create(1)));
    }
    return t.divided(r);
  }
}
class z_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    if (!e.isReferenceObject() || r && !r.isReferenceObject())
      return g.create(m.VALUE);
    let n = t;
    if (t.isReferenceObject() && (n = t.toArrayValueObject()), n.isArray()) {
      const s = n.mapValue((o) => this._handleSingleObject(e, o, r));
      return s.getRowCount() === 1 && s.getColumnCount() === 1 ? s.get(0, 0) : s;
    }
    return this._handleSingleObject(e, n, r);
  }
  _handleSingleObject(e, t, r) {
    const n = e.toArrayValueObject();
    let s = Zn(n, t);
    s = zn(s, n, t);
    const o = n.getRowCount(), u = n.getColumnCount();
    let c = n;
    if (r) {
      c = r.toArrayValueObject();
      const d = c.getRowCount(), _ = c.getColumnCount();
      if (o !== d || u !== _) {
        const C = r.getRangeData();
        C.endRow = C.startRow + o - 1, C.endColumn = C.startColumn + u - 1, r.setRangeData(C), c = r.toArrayValueObject();
      }
    }
    const l = c.pick(s), f = l.sum(), h = l.count();
    return f.divided(h);
  }
}
class J_ extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(m.VALUE) : O(o, u, g.create(m.VALUE));
    const f = $r(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s), u = o.sum(), c = o.count();
      return u.divided(c);
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : q.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class eA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = s != null ? s : y.create(0), c = o != null ? o : y.create(1);
    u.isNull() && (u = y.create(0)), c.isNull() && (c = y.create(1));
    const l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, e, g.create(m.NA)), d = O(l, f, t, g.create(m.NA)), _ = O(l, f, r, g.create(m.NA)), C = O(l, f, n, g.create(m.NA)), E = O(l, f, u, g.create(m.NA)), b = O(l, f, c, g.create(m.NA)), R = h.mapValue((p, N, M) => {
      const w = d.get(N, M), S = _.get(N, M), D = C.get(N, M), L = E.get(N, M), U = b.get(N, M);
      return this._handleSingleObject(p, w, S, D, L, U);
    });
    return l === 1 && f === 1 ? R.get(0, 0) : R;
  }
  _handleSingleObject(e, t, r, n, s, o) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    if (o.isError())
      return o;
    const { isError: u, errorObject: c, variants: l } = B(e, t, r, n, s, o);
    if (u)
      return c;
    const [f, h, d, _, C, E] = l, b = +f.getValue(), R = +h.getValue(), p = +d.getValue(), N = +_.getValue(), M = +C.getValue(), w = +E.getValue();
    if (R <= 0 || p <= 0 || b < M || b > w || M === w)
      return g.create(m.NUM);
    let S;
    return N ? S = $o((b - M) / (w - M), R, p) : S = um((b - M) / (w - M), R, p) / (w - M), y.create(S);
  }
}
class tA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = n != null ? n : r;
    s.isNull() && (s = r);
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(m.NA)), l = O(o, u, t, g.create(m.NA)), f = O(o, u, r, g.create(m.NA)), h = O(o, u, s, g.create(m.NA)), d = c.mapValue((_, C, E) => {
      const b = l.get(C, E), R = f.get(C, E), p = h.get(C, E);
      return _.isError() ? _ : b.isError() ? b : R.isError() ? R : p.isError() ? p : this._handleSingleObject(_, b, R, p);
    });
    return o === 1 && u === 1 ? d.get(0, 0) : d;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = Math.floor(+c.getValue()), _ = +l.getValue(), C = Math.floor(+f.getValue()), E = Math.floor(+h.getValue());
    if (d < 0 || _ < 0 || _ > 1 || C < 0 || C > d || E < 0 || E < C || E > d)
      return g.create(m.NUM);
    let b = 0;
    for (let R = C; R <= E; R++)
      b += va(R, d, _);
    return y.create(b);
  }
}
class rA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = Math.floor(+c.getValue()), d = +l.getValue();
    if (f < 0 || h < 1 || h > 10 ** 10)
      return g.create(m.NUM);
    let _;
    return d ? _ = Ta(f, h) : _ = cm(f, h), y.create(_);
  }
}
class nA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = Ho(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class sA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      if (f.isError())
        return f;
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const { isError: E, errorObject: b, variants: R } = B(f, _, C);
      if (E)
        return b;
      const [p, N, M] = R, w = +p.getValue(), S = +N.getValue(), D = Math.floor(+M.getValue());
      if (w <= 0 || w >= 1 || S <= 0 || D < 1)
        return g.create(m.NUM);
      if (D === 1)
        return g.create(m.DIV_BY_ZERO);
      const L = Math.abs(rs(w / 2, D - 1) * S / Math.sqrt(D));
      return y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class aA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(m.VALUE) : g.create(m.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++) {
      const _ = e[d] - o, C = t[d] - u;
      c += _ * C, l += _ ** 2, f += C ** 2;
    }
    const h = Math.sqrt(l * f);
    return h === 0 ? g.create(m.DIV_BY_ZERO) : y.create(c / h);
  }
}
class iA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      n.isError() || (n.isArray() ? t = t.plus(n.count()) : n.isString() ? n.convertToNumberObjectValue().isError() || (t = t.plus(y.create(1))) : n.isNull() || (t = t.plus(y.create(1))));
    }
    return t;
  }
}
class oA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isError()) {
        t = t.plus(y.create(1));
        continue;
      }
      n.isArray() ? (n = n.countA(), t = t.plus(n)) : n.isNull() || (t = t.plus(y.create(1)));
    }
    return t;
  }
}
class uA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.getValue() === "" || e.isNull() ? y.create(1) : e.isArray() ? e.countBlank() : y.create(0);
  }
}
class cA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t) {
    if (!e.isReferenceObject())
      return g.create(m.VALUE);
    let r = t;
    if (t.isReferenceObject() && (r = t.toArrayValueObject()), r.isArray()) {
      const n = r.mapValue((s) => this._handleSingleObject(e, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t) {
    const r = e.toArrayValueObject();
    let n = Zn(r, t);
    n = zn(n, r, t);
    const s = r.pick(n);
    return this._countA(s);
  }
  _countA(e) {
    let t = y.create(0);
    return e.iterator((r) => {
      if (r == null)
        return !0;
      t = t.plusBy(1);
    }), t;
  }
}
class lA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(...e) {
    const {
      isError: t,
      errorObject: r,
      rangeIsDifferentSize: n,
      criteriaMaxRowLength: s,
      criteriaMaxColumnLength: o,
      variants: u
    } = kr(e);
    if (t)
      return r;
    if (n)
      return s === 1 && o === 1 ? g.create(m.VALUE) : O(s, o, g.create(m.VALUE));
    const c = $r(u, s, o, !0);
    return this._aggregateResults(c);
  }
  _aggregateResults(e) {
    const t = e.map((r) => r.map((n) => fA(n)));
    return t.length === 1 && t[0].length === 1 ? t[0][0] : q.create({
      calculateValueList: t,
      rowCount: t.length,
      columnCount: t[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
function fA(i) {
  let a = 0;
  return i.iterator((e) => {
    e != null && e.isBoolean() && e.getValue() === !0 && a++;
  }), y.create(a);
}
class hA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(m.VALUE);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    if (e.length <= 1)
      return g.create(m.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let l = 0; l < r; l++)
      n += e[l], s += t[l];
    const o = n / r, u = s / r;
    let c = 0;
    for (let l = 0; l < r; l++) {
      const f = e[l] - o, h = t[l] - u;
      c += f * h;
    }
    return y.create(c / (r - 1));
  }
}
class mA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0, n = !0;
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      if (c.isArray()) {
        let l = !1, f = g.create(m.VALUE);
        if (c.iterator((h) => {
          const d = this._handleSingleObject(h);
          if (d.isError())
            return l = !0, f = d, !1;
          if (d.isNull())
            return !0;
          const _ = d.getValue();
          t.push(_), r += _, n = !1;
        }), l)
          return f;
      } else {
        const l = this._handleSingleObject(c);
        if (l.isError())
          return l;
        if (l.isNull())
          continue;
        const f = l.getValue();
        t.push(f), r += f, n = !1;
      }
    }
    if (n)
      return g.create(m.NUM);
    const s = r / t.length;
    let o = 0;
    for (let u = 0; u < t.length; u++)
      o += (t[u] - s) ** 2;
    return y.create(o);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull() || e.isBoolean())
      return ce.create();
    const t = e.getValue();
    return W(t) ? y.create(+t) : ce.create();
  }
}
class gA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = +c.getValue(), _ = Math.floor(+l.getValue()), C = Math.floor(+f.getValue()), E = +h.getValue();
    if (d < 0 || _ < 1 || _ > 10 ** 10 || C < 1 || C > 10 ** 10)
      return g.create(m.NUM);
    let b;
    return E ? b = Ba(d, _, C) : b = lm(d, _, C), Number.isNaN(b) || !Number.isFinite(b) ? g.create(m.NUM) : y.create(b);
  }
}
class dA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || f > 1 || h < 1 || h > 10 ** 10 || d < 1 || d > 10 ** 10)
      return g.create(m.NUM);
    const _ = Go(f, h, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : y.create(_);
  }
}
class CA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = s.getValue();
    if (o <= -1 || o >= 1)
      return g.create(m.NUM);
    const u = Math.log((1 + o) / (1 - o)) / 2;
    return y.create(u);
  }
}
class _A extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.exp(2 * o) - 1, c = Math.exp(2 * o) + 1;
    return !Number.isFinite(u) && u > 0 && !Number.isFinite(c) && c > 0 ? y.create(1) : y.create(u / c);
  }
}
class Ti extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t.isArray() ? t.getRowCount() : 1, s = t.isArray() ? t.getColumnCount() : 1, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    let c = t;
    t.isArray() && n === 1 && s === 1 && (c = t.get(0, 0));
    let l = r;
    return r.isArray() && o === 1 && u === 1 && (l = r.get(0, 0)), e.isArray() ? e.mapValue(
      (f) => this._handleSingleObject(f, c, l, n, s, o, u)
    ) : this._handleSingleObject(e, c, l, n, s, o, u);
  }
  _handleSingleObject(e, t, r, n, s, o, u) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    let c = e;
    if (e.isString() && (c = e.convertToNumberObjectValue()), c.isError())
      return c;
    const l = +c.getValue();
    if ((n * s === 1 || o * u === 1) && (t.isNull() || r.isNull()))
      return g.create(m.VALUE);
    if (n * s !== o * u)
      return g.create(m.NA);
    const {
      isError: f,
      errorObject: h,
      array1Values: d,
      array2Values: _,
      noCalculate: C
    } = rt(
      t,
      r,
      n * s,
      s,
      u
    );
    if (f)
      return h;
    if (C)
      return g.create(m.DIV_BY_ZERO);
    const E = Qo(l, d, _);
    return Number.isFinite(E) ? y.create(E) : g.create(m.DIV_BY_ZERO);
  }
}
class AA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, values: s } = this._getValues(e);
    if (r)
      return n;
    if (e.isNull() || t.isNull())
      return g.create(m.VALUE);
    let { values: o } = this._getValues(t, !0);
    o.length === 0 && (o = [0]);
    const u = this._getNewBinsArrayValues(o), c = new Array(u.length).fill(0);
    for (let l = 0; l < s.length; l++) {
      const f = s[l], h = u.findIndex((d) => f > d.start && f <= d.end);
      c[h]++;
    }
    return q.createByArray(c.map((l) => [l]));
  }
  _getValues(e, t = !1) {
    const r = [], n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    for (let o = 0; o < n; o++)
      for (let u = 0; u < s; u++) {
        const c = e.isArray() ? e.get(o, u) : e;
        if (c.isError()) {
          if (!t)
            return {
              isError: !0,
              errorObject: c,
              values: r
            };
          continue;
        }
        if (c.isNull() || c.isBoolean())
          continue;
        const l = c.getValue();
        W(l) && r.push(+l);
      }
    return {
      isError: !1,
      errorObject: null,
      values: r
    };
  }
  _getNewBinsArrayValues(e) {
    const t = e.map((n, s) => ({
      value: n,
      index: s
    })).sort((n, s) => n.value - s.value), r = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n].index;
      if (n === 0) {
        r[s] = {
          start: -1 / 0,
          end: t[n].value
        };
        continue;
      }
      r[s] = {
        start: t[n - 1].value,
        end: t[n].value
      };
    }
    return r.push({
      start: t[t.length - 1].value,
      end: 1 / 0
    }), r;
  }
}
var v = /* @__PURE__ */ ((i) => (i.AVEDEV = "AVEDEV", i.AVERAGE = "AVERAGE", i.AVERAGE_WEIGHTED = "AVERAGE.WEIGHTED", i.AVERAGEA = "AVERAGEA", i.AVERAGEIF = "AVERAGEIF", i.AVERAGEIFS = "AVERAGEIFS", i.BETA_DIST = "BETA.DIST", i.BETA_INV = "BETA.INV", i.BINOM_DIST = "BINOM.DIST", i.BINOM_DIST_RANGE = "BINOM.DIST.RANGE", i.BINOM_INV = "BINOM.INV", i.CHISQ_DIST = "CHISQ.DIST", i.CHISQ_DIST_RT = "CHISQ.DIST.RT", i.CHISQ_INV = "CHISQ.INV", i.CHISQ_INV_RT = "CHISQ.INV.RT", i.CHISQ_TEST = "CHISQ.TEST", i.CONFIDENCE_NORM = "CONFIDENCE.NORM", i.CONFIDENCE_T = "CONFIDENCE.T", i.CORREL = "CORREL", i.COUNT = "COUNT", i.COUNTA = "COUNTA", i.COUNTBLANK = "COUNTBLANK", i.COUNTIF = "COUNTIF", i.COUNTIFS = "COUNTIFS", i.COVARIANCE_P = "COVARIANCE.P", i.COVARIANCE_S = "COVARIANCE.S", i.DEVSQ = "DEVSQ", i.EXPON_DIST = "EXPON.DIST", i.F_DIST = "F.DIST", i.F_DIST_RT = "F.DIST.RT", i.F_INV = "F.INV", i.F_INV_RT = "F.INV.RT", i.F_TEST = "F.TEST", i.FISHER = "FISHER", i.FISHERINV = "FISHERINV", i.FORECAST = "FORECAST", i.FORECAST_ETS = "FORECAST.ETS", i.FORECAST_ETS_CONFINT = "FORECAST.ETS.CONFINT", i.FORECAST_ETS_SEASONALITY = "FORECAST.ETS.SEASONALITY", i.FORECAST_ETS_STAT = "FORECAST.ETS.STAT", i.FORECAST_LINEAR = "FORECAST.LINEAR", i.FREQUENCY = "FREQUENCY", i.GAMMA = "GAMMA", i.GAMMA_DIST = "GAMMA.DIST", i.GAMMA_INV = "GAMMA.INV", i.GAMMALN = "GAMMALN", i.GAMMALN_PRECISE = "GAMMALN.PRECISE", i.GAUSS = "GAUSS", i.GEOMEAN = "GEOMEAN", i.GROWTH = "GROWTH", i.HARMEAN = "HARMEAN", i.HYPGEOM_DIST = "HYPGEOM.DIST", i.INTERCEPT = "INTERCEPT", i.KURT = "KURT", i.LARGE = "LARGE", i.LINEST = "LINEST", i.LOGEST = "LOGEST", i.LOGNORM_DIST = "LOGNORM.DIST", i.LOGNORM_INV = "LOGNORM.INV", i.MARGINOFERROR = "MARGINOFERROR", i.MAX = "MAX", i.MAXA = "MAXA", i.MAXIFS = "MAXIFS", i.MEDIAN = "MEDIAN", i.MIN = "MIN", i.MINA = "MINA", i.MINIFS = "MINIFS", i.MODE_MULT = "MODE.MULT", i.MODE_SNGL = "MODE.SNGL", i.NEGBINOM_DIST = "NEGBINOM.DIST", i.NORM_DIST = "NORM.DIST", i.NORM_INV = "NORM.INV", i.NORM_S_DIST = "NORM.S.DIST", i.NORM_S_INV = "NORM.S.INV", i.PEARSON = "PEARSON", i.PERCENTILE_EXC = "PERCENTILE.EXC", i.PERCENTILE_INC = "PERCENTILE.INC", i.PERCENTRANK_EXC = "PERCENTRANK.EXC", i.PERCENTRANK_INC = "PERCENTRANK.INC", i.PERMUT = "PERMUT", i.PERMUTATIONA = "PERMUTATIONA", i.PHI = "PHI", i.POISSON_DIST = "POISSON.DIST", i.PROB = "PROB", i.QUARTILE_EXC = "QUARTILE.EXC", i.QUARTILE_INC = "QUARTILE.INC", i.RANK_AVG = "RANK.AVG", i.RANK_EQ = "RANK.EQ", i.RSQ = "RSQ", i.SKEW = "SKEW", i.SKEW_P = "SKEW.P", i.SLOPE = "SLOPE", i.SMALL = "SMALL", i.STANDARDIZE = "STANDARDIZE", i.STDEV_P = "STDEV.P", i.STDEV_S = "STDEV.S", i.STDEVA = "STDEVA", i.STDEVPA = "STDEVPA", i.STEYX = "STEYX", i.T_DIST = "T.DIST", i.T_DIST_2T = "T.DIST.2T", i.T_DIST_RT = "T.DIST.RT", i.T_INV = "T.INV", i.T_INV_2T = "T.INV.2T", i.T_TEST = "T.TEST", i.TREND = "TREND", i.TRIMMEAN = "TRIMMEAN", i.VAR_P = "VAR.P", i.VAR_S = "VAR.S", i.VARA = "VARA", i.VARPA = "VARPA", i.WEIBULL_DIST = "WEIBULL.DIST", i.Z_TEST = "Z.TEST", i))(v || {});
class EA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o === 0 || o < 0 && o % 1 === 0)
      return g.create(m.NUM);
    const u = mn(o);
    return Number.isNaN(u) || !Number.isFinite(u) ? g.create(m.NUM) : y.create(u);
  }
}
class Bi extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o <= 0)
      return g.create(m.NUM);
    const u = ft(o);
    return Math.abs(u) < 1e-15 ? y.create(0) : y.create(u);
  }
}
class bA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Hr(o, 0, 1) - 0.5;
    return y.create(u);
  }
}
class yA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 1, r = 0, n = !1;
    for (let o = 0; o < e.length; o++) {
      const u = e[o];
      if (u.isArray()) {
        let c = !1, l = g.create(m.VALUE);
        if (u.iterator((f) => {
          if (f != null && f.isError())
            return c = !0, l = f, !1;
          if (f != null && f.isNull() || f != null && f.isBoolean())
            return !0;
          const h = f.getValue();
          if (!W(h))
            return !0;
          +h <= 0 && (n = !0), t *= +h, r++;
        }), c)
          return l;
      } else {
        if (u.isError())
          return u;
        if (u.isString()) {
          const l = u.convertToNumberObjectValue();
          if (l.isError())
            return l;
        }
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        if (!W(c))
          continue;
        +c <= 0 && (n = !0), t *= +c, r++;
      }
    }
    if (r === 0 || n)
      return g.create(m.NUM);
    const s = t ** (1 / r);
    return y.create(s);
  }
}
class RA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = ns(e, t, r);
    if (s)
      return o;
    const u = Et(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    const l = this._getNewXsValues(c, r);
    if (l instanceof g)
      return l;
    let f = n != null ? n : T.create(!0);
    if (f.isArray() && (f = f.get(0, 0)), f.isString() && (f = f.convertToNumberObjectValue()), f.isError())
      return f;
    const h = +f.getValue();
    return this._getResult(u, c, l, h);
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (n ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (n ? t[0].length + 1 : t[0].length) > e.length ? g.create(m.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = e.length === 1 && e[0].length > 1, o = is(e, t, r, n, !0);
    if (o instanceof g)
      return o;
    const { coefficients: u, newX: c } = o, l = u[0].length, f = u[0][l - 1];
    let h = [];
    for (let d = 0; d < c.length; d++) {
      h[d] = [];
      let _ = f;
      for (let C = l - 2; C >= 0; C--)
        _ *= u[0][l - 2 - C] ** c[d][C];
      h[d].push(_);
    }
    return s && (h = Ct(h)), q.createByArray(h);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = as(o, s, n, !0), l = r.map((f) => f.map((h) => c * u ** h));
    return q.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? ss(e.length, e[0].length) : Et(t);
  }
  _getNewXsValues(e, t) {
    return !t || t.isNull() ? e : Et(t);
  }
}
class pA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 0, n = !1;
    for (let o = 0; o < e.length; o++) {
      const u = e[o];
      if (u.isArray()) {
        let c = !1, l = g.create(m.VALUE);
        if (u.iterator((f) => {
          if (f != null && f.isError())
            return c = !0, l = f, !1;
          if (f != null && f.isNull() || f != null && f.isBoolean())
            return !0;
          const h = f.getValue();
          if (!W(h))
            return !0;
          +h <= 0 && (n = !0), t += 1 / +h, r++;
        }), c)
          return l;
      } else {
        if (u.isError())
          return u;
        if (u.isString()) {
          const l = u.convertToNumberObjectValue();
          if (l.isError())
            return l;
        }
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        if (!W(c))
          continue;
        +c <= 0 && (n = !0), t += 1 / +c, r++;
      }
    }
    if (r === 0)
      return g.create(m.NA);
    if (n)
      return g.create(m.NUM);
    const s = r / t;
    return y.create(s);
  }
}
class VA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(m.NA)), l = O(o, u, t, g.create(m.NA)), f = O(o, u, r, g.create(m.NA)), h = O(o, u, n, g.create(m.NA)), d = O(o, u, s, g.create(m.NA)), _ = c.mapValue((C, E, b) => {
      const R = l.get(E, b), p = f.get(E, b), N = h.get(E, b), M = d.get(E, b);
      return C.isError() ? C : R.isError() ? R : p.isError() ? p : N.isError() ? N : M.isError() ? M : this._handleSingleObject(C, R, p, N, M);
    });
    return o === 1 && u === 1 ? _.get(0, 0) : _;
  }
  _handleSingleObject(e, t, r, n, s) {
    const { isError: o, errorObject: u, variants: c } = B(e, t, r, n, s);
    if (o)
      return u;
    const [l, f, h, d, _] = c, C = Math.floor(+l.getValue()), E = Math.floor(+f.getValue()), b = Math.floor(+h.getValue()), R = Math.floor(+d.getValue()), p = +_.getValue();
    if (C < 0 || C > E || C > b || C < E - R + b || E <= 0 || E > R || b <= 0 || b > R || R <= 0)
      return g.create(m.NUM);
    let N;
    return p ? N = Cm(C, E, b, R) : N = Fa(C, E, b, R), Number.isNaN(N) && (N = 0), y.create(N);
  }
}
class NA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(m.VALUE) : g.create(m.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    const r = Qo(0, e, t);
    return Number.isFinite(r) ? y.create(r) : g.create(m.DIV_BY_ZERO);
  }
}
class OA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = s.isArray() ? s.get(c, l) : s;
          if (f.isError())
            return f;
          if (f.isNull() || f.isBoolean())
            continue;
          const h = f.getValue();
          W(h) && (t.push(+h), r += +h);
        }
    }
    return t.length <= 3 ? g.create(m.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += (e[l] - n) ** 2;
    const o = Math.sqrt(s / (r - 1));
    if (o === 0)
      return g.create(m.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += ((e[l] - n) / o) ** 4;
    const c = r * (r + 1) / ((r - 1) * (r - 2) * (r - 3)) * u - 3 * (r - 1) ** 2 / ((r - 2) * (r - 3));
    return y.create(c);
  }
}
class MA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s;
    let u = +o.getValue();
    return u < 1 || u > e.length ? g.create(m.NUM) : (u = Math.ceil(u), y.create(e[u - 1]));
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => o - s);
  }
}
class wA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = ns(e, t);
    if (s)
      return o;
    const u = Et(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    let l = r != null ? r : T.create(!0);
    l.isArray() && (l = l.get(0, 0));
    let f = n != null ? n : T.create(!1);
    f.isArray() && (f = f.get(0, 0));
    const { isError: h, errorObject: d, variants: _ } = B(l, f);
    if (h)
      return d;
    const [C, E] = _;
    return this._getResult(u, c, +C.getValue(), +E.getValue());
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (r ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (r ? t[0].length + 1 : t[0].length) > e.length ? g.create(m.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = is(e, t, t, r, !1);
    if (s instanceof g)
      return s;
    const { coefficients: o, X: u, XTXInverse: c } = s;
    let l = [];
    if (n) {
      const f = e.flat(), h = f.length, d = r ? f.reduce((x, k) => x + k, 0) / h : 0, _ = c.length, C = h - _, E = o[0].length, b = new Array(E - 2).fill(m.NA), R = o[0][E - 1], p = [];
      for (let x = 0; x < u.length; x++) {
        let k = R;
        for (let Q = E - 2; Q >= 0; Q--)
          k += o[0][E - 2 - Q] * u[x][Q];
        p.push(k);
      }
      let N = 0, M = 0;
      for (let x = 0; x < h; x++)
        N += (f[x] - d) ** 2, M += (f[x] - p[x]) ** 2;
      const w = N - M, S = N === 0 ? 0 : w / N, D = [];
      for (let x = _ - 1; x >= 0; x--) {
        const k = C > 0 ? Math.sqrt(M / C * c[x][x]) : 0;
        D.push(k);
      }
      if (r) {
        const x = D.shift();
        D.push(x);
      } else
        D.push(m.NA);
      const L = C > 0 ? Math.sqrt(M / C) : 0, U = C > 0 ? w / (E - 1) / (M / C) : m.NUM;
      l = [
        o[0],
        // [mn, mn-1, ..., m1, b]
        [...D],
        // [sen, sen-1, ..., se1, seb]
        [S, L, ...b],
        // [r2, sey]
        [U, C, ...b],
        // [F, df]
        [w, M, ...b]
        // [ssreg, ssresid]
      ];
    } else
      l = [
        o[0]
        // [mn, mn-1, ..., m1, b]
      ];
    return q.createByArray(l);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = as(o, s, r, !1);
    if (Number.isNaN(u))
      return g.create(m.NA);
    let l = [];
    if (n) {
      const f = s.length;
      let h = 0, d = 0, _ = f - 1;
      if (r) {
        let D = 0, L = 0;
        for (let U = 0; U < f; U++)
          D += s[U], L += o[U];
        h = D / f, d = L / f, _ = f - 2;
      }
      let C = 0, E = 0, b = 0;
      for (let D = 0; D < f; D++)
        C += (s[D] - h) ** 2, E += (s[D] - (u * o[D] + c)) ** 2, b += (o[D] - d) ** 2;
      const R = C - E, p = R === C ? 1 : R / C;
      let N = 0, M = 0, w = 0;
      _ > 0 && (b > 0 && (N = Math.sqrt(E / _ / b), M = Math.sqrt(E / _ * (1 / f + d ** 2 / b))), w = Math.sqrt(E / _));
      const S = _ > 0 ? R / 1 / (E / _) : m.NUM;
      r || (M = m.NA), l = [
        [u, c],
        // [m, b]
        [N, M],
        // [se, seb]
        [p, w],
        // [r2, sey]
        [S, _],
        // [F, df]
        [R, E]
        // [ssreg, ssresid]
      ];
    } else
      l = [
        [u, c]
        // [m, b]
      ];
    return q.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? ss(e.length, e[0].length) : Et(t);
  }
}
class SA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = ns(e, t);
    if (s)
      return o;
    const u = Et(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    let l = r != null ? r : T.create(!0);
    l.isArray() && (l = l.get(0, 0));
    let f = n != null ? n : T.create(!1);
    f.isArray() && (f = f.get(0, 0));
    const { isError: h, errorObject: d, variants: _ } = B(l, f);
    if (h)
      return d;
    const [C, E] = _;
    return this._getResult(u, c, +C.getValue(), +E.getValue());
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (r ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (r ? t[0].length + 1 : t[0].length) > e.length ? g.create(m.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  // eslint-disable-next-line max-lines-per-function
  _getResultByMultipleVariables(e, t, r, n) {
    const s = is(e, t, t, r, !0);
    if (s instanceof g)
      return s;
    const { coefficients: o, Y: u, X: c, XTXInverse: l } = s;
    let f = [];
    if (n) {
      const h = u.flat(), d = h.length, _ = r ? h.reduce((k, Q) => k + Q, 0) / d : 0, C = l.length, E = d - C, b = o[0].length, R = new Array(b - 2).fill(m.NA), p = o[0][b - 1], N = [];
      for (let k = 0; k < c.length; k++) {
        let Q = p;
        for (let ne = b - 2; ne >= 0; ne--)
          Q *= o[0][b - 2 - ne] ** c[k][ne];
        N.push(Math.log(Q));
      }
      let M = 0, w = 0;
      for (let k = 0; k < d; k++)
        M += (h[k] - _) ** 2, !(!r && !Number.isFinite(N[k])) && (w += (h[k] - N[k]) ** 2);
      Number.isFinite(w) || (w = 0);
      const S = M - w, D = M === 0 ? 0 : S / M, L = [];
      for (let k = C - 1; k >= 0; k--) {
        const Q = E > 0 ? Math.sqrt(w / E * l[k][k]) : 0;
        L.push(Q);
      }
      if (r) {
        const k = L.shift();
        L.push(k);
      } else
        L.push(m.NA);
      const U = E > 0 ? Math.sqrt(w / E) : 0, x = E > 0 ? S / (b - 1) / (w / E) : m.NUM;
      f = [
        o[0],
        // [mn, mn-1, ..., m1, b]
        [...L],
        // [sen, sen-1, ..., se1, seb]
        [D, U, ...R],
        // [r2, sey]
        [x, E, ...R],
        // [F, df]
        [S, w, ...R]
        // [ssreg, ssresid]
      ];
    } else
      f = [
        o[0]
        // [mn, mn-1, ..., m1, b]
      ];
    return q.createByArray(f);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c, Y: l } = as(o, s, r, !0);
    if (Number.isNaN(u))
      return g.create(m.NA);
    let f = [];
    if (n) {
      const h = l.length;
      let d = 0, _ = 0, C = h - 1;
      if (r) {
        let L = 0, U = 0;
        for (let x = 0; x < h; x++)
          L += l[x], U += o[x];
        d = L / h, _ = U / h, C = h - 2;
      }
      let E = 0, b = 0, R = 0;
      for (let L = 0; L < h; L++)
        E += (l[L] - d) ** 2, b += (l[L] - Math.log(c * u ** o[L])) ** 2, R += (o[L] - _) ** 2;
      const p = E - b, N = E === 0 ? 0 : p / E;
      let M = 0, w = 0, S = 0, D = 0;
      C > 0 && (R > 0 && (M = Math.sqrt(b / C / R), w = Math.sqrt(b / C * (1 / h + _ ** 2 / R))), S = Math.sqrt(b / C), D = p / 1 / (b / C)), r || (w = m.NA), f = [
        [u, c],
        // [m, b]
        [M, w],
        // [se, seb]
        [N, S],
        // [r2, sey]
        [D, C],
        // [F, df]
        [p, b]
        // [ssreg, ssresid]
      ];
    } else
      f = [
        [u, c]
        // [m, b]
      ];
    return q.createByArray(f);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? ss(e.length, e[0].length) : Et(t);
  }
}
class DA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +h.getValue();
    if (d <= 0 || C <= 0)
      return g.create(m.NUM);
    let b;
    return E ? b = qo(d, _, C) : b = _m(d, _, C), y.create(b);
  }
}
class LA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getRangeValues(e);
    if (r instanceof g)
      return r;
    const n = zt(t);
    if (n.isError())
      return n;
    const { isError: s, errorObject: o, variants: u } = B(n);
    if (s)
      return o;
    const [c] = u, l = +c.getValue();
    if (l <= 0 || l >= 1)
      return g.create(m.NUM);
    if (r.length < 2)
      return g.create(m.DIV_BY_ZERO);
    const f = 1 - l, h = r.length, d = r.reduce((b, R) => b + R, 0) / h, _ = r.reduce((b, R) => b + (R - d) ** 2, 0) / (h - 1), C = Math.sqrt(_);
    if (C <= 0)
      return g.create(m.NUM);
    const E = Math.abs(rs(f / 2, h - 1) * C / Math.sqrt(h));
    return y.create(E);
  }
  _getRangeValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        u.isNull() || u.isBoolean() || u.isString() || t.push(+u.getValue());
      }
    return t;
  }
}
class PA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.NEGATIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isArray() && (n = n.max()), n.isError())
          return n;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.NEGATIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isLessThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class xA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.NEGATIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isError())
          return n;
        if (n.isArray() && n.iterator((s) => {
          let o = s;
          if ((o == null || o.isNull() || o.isString()) && (o = y.create(0)), o.isBoolean() && (o = o.convertToNumberObjectValue()), o.isError())
            return t = o, !1;
          t = this._validator(t, o);
        }), t.isError())
          return t;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.NEGATIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isLessThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class jA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(m.VALUE) : O(o, u, g.create(m.VALUE));
    const f = $r(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s);
      return o.getColumnCount() === 0 ? q.create("0") : o.max();
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : q.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class UA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isArray()) {
        let s = !1, o = g.create(m.VALUE);
        if (n.iterator((u) => {
          if (u != null && u.isError())
            return s = !0, o = u, !1;
          if (u != null && u.isNull() || u != null && u.isBoolean())
            return !0;
          const c = u.getValue();
          if (!W(c))
            return !0;
          t.push(+c);
        }), s)
          return o;
      } else {
        if (n.isError())
          return n;
        if (n.isNull() || n.isBoolean())
          continue;
        if (n.isString()) {
          const o = n.convertToNumberObjectValue();
          if (o.isError())
            return o;
        }
        const s = n.getValue();
        if (!W(s))
          continue;
        t.push(+s);
      }
    }
    return t.length === 0 ? g.create(m.NUM) : this._getResult(t.sort((r, n) => r - n));
  }
  _getResult(e) {
    const t = e.length;
    let r;
    if (t % 2 === 0) {
      const n = t / 2;
      r = (e[n - 1] + e[n]) / 2;
    } else
      r = e[Math.floor(t / 2)];
    return y.create(r);
  }
}
class vA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.POSITIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isArray() && (n = n.min()), n.isError())
          return n;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.POSITIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isGreaterThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class TA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.POSITIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isError())
          return n;
        if (n.isArray() && n.iterator((s) => {
          let o = s;
          if ((o == null || o.isNull() || o.isString()) && (o = y.create(0)), o.isBoolean() && (o = o.convertToNumberObjectValue()), o.isError())
            return t = o, !1;
          t = this._validator(t, o);
        }), t.isError())
          return t;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.POSITIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isGreaterThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class BA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(m.VALUE) : O(o, u, g.create(m.VALUE));
    const f = $r(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s);
      return o.getColumnCount() === 0 ? q.create("0") : o.min();
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : q.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class IA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = {};
    let r = 0, n = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o.isError())
        return o;
      if (o.isString()) {
        const l = o.convertToNumberObjectValue();
        if (l.isError())
          return l;
      }
      const u = o.isArray() ? o.getRowCount() : 1, c = o.isArray() ? o.getColumnCount() : 1;
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const h = o.isArray() ? o.get(l, f) : o;
          if (h.isError())
            return h;
          if (h.isNull() || h.isBoolean() || h.isString())
            continue;
          const d = h.getValue();
          W(d) && (t[+d] ? (t[+d].count++, t[+d].count > n && (n = t[+d].count)) : t[+d] = { count: 1, order: r++ });
        }
    }
    return r === 0 || n === 1 ? new g(m.NA) : this._getResult(t, n);
  }
  _getResult(e, t) {
    const r = Object.entries(e).filter(([n, { count: s }]) => s === t).sort((n, s) => n[1].order - s[1].order).map(([n]) => +n);
    return r.length === 1 ? y.create(r[0]) : q.createByArray(r.map((n) => [n]));
  }
}
class FA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, h] = u, d = Math.floor(+c.getValue()), _ = Math.floor(+l.getValue()), C = +f.getValue(), E = +h.getValue();
    if (d < 0 || _ < 1 || C <= 0 || C >= 1)
      return g.create(m.NUM);
    let b;
    return E ? b = Em(d, _, C) : b = ka(d, _, C), y.create(b);
  }
}
class kA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = +u.getValue();
    let f;
    return l ? f = Hr(c, 0, 1) : f = Ko(c, 0, 1), y.create(f);
  }
}
class $A extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(m.VALUE) : g.create(m.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++)
      c += (e[d] - o) * (t[d] - u), l += (e[d] - o) ** 2, f += (t[d] - u) ** 2;
    if (l === 0 || f === 0)
      return g.create(m.DIV_BY_ZERO);
    const h = c / Math.sqrt(l * f);
    return y.create(h);
  }
}
class YA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue(), c = e.length;
    if (u < 1 / (c + 1) || u > 1 - 1 / (c + 1))
      return g.create(m.NUM);
    const l = u * (c + 1) - 1, f = Math.floor(l), h = l - f;
    if (h === 0)
      return y.create(e[f]);
    const d = e[f] + h * (e[f + 1] - e[f]);
    return y.create(d);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => s - o);
  }
}
class HA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getValues(e);
    let s = r != null ? r : y.create(3);
    s.isNull() && (s = y.create(3));
    const o = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, t, g.create(m.NA)), l = O(o, u, s, g.create(m.NA)), f = c.mapValue((h, d, _) => {
      const C = l.get(d, _);
      return h.isError() ? h : C.isError() ? C : this._handleSingleObject(n, h, C);
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g)
      return e;
    const { isError: n, errorObject: s, variants: o } = B(t, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = Math.floor(+c.getValue()), h = e.length;
    if (h === 0 || l < e[0] || l > e[h - 1])
      return g.create(m.NA);
    if (h === 1)
      return l === e[0] ? y.create(1) : g.create(m.NA);
    let d = 0, _ = !1, C = 0;
    for (; !_ && C < h; )
      l === e[C] ? (d = (C + 1) / (h + 1), _ = !0) : l > e[C] && C + 1 < h && l < e[C + 1] && (d = (C + 1 + (l - e[C]) / (e[C + 1] - e[C])) / (h + 1), _ = !0), C++;
    return _ ? f < 1 ? g.create(m.NUM) : (d = Ke(d, f), y.create(d)) : g.create(m.NA);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.sort((s, o) => s - o);
  }
}
class GA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      if (c.isError())
        return c;
      if (h.isError())
        return h;
      const { isError: d, errorObject: _, variants: C } = B(c, h);
      if (d)
        return _;
      const [E, b] = C, R = Math.floor(+E.getValue()), p = Math.floor(+b.getValue());
      if (R < 0 || R >= 2147483647 || p < 0 || R < p)
        return g.create(m.NUM);
      let N = 1;
      for (let M = R - p + 1; M <= R; M++)
        N *= M;
      return Number.isFinite(N) ? y.create(N) : g.create(m.NUM);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class QA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      if (c.isError())
        return c;
      if (h.isError())
        return h;
      const { isError: d, errorObject: _, variants: C } = B(c, h);
      if (d)
        return _;
      const [E, b] = C, R = Math.floor(+E.getValue()), p = Math.floor(+b.getValue());
      if (R < 0 || R >= 2147483647 || p < 0)
        return g.create(m.NUM);
      if (R === 0)
        return p === 0 ? y.create(1) : y.create(0);
      const N = R ** p;
      return Number.isFinite(N) ? y.create(N) : g.create(m.NUM);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class WA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.exp(-0.5 * o * o) / Math.sqrt(2 * Math.PI);
    return y.create(u);
  }
}
class qA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o, xRangeValues: u, probRangeValues: c } = this._handleXRangeAndProbRange(e, t);
    let l = n != null ? n : r;
    n != null && n.isNull() && (l = r);
    const f = Math.max(
      r.isArray() ? r.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), h = Math.max(
      r.isArray() ? r.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d = O(f, h, r, g.create(m.NA)), _ = O(f, h, l, g.create(m.NA)), C = d.mapValue((E, b, R) => {
      const p = _.get(b, R);
      return e.isError() ? e : t.isError() ? t : E.isError() ? E : p.isError() ? p : s ? o : this._handleSingleObject(u, c, E, p);
    });
    return f === 1 && h === 1 ? C.get(0, 0) : C;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(r, n);
    if (s)
      return o;
    const [c, l] = u, f = +c.getValue(), h = +l.getValue();
    if (t.reduce((_, C) => _ + C, 0) !== 1)
      return g.create(m.NUM);
    let d = 0;
    for (let _ = 0; _ < e.length; _++)
      e[_] >= f && e[_] <= h && (d += t[_]);
    return y.create(d);
  }
  // eslint-disable-next-line
  _handleXRangeAndProbRange(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return {
        isError: !0,
        errorObject: u,
        xRangeValues: [],
        probRangeValues: []
      };
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return {
        isError: !0,
        errorObject: c,
        xRangeValues: [],
        probRangeValues: []
      };
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return {
        isError: !0,
        errorObject: g.create(m.VALUE),
        xRangeValues: [],
        probRangeValues: []
      };
    if (r * n !== s * o)
      return {
        isError: !0,
        errorObject: g.create(m.NA),
        xRangeValues: [],
        probRangeValues: []
      };
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? {
      isError: !0,
      errorObject: f,
      xRangeValues: [],
      probRangeValues: []
    } : _ ? {
      isError: !0,
      errorObject: g.create(m.DIV_BY_ZERO),
      xRangeValues: [],
      probRangeValues: []
    } : {
      isError: !1,
      errorObject: null,
      xRangeValues: h,
      probRangeValues: d
    };
  }
}
class KA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    if (u <= 0 || u >= 4)
      return g.create(m.NUM);
    const c = u / 4, l = e.length;
    if (c < 1 / (l + 1) || c > 1 - 1 / (l + 1))
      return g.create(m.NUM);
    const f = c * (l + 1) - 1, h = Math.floor(f), d = f - h;
    if (d === 0)
      return y.create(e[h]);
    const _ = e[h] + d * (e[h + 1] - e[h]);
    return y.create(_);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => s - o);
  }
}
class XA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, n, g.create(m.NA)), d = O(l, f, c, g.create(m.NA)), _ = h.map((C, E, b) => {
      const R = d.get(E, b);
      if (!e.isReferenceObject() && e.isNull())
        return g.create(m.NA);
      if (s)
        return o;
      if (R.isError())
        return R;
      const p = +C.getValue(), N = +R.getValue();
      return Number.isNaN(p) || Number.isNaN(N) ? g.create(m.VALUE) : this._getResult(p, N, u);
    });
    return l === 1 && f === 1 ? _.get(0, 0) : _;
  }
  _getResult(e, t, r) {
    const n = r.sort((c, l) => t ? c - l : l - c);
    let s = n.indexOf(e);
    const o = [];
    for (; s >= 0; ) {
      const c = s + 1;
      o.push(c), s = n.indexOf(e, c);
    }
    if (o.length === 0)
      return g.create(m.NA);
    const u = o.reduce((c, l) => c + l, 0) / o.length;
    return y.create(u);
  }
  _checkRefReferenceObject(e) {
    let t = !1, r = g.create(m.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = !0, r = u, !1;
      if (u.isNull() || u.isBoolean())
        return !0;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return !0;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: !0,
      refErrorObject: r,
      refNumbers: n
    };
  }
}
class ZA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), h = O(l, f, n, g.create(m.NA)), d = O(l, f, c, g.create(m.NA)), _ = h.map((C, E, b) => {
      const R = d.get(E, b);
      if (!e.isReferenceObject() && e.isNull())
        return g.create(m.NA);
      if (s)
        return o;
      if (R.isError())
        return R;
      const p = +C.getValue(), N = +R.getValue();
      if (Number.isNaN(p) || Number.isNaN(N))
        return g.create(m.VALUE);
      const w = u.sort((S, D) => N ? S - D : D - S).indexOf(p);
      return w === -1 ? g.create(m.NA) : y.create(w + 1);
    });
    return l === 1 && f === 1 ? _.get(0, 0) : _;
  }
  _checkRefReferenceObject(e) {
    let t = !1, r = g.create(m.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = !0, r = u, !1;
      if (u.isNull() || u.isBoolean())
        return !0;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return !0;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: !0,
      refErrorObject: r,
      refNumbers: n
    };
  }
}
class zA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(m.VALUE);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    if (e.length === 0)
      return g.create(m.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++)
      c += (e[d] - o) * (t[d] - u), l += (e[d] - o) ** 2, f += (t[d] - u) ** 2;
    if (l === 0 || f === 0)
      return g.create(m.DIV_BY_ZERO);
    const h = (c / Math.sqrt(l * f)) ** 2;
    return y.create(h);
  }
}
class JA extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = s.isArray() ? s.get(c, l) : s;
          if (f.isError())
            return f;
          if (f.isNull() || f.isBoolean())
            continue;
          const h = f.getValue();
          W(h) && (t.push(+h), r += +h);
        }
    }
    return t.length <= 2 ? g.create(m.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += (e[l] - n) ** 2;
    const o = Math.sqrt(s / (r - 1));
    if (o === 0)
      return g.create(m.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += ((e[l] - n) / o) ** 3;
    const c = r / ((r - 1) * (r - 2)) * u;
    return y.create(c);
  }
}
class eE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = s.isArray() ? s.get(c, l) : s;
          if (f.isError())
            return f;
          if (f.isNull() || f.isBoolean())
            continue;
          const h = f.getValue();
          W(h) && (t.push(+h), r += +h);
        }
    }
    return t.length <= 2 ? g.create(m.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += (e[l] - n) ** 2;
    const o = Math.sqrt(s / r);
    if (o === 0)
      return g.create(m.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += ((e[l] - n) / o) ** 3;
    const c = u / r;
    return y.create(c);
  }
}
class tE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(m.VALUE) : g.create(m.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let h = 0; h < r; h++)
      n += e[h], s += t[h];
    const o = n / r, u = s / r;
    let c = 0, l = 0;
    for (let h = 0; h < r; h++)
      c += (e[h] - o) * (t[h] - u), l += (t[h] - u) ** 2;
    if (l === 0)
      return g.create(m.DIV_BY_ZERO);
    const f = c / l;
    return y.create(f);
  }
}
class rE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s;
    let u = +o.getValue();
    return u < 1 || u > e.length ? g.create(m.NUM) : (u = Math.floor(u), y.create(e[u - 1]));
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => s - o);
  }
}
class nE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = +c.getValue(), d = +l.getValue();
    if (d <= 0)
      return g.create(m.NUM);
    const _ = (f - h) / d;
    return y.create(_);
  }
}
class sE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.std(1);
  }
}
class aE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.std();
  }
}
class iE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(m.VALUE);
    if (r * n !== s * o)
      return g.create(m.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: h,
      array2Values: d,
      noCalculate: _
    } = rt(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(m.DIV_BY_ZERO) : this._getResult(h, d);
  }
  _getResult(e, t) {
    const r = e.length;
    if (r <= 2)
      return g.create(m.DIV_BY_ZERO);
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++)
      c += (e[d] - o) * (t[d] - u), l += (e[d] - o) ** 2, f += (t[d] - u) ** 2;
    if (f === 0)
      return g.create(m.DIV_BY_ZERO);
    const h = Math.sqrt((l - c ** 2 / f) / (r - 2));
    return Number.isNaN(h) || !Number.isFinite(h) ? g.create(m.NUM) : y.create(h);
  }
}
class oE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), h = Math.floor(+c.getValue()), d = +l.getValue();
    if (h < 1)
      return g.create(m.NUM);
    let _;
    return d ? _ = Gr(f, h) : _ = ym(f, h), Number.isNaN(_) || !Number.isFinite(_) ? g.create(m.NUM) : y.create(_);
  }
}
class uE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = Gr(-c, l) * 2;
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class cE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = Gr(-c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class lE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c <= 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(m.NUM);
    const f = rs(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(m.NUM) : y.create(f);
  }
}
class fE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = ns(e, t, r);
    if (s)
      return o;
    const u = Et(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    const l = this._getNewXsValues(c, r);
    if (l instanceof g)
      return l;
    let f = n != null ? n : T.create(!0);
    if (f.isArray() && (f = f.get(0, 0)), f.isString() && (f = f.convertToNumberObjectValue()), f.isError())
      return f;
    const h = +f.getValue();
    return this._getResult(u, c, l, h);
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (n ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (n ? t[0].length + 1 : t[0].length) > e.length ? g.create(m.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = e.length === 1 && e[0].length > 1, o = is(e, t, r, n, !1);
    if (o instanceof g)
      return o;
    const { coefficients: u, newX: c } = o, l = u[0].length, f = u[0][l - 1];
    let h = [];
    for (let d = 0; d < c.length; d++) {
      h[d] = [];
      let _ = f;
      for (let C = l - 2; C >= 0; C--)
        _ += u[0][l - 2 - C] * c[d][C];
      h[d].push(_);
    }
    return s && (h = Ct(h)), q.createByArray(h);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = as(o, s, n, !1);
    if (Number.isNaN(u))
      return g.create(m.NA);
    const l = r.map((f) => f.map((h) => u * h + c));
    return q.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? ss(e.length, e[0].length) : Et(t);
  }
  _getNewXsValues(e, t) {
    return !t || t.isNull() ? e : Et(t);
  }
}
class hE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    if (u < 0 || u >= 1)
      return g.create(m.NUM);
    const c = Ke(e.length * u / 2, 0) * 2, l = e.slice(c / 2, e.length - c / 2), f = l.reduce((h, d) => h + d, 0) / l.length;
    return y.create(f);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        W(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(m.NUM) : n.sort((s, o) => s - o);
  }
}
class mE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.var(1);
  }
}
class gE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.var();
  }
}
const dE = [
  [W_, v.AVEDEV],
  [K_, v.AVERAGE],
  [X_, v.AVERAGE_WEIGHTED],
  [Z_, v.AVERAGEA],
  [z_, v.AVERAGEIF],
  [J_, v.AVERAGEIFS],
  [eA, v.BETA_DIST],
  [Zo, v.BETA_INV],
  [zo, v.BINOM_DIST],
  [tA, v.BINOM_DIST_RANGE],
  [Jo, v.BINOM_INV],
  [rA, v.CHISQ_DIST],
  [eu, v.CHISQ_DIST_RT],
  [nA, v.CHISQ_INV],
  [tu, v.CHISQ_INV_RT],
  [ru, v.CHISQ_TEST],
  [nu, v.CONFIDENCE_NORM],
  [sA, v.CONFIDENCE_T],
  [aA, v.CORREL],
  [iA, v.COUNT],
  [oA, v.COUNTA],
  [uA, v.COUNTBLANK],
  [cA, v.COUNTIF],
  [lA, v.COUNTIFS],
  [su, v.COVARIANCE_P],
  [hA, v.COVARIANCE_S],
  [mA, v.DEVSQ],
  [au, v.EXPON_DIST],
  [gA, v.F_DIST],
  [iu, v.F_DIST_RT],
  [dA, v.F_INV],
  [ou, v.F_INV_RT],
  [uu, v.F_TEST],
  [CA, v.FISHER],
  [_A, v.FISHERINV],
  [Ti, v.FORECAST],
  [Ti, v.FORECAST_LINEAR],
  [AA, v.FREQUENCY],
  [EA, v.GAMMA],
  [cu, v.GAMMA_DIST],
  [lu, v.GAMMA_INV],
  [Bi, v.GAMMALN],
  [Bi, v.GAMMALN_PRECISE],
  [bA, v.GAUSS],
  [yA, v.GEOMEAN],
  [RA, v.GROWTH],
  [pA, v.HARMEAN],
  [VA, v.HYPGEOM_DIST],
  [NA, v.INTERCEPT],
  [OA, v.KURT],
  [MA, v.LARGE],
  [wA, v.LINEST],
  [SA, v.LOGEST],
  [DA, v.LOGNORM_DIST],
  [fu, v.LOGNORM_INV],
  [LA, v.MARGINOFERROR],
  [PA, v.MAX],
  [xA, v.MAXA],
  [jA, v.MAXIFS],
  [UA, v.MEDIAN],
  [vA, v.MIN],
  [TA, v.MINA],
  [BA, v.MINIFS],
  [IA, v.MODE_MULT],
  [hu, v.MODE_SNGL],
  [FA, v.NEGBINOM_DIST],
  [mu, v.NORM_DIST],
  [gu, v.NORM_INV],
  [kA, v.NORM_S_DIST],
  [du, v.NORM_S_INV],
  [$A, v.PEARSON],
  [YA, v.PERCENTILE_EXC],
  [Cu, v.PERCENTILE_INC],
  [HA, v.PERCENTRANK_EXC],
  [_u, v.PERCENTRANK_INC],
  [GA, v.PERMUT],
  [QA, v.PERMUTATIONA],
  [WA, v.PHI],
  [Au, v.POISSON_DIST],
  [qA, v.PROB],
  [KA, v.QUARTILE_EXC],
  [Eu, v.QUARTILE_INC],
  [XA, v.RANK_AVG],
  [ZA, v.RANK_EQ],
  [zA, v.RSQ],
  [JA, v.SKEW],
  [eE, v.SKEW_P],
  [tE, v.SLOPE],
  [rE, v.SMALL],
  [nE, v.STANDARDIZE],
  [bu, v.STDEV_P],
  [yu, v.STDEV_S],
  [sE, v.STDEVA],
  [aE, v.STDEVPA],
  [iE, v.STEYX],
  [oE, v.T_DIST],
  [uE, v.T_DIST_2T],
  [cE, v.T_DIST_RT],
  [lE, v.T_INV],
  [Ru, v.T_INV_2T],
  [pu, v.T_TEST],
  [fE, v.TREND],
  [hE, v.TRIMMEAN],
  [Vu, v.VAR_P],
  [Nu, v.VAR_S],
  [mE, v.VARA],
  [gE, v.VARPA],
  [Ou, v.WEIBULL_DIST],
  [Mu, v.Z_TEST]
];
class CE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = t != null ? t : y.create(0);
    if (t != null && t.isNull() && (r = y.create(0)), r.isArray()) {
      const n = r.mapValue((s) => this._handleSingleObject(e, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t) {
    const r = this._checkArray(e);
    if (r.isError())
      return r;
    const { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    const [u] = o, c = +u.getValue(), l = e.isArray() ? e.getRowCount() : 1, f = e.isArray() ? e.getColumnCount() : 1;
    let h = "";
    for (let d = 0; d < l; d++)
      for (let _ = 0; _ < f; _++) {
        const C = e.isArray() ? e.get(d, _) : e;
        let E = `${C.getValue()}`;
        C.isNull() && (E = ""), C.isBoolean() && (E = E.toLocaleUpperCase()), C.isString() && c ? h += `"${E}"` : h += E, d === l - 1 && _ === f - 1 || (c ? _ === f - 1 ? h += ";" : h += "," : h += ", ");
      }
    return c && (h = `{${h}}`), h.length > 32767 ? g.create(m.CALC) : j.create(h);
  }
  _checkArray(e) {
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      return t > 1 || r > 1 ? e : e.get(0, 0);
    }
    return e;
  }
}
class _E extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isNull() || e.isBoolean() || e.isNumber())
      return e;
    const t = e.getValue().toLocaleString();
    let r = "";
    for (let n = 0; n < t.length; n++) {
      let s = t.charCodeAt(n);
      s === 12288 ? s = 32 : s >= 65281 && s <= 65374 && (s -= 65248), r += String.fromCharCode(s);
    }
    return j.create(r);
  }
}
class AE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.abs(Number.parseInt(o.toString(), 10)), c = Number.parseFloat((Math.abs(o) - u).toFixed(2));
    let l = "";
    return u === 0 ? c !== 0 ? l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(c * 100)}สตางค์` : l = "ศูนย์บาทถ้วน" : c === 0 ? l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(u)}บาทถ้วน` : l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(u)}บาท${this._convertNumberToThaiText(c * 100)}สตางค์`, j.create(l);
  }
  _convertNumberToThaiText(e) {
    const t = ["ล้าน", "สิบ", "ร้อย", "พัน", "หมื่น", "แสน", ""], r = ["ศูนย์", "หนึ่ง", "สอง", "สาม", "สี่", "ห้า", "หก", "เจ็ด", "แปด", "เก้า"], n = ["ลบ", "บาท", "ถ้วน", "สตางค์", "ยี่", "เอ็ด", ",", " ", "฿"], s = e.toString(), o = s.length;
    let u = "";
    for (let c = o; c > 0; c--) {
      const l = Number.parseInt(s.charAt(o - c), 10);
      let f = r[l];
      const h = c > 1 ? (c - 1) % 6 : 6;
      if (h === 1 && l === 2 && (f = n[4]), l === 1)
        switch (h) {
          case 0:
          case 6:
            u += c < o ? n[5] : f;
            break;
          case 1:
            break;
          default:
            u += f;
            break;
        }
      else if (l === 0) {
        h === 0 && (u += t[h]);
        continue;
      } else
        u += f;
      u += t[h];
    }
    return u;
  }
}
const EE = Object.values(Te).filter((i) => [
  Te.TABLE_START,
  Te.TABLE_ROW_START,
  Te.TABLE_CELL_START,
  Te.TABLE_CELL_END,
  Te.TABLE_ROW_END,
  Te.TABLE_END,
  Te.CUSTOM_BLOCK
].includes(i));
class bE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = Math.floor(+s.getValue());
    if (o <= 0)
      return g.create(m.VALUE);
    let u = String.fromCharCode(o);
    return EE.some((c) => c === u) && (u = ""), j.create(u);
  }
}
class yE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isBoolean() || e.isNumber())
      return e;
    if (e.isNull())
      return j.create("");
    const r = `${e.getValue()}`.replace(/[\0-\x1F]/g, "");
    return j.create(r);
  }
}
class RE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(m.VALUE);
    let t = e.getValue().toLocaleString();
    if (e.isBoolean() && (t = t.toLocaleUpperCase()), t === "")
      return g.create(m.VALUE);
    const r = t.charCodeAt(0);
    return y.create(r);
  }
}
class pE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "", r = null;
    for (const n of e)
      if (n.isArray()) {
        if (n.iterator((s) => {
          if (s == null || s.isNull())
            return !0;
          if (s.isError())
            return r = s, !1;
          s.isBoolean() ? t += `${s.getValue()}`.toLocaleUpperCase() : (s.isString() || s.isNumber()) && (t += s.getValue());
        }), r)
          return r;
      } else !n.isError() && !n.isNull() && (t += n.getValue());
    return j.create(t);
  }
}
class VE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 0;
    e.forEach((s) => {
      if (s.isArray()) {
        const o = s;
        t = Math.max(t, o.getRowCount()), r = Math.max(r, o.getColumnCount());
      } else
        t = Math.max(t, 1), r = Math.max(r, 1);
    });
    let n = null;
    for (const s of e)
      n = O(t, r, s, g.create(m.NA)).mapValue((u, c, l) => {
        const f = n && n.get(c, l);
        if (f != null && f.isError())
          return f;
        if (u.isError())
          return u;
        let h = f == null ? void 0 : f.getValue(), d = u == null ? void 0 : u.getValue();
        f != null && f.isBoolean() && (h = `${h}`.toLocaleUpperCase()), u != null && u.isBoolean() && (d = `${d}`.toLocaleUpperCase());
        const _ = f != null && f.isNull() ? "" : h != null ? h : "", C = u != null && u.isNull() ? "" : d != null ? d : "";
        return j.create(`${_}${C}`);
      });
    return n || g.create(m.VALUE);
  }
}
class NE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return j.create("");
    let t = `${e.getValue()}`;
    e.isBoolean() && (t = t.toLocaleUpperCase());
    let r = "";
    for (let n = 0; n < t.length; n++) {
      const s = t.charCodeAt(n);
      s >= 33 && s <= 126 ? r += String.fromCharCode(s + 65248) : s === 32 ? r += "　" : r += t.charAt(n);
    }
    return j.create(r);
  }
}
class OE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "needsLocale", !0);
  }
  calculate(e, t) {
    let r = t != null ? t : y.create(2);
    r.isNull() && (r = y.create(2));
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = +o.getValue(), l = Math.trunc(+u.getValue());
    if (l > 127)
      return g.create(m.VALUE);
    l < 0 && (`${c}`.length < Math.abs(l) ? c = 0 : c = c < 0 ? -Bt(Math.abs(c), l) : Bt(c, l), l = 0);
    const f = pl(this.getLocale(), c, l);
    return j.create(f);
  }
}
class ME extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, ce.create()), o = O(r, n, t, ce.create()), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    if (e.isNull() || t.isNull()) {
      const o = e.isNull() && t.isNull();
      return T.create(o);
    }
    let r = `${e.getValue()}`;
    e.isBoolean() && (r = r.toLocaleUpperCase());
    let n = `${t.getValue()}`;
    t.isBoolean() && (n = n.toLocaleUpperCase());
    const s = r === n;
    return T.create(s);
  }
}
const qa = (i, a) => At.format(i, a, { throws: !1 }), Se = (i) => {
  let a = `${i.getValue()}`;
  return i.isNull() && (a = ""), i.isBoolean() && (a = a.toLocaleUpperCase()), i.isNumber() && (i.getPattern() !== "" ? a = qa(i.getPattern(), +i.getValue()) : a = `${ba(+i.getValue())}`), a;
};
class wE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, n, g.create(m.NA)), f = u.mapValue((h, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return h.isError() ? h : C.isError() ? C : E.isError() ? E : this._handleSingleObject(h, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Se(e), s = Se(t), { isError: o, errorObject: u, variants: c } = B(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(m.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const h = s.indexOf(n, f - 1);
    return h === -1 ? g.create(m.VALUE) : y.create(h + 1);
  }
}
function Ka(i) {
  let a = 0;
  for (let e = 0; e < i.length; e++)
    a += Kr(i, e);
  return a;
}
function Kr(i, a, e = "ltr") {
  return SE(i, a, e) > 255 ? 2 : 1;
}
function Ii(i) {
  return i >= 55296 && i <= 56319;
}
function Fi(i) {
  return i >= 56320 && i <= 57343;
}
function ki(i, a) {
  const e = (i & 1023) << 10, t = a & 1023;
  return e + t + 65536;
}
function SE(i, a, e = "ltr") {
  const t = i.charCodeAt(a);
  if (e === "ltr" && Ii(t) && a + 1 < i.length) {
    const r = i.charCodeAt(a + 1);
    if (Fi(r))
      return ki(t, r);
  }
  if (e === "rtl" && Fi(t) && a - 1 >= 0) {
    const r = i.charCodeAt(a - 1);
    if (Ii(r))
      return ki(r, t);
  }
  return t;
}
class DE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, n, g.create(m.NA)), f = u.mapValue((h, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return h.isError() ? h : C.isError() ? C : E.isError() ? E : this._handleSingleObject(h, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Se(e), s = Se(t), { isError: o, errorObject: u, variants: c } = B(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(m.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const h = s.indexOf(n, f - 1);
    if (h === -1)
      return g.create(m.VALUE);
    const d = Ka(s.substring(0, h)) + 1;
    return y.create(d);
  }
}
class LE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = t != null ? t : y.create(2);
    n.isNull() && (n = y.create(2));
    let s = r != null ? r : T.create(!1);
    s.isNull() && (s = T.create(!1));
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(m.NA)), l = O(o, u, n, g.create(m.NA)), f = O(o, u, s, g.create(m.NA)), h = c.mapValue((d, _, C) => {
      const E = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : this._handleSingleObject(d, E, b);
    });
    return o === 1 && u === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = B(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o;
    let f = +u.getValue(), h = Math.trunc(+c.getValue());
    const d = +l.getValue();
    if (h > 127)
      return g.create(m.VALUE);
    h < 0 && (`${f}`.length < Math.abs(h) ? f = 0 : f = f < 0 ? -Bt(Math.abs(f), h) : Bt(f, h), h = 0);
    let _ = d ? "###0" : "#,##0";
    h > 0 && (_ += `.${"0".repeat(h)}`);
    const C = qa(_, f);
    return j.create(C);
  }
}
class PE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Se(e), { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(m.VALUE);
    if (e.isNull() || c === 0)
      return j.create("");
    if (c >= r.length)
      return j.create(r);
    const l = r.substring(0, c);
    return j.create(l);
  }
}
class xE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, ce.create()), u = O(n, s, r, ce.create()), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Se(e), { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(m.VALUE);
    if (e.isNull() || c === 0)
      return j.create("");
    let l = 0, f = 0, h = "";
    for (; f < c && l < r.length; )
      f += Kr(r, l), h += r.charAt(l), l++;
    return j.create(h);
  }
}
class jE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleText(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleText(e);
  }
  _handleSingleText(e) {
    if (e.isError())
      return e;
    const t = Se(e);
    return y.create(t.length);
  }
}
class UE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleText(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleText(e);
  }
  _handleSingleText(e) {
    if (e.isError())
      return e;
    const t = Se(e), r = Ka(t);
    return y.create(r);
  }
}
class vE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return j.create("");
    const t = `${e.getValue()}`.toLocaleLowerCase();
    return j.create(t);
  }
}
class TE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const n = Se(e), { isError: s, errorObject: o, variants: u } = B(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), h = Math.floor(+l.getValue());
    if (f <= 0 || h < 0)
      return g.create(m.VALUE);
    if (e.isNull() || f > n.length || h === 0)
      return j.create("");
    const d = n.substring(f - 1, f - 1 + h);
    return j.create(d);
  }
}
class BE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, t, g.create(m.NA)), c = O(n, s, r, g.create(m.NA)), l = o.mapValue((f, h, d) => {
      const _ = u.get(h, d), C = c.get(h, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    let n = Se(e);
    const { isError: s, errorObject: o, variants: u } = B(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), h = Math.floor(+l.getValue());
    if (f <= 0 || h < 0)
      return g.create(m.VALUE);
    if (e.isNull() || f > n.length || h === 0)
      return j.create("");
    n = n.substring(f - 1);
    let d = 0, _ = 0, C = "";
    for (; _ < h && d < n.length; )
      _ += Kr(n, d), C += n.charAt(d), d++;
    return j.create(C);
  }
}
const wr = ["〇", "一", "二", "三", "四", "五", "六", "七", "八", "九"], tn = ["零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"], IE = ["", "十", "百", "千"], FE = ["", "拾", "佰", "仟"], kE = ["", "万", "亿", "兆"];
class $E extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.mapValue((c, l, f) => {
      const h = o.get(l, f);
      return c.isError() ? c : h.isError() ? h : this._handleSingleObject(c, h);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t) {
    const r = e.convertToNumberObjectValue();
    if (r.isError())
      return r;
    const n = t.convertToNumberObjectValue();
    if (n.isError())
      return n;
    let s = r.getValue();
    const o = Math.trunc(n.getValue());
    if (s < 0 || ![1, 2, 3].includes(o))
      return g.create(m.NUM);
    s = Math.round(s);
    const u = s.toString(), c = u.length;
    let l = "", f = !1;
    for (let h = 0; h < c; h++) {
      const d = Number(u[h]);
      if (c === 1 && d === 0) {
        l += o === 2 ? tn[0] : wr[0];
        break;
      }
      if (o === 3) {
        l += wr[d];
        continue;
      }
      const _ = c - h - 1, C = _ % 4, E = Math.trunc(_ / 4);
      if (c >= 17 && E > 2) {
        if (l += o === 1 ? wr[d] : tn[d], E > 3)
          continue;
      } else
        d === 0 ? f = C !== 0 : (f && (l += o === 1 ? wr[0] : tn[0], f = !1), l += o === 1 ? wr[d] + IE[C] : tn[d] + FE[C]);
      C === 0 && E > 0 && u.slice(Math.max(0, h - 3), h + 1) !== "0000" && (l += kE[E]);
    }
    return j.create(l);
  }
}
class YE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e, t, r) {
    const n = t != null ? t : j.create("."), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, n, g.create(m.NA)), l = r ? O(s, o, r, g.create(m.NA)) : void 0, f = u.mapValue((h, d, _) => {
      const C = c.get(d, _), E = r ? l.get(d, _) : void 0;
      return h.isError() ? h : C.isError() ? C : E != null && E.isError() ? E : C.isNull() || E != null && E.isNull() ? g.create(m.VALUE) : h.isNull() ? y.create(0) : this._handleSingleObject(h, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t, r) {
    let n = `${e.getValue()}`;
    n = n.replace(/\s+/g, "");
    let s = `${t.getValue()}`;
    t.isBoolean() && (s = s.toLocaleUpperCase()), s = s.charAt(0);
    let o;
    if (r && (o = `${r.getValue()}`, r.isBoolean() && (o = o.toLocaleUpperCase()), o = o.charAt(0), s === o))
      return g.create(m.VALUE);
    if (n.trim() === "")
      return y.create(0);
    if (!n.match(/^\s*[+-]?\s*(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:[eE][+-]?\d+)?[ \t]*/))
      return g.create(m.VALUE);
    const u = n.split(s);
    if (u.length > 2)
      return g.create(m.VALUE);
    let c = u[0].replace(/,/g, "");
    r && (c = c.split(o).join(""));
    let l = 0;
    if (u.length === 1) {
      s === "," && (c = c.replace(/\./g, ""));
      let f = 0;
      for (; c.endsWith("%"); )
        c = c.slice(0, -1), f++;
      f > 0 ? l = +c / 100 ** f : l = +c;
    } else {
      if (!W(c))
        return g.create(m.VALUE);
      let f = u[1], h = 0;
      for (; f.endsWith("%"); )
        f = f.slice(0, -1), h++;
      const d = `${c}.${f}`;
      if (!W(d))
        return g.create(m.VALUE);
      h > 0 ? l = +d / 100 ** h : l = +d;
    }
    return Number.isNaN(l) ? g.create(m.VALUE) : y.create(l);
  }
}
class HE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isNull() || e.isBoolean() || e.isNumber())
      return e;
    const r = e.getValue().toLocaleString().toLocaleLowerCase().replace(/(^|\b|\W|\d|_)[a-z]/g, (n) => n.toLocaleUpperCase());
    return j.create(r);
  }
}
const Tu = () => [
  {
    type: 4,
    from: 48,
    to: 57
  }
], Bu = () => [
  {
    type: 7,
    value: 95
  },
  {
    type: 4,
    from: 97,
    to: 122
  },
  {
    type: 4,
    from: 65,
    to: 90
  },
  {
    type: 4,
    from: 48,
    to: 57
  }
], Iu = () => [
  {
    type: 7,
    value: 9
  },
  {
    type: 7,
    value: 10
  },
  {
    type: 7,
    value: 11
  },
  {
    type: 7,
    value: 12
  },
  {
    type: 7,
    value: 13
  },
  {
    type: 7,
    value: 32
  },
  {
    type: 7,
    value: 160
  },
  {
    type: 7,
    value: 5760
  },
  {
    type: 4,
    from: 8192,
    to: 8202
  },
  {
    type: 7,
    value: 8232
  },
  {
    type: 7,
    value: 8233
  },
  {
    type: 7,
    value: 8239
  },
  {
    type: 7,
    value: 8287
  },
  {
    type: 7,
    value: 12288
  },
  {
    type: 7,
    value: 65279
  }
], Fu = () => ({
  type: 3,
  set: Bu(),
  not: !1
}), ku = () => ({
  type: 3,
  set: Bu(),
  not: !0
}), $u = () => ({
  type: 3,
  set: Tu(),
  not: !1
}), Yu = () => ({
  type: 3,
  set: Tu(),
  not: !0
}), Hu = () => ({
  type: 3,
  set: Iu(),
  not: !1
}), Gu = () => ({
  type: 3,
  set: Iu(),
  not: !0
}), GE = () => ({
  type: 3,
  set: [
    {
      type: 7,
      value: 10
    },
    {
      type: 7,
      value: 13
    },
    {
      type: 7,
      value: 8232
    },
    {
      type: 7,
      value: 8233
    }
  ],
  not: !0
});
function QE(i) {
  const a = {
    type: 0,
    stack: []
  };
  let e = a, t = a.stack;
  const r = [], n = [];
  let s = 0;
  const o = (f) => {
    throw new SyntaxError(`Invalid regular expression: /${i}/: Nothing to repeat at column ${f - 1}`);
  }, u = qE(i);
  let c = 0, l;
  for (; c < u.length; )
    switch (l = u[c++], l) {
      case "\\":
        if (c === u.length)
          throw new SyntaxError(`Invalid regular expression: /${i}/: \\ at end of pattern`);
        switch (l = u[c++], l) {
          case "b":
            t.push({
              type: 2,
              value: "b"
            });
            break;
          case "B":
            t.push({
              type: 2,
              value: "B"
            });
            break;
          case "w":
            t.push(Fu());
            break;
          case "W":
            t.push(ku());
            break;
          case "d":
            t.push($u());
            break;
          case "D":
            t.push(Yu());
            break;
          case "s":
            t.push(Hu());
            break;
          case "S":
            t.push(Gu());
            break;
          default:
            if (/\d/.test(l)) {
              for (; /\d/.test(u[c]) && c < u.length; )
                l += u[c++];
              const f = Number.parseInt(l, 10);
              t.push({
                type: 6,
                value: f
              }), n.push({
                reference: {
                  type: 6,
                  value: f
                },
                stack: t,
                index: t.length - 1
              });
            } else
              t.push({
                type: 7,
                value: l.charCodeAt(0)
              });
        }
        break;
      case "^":
        t.push({
          type: 2,
          value: "^"
        });
        break;
      case "$":
        t.push({
          type: 2,
          value: "$"
        });
        break;
      case "[": {
        const f = u[c] === "^";
        f && c++;
        const h = WE(u.slice(c), i);
        c += h[1], t.push({
          type: 3,
          set: h[0],
          not: f
        });
        break;
      }
      case ".":
        t.push(GE());
        break;
      case "(": {
        const f = {
          type: 1,
          stack: [],
          remember: !0
          // 默认情况下，捕获组是需要记住（捕获）的
        };
        if (u[c] === "?") {
          const h = u[c + 1];
          if (c += 2, h === "=")
            f.followedBy = !0;
          else if (h === "!")
            f.notFollowedBy = !0;
          else if (h !== ":")
            throw new SyntaxError(`Invalid regular expression: /${i}/: Invalid group, character '${h}' after '?' at column ${c - 1}`);
          f.remember = !1;
        } else
          s += 1;
        t.push(f), r.push(e), e = f, t = f.stack;
        break;
      }
      case ")":
        if (r.length === 0)
          throw new SyntaxError(`Invalid regular expression: /${i}/: Unmatched ) at column ${c - 1}`);
        e = r.pop(), t = e.options ? e.options[e.options.length - 1] : e.stack;
        break;
      case "|": {
        e.options || (e.options = [e.stack], delete e.stack);
        const f = [];
        e.options.push(f), t = f;
        break;
      }
      case "{": {
        const f = /^(\d+)(,(\d+)?)?\}/.exec(u.slice(c));
        if (f) {
          t.length === 0 && o(c);
          const h = Number.parseInt(f[1], 10), d = f[2] ? f[3] ? Number.parseInt(f[3], 10) : 1 / 0 : h;
          c += f[0].length, t.push({
            type: 5,
            min: h,
            max: d,
            value: t.pop()
          });
        } else
          t.push({
            // Assuming 123 is the character code for '{'
            type: 7,
            value: 123
          });
        break;
      }
      case "?":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 0,
          max: 1,
          value: t.pop()
        });
        break;
      case "+":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 1,
          max: 1 / 0,
          value: t.pop()
        });
        break;
      case "*":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 0,
          max: 1 / 0,
          value: t.pop()
        });
        break;
      default:
        t.push({
          type: 7,
          value: l.charCodeAt(0)
        });
    }
  if (r.length > 0)
    throw new SyntaxError(`Invalid regular expression: /${i}/: Unterminated group`);
  return KE(n, s), a;
}
function WE(i, a) {
  let e;
  const t = [], r = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (e = r.exec(i)) !== null; ) {
    let n = null;
    const [, s, o, u, c, l, f, h, d, _, C] = e;
    if (s || o || u || c || l || f ? n = (() => {
      let E = {
        type: 3,
        set: [],
        not: !1
      };
      return s ? E = Fu() : o ? E = $u() : u ? E = Hu() : c ? E = ku() : l ? E = Yu() : f && (E = Gu()), E;
    })() : h && C ? n = {
      type: 4,
      from: (d || _).charCodeAt(0),
      to: C.charCodeAt(C.length - 1)
    } : e[16] && (n = {
      type: 7,
      value: e[16].charCodeAt(0)
    }), !n)
      return [t, r.lastIndex];
    t.push(n);
  }
  throw new SyntaxError(`Invalid regular expression: /${a}/: Unterminated character class`);
}
function qE(i) {
  return i.replace(
    /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g,
    (a, e, t, r, n, s, o) => {
      if (t)
        return a;
      let u;
      e ? u = 8 : r ? u = Number.parseInt(r, 16) : n ? u = Number.parseInt(n, 16) : s ? u = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?".indexOf(s) : u = {
        0: 0,
        t: 9,
        n: 10,
        v: 11,
        f: 12,
        r: 13
      }[o];
      const c = String.fromCharCode(u);
      return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
    }
  );
}
function KE(i, a) {
  for (const e of i.reverse()) {
    const t = e.reference.value;
    if (a < t) {
      e.reference.type = 7;
      const r = t.toString();
      if (e.reference.value = Number.parseInt(r, 8), !/^[0-7]+$/.test(r)) {
        let n = 0;
        for (; r[n] !== "8" && r[n] !== "9" && n < r.length; )
          n += 1;
        if (n === 0 ? (e.reference.value = r.charCodeAt(0), n += 1) : e.reference.value = Number.parseInt(r.slice(0, n), 8), r.length > n) {
          const s = e.stack.splice(e.index + 1);
          for (const o of r.slice(n))
            e.stack.push({
              type: 7,
              value: o.charCodeAt(0)
            });
          e.stack.push(...s);
        }
      }
    }
  }
}
function Xa(i, a) {
  if (!XE(i))
    return {
      isError: !0,
      regExp: null
    };
  try {
    const e = new RegExp(i, a ? "ug" : "u");
    return ZE(e) ? {
      isError: !1,
      regExp: e
    } : {
      isError: !0,
      regExp: null
    };
  } catch {
    return {
      isError: !0,
      regExp: null
    };
  }
}
function XE(i) {
  return !(/\(\?<=.*?\)/g.test(i) && !/\[.*?(\?<=.*?)\]/g.test(i) || /\(\?<!.*?\)/g.test(i) && !/\[.*?(\?<!.*?)\]/g.test(i));
}
function ZE(i, a) {
  let t;
  Object.prototype.toString.call(i) === "[object RegExp]" ? t = i.source : i && typeof i != "string" && (t = `${i}`);
  let r;
  try {
    r = QE(t);
  } catch {
    return !1;
  }
  let n = 0;
  const s = (o, u) => {
    let c = u;
    if (o.type === 5 && (c++, n++, c > 1 || n > 25))
      return !1;
    if (o.options) {
      for (const f of o.options)
        if (!s({ stack: f }, c))
          return !1;
    }
    const l = o.stack || o.value && o.value.stack;
    if (!l)
      return !0;
    for (const f of l)
      if (!s(f, c))
        return !1;
    return !0;
  };
  return s(r, 0);
}
class zE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = Yr(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = o.getValue();
    o.isNull() && (c = ""), o.isBoolean() && (c = c ? "TRUE" : "FALSE"), c = `${c}`;
    let l = u.getValue();
    u.isNull() && (l = ""), u.isBoolean() && (l = l ? "TRUE" : "FALSE"), l = `${l}`;
    const { isError: f, regExp: h } = Xa(l, !1);
    if (f)
      return g.create(m.REF);
    const d = c.match(h);
    if (d === null)
      return g.create(m.NA);
    if (d.length > 1) {
      const _ = d.slice(1).map((C) => j.create(C));
      return _.length > 1 ? q.create({
        calculateValueList: [_],
        rowCount: 1,
        columnCount: _.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      }) : _[0];
    }
    return j.create(d[0]);
  }
}
class JE extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = Yr(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = o.getValue();
    o.isNull() && (c = ""), o.isBoolean() && (c = c ? "TRUE" : "FALSE"), c = `${c}`;
    let l = u.getValue();
    u.isNull() && (l = ""), u.isBoolean() && (l = l ? "TRUE" : "FALSE"), l = `${l}`;
    const { isError: f, regExp: h } = Xa(l, !1);
    return f ? g.create(m.REF) : c.match(h) === null ? T.create(!1) : T.create(!0);
  }
}
class eb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Yr(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o;
    let f = u.getValue();
    u.isNull() && (f = ""), u.isBoolean() && (f = f ? "TRUE" : "FALSE"), f = `${f}`;
    let h = c.getValue();
    c.isNull() && (h = ""), c.isBoolean() && (h = h ? "TRUE" : "FALSE"), h = `${h}`;
    let d = l.getValue();
    l.isNull() && (d = ""), l.isBoolean() && (d = d ? "TRUE" : "FALSE"), d = `${d}`;
    const { isError: _, regExp: C } = Xa(h, !0);
    if (_)
      return g.create(m.REF);
    const E = f.replace(C, d);
    return j.create(E);
  }
}
class tb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), h = Math.floor(+l.getValue());
    if (f <= 0 || h < 0)
      return g.create(m.VALUE);
    const d = Se(e), _ = Se(n), C = d.substring(0, f - 1) + _ + d.substring(f - 1 + h);
    return j.create(C);
  }
}
class rb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = O(s, o, n, g.create(m.NA)), h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R.isError() ? R : this._handleSingleObject(d, E, b, R);
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = B(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), h = Math.floor(+l.getValue());
    if (f <= 0 || h < 0)
      return g.create(m.VALUE);
    let d = Se(e);
    const _ = Se(n);
    let C = d.substring(0, f - 1);
    d = d.substring(f - 1);
    let E = 0, b = 0;
    for (; b < h && E < d.length; )
      b += Kr(d, E), E++;
    return C += _ + d.substring(E), j.create(C);
  }
}
class nb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(m.NA)), o = O(r, n, t, g.create(m.NA)), u = s.map((c, l, f) => {
      let h = o.get(l, f);
      if (c.isError())
        return c;
      let d = c.getValue();
      if (c.isNull() && (d = ""), c.isBoolean() && (d = d ? "TRUE" : "FALSE"), d += "", h.isString() && (h = h.convertToNumberObjectValue()), h.isError())
        return h;
      const _ = 32767, C = Math.floor(+h.getValue());
      if (C < 0 || C > _ / d.length)
        return g.create(m.VALUE);
      const E = d.repeat(C);
      return j.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class sb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Se(e), { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(m.VALUE);
    if (e.isNull() || c === 0)
      return j.create("");
    if (c >= r.length)
      return j.create(r);
    const l = r.substring(r.length - c);
    return j.create(l);
  }
}
class ab extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Se(e), { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(m.VALUE);
    if (e.isNull() || c === 0)
      return j.create("");
    let l = r.length - 1, f = 0, h = "";
    for (; f < c && l >= 0; )
      f += Kr(r, l, "rtl"), h = r.charAt(l) + h, l--;
    return j.create(h);
  }
}
class ib extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, n, g.create(m.NA)), f = u.mapValue((h, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return h.isError() ? h : C.isError() ? C : E.isError() ? E : this._handleSingleObject(h, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Se(e).toLocaleUpperCase(), s = Se(t).toLocaleUpperCase(), { isError: o, errorObject: u, variants: c } = B(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(m.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const h = s.indexOf(n, f - 1);
    return h === -1 ? g.create(m.VALUE) : y.create(h + 1);
  }
}
class ob extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, n, g.create(m.NA)), f = u.mapValue((h, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return h.isError() ? h : C.isError() ? C : E.isError() ? E : this._handleSingleObject(h, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Se(e).toLocaleUpperCase(), s = Se(t).toLocaleUpperCase(), { isError: o, errorObject: u, variants: c } = B(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(m.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const h = s.indexOf(n, f - 1);
    if (h === -1)
      return g.create(m.VALUE);
    const d = Ka(s.substring(0, h)) + 1;
    return y.create(d);
  }
}
class ub extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n != null && n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n != null && n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(m.NA)), c = O(s, o, t, g.create(m.NA)), l = O(s, o, r, g.create(m.NA)), f = n ? O(s, o, n, g.create(m.NA)) : void 0, h = u.mapValue((d, _, C) => {
      const E = c.get(_, C), b = l.get(_, C);
      let R = n ? f.get(_, C) : void 0;
      return d.isError() ? d : E.isError() ? E : b.isError() ? b : R != null && R.isError() ? R : R != null && R.isNull() || R != null && R.isBoolean() ? g.create(m.VALUE) : (R != null && R.isString() && (R = R.convertToNumberObjectValue()), R != null && R.isError() ? R : this._handleSingleObject(d, E, b, R));
    });
    return s === 1 && o === 1 ? h.get(0, 0) : h;
  }
  _handleSingleObject(e, t, r, n) {
    const s = this._getObjectString(e), o = this._getObjectString(t), u = this._getObjectString(r), c = n ? Math.floor(+n.getValue()) : void 0;
    if (n && c <= 0)
      return g.create(m.VALUE);
    if (o === "")
      return j.create(s);
    let l = "", f = 0;
    for (let h = 0; h < s.length; h++) {
      const d = s.substr(h, o.length);
      if (d === o || d.length === o.length && d.trim() === o.trim()) {
        if (f++, f === c) {
          l = s.substr(0, h) + u + s.substr(h + o.length);
          break;
        }
        c === void 0 && (l += u), h += o.length - 1;
      } else
        c === void 0 && (l += s[h]);
    }
    return c && f < c && (l = s), j.create(l);
  }
  _getObjectString(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
}
class cb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    let t = e;
    return e.isReferenceObject() && (t = e.toArrayValueObject().get(0, 0)), t.isArray() ? t.mapValue((r) => this._handleSingleObject(r)) : this._handleSingleObject(t);
  }
  _handleSingleObject(e) {
    return e.isError() ? e : e.isNull() || e.isBoolean() || e.isNumber() ? j.create("") : e;
  }
}
class lb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t), u = s.map((c, l, f) => {
      if (c.isError())
        return c;
      let h = o.get(l, f) || j.create(" ");
      if (h.isError())
        return h;
      if (h.isBoolean())
        return g.create(m.VALUE);
      if (c.isBoolean())
        return c;
      let d = c.getValue();
      c.isNull() && (d = 0), c.isString() && W(d) && (d = Number(d)), h.isNull() && (h = j.create(" "));
      const _ = `${h.getValue()}`, C = qa(_, d);
      return j.create(_ === " " ? C.trimEnd() : C);
    });
    return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
  }
}
class fb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = !1, c = r != null ? r : y.create(1);
    c.isNull() && (u = !0, c = y.create(1));
    const l = !n, f = n != null ? n : y.create(0), h = s != null ? s : y.create(0), d = o != null ? o : g.create(m.NA), _ = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      f.isArray() ? f.getRowCount() : 1,
      h.isArray() ? h.getRowCount() : 1,
      d.isArray() ? d.getRowCount() : 1
    ), C = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      f.isArray() ? f.getColumnCount() : 1,
      h.isArray() ? h.getColumnCount() : 1,
      d.isArray() ? d.getColumnCount() : 1
    ), E = O(_, C, e, g.create(m.NA)), b = O(_, C, c, g.create(m.NA)), R = O(_, C, f, g.create(m.NA)), p = O(_, C, h, g.create(m.NA)), N = O(_, C, d, g.create(m.NA)), M = this._getResultArray(E, t, b, R, p, N, u, l);
    return _ === 1 && C === 1 ? M.get(0, 0) : M;
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f, h, d) => {
      const _ = r.get(h, d), C = n.get(h, d), E = s.get(h, d), b = o.get(h, d), R = this._checkVariantsError(f, _, C, E);
      if (R.isError())
        return R;
      const p = this._getStringValue(f), N = this._getDelimiterValue(t);
      if (N instanceof g)
        return N;
      const M = this._getVariantsNumberFloorValue(_, C, E);
      if (M instanceof g)
        return M;
      const [w, S, D] = M;
      return w === 0 || S < 0 || S > 1 || D < 0 || D > 1 ? g.create(m.VALUE) : N.includes("") ? w > 0 ? j.create(p) : j.create("") : !u && Math.abs(w) > p.length ? g.create(m.VALUE) : N.every((L) => L.length > p.length) ? g.create(m.NA) : this._getResult(p, N, w, S, D, b, c);
    });
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(!0);
  }
  _getStringValue(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
  _getDelimiterValue(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(m.VALUE);
      if (e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        t.push(this._getStringValue(o));
      }), r)
        return n;
    } else {
      if (e.isError())
        return e;
      t.push(this._getStringValue(e));
    }
    return t;
  }
  _getVariantsNumberFloorValue(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      const s = Math.floor(+n.getValue());
      t.push(s);
    }
    return t;
  }
  _getResult(e, t, r, n, s, o, u) {
    let c = n ? e.toLocaleLowerCase() : e;
    const l = n ? t.map((C) => C.toLocaleLowerCase()) : t;
    let f = 0, h = 0, d = 0;
    for (let C = 0; C < Math.abs(r); C++)
      if (r < 0) {
        const E = l.map((b) => ({
          index: c.lastIndexOf(b),
          length: b.length
        })).filter((b) => b.index !== -1).sort((b, R) => R.index - b.index)[0];
        if (!E)
          break;
        f = E.index, c = c.substr(0, E.index), d = E.length, h++;
      } else {
        const E = l.map((b) => ({
          index: c.indexOf(b),
          length: b.length
        })).filter((b) => b.index !== -1).sort((b, R) => b.index - R.index)[0];
        if (!E)
          break;
        f += E.index + d, c = c.substr(E.index + E.length), d = E.length, h++;
      }
    if (h && h < Math.abs(r) && u)
      return g.create(m.NA);
    if (!h || h < Math.abs(r))
      return s ? r > 0 ? j.create("") : j.create(e) : o;
    const _ = e.substr(f + d);
    return j.create(_);
  }
}
class hb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = !1, c = r != null ? r : y.create(1);
    c.isNull() && (u = !0, c = y.create(1));
    const l = !n, f = n != null ? n : y.create(0), h = s != null ? s : y.create(0), d = o != null ? o : g.create(m.NA), _ = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      f.isArray() ? f.getRowCount() : 1,
      h.isArray() ? h.getRowCount() : 1,
      d.isArray() ? d.getRowCount() : 1
    ), C = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      f.isArray() ? f.getColumnCount() : 1,
      h.isArray() ? h.getColumnCount() : 1,
      d.isArray() ? d.getColumnCount() : 1
    ), E = O(_, C, e, g.create(m.NA)), b = O(_, C, c, g.create(m.NA)), R = O(_, C, f, g.create(m.NA)), p = O(_, C, h, g.create(m.NA)), N = O(_, C, d, g.create(m.NA)), M = this._getResultArray(E, t, b, R, p, N, u, l);
    return _ === 1 && C === 1 ? M.get(0, 0) : M;
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f, h, d) => {
      const _ = r.get(h, d), C = n.get(h, d), E = s.get(h, d), b = o.get(h, d), R = this._checkVariantsError(f, _, C, E);
      if (R.isError())
        return R;
      const p = this._getStringValue(f), N = this._getDelimiterValue(t);
      if (N instanceof g)
        return N;
      const M = this._getVariantsNumberFloorValue(_, C, E);
      if (M instanceof g)
        return M;
      const [w, S, D] = M;
      return w === 0 || S < 0 || S > 1 || D < 0 || D > 1 ? g.create(m.VALUE) : N.includes("") ? w > 0 ? j.create("") : j.create(p) : !u && Math.abs(w) > p.length ? g.create(m.VALUE) : N.every((L) => L.length > p.length) ? g.create(m.NA) : this._getResult(p, N, w, S, D, b, c);
    });
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(!0);
  }
  _getStringValue(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
  _getDelimiterValue(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(m.VALUE);
      if (e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        t.push(this._getStringValue(o));
      }), r)
        return n;
    } else {
      if (e.isError())
        return e;
      t.push(this._getStringValue(e));
    }
    return t;
  }
  _getVariantsNumberFloorValue(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      const s = Math.floor(+n.getValue());
      t.push(s);
    }
    return t;
  }
  _getResult(e, t, r, n, s, o, u) {
    let c = n ? e.toLocaleLowerCase() : e;
    const l = n ? t.map((C) => C.toLocaleLowerCase()) : t;
    let f = 0, h = 0, d = 0;
    for (let C = 0; C < Math.abs(r); C++)
      if (r < 0) {
        const E = l.map((b) => ({
          index: c.lastIndexOf(b),
          length: b.length
        })).filter((b) => b.index !== -1).sort((b, R) => R.index - b.index)[0];
        if (!E)
          break;
        f = E.index, c = c.substr(0, E.index), h++;
      } else {
        const E = l.map((b) => ({
          index: c.indexOf(b),
          length: b.length
        })).filter((b) => b.index !== -1).sort((b, R) => b.index - R.index)[0];
        if (!E)
          break;
        f += E.index + d, c = c.substr(E.index + E.length), d = E.length, h++;
      }
    if (h && h < Math.abs(r) && u)
      return g.create(m.NA);
    if (!h || h < Math.abs(r))
      return s ? r > 0 ? j.create(e) : j.create("") : o;
    const _ = e.substr(0, f);
    return j.create(_);
  }
}
class mb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
  }
  calculate(e, t, ...r) {
    const n = this._getDelimiterValues(e), s = this._getTextValues(r);
    if (t.isArray()) {
      const u = t.mapValue((c) => this._handleSingleObject(n, c, s));
      return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
    }
    const o = t;
    if (o.isString()) {
      const u = `${o.getValue()}`.toLocaleUpperCase();
      if (u === "TRUE")
        return this._handleSingleObject(n, T.create(!0), s);
      if (u === "FALSE")
        return this._handleSingleObject(n, T.create(!1), s);
    }
    return this._handleSingleObject(n, t, s);
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g)
      return e;
    const { isError: n, errorObject: s, variants: o } = B(t);
    if (n)
      return s;
    if (r instanceof g)
      return r;
    const [u] = o, c = +u.getValue();
    let l = r;
    c && (l = r.filter((h) => h !== null && h !== ""));
    let f = "";
    for (let h = 0; h < l.length; h++)
      l[h] !== null && (f += l[h]), h < l.length - 1 && (f += e[h % e.length]);
    return j.create(f);
  }
  _getDelimiterValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        let c = `${u.getValue()}`;
        u.isNull() && (c = ""), u.isBoolean() && (c = c.toLocaleUpperCase()), t.push(c);
      }
    return t;
  }
  _getTextValues(e) {
    const t = [];
    for (const r of e) {
      const n = r.isArray() ? r.getRowCount() : 1, s = r.isArray() ? r.getColumnCount() : 1;
      for (let o = 0; o < n; o++)
        for (let u = 0; u < s; u++) {
          const c = r.isArray() ? r.get(o, u) : r;
          if (c.isError())
            return c;
          if (c.isNull()) {
            t.push(null);
            continue;
          }
          let l = `${c.getValue()}`;
          c.isBoolean() && (l = l.toLocaleUpperCase()), t.push(l);
        }
    }
    return t;
  }
}
class gb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = r != null ? r : j.create("\\s");
    const c = n != null ? n : y.create(0), l = s != null ? s : y.create(0), f = o != null ? o : j.create(m.NA), { _variant: h, values: d } = this._getStringValues(t), { _variant: _, values: C } = this._getStringValues(u, !1);
    u = _;
    const E = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), b = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), R = O(E, b, e, g.create(m.NA)), p = O(E, b, c, g.create(m.NA)), N = O(E, b, l, g.create(m.NA)), M = this._getResultArray(
      R,
      h,
      u,
      p,
      N,
      f,
      d,
      C
    );
    return E === 1 && b === 1 ? M.get(0, 0) : M.map((w) => w.get(0, 0));
  }
  _getStringValues(e, t = !0) {
    let r = e;
    const n = [];
    if (r.isArray())
      r.iterator((s) => {
        if (s != null && s.isError())
          return r = s, !1;
        if (s != null && s.isNull() && t)
          return r = g.create(m.VALUE), !1;
        const o = this._getRegExpStringValue(s);
        if (o === "")
          return r = g.create(m.VALUE), !1;
        n.push(o);
      });
    else {
      r.isNull() && t && (r = g.create(m.VALUE));
      const s = this._getRegExpStringValue(r);
      s === "" && (r = g.create(m.VALUE)), n.push(s);
    }
    return {
      _variant: r,
      values: n
    };
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f, h, d) => {
      let _ = n.get(h, d), C = s.get(h, d);
      const E = this._checkVariantsError(f, t, r, _, C);
      if (E.isError())
        return E;
      if (f.isNull())
        return g.create(m.VALUE);
      let b = o;
      if (b.isArray()) {
        const w = b.getRowCount(), S = b.getColumnCount();
        if (w > 1 || S > 1)
          return g.create(m.VALUE);
        b = b.get(0, 0);
      }
      let R = `${f.getValue()}`;
      if (f.isBoolean() && (R = R.toLocaleUpperCase()), _.isString() && (_ = _.convertToNumberObjectValue(), _.isError()))
        return _;
      const p = Math.floor(+_.getValue());
      if (C.isString() && (C = C.convertToNumberObjectValue(), C.isError()))
        return C;
      const N = Math.floor(+C.getValue());
      if (N < 0 || N > 1)
        return g.create(m.VALUE);
      let M = `${b.getValue()}`;
      return b.isBoolean() && (M = M.toLocaleUpperCase()), this._getResult(R, u, c, p, N, M);
    });
  }
  _getResult(e, t, r, n, s, o) {
    const u = new RegExp(r.join("|"), `g${s ? "i" : ""}`), c = new RegExp(t.join("|"), `g${s ? "i" : ""}`), l = e.split(u);
    let f = 1, h = l.map((d) => {
      let _ = d.split(c);
      return n && (_ = _.filter((C) => C !== "")), f = Math.max(f, _.length), _;
    });
    return h = h.map((d) => {
      let _ = d;
      return _.length < f && (_ = _.concat(new Array(f - _.length).fill(o))), _;
    }), q.createByArray(h);
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(!0);
  }
  _getRegExpStringValue(e) {
    let t = e.getValue();
    return e.isNull() && (t = "\\s"), e.isBoolean() && (t = t ? "TRUE" : "FALSE"), t += "", this._escapeRegExp(t);
  }
  _escapeRegExp(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
}
class db extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return j.create("");
    let t = `${e.getValue()}`;
    return e.isBoolean() && (t = t.toLocaleUpperCase()), t = t.trim().replace(/\s+/g, " "), j.create(t);
  }
}
const Cb = Object.values(Te).filter((i) => [
  Te.TABLE_START,
  Te.TABLE_ROW_START,
  Te.TABLE_CELL_START,
  Te.TABLE_CELL_END,
  Te.TABLE_ROW_END,
  Te.TABLE_END,
  Te.CUSTOM_BLOCK
].includes(i));
class _b extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = B(e);
    if (t)
      return r;
    const [s] = n, o = Math.floor(+s.getValue());
    if (o < 1 || o > 1114111)
      return g.create(m.VALUE);
    if (o === 1114111 || o === 1114110)
      return g.create(m.NA);
    let u = String.fromCharCode(o);
    return Cb.some((c) => c === u) && (u = ""), j.create(u);
  }
}
class Ab extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(m.VALUE);
    let t = e.getValue().toLocaleString();
    e.isBoolean() && (t = t.toLocaleUpperCase());
    const r = t.charCodeAt(0);
    return y.create(r);
  }
}
class Eb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return j.create("");
    const t = `${e.getValue()}`.toLocaleUpperCase();
    return j.create(t);
  }
}
class bb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g.create(m.VALUE);
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue(), t.isError()))
      return t;
    const r = +t.getValue();
    return y.create(r);
  }
}
class yb extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(m.NA)), u = O(n, s, r, g.create(m.NA)), c = o.mapValue((l, f, h) => {
      const d = u.get(f, h);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = B(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    if (u < 0 || u > 1)
      return g.create(m.VALUE);
    if (e.isNull())
      return j.create("");
    if (e.isBoolean())
      return e;
    if (e.isNumber())
      return y.create(e.getValue());
    const c = u ? `"${e.getValue()}"` : `${e.getValue()}`;
    return j.create(c);
  }
}
const Rb = [
  [_E, se.ASC],
  [CE, se.ARRAYTOTEXT],
  [AE, se.BAHTTEXT],
  [bE, se.CHAR],
  [yE, se.CLEAN],
  [RE, se.CODE],
  [pE, se.CONCAT],
  [VE, se.CONCATENATE],
  [NE, se.DBCS],
  [OE, se.DOLLAR],
  [ME, se.EXACT],
  [wE, se.FIND],
  [DE, se.FINDB],
  [LE, se.FIXED],
  [PE, se.LEFT],
  [xE, se.LEFTB],
  [jE, se.LEN],
  [UE, se.LENB],
  [vE, se.LOWER],
  [TE, se.MID],
  [BE, se.MIDB],
  [$E, se.NUMBERSTRING],
  [YE, se.NUMBERVALUE],
  [zE, se.REGEXEXTRACT],
  [JE, se.REGEXMATCH],
  [eb, se.REGEXREPLACE],
  [HE, se.PROPER],
  [tb, se.REPLACE],
  [rb, se.REPLACEB],
  [nb, se.REPT],
  [sb, se.RIGHT],
  [ab, se.RIGHTB],
  [ib, se.SEARCH],
  [ob, se.SEARCHB],
  [ub, se.SUBSTITUTE],
  [cb, se.T],
  [lb, se.TEXT],
  [fb, se.TEXTAFTER],
  [hb, se.TEXTBEFORE],
  [mb, se.TEXTJOIN],
  [gb, se.TEXTSPLIT],
  [db, se.TRIM],
  [_b, se.UNICHAR],
  [Ab, se.UNICODE],
  [Eb, se.UPPER],
  [bb, se.VALUE],
  [yb, se.VALUETOTEXT]
], pb = [];
var Vb = /* @__PURE__ */ ((i) => i)(Vb || {});
class Nb extends Ne {
  constructor() {
    super(...arguments);
    // 18.5.1.2 table (Table)
    A(this, "_tableMap", /* @__PURE__ */ new Map());
    // 18.5.1.2 table (Table) for I18N
    A(this, "_tableOptionMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._tableMap.clear(), this._tableOptionMap.clear();
  }
  remove(e, t) {
    var r;
    (r = this._tableMap.get(e)) == null || r.delete(t);
  }
  getTableMap(e) {
    return this._tableMap.get(e);
  }
  getTableOptionMap() {
    return this._tableOptionMap;
  }
  registerTable(e, t, r) {
    var n;
    this._tableMap.get(e) == null && this._tableMap.set(e, /* @__PURE__ */ new Map()), (n = this._tableMap.get(e)) == null || n.set(t, r);
  }
  registerTableOptionMap(e, t) {
    this._tableOptionMap.set(e, t);
  }
}
const Qu = Ze("univer.formula.super-table.service");
function $i(i) {
  return i.map((a) => a.map((e) => typeof e == "number" ? ba(e) : e));
}
function ay(i, a = !1) {
  if (i.isReferenceObject()) {
    const e = i.toArrayValueObject().toValue();
    return a ? $i(e) : e;
  } else if (i.isArray()) {
    const e = i.toValue();
    return a ? $i(e) : e;
  } else if (i.isNumber()) {
    const e = i.getValue();
    return a ? ba(e) : e;
  }
  return i.getValue();
}
class Ob extends V {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const t = Se(e), r = encodeURIComponent(t).replace(/[!~'()*]/g, (n) => `%${n.charCodeAt(0).toString(16).toLocaleUpperCase()}`);
    return j.create(r);
  }
}
var Wu = /* @__PURE__ */ ((i) => (i.ENCODEURL = "ENCODEURL", i.FILTERXML = "FILTERXML", i.WEBSERVICE = "WEBSERVICE", i))(Wu || {});
const Mb = [
  [Ob, Wu.ENCODEURL]
];
class qu extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_allSubjects", []);
    A(this, "_computingStatus$", new Xi(!0));
    A(this, "computingStatus$", this._computingStatus$.pipe(Zi()));
    A(this, "_computingSubscription");
  }
  get computingStatus() {
    return this._computingStatus$.getValue();
  }
  dispose() {
    var e;
    super.dispose(), (e = this._computingSubscription) == null || e.unsubscribe(), this._computingStatus$.next(!0), this._computingStatus$.complete(), this._allSubjects.forEach((t) => {
      t.complete();
    });
  }
  pushComputingStatusSubject(e) {
    return this._allSubjects.push(e), this._updateComputingObservable(), {
      dispose: () => {
        const t = this._allSubjects.indexOf(e);
        t !== -1 && this._allSubjects.splice(t, 1), this._updateComputingObservable();
      }
    };
  }
  _updateComputingObservable() {
    var e;
    if ((e = this._computingSubscription) == null || e.unsubscribe(), this._allSubjects.length === 0) {
      this._computingStatus$.next(!0);
      return;
    }
    this._computingSubscription = dc(this._allSubjects).pipe(Cc((t) => t.every((r) => r))).subscribe((t) => this._computingStatus$.next(t));
  }
}
var wb = Object.getOwnPropertyDescriptor, Sb = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? wb(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Yi = (i, a) => (e, t) => a(e, t, i);
let sa = class extends Ne {
  constructor(a, e) {
    super();
    A(this, "_computingCompleted$", new _c((a) => {
      this._commandService.onCommandExecuted((e) => {
        if (e.id !== _n.id) return;
        const t = e.params;
        if (t.stageInfo)
          return a.next(
            t.stageInfo.stage === Je.IDLE || t.stageInfo.stage === Je.CALCULATION_COMPLETED
          );
      });
    }).pipe(
      Zi(),
      Ac()
    ));
    this._commandService = a, this._globalComputingSrv = e;
    const t = new fc(), r = new Xi(!0);
    t.add(this._globalComputingSrv.pushComputingStatusSubject(r)), t.add(this._computingCompleted$.subscribe((n) => r.next(n))), t.add(() => r.complete()), this.disposeWithMe(t);
  }
};
sa = Sb([
  Yi(0, ir),
  Yi(1, ye(qu))
], sa);
var Db = Object.getOwnPropertyDescriptor, Lb = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Db(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, rn = (i, a) => (e, t) => a(e, t, i);
let Tn = class extends Ne {
  constructor(i, a, e, t) {
    super(), this._commandService = i, this._functionService = a, this._configService = e, this._dataSyncPrimaryController = t, this._initialize();
  }
  _initialize() {
    this._registerCommands(), this._registerFunctions();
  }
  _registerCommands() {
    [
      fo,
      ws,
      uo,
      co,
      _n,
      lo,
      ca,
      oo,
      la,
      fa,
      ha,
      ma,
      el,
      tl,
      ho,
      kc
    ].forEach((i) => {
      var a;
      this._commandService.registerCommand(i), (a = this._dataSyncPrimaryController) == null || a.registerSyncingMutations(i);
    });
  }
  _registerFunctions() {
    var e;
    const i = this._configService.getConfig(Ca), a = [
      ...Zh,
      ...Lm,
      ...Pm,
      ...Wm,
      ...Lg,
      ...U1,
      ...F0,
      ...ld,
      ...Dd,
      ...hC,
      ...I_,
      ...Q_,
      ...dE,
      ...Rb,
      ...pb,
      ...Mb
    ].concat((e = i == null ? void 0 : i.function) != null ? e : []).map((t) => {
      const r = t[0], n = t[1];
      return new r(n);
    });
    this._functionService.registerExecutors(...a);
  }
};
Tn = Lb([
  rn(0, ir),
  rn(1, Qt),
  rn(2, ia),
  rn(3, hc(Ec))
], Tn);
var Pb = Object.getOwnPropertyDescriptor, xb = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Pb(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, nn = (i, a) => (e, t) => a(e, t, i);
let Bn = class extends Ne {
  constructor(i, a, e) {
    super(), this._commandService = i, this._dependencyManagerService = a, this._featureCalculationManagerService = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener(), this._featureCalculationManagerServiceListener();
  }
  _featureCalculationManagerServiceListener() {
    this.disposeWithMe(
      this._featureCalculationManagerService.onChanged$.subscribe((i) => {
        const { unitId: a, subUnitId: e, featureIds: t } = i;
        this._dependencyManagerService.removeFeatureFormulaDependency(a, e, t);
      })
    );
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        if (i.id === fa.id) {
          const a = i.params;
          if (a == null)
            return;
          const { featureIds: e, unitId: t, subUnitId: r } = a;
          this._dependencyManagerService.removeFeatureFormulaDependency(t, r, e);
        } else if (i.id === la.id) {
          const a = i.params;
          if (a == null)
            return;
          const { featureId: e, calculationParam: t } = a, { unitId: r, subUnitId: n } = t;
          this._dependencyManagerService.removeFeatureFormulaDependency(r, n, [e]);
        } else if (i.id === ma.id) {
          const a = i.params;
          if (a == null)
            return;
          this._dependencyManagerService.removeOtherFormulaDependency(a.unitId, a.subUnitId, a.formulaIdList);
        } else if (i.id === ha.id) {
          const a = i.params;
          if (a == null)
            return;
          const e = a.formulaMap, t = [];
          Object.keys(e).forEach((r) => {
            t.push(r);
          }), this._dependencyManagerService.removeOtherFormulaDependency(a.unitId, a.subUnitId, t);
        } else if (i.id === fo.id) {
          const a = i.params.formulaData;
          Object.keys(a).forEach((e) => {
            const t = a[e];
            if (t !== void 0) {
              if (t === null) {
                this._dependencyManagerService.clearFormulaDependency(e);
                return;
              }
              Object.keys(t).forEach((r) => {
                const n = t[r];
                if (n !== void 0) {
                  if (n === null)
                    return this._dependencyManagerService.clearFormulaDependency(e, r), !0;
                  new Ce(n).forValue((s, o) => {
                    this._dependencyManagerService.removeFormulaDependency(e, r, s, o);
                  });
                }
              });
            }
          });
        } else i.id === ca.id && this._handleSetDefinedName(i);
      })
    );
  }
  _handleSetDefinedName(i) {
    const a = i.params;
    if (a == null)
      return;
    const { unitId: e, name: t } = a;
    this._dependencyManagerService.removeFormulaDependencyByDefinedName(e, t);
  }
};
Bn = xb([
  nn(0, ir),
  nn(1, vr),
  nn(1, Jn),
  nn(2, vr)
], Bn);
var jb = Object.getOwnPropertyDescriptor, Ub = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? jb(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Hi = (i, a) => (e, t) => a(e, t, i);
let In = class extends Ne {
  constructor(i, a) {
    super(), this._commandService = i, this._featureCalculationManagerService = a, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        if (i.id === la.id) {
          const a = i.params;
          if (a == null)
            return;
          const { featureId: e, calculationParam: t } = a, { unitId: r, subUnitId: n } = t;
          this._featureCalculationManagerService.register(r, n, e, t);
        } else if (i.id === fa.id) {
          const a = i.params;
          if (a == null)
            return;
          const { featureIds: e, unitId: t, subUnitId: r } = a;
          this._featureCalculationManagerService.remove(t, r, e);
        }
      })
    );
  }
};
In = Ub([
  Hi(0, ir),
  Hi(1, vr)
], In);
var vb = Object.getOwnPropertyDescriptor, Tb = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? vb(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Vs = (i, a) => (e, t) => a(e, t, i);
let Fn = class extends Ne {
  constructor(i, a, e) {
    super(), this._commandService = i, this._otherFormulaManagerService = a, this._dependencyManagerService = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        if (i.id === ha.id) {
          const a = i.params;
          if (a == null)
            return;
          const e = { [a.unitId]: { [a.subUnitId]: a.formulaMap } };
          this._otherFormulaManagerService.batchRegister(e);
        } else if (i.id === ma.id) {
          const a = i.params;
          if (a == null)
            return;
          const e = {};
          a.formulaIdList.forEach((r) => e[r] = !0);
          const t = { [a.unitId]: { [a.subUnitId]: e } };
          this._otherFormulaManagerService.batchRemove(t);
        }
      })
    );
  }
};
Fn = Tb([
  Vs(0, ir),
  Vs(1, Ma),
  Vs(2, Jn)
], Fn);
var Bb = Object.getOwnPropertyDescriptor, Ib = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Bb(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Gi = (i, a) => (e, t) => a(e, t, i);
let kn = class extends Ne {
  constructor(i, a) {
    super(), this._commandService = i, this._superTableService = a, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        if (i.id === ca.id) {
          const a = i.params;
          if (a == null)
            return;
          const { unitId: e, tableName: t, reference: r } = a;
          this._superTableService.registerTable(e, t, r);
        } else if (i.id === oo.id) {
          const a = i.params;
          if (a == null)
            return;
          const { unitId: e, tableName: t } = a;
          this._superTableService.remove(e, t);
        } else if (i.id === ho.id) {
          const a = i.params;
          if (a == null)
            return;
          const { tableOption: e, tableOptionType: t } = a;
          this._superTableService.registerTableOptionMap(e, t);
        }
      })
    );
  }
};
kn = Ib([
  Gi(0, ir),
  Gi(1, Qu)
], kn);
class Fb extends Ne {
  constructor() {
    super(...arguments);
    A(this, "_dirtyConversionMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._dirtyConversionMap.clear();
  }
  remove(e) {
    this._dirtyConversionMap.delete(e);
  }
  get(e) {
    return this._dirtyConversionMap.get(e);
  }
  has(e) {
    return this._dirtyConversionMap.has(e);
  }
  register(e, t) {
    this._dirtyConversionMap.set(e, t);
  }
  getDirtyConversionMap() {
    return this._dirtyConversionMap;
  }
}
const kb = Ze(
  "univer.formula.active-dirty-manager.service"
);
var $b = Object.getOwnPropertyDescriptor, Yb = (i, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? $b(a, e) : a, n = i.length - 1, s; n >= 0; n--)
    (s = i[n]) && (r = s(r) || r);
  return r;
}, Qi = (i, a) => (e, t) => a(e, t, i);
const Hb = "UNIVER_ENGINE_FORMULA_PLUGIN";
var Ns;
let Wi = (Ns = class extends mc {
  constructor(i = hi, a, e) {
    super(), this._config = i, this._injector = a, this._configService = e;
    const { ...t } = gc(
      {},
      hi,
      this._config
    );
    this._configService.setConfig(Ca, t);
  }
  onStarting() {
    this._initialize(), this._initializeWithOverride();
  }
  onReady() {
    var i;
    cs(this._injector, [
      [Tn],
      [kn]
    ]), (i = this._config) != null && i.notExecuteFormula || cs(this._injector, [
      [Fn],
      [In],
      [Bn],
      [Pn]
    ]);
  }
  onRendered() {
    var i;
    (i = this._config) != null && i.notExecuteFormula || cs(this._injector, [
      [zs],
      [Xs]
    ]);
  }
  _initialize() {
    const i = !this._config.notExecuteFormula, a = [
      // Services
      [Qt, { useClass: sh }],
      [Nr, { useClass: Ps }],
      [kb, { useClass: Fb }],
      [Lo, { useClass: Qs }],
      [_o, { useClass: hl }],
      [Qu, { useClass: Nb }],
      [qu],
      // Models
      [_r],
      // Engine
      [ga],
      //Controllers
      [Tn],
      [kn],
      [sa]
    ];
    i && a.push(
      // Services
      [Ma, { useClass: Ih }],
      [St, { useClass: Ws }],
      [Yt, { useClass: Us }],
      [vr, { useClass: Bh }],
      //Controller
      [Pn],
      [Fn],
      [Bn],
      [In],
      // Calculation engine
      [br],
      [Ur],
      [Ar],
      // AstNode factory
      [Po],
      [On],
      [Mn],
      [Bo],
      [wn],
      [Nn],
      [Sn],
      [Dn],
      [Ln],
      [Io]
    ), a.forEach((e) => this._injector.add(e));
  }
  _initializeWithOverride() {
    var i;
    (i = this._config) != null && i.notExecuteFormula || [
      [zs, { useClass: Js }],
      [Jn, { useClass: Th }],
      [Xs, { useClass: Zs }]
    ].forEach((e) => this._injector.add(e));
  }
}, A(Ns, "pluginName", Hb), Ns);
Wi = Yb([
  Qi(1, ye(Ki)),
  Qi(2, ia)
], Wi);
export {
  Fb as ActiveDirtyManagerService,
  q as ArrayValueObject,
  Po as AstRootNodeFactory,
  Ur as AstTreeBuilder,
  Yf as AsyncArrayObject,
  ny as AsyncCustomFunction,
  $f as AsyncObject,
  V as BaseFunction,
  Xn as BaseReferenceObject,
  Ht as BaseValueObject,
  rr as BooleanValue,
  T as BooleanValueObject,
  Pn as CalculateController,
  Js as CalculateFormulaService,
  jm as CustomFunction,
  Hh as DEFAULT_INTERVAL_COUNT,
  Ps as DefinedNamesService,
  vh as DependencyManagerBaseService,
  Th as DependencyManagerService,
  ey as ENGINE_FORMULA_CYCLE_REFERENCE_COUNT,
  Ca as ENGINE_FORMULA_PLUGIN_CONFIG_KEY,
  or as ERROR_TYPE_SET,
  m as ErrorType,
  g as ErrorValueObject,
  ea as FUNCTION_NAMES_ARRAY,
  le as FUNCTION_NAMES_COMPATIBILITY,
  xm as FUNCTION_NAMES_CUBE,
  Qe as FUNCTION_NAMES_DATABASE,
  be as FUNCTION_NAMES_DATE,
  Z as FUNCTION_NAMES_ENGINEERING,
  ee as FUNCTION_NAMES_FINANCIAL,
  Oe as FUNCTION_NAMES_INFORMATION,
  De as FUNCTION_NAMES_LOGICAL,
  fe as FUNCTION_NAMES_LOOKUP,
  Y as FUNCTION_NAMES_MATH,
  v as FUNCTION_NAMES_STATISTICAL,
  se as FUNCTION_NAMES_TEXT,
  Vb as FUNCTION_NAMES_UNIVER,
  Wu as FUNCTION_NAMES_WEB,
  Bh as FeatureCalculationManagerService,
  Us as FormulaCurrentConfigService,
  _r as FormulaDataModel,
  Zs as FormulaDependencyGenerator,
  bs as FormulaDependencyTree,
  Ks as FormulaDependencyTreeType,
  Si as FormulaDependencyTreeVirtual,
  Je as FormulaExecuteStageType,
  Sr as FormulaExecutedStateType,
  Ws as FormulaRuntimeService,
  On as FunctionNodeFactory,
  sh as FunctionService,
  yc as FunctionType,
  qu as GlobalComputingStatusService,
  Qs as HyperlinkEngineFormulaService,
  kb as IActiveDirtyManagerService,
  zs as ICalculateFormulaService,
  Nr as IDefinedNamesService,
  Jn as IDependencyManagerService,
  vr as IFeatureCalculationManagerService,
  Yt as IFormulaCurrentConfigService,
  Xs as IFormulaDependencyGenerator,
  St as IFormulaRuntimeService,
  Qt as IFunctionService,
  Lo as IHyperlinkEngineFormulaService,
  Ma as IOtherFormulaManagerService,
  _o as ISheetRowFilteredService,
  Qu as ISuperTableService,
  br as Interpreter,
  Mn as LambdaNodeFactory,
  Bo as LambdaParameterNodeFactory,
  Oa as LambdaValueObjectObject,
  Ar as Lexer,
  ae as LexerNode,
  ga as LexerTreeBuilder,
  ce as NullValueObject,
  y as NumberValueObject,
  wn as OperatorNodeFactory,
  Ih as OtherFormulaManagerService,
  Nn as PrefixNodeFactory,
  pn as RangeReferenceObject,
  Sn as ReferenceNodeFactory,
  kc as RegisterFunctionMutation,
  oo as RemoveDefinedNameMutation,
  fa as RemoveFeatureCalculationMutation,
  ma as RemoveOtherFormulaMutation,
  tl as RemoveSuperTableMutation,
  ws as SetArrayFormulaDataMutation,
  ca as SetDefinedNameMutation,
  Jb as SetDefinedNameMutationFactory,
  la as SetFeatureCalculationMutation,
  _n as SetFormulaCalculationNotificationMutation,
  lo as SetFormulaCalculationResultMutation,
  uo as SetFormulaCalculationStartMutation,
  co as SetFormulaCalculationStopMutation,
  fo as SetFormulaDataMutation,
  ha as SetOtherFormulaMutation,
  el as SetSuperTableMutation,
  ho as SetSuperTableOptionMutation,
  hl as SheetRowFilteredService,
  j as StringValueObject,
  Dn as SuffixNodeFactory,
  Nb as SuperTableService,
  Ln as UnionNodeFactory,
  Wi as UniverFormulaEnginePlugin,
  Io as ValueNodeFactory,
  Mt as ValueObjectFactory,
  F as compareToken,
  Ic as convertUnitDataToRuntime,
  Wh as deserializeRangeForR1C1,
  Dr as deserializeRangeWithSheet,
  Cr as deserializeRangeWithSheetWithCache,
  ry as extractFormulaError,
  Zh as functionArray,
  Lm as functionCompatibility,
  Pm as functionCube,
  Wm as functionDatabase,
  Lg as functionDate,
  U1 as functionEngineering,
  F0 as functionFinancial,
  ld as functionInformation,
  Dd as functionLogical,
  hC as functionLookup,
  I_ as functionMath,
  Q_ as functionMeta,
  dE as functionStatistical,
  Rb as functionText,
  pb as functionUniver,
  Mb as functionWeb,
  Vi as generateAstNode,
  Oi as generateExecuteAstNodeData,
  cr as generateRandomDependencyTreeId,
  ci as generateStringWithSequence,
  Zb as getAbsoluteRefTypeWitString,
  on as getAbsoluteRefTypeWithSingleString,
  ay as getObjectValue,
  zb as getRangeWithRefsString,
  ty as handleNumfmtInCell,
  ua as handleRefStringInfo,
  Vc as includeFormulaLexerToken,
  fi as initSheetFormulaData,
  an as isFormulaLexerToken,
  bc as isInDirtyRange,
  so as isReferenceString,
  un as isReferenceStringWithEffectiveColumn,
  Wc as isReferenceStrings,
  Xb as matchRefDrawToken,
  K as matchToken,
  Ds as needsQuoting,
  Kb as normalizeSheetName,
  X as operatorToken,
  Ls as quoteSheetName,
  $e as sequenceNodeType,
  Ft as serializeRange,
  Ss as serializeRangeToRefString,
  Hc as serializeRangeWithSheet,
  Gc as serializeRangeWithSpreadsheet,
  fs as singleReferenceToGrid,
  yi as strip,
  ba as stripErrorMargin,
  ui as unquoteSheetName
};
