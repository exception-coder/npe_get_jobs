var _c = Object.defineProperty;
var pc = (e, t, n) => t in e ? _c(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var p = (e, t, n) => pc(e, typeof t != "symbol" ? t + "" : t, n);
import { createIdentifier as ht, Inject as Nt, Injector as Yn } from "@wendellhu/redi";
export * from "@wendellhu/redi";
import { Subscription as Ec, Subject as ot, Observable as br, filter as Rr, ReplaySubject as Cc, take as Rc, tap as na, debounceTime as Ic, map as Ji, BehaviorSubject as tt, merge as Ll, timer as wc, distinctUntilChanged as Sc, firstValueFrom as Oc, skip as xl, of as Mr, combineLatest as vc } from "rxjs";
import { filter as bc, debounceTime as Ac, first as yc, map as Nc } from "rxjs/operators";
import { defaultTheme as Lr } from "@univerjs/themes";
function Tc(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const s in r)
        if (s !== "default" && !(s in e)) {
          const i = Object.getOwnPropertyDescriptor(r, s);
          i && Object.defineProperty(e, s, i.get ? i : {
            enumerable: !0,
            get: () => r[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
const Dt = typeof global < "u" ? global : typeof self < "u" ? self : window;
function Mc() {
  const t = /* @__PURE__ */ new Map();
  let n = 0;
  typeof Dt.requestIdleCallback != "function" && (Dt.requestIdleCallback = function(s) {
    const i = Date.now(), o = ++n, a = setTimeout(function() {
      t.delete(o);
      const u = Math.max(0, 50 - (Date.now() - i));
      s({
        didTimeout: u === 0,
        timeRemaining() {
          return u;
        }
      });
    }, 1);
    return t.set(o, a), o;
  }), typeof Dt.cancelIdleCallback != "function" && (Dt.cancelIdleCallback = function(s) {
    const i = t.get(s);
    i !== void 0 && (clearTimeout(i), t.delete(s));
  });
}
function Lc() {
  typeof Dt.Array.prototype.findLastIndex != "function" && (Dt.Array.prototype.findLastIndex = function(t, n) {
    if (this == null)
      throw new TypeError("Array.prototype.findLastIndex called on null or undefined");
    if (typeof t != "function")
      throw new TypeError("callback must be a function");
    const r = this.length >>> 0;
    for (let s = r - 1; s >= 0; s--)
      if (s in this && t.call(n, this[s], s, this))
        return s;
    return -1;
  }), typeof Dt.Array.prototype.findLast != "function" && (Dt.Array.prototype.findLast = function(t, n) {
    const r = this.findLastIndex(t, n);
    return r !== -1 ? this[r] : void 0;
  });
}
function xc() {
  typeof Dt.String.prototype.at != "function" && (Dt.String.prototype.at = function(t) {
    if (this == null)
      throw new TypeError("String.prototype.at called on null or undefined");
    const n = this.length;
    if (t < 0 && (t = n + t), !(t < 0 || t >= n))
      return this.charAt(t);
  });
}
function Dc() {
  Mc(), Lc(), xc();
}
function Os(e, t) {
  const n = e.indexOf(t);
  return n > -1 ? (e.splice(n, 1), !0) : !1;
}
function $C(e) {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const r of e)
    t.has(r) || (t.add(r), n.push(r));
  return n;
}
function HC(e, t) {
  const n = /* @__PURE__ */ new Set(), r = [];
  for (const s of e) {
    const i = t(s);
    n.has(i) || (n.add(i), r.push(s));
  }
  return r;
}
function Uc(e, t) {
  for (let n = e.length - 1; n > -1; n--) {
    const r = e[n];
    if (t(r, n))
      return r;
  }
  return null;
}
function BC(e, t) {
  if (e.length === 0)
    return e;
  const n = t % e.length;
  return e.slice(n).concat(e.slice(0, n));
}
function jC(e, t) {
  const n = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    const s = t(r);
    let i = n.get(s);
    n.has(s) || (i = [], n.set(s, i)), i.push(r);
  }), n;
}
function WC(e) {
  return Array.isArray(e) ? e : [e];
}
function Rt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ws, ra;
function kc() {
  if (ra) return Ws;
  ra = 1;
  var e = function(t) {
    if (t = t || {}, this.Promise = t.Promise || Promise, this.queues = /* @__PURE__ */ Object.create(null), this.domainReentrant = t.domainReentrant || !1, this.domainReentrant) {
      if (typeof process > "u" || typeof process.domain > "u")
        throw new Error(
          "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
        );
      this.domains = /* @__PURE__ */ Object.create(null);
    }
    this.timeout = t.timeout || e.DEFAULT_TIMEOUT, this.maxOccupationTime = t.maxOccupationTime || e.DEFAULT_MAX_OCCUPATION_TIME, this.maxExecutionTime = t.maxExecutionTime || e.DEFAULT_MAX_EXECUTION_TIME, t.maxPending === 1 / 0 || Number.isInteger(t.maxPending) && t.maxPending >= 0 ? this.maxPending = t.maxPending : this.maxPending = e.DEFAULT_MAX_PENDING;
  };
  return e.DEFAULT_TIMEOUT = 0, e.DEFAULT_MAX_OCCUPATION_TIME = 0, e.DEFAULT_MAX_EXECUTION_TIME = 0, e.DEFAULT_MAX_PENDING = 1e3, e.prototype.acquire = function(t, n, r, s) {
    if (Array.isArray(t))
      return this._acquireBatch(t, n, r, s);
    if (typeof n != "function")
      throw new Error("You must pass a function to execute");
    var i = null, o = null, a = null;
    typeof r != "function" && (s = r, r = null, a = new this.Promise(function(P, W) {
      i = P, o = W;
    })), s = s || {};
    var l = !1, u = null, c = null, h = null, d = this, f = function(P, W, w) {
      c && (clearTimeout(c), c = null), h && (clearTimeout(h), h = null), P && (d.queues[t] && d.queues[t].length === 0 && delete d.queues[t], d.domainReentrant && delete d.domains[t]), l || (a ? W ? o(W) : i(w) : typeof r == "function" && r(W, w), l = !0), P && d.queues[t] && d.queues[t].length > 0 && d.queues[t].shift()();
    }, g = function(P) {
      if (l)
        return f(P);
      u && (clearTimeout(u), u = null), d.domainReentrant && P && (d.domains[t] = process.domain);
      var W = s.maxExecutionTime || d.maxExecutionTime;
      if (W && (h = setTimeout(function() {
        d.queues[t] && f(P, new Error("Maximum execution time is exceeded " + t));
      }, W)), n.length === 1) {
        var w = !1;
        try {
          n(function(C, v) {
            w || (w = !0, f(P, C, v));
          });
        } catch (C) {
          w || (w = !0, f(P, C));
        }
      } else
        d._promiseTry(function() {
          return n();
        }).then(function(C) {
          f(P, void 0, C);
        }, function(C) {
          f(P, C);
        });
    };
    d.domainReentrant && process.domain && (g = process.domain.bind(g));
    var _ = s.maxPending || d.maxPending;
    if (!d.queues[t])
      d.queues[t] = [], g(!0);
    else if (d.domainReentrant && process.domain && process.domain === d.domains[t])
      g(!1);
    else if (d.queues[t].length >= _)
      f(!1, new Error("Too many pending tasks in queue " + t));
    else {
      var R = function() {
        g(!0);
      };
      s.skipQueue ? d.queues[t].unshift(R) : d.queues[t].push(R);
      var b = s.timeout || d.timeout;
      b && (u = setTimeout(function() {
        u = null, f(!1, new Error("async-lock timed out in queue " + t));
      }, b));
    }
    var H = s.maxOccupationTime || d.maxOccupationTime;
    if (H && (c = setTimeout(function() {
      d.queues[t] && f(!1, new Error("Maximum occupation time is exceeded in queue " + t));
    }, H)), a)
      return a;
  }, e.prototype._acquireBatch = function(t, n, r, s) {
    typeof r != "function" && (s = r, r = null);
    var i = this, o = function(l, u) {
      return function(c) {
        i.acquire(l, u, c, s);
      };
    }, a = t.reduceRight(function(l, u) {
      return o(u, l);
    }, n);
    if (typeof r == "function")
      a(r);
    else
      return new this.Promise(function(l, u) {
        a.length === 1 ? a(function(c, h) {
          c ? u(c) : l(h);
        }) : l(a());
      });
  }, e.prototype.isBusy = function(t) {
    return t ? !!this.queues[t] : Object.keys(this.queues).length > 0;
  }, e.prototype._promiseTry = function(t) {
    try {
      return this.Promise.resolve(t());
    } catch (n) {
      return this.Promise.reject(n);
    }
  }, Ws = e, Ws;
}
var Ys, sa;
function Pc() {
  return sa || (sa = 1, Ys = kc()), Ys;
}
var Fc = Pc();
const YC = /* @__PURE__ */ Rt(Fc), $c = /* @__PURE__ */ new Set(["true", "false"]);
function zC(e) {
  return $c.has(e.toLowerCase());
}
const Ar = "__INTERNAL_EDITOR__", Dl = `${Ar}DOCS_NORMAL`, Ul = `${Ar}DOCS_FORMULA_BAR`, Hc = `${Ar}ZEN_EDITOR`, Bc = `\r
`, jc = "isRowStylePrecedeColumnStyle", Wc = Symbol("AUTO_HEIGHT_FOR_MERGED_CELLS");
function VC(e) {
  return `${Ar}${e}`;
}
function Yc(e) {
  return e.startsWith(Ar);
}
function GC(e, t) {
  t.forEach((n) => e.add(n));
}
function zc(e, t) {
  t.forEach(([n]) => {
    e.has(n) && e.get(n);
  });
}
function Vc(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return !1;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  const s = Object.prototype.hasOwnProperty.bind(t);
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (!s(o))
      return !1;
    const a = e[o], l = t[o];
    if (a !== l)
      return !1;
  }
  return !0;
}
class _i extends Error {
  constructor(t) {
    super(t), this.name = "CustomCommandExecutionError";
  }
}
class KC extends _i {
  constructor() {
    super("Canceled by facade"), this.name = "CanceledError";
  }
}
function XC(e, t = 16) {
  let n = 0, r = null;
  return function(...i) {
    const o = Date.now();
    o - n < t ? (r && clearTimeout(r), r = setTimeout(() => {
      n = o, e.apply(this, i);
    }, t)) : (n = o, e.apply(this, i));
  };
}
var sr = /* @__PURE__ */ ((e) => (e[e.Style = 1] = "Style", e[e.Value = 2] = "Value", e))(sr || {});
function qC(e) {
  return `sheet_interceptor_${e}`;
}
const Gc = (e) => function(t, n) {
  let r = -1, s = t;
  for (let i = 0; i <= e.length; i++) {
    if (i <= r)
      throw new Error("[SheetInterceptorService]: next() called multiple times!");
    if (r = i, i === e.length)
      return s;
    const o = e[i];
    let a = !1;
    if (s = o.handler(s, n, (l) => (a = !0, l)), !a)
      break;
  }
  return s;
};
class ZC {
  constructor(t) {
    p(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    p(this, "_interceptorPoints");
    this._interceptorPoints = t;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughInterceptors(t, n) {
    const r = t;
    let s = this._interceptorsByName.get(r);
    return n && (s = s.filter(n)), Gc(s || []);
  }
  intercept(t, n) {
    const r = t;
    this._interceptorsByName.has(r) || this._interceptorsByName.set(r, []);
    const s = this._interceptorsByName.get(r);
    return s.push(n), this._interceptorsByName.set(
      r,
      s.sort((i, o) => {
        var a, l;
        return ((a = o.priority) != null ? a : 0) - ((l = i.priority) != null ? l : 0);
      })
      // from large to small
    ), () => Os(this._interceptorsByName.get(r), n);
  }
  getInterceptPoints() {
    return this._interceptorPoints;
  }
  dispose() {
    this._interceptorsByName.clear();
  }
}
function JC(e) {
  return `sheet_async_interceptor_${e}`;
}
const Kc = (e) => async function(t, n) {
  let r = -1, s = t;
  for (let i = 0; i <= e.length; i++) {
    if (i <= r)
      throw new Error("[SheetInterceptorService]: next() called multiple times!");
    if (r = i, i === e.length)
      return s;
    const o = e[i];
    let a = !1;
    if (s = await o.handler(s, n, async (l) => (a = !0, l)), !a)
      break;
  }
  return s;
};
class QC {
  constructor(t) {
    p(this, "_asyncInterceptorsByName", /* @__PURE__ */ new Map());
    p(this, "_asyncInterceptorPoints");
    this._asyncInterceptorPoints = t;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughAsyncInterceptors(t, n) {
    const r = t;
    let s = this._asyncInterceptorsByName.get(r);
    return n && (s = s.filter(n)), Kc(s || []);
  }
  async interceptAsync(t, n) {
    const r = t;
    this._asyncInterceptorsByName.has(r) || this._asyncInterceptorsByName.set(r, []);
    const s = this._asyncInterceptorsByName.get(r);
    return s.push(n), this._asyncInterceptorsByName.set(
      r,
      s.sort((i, o) => {
        var a, l;
        return ((a = o.priority) != null ? a : 0) - ((l = i.priority) != null ? l : 0);
      })
      // from large to small
    ), () => Os(this._asyncInterceptorsByName.get(r), n);
  }
  getInterceptPoints() {
    return this._asyncInterceptorPoints;
  }
  dispose() {
    this._asyncInterceptorsByName.clear();
  }
}
function kl(e) {
  return e.map((t) => t / 255);
}
function Pl(e) {
  return e.map((t) => Math.round(t * 255));
}
function Xc([e, t, n]) {
  const r = Math.max(e, t, n), s = Math.min(e, t, n), i = (r + s) / 2;
  let o = 0, a = 0;
  if (r !== s) {
    const l = r - s;
    switch (a = i > 0.5 ? l / (2 - r - s) : l / (r + s), r) {
      case e:
        o = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        o = (n - e) / l + 2;
        break;
      case n:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return [o, a, i];
}
function ds(e, t, n) {
  const r = [e, t, n].map((s) => s <= 0.03928 ? s / 12.92 : ((s + 0.055) / 1.055) ** 2.4);
  return 0.2126 * r[0] + 0.7152 * r[1] + 0.0722 * r[2];
}
function ia(e, t) {
  return (Math.max(e, t) + 0.05) / (Math.min(e, t) + 0.05);
}
function qc(e, t, n) {
  let r, s, i;
  if (t === 0)
    r = s = i = n;
  else {
    const o = (u, c, h) => {
      let d = h;
      return d < 0 && (d += 1), d > 1 && (d -= 1), d < 0.16666666666666666 ? u + (c - u) * 6 * d : d < 0.5 ? c : d < 0.6666666666666666 ? u + (c - u) * (0.6666666666666666 - d) * 6 : u;
    }, a = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
    r = o(l, a, e + 1 / 3), s = o(l, a, e), i = o(l, a, e - 1 / 3);
  }
  return [r, s, i];
}
const zs = { r: 1, g: 1, b: 1 }, Vs = { r: 0, g: 0, b: 0 }, Zc = ds(zs.r, zs.g, zs.b), Jc = ds(Vs.r, Vs.g, Vs.b);
function Qc(e) {
  const t = ds(e[0], e[1], e[2]), n = ia(
    Zc,
    t
  ), r = Xc(e);
  let s = 1 - r[2], i, o, a;
  do
    i = qc(r[0], r[1], s), o = ds(i[0], i[1], i[2]), a = ia(o, Jc), s += 0.01;
  while (s <= 1 && s >= 0 && Math.abs(a - n) < 0.01);
  return i;
}
function e1(e) {
  return Pl(Qc(kl(e)));
}
const mt = [
  [0.333, -0.667, -0.667, 0, 1],
  [-0.667, 0.333, -0.667, 0, 1],
  [-0.667, -0.667, 0.333, 0, 1],
  [0, 0, 0, 1, 0]
];
function eh(e) {
  const t = e[0], n = e[1], r = e[2];
  let s = [
    mt[0][0] * t + mt[0][1] * n + mt[0][2] * r + mt[0][4],
    mt[1][0] * t + mt[1][1] * n + mt[1][2] * r + mt[1][4],
    mt[2][0] * t + mt[2][1] * n + mt[2][2] * r + mt[2][4]
  ];
  return s = s.map((i) => i > 1 ? 1 : i < 0 ? 0 : i), s;
}
function t1(e) {
  return Pl(eh(kl(e)));
}
var Fl = typeof global == "object" && global && global.Object === Object && global, th = typeof self == "object" && self && self.Object === Object && self, Cn = Fl || th || Function("return this")(), $n = Cn.Symbol, $l = Object.prototype, nh = $l.hasOwnProperty, rh = $l.toString, qn = $n ? $n.toStringTag : void 0;
function sh(e) {
  var t = nh.call(e, qn), n = e[qn];
  try {
    e[qn] = void 0;
    var r = !0;
  } catch {
  }
  var s = rh.call(e);
  return r && (t ? e[qn] = n : delete e[qn]), s;
}
var ih = Object.prototype, oh = ih.toString;
function ah(e) {
  return oh.call(e);
}
var lh = "[object Null]", uh = "[object Undefined]", oa = $n ? $n.toStringTag : void 0;
function yr(e) {
  return e == null ? e === void 0 ? uh : lh : oa && oa in Object(e) ? sh(e) : ah(e);
}
function zn(e) {
  return e != null && typeof e == "object";
}
var ch = "[object Symbol]";
function vs(e) {
  return typeof e == "symbol" || zn(e) && yr(e) == ch;
}
function hh(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, s = Array(r); ++n < r; )
    s[n] = t(e[n], n, e);
  return s;
}
var Hn = Array.isArray, aa = $n ? $n.prototype : void 0, la = aa ? aa.toString : void 0;
function Hl(e) {
  if (typeof e == "string")
    return e;
  if (Hn(e))
    return hh(e, Hl) + "";
  if (vs(e))
    return la ? la.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var dh = /\s/;
function fh(e) {
  for (var t = e.length; t-- && dh.test(e.charAt(t)); )
    ;
  return t;
}
var mh = /^\s+/;
function gh(e) {
  return e && e.slice(0, fh(e) + 1).replace(mh, "");
}
function Ct(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var ua = NaN, _h = /^[-+]0x[0-9a-f]+$/i, ph = /^0b[01]+$/i, Eh = /^0o[0-7]+$/i, Ch = parseInt;
function ca(e) {
  if (typeof e == "number")
    return e;
  if (vs(e))
    return ua;
  if (Ct(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ct(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = gh(e);
  var n = ph.test(e);
  return n || Eh.test(e) ? Ch(e.slice(2), n ? 2 : 8) : _h.test(e) ? ua : +e;
}
function Bl(e) {
  return e;
}
var Rh = "[object AsyncFunction]", Ih = "[object Function]", wh = "[object GeneratorFunction]", Sh = "[object Proxy]";
function Qi(e) {
  if (!Ct(e))
    return !1;
  var t = yr(e);
  return t == Ih || t == wh || t == Rh || t == Sh;
}
var Gs = Cn["__core-js_shared__"], ha = (function() {
  var e = /[^.]+$/.exec(Gs && Gs.keys && Gs.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function Oh(e) {
  return !!ha && ha in e;
}
var vh = Function.prototype, bh = vh.toString;
function Ah(e) {
  if (e != null) {
    try {
      return bh.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var yh = /[\\^$.*+?()[\]{}|]/g, Nh = /^\[object .+?Constructor\]$/, Th = Function.prototype, Mh = Object.prototype, Lh = Th.toString, xh = Mh.hasOwnProperty, Dh = RegExp(
  "^" + Lh.call(xh).replace(yh, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Uh(e) {
  if (!Ct(e) || Oh(e))
    return !1;
  var t = Qi(e) ? Dh : Nh;
  return t.test(Ah(e));
}
function kh(e, t) {
  return e == null ? void 0 : e[t];
}
function eo(e, t) {
  var n = kh(e, t);
  return Uh(n) ? n : void 0;
}
var da = Object.create, Ph = /* @__PURE__ */ (function() {
  function e() {
  }
  return function(t) {
    if (!Ct(t))
      return {};
    if (da)
      return da(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
})();
function Fh(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function $h(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var Hh = 800, Bh = 16, jh = Date.now;
function Wh(e) {
  var t = 0, n = 0;
  return function() {
    var r = jh(), s = Bh - (r - n);
    if (n = r, s > 0) {
      if (++t >= Hh)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function Yh(e) {
  return function() {
    return e;
  };
}
var fs = (function() {
  try {
    var e = eo(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
})(), zh = fs ? function(e, t) {
  return fs(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Yh(t),
    writable: !0
  });
} : Bl, Vh = Wh(zh), Gh = 9007199254740991, Kh = /^(?:0|[1-9]\d*)$/;
function to(e, t) {
  var n = typeof e;
  return t = t == null ? Gh : t, !!t && (n == "number" || n != "symbol" && Kh.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function no(e, t, n) {
  t == "__proto__" && fs ? fs(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function bs(e, t) {
  return e === t || e !== e && t !== t;
}
var Xh = Object.prototype, qh = Xh.hasOwnProperty;
function jl(e, t, n) {
  var r = e[t];
  (!(qh.call(e, t) && bs(r, n)) || n === void 0 && !(t in e)) && no(e, t, n);
}
function Zh(e, t, n, r) {
  var s = !n;
  n || (n = {});
  for (var i = -1, o = t.length; ++i < o; ) {
    var a = t[i], l = void 0;
    l === void 0 && (l = e[a]), s ? no(n, a, l) : jl(n, a, l);
  }
  return n;
}
var fa = Math.max;
function Jh(e, t, n) {
  return t = fa(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, s = -1, i = fa(r.length - t, 0), o = Array(i); ++s < i; )
      o[s] = r[t + s];
    s = -1;
    for (var a = Array(t + 1); ++s < t; )
      a[s] = r[s];
    return a[t] = n(o), Fh(e, this, a);
  };
}
function Qh(e, t) {
  return Vh(Jh(e, t, Bl), e + "");
}
var ed = 9007199254740991;
function Wl(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= ed;
}
function ro(e) {
  return e != null && Wl(e.length) && !Qi(e);
}
function td(e, t, n) {
  if (!Ct(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? ro(n) && to(t, n.length) : r == "string" && t in n) ? bs(n[t], e) : !1;
}
function Yl(e) {
  return Qh(function(t, n) {
    var r = -1, s = n.length, i = s > 1 ? n[s - 1] : void 0, o = s > 2 ? n[2] : void 0;
    for (i = e.length > 3 && typeof i == "function" ? (s--, i) : void 0, o && td(n[0], n[1], o) && (i = s < 3 ? void 0 : i, s = 1), t = Object(t); ++r < s; ) {
      var a = n[r];
      a && e(t, a, r, i);
    }
    return t;
  });
}
var nd = Object.prototype;
function zl(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || nd;
  return e === n;
}
function rd(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var sd = "[object Arguments]";
function ma(e) {
  return zn(e) && yr(e) == sd;
}
var Vl = Object.prototype, id = Vl.hasOwnProperty, od = Vl.propertyIsEnumerable, pi = ma(/* @__PURE__ */ (function() {
  return arguments;
})()) ? ma : function(e) {
  return zn(e) && id.call(e, "callee") && !od.call(e, "callee");
};
function ad() {
  return !1;
}
var Gl = typeof exports == "object" && exports && !exports.nodeType && exports, ga = Gl && typeof module == "object" && module && !module.nodeType && module, ld = ga && ga.exports === Gl, _a = ld ? Cn.Buffer : void 0, ud = _a ? _a.isBuffer : void 0, Kl = ud || ad, cd = "[object Arguments]", hd = "[object Array]", dd = "[object Boolean]", fd = "[object Date]", md = "[object Error]", gd = "[object Function]", _d = "[object Map]", pd = "[object Number]", Ed = "[object Object]", Cd = "[object RegExp]", Rd = "[object Set]", Id = "[object String]", wd = "[object WeakMap]", Sd = "[object ArrayBuffer]", Od = "[object DataView]", vd = "[object Float32Array]", bd = "[object Float64Array]", Ad = "[object Int8Array]", yd = "[object Int16Array]", Nd = "[object Int32Array]", Td = "[object Uint8Array]", Md = "[object Uint8ClampedArray]", Ld = "[object Uint16Array]", xd = "[object Uint32Array]", Ue = {};
Ue[vd] = Ue[bd] = Ue[Ad] = Ue[yd] = Ue[Nd] = Ue[Td] = Ue[Md] = Ue[Ld] = Ue[xd] = !0;
Ue[cd] = Ue[hd] = Ue[Sd] = Ue[dd] = Ue[Od] = Ue[fd] = Ue[md] = Ue[gd] = Ue[_d] = Ue[pd] = Ue[Ed] = Ue[Cd] = Ue[Rd] = Ue[Id] = Ue[wd] = !1;
function Dd(e) {
  return zn(e) && Wl(e.length) && !!Ue[yr(e)];
}
function Ud(e) {
  return function(t) {
    return e(t);
  };
}
var Xl = typeof exports == "object" && exports && !exports.nodeType && exports, _r = Xl && typeof module == "object" && module && !module.nodeType && module, kd = _r && _r.exports === Xl, Ks = kd && Fl.process, pa = (function() {
  try {
    var e = _r && _r.require && _r.require("util").types;
    return e || Ks && Ks.binding && Ks.binding("util");
  } catch {
  }
})(), Ea = pa && pa.isTypedArray, ql = Ea ? Ud(Ea) : Dd;
function Pd(e, t) {
  var n = Hn(e), r = !n && pi(e), s = !n && !r && Kl(e), i = !n && !r && !s && ql(e), o = n || r || s || i, a = o ? rd(e.length, String) : [], l = a.length;
  for (var u in e)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    to(u, l)) || a.push(u);
  return a;
}
function Fd(e, t) {
  return function(n) {
    return e(t(n));
  };
}
function $d(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var Hd = Object.prototype, Bd = Hd.hasOwnProperty;
function jd(e) {
  if (!Ct(e))
    return $d(e);
  var t = zl(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !Bd.call(e, r)) || n.push(r);
  return n;
}
function Zl(e) {
  return ro(e) ? Pd(e) : jd(e);
}
var Wd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Yd = /^\w*$/;
function zd(e, t) {
  if (Hn(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || vs(e) ? !0 : Yd.test(e) || !Wd.test(e) || t != null && e in Object(t);
}
var Ir = eo(Object, "create");
function Vd() {
  this.__data__ = Ir ? Ir(null) : {}, this.size = 0;
}
function Gd(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Kd = "__lodash_hash_undefined__", Xd = Object.prototype, qd = Xd.hasOwnProperty;
function Zd(e) {
  var t = this.__data__;
  if (Ir) {
    var n = t[e];
    return n === Kd ? void 0 : n;
  }
  return qd.call(t, e) ? t[e] : void 0;
}
var Jd = Object.prototype, Qd = Jd.hasOwnProperty;
function ef(e) {
  var t = this.__data__;
  return Ir ? t[e] !== void 0 : Qd.call(t, e);
}
var tf = "__lodash_hash_undefined__";
function nf(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Ir && t === void 0 ? tf : t, this;
}
function _n(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
_n.prototype.clear = Vd;
_n.prototype.delete = Gd;
_n.prototype.get = Zd;
_n.prototype.has = ef;
_n.prototype.set = nf;
function rf() {
  this.__data__ = [], this.size = 0;
}
function As(e, t) {
  for (var n = e.length; n--; )
    if (bs(e[n][0], t))
      return n;
  return -1;
}
var sf = Array.prototype, of = sf.splice;
function af(e) {
  var t = this.__data__, n = As(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : of.call(t, n, 1), --this.size, !0;
}
function lf(e) {
  var t = this.__data__, n = As(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function uf(e) {
  return As(this.__data__, e) > -1;
}
function cf(e, t) {
  var n = this.__data__, r = As(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Vt(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Vt.prototype.clear = rf;
Vt.prototype.delete = af;
Vt.prototype.get = lf;
Vt.prototype.has = uf;
Vt.prototype.set = cf;
var Jl = eo(Cn, "Map");
function hf() {
  this.size = 0, this.__data__ = {
    hash: new _n(),
    map: new (Jl || Vt)(),
    string: new _n()
  };
}
function df(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function ys(e, t) {
  var n = e.__data__;
  return df(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function ff(e) {
  var t = ys(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function mf(e) {
  return ys(this, e).get(e);
}
function gf(e) {
  return ys(this, e).has(e);
}
function _f(e, t) {
  var n = ys(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function en(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
en.prototype.clear = hf;
en.prototype.delete = ff;
en.prototype.get = mf;
en.prototype.has = gf;
en.prototype.set = _f;
var pf = "Expected a function";
function so(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(pf);
  var n = function() {
    var r = arguments, s = t ? t.apply(this, r) : r[0], i = n.cache;
    if (i.has(s))
      return i.get(s);
    var o = e.apply(this, r);
    return n.cache = i.set(s, o) || i, o;
  };
  return n.cache = new (so.Cache || en)(), n;
}
so.Cache = en;
var Ef = 500;
function Cf(e) {
  var t = so(e, function(r) {
    return n.size === Ef && n.clear(), r;
  }), n = t.cache;
  return t;
}
var Rf = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, If = /\\(\\)?/g, wf = Cf(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Rf, function(n, r, s, i) {
    t.push(s ? i.replace(If, "$1") : r || n);
  }), t;
});
function Sf(e) {
  return e == null ? "" : Hl(e);
}
function Ql(e, t) {
  return Hn(e) ? e : zd(e, t) ? [e] : wf(Sf(e));
}
function eu(e) {
  if (typeof e == "string" || vs(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function Of(e, t) {
  t = Ql(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[eu(t[n++])];
  return n && n == r ? e : void 0;
}
function vf(e, t, n) {
  var r = e == null ? void 0 : Of(e, t);
  return r === void 0 ? n : r;
}
var tu = Fd(Object.getPrototypeOf, Object), bf = "[object Object]", Af = Function.prototype, yf = Object.prototype, nu = Af.toString, Nf = yf.hasOwnProperty, Tf = nu.call(Object);
function Mf(e) {
  if (!zn(e) || yr(e) != bf)
    return !1;
  var t = tu(e);
  if (t === null)
    return !0;
  var n = Nf.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && nu.call(n) == Tf;
}
function Lf() {
  this.__data__ = new Vt(), this.size = 0;
}
function xf(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function Df(e) {
  return this.__data__.get(e);
}
function Uf(e) {
  return this.__data__.has(e);
}
var kf = 200;
function Pf(e, t) {
  var n = this.__data__;
  if (n instanceof Vt) {
    var r = n.__data__;
    if (!Jl || r.length < kf - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new en(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Vn(e) {
  var t = this.__data__ = new Vt(e);
  this.size = t.size;
}
Vn.prototype.clear = Lf;
Vn.prototype.delete = xf;
Vn.prototype.get = Df;
Vn.prototype.has = Uf;
Vn.prototype.set = Pf;
var ru = typeof exports == "object" && exports && !exports.nodeType && exports, Ca = ru && typeof module == "object" && module && !module.nodeType && module, Ff = Ca && Ca.exports === ru, Ra = Ff ? Cn.Buffer : void 0;
Ra && Ra.allocUnsafe;
function $f(e, t) {
  return e.slice();
}
var Ia = Cn.Uint8Array;
function Hf(e) {
  var t = new e.constructor(e.byteLength);
  return new Ia(t).set(new Ia(e)), t;
}
function Bf(e, t) {
  var n = Hf(e.buffer);
  return new e.constructor(n, e.byteOffset, e.length);
}
function jf(e) {
  return typeof e.constructor == "function" && !zl(e) ? Ph(tu(e)) : {};
}
function Wf(e) {
  return function(t, n, r) {
    for (var s = -1, i = Object(t), o = r(t), a = o.length; a--; ) {
      var l = o[++s];
      if (n(i[l], l, i) === !1)
        break;
    }
    return t;
  };
}
var Yf = Wf(), Xs = function() {
  return Cn.Date.now();
}, zf = "Expected a function", Vf = Math.max, Gf = Math.min;
function n1(e, t, n) {
  var r, s, i, o, a, l, u = 0, c = !1, h = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(zf);
  t = ca(t) || 0, Ct(n) && (c = !!n.leading, h = "maxWait" in n, i = h ? Vf(ca(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function f(C) {
    var v = r, y = s;
    return r = s = void 0, u = C, o = e.apply(y, v), o;
  }
  function g(C) {
    return u = C, a = setTimeout(b, t), c ? f(C) : o;
  }
  function _(C) {
    var v = C - l, y = C - u, F = t - v;
    return h ? Gf(F, i - y) : F;
  }
  function R(C) {
    var v = C - l, y = C - u;
    return l === void 0 || v >= t || v < 0 || h && y >= i;
  }
  function b() {
    var C = Xs();
    if (R(C))
      return H(C);
    a = setTimeout(b, _(C));
  }
  function H(C) {
    return a = void 0, d && r ? f(C) : (r = s = void 0, o);
  }
  function P() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = s = a = void 0;
  }
  function W() {
    return a === void 0 ? o : H(Xs());
  }
  function w() {
    var C = Xs(), v = R(C);
    if (r = arguments, s = this, l = C, v) {
      if (a === void 0)
        return g(l);
      if (h)
        return clearTimeout(a), a = setTimeout(b, t), f(l);
    }
    return a === void 0 && (a = setTimeout(b, t)), o;
  }
  return w.cancel = P, w.flush = W, w;
}
function Ei(e, t, n) {
  (n !== void 0 && !bs(e[t], n) || n === void 0 && !(t in e)) && no(e, t, n);
}
function Kf(e) {
  return zn(e) && ro(e);
}
function Ci(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Xf(e) {
  return Zh(e, Zl(e));
}
function qf(e, t, n, r, s, i, o) {
  var a = Ci(e, n), l = Ci(t, n), u = o.get(l);
  if (u) {
    Ei(e, n, u);
    return;
  }
  var c = i ? i(a, l, n + "", e, t, o) : void 0, h = c === void 0;
  if (h) {
    var d = Hn(l), f = !d && Kl(l), g = !d && !f && ql(l);
    c = l, d || f || g ? Hn(a) ? c = a : Kf(a) ? c = $h(a) : f ? (h = !1, c = $f(l)) : g ? (h = !1, c = Bf(l)) : c = [] : Mf(l) || pi(l) ? (c = a, pi(a) ? c = Xf(a) : (!Ct(a) || Qi(a)) && (c = jf(l))) : h = !1;
  }
  h && (o.set(l, c), s(c, l, r, i, o), o.delete(l)), Ei(e, n, c);
}
function io(e, t, n, r, s) {
  e !== t && Yf(t, function(i, o) {
    if (s || (s = new Vn()), Ct(i))
      qf(e, t, o, n, io, r, s);
    else {
      var a = r ? r(Ci(e, o), i, o + "", e, t, s) : void 0;
      a === void 0 && (a = i), Ei(e, o, a);
    }
  }, Zl);
}
var r1 = Yl(function(e, t, n, r) {
  io(e, t, n, r);
}), oo = Yl(function(e, t, n) {
  io(e, t, n);
});
function Zf(e, t, n, r) {
  if (!Ct(e))
    return e;
  t = Ql(t, e);
  for (var s = -1, i = t.length, o = i - 1, a = e; a != null && ++s < i; ) {
    var l = eu(t[s]), u = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (s != o) {
      var c = a[l];
      u = void 0, u === void 0 && (u = Ct(c) ? c : to(t[s + 1]) ? [] : {});
    }
    jl(a, l, u), a = a[l];
  }
  return e;
}
function s1(e, t, n) {
  return e == null ? e : Zf(e, t, n);
}
class Gn {
  constructor() {
    p(this, "cursor", 0);
  }
  reset() {
    return this.cursor = 0, this;
  }
  moveCursor(t) {
    this.cursor += t;
  }
  moveCursorTo(t) {
    this.cursor = t;
  }
}
function i1(e, t) {
  for (const n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
}
function Jf(e) {
  return /^-?\d+(\.\d+)?$/.test(e);
}
function o1(e) {
  return Jf(e) ? Number(e) <= Number.MAX_SAFE_INTEGER : !1;
}
function a1(e) {
  return Number(e) > Number.MAX_SAFE_INTEGER || e.length >= 18;
}
class su {
  constructor() {
    p(this, "_data", []);
  }
  static create() {
    return new su();
  }
  add(t) {
    this._data.indexOf(t) > -1 || this._data.push(t);
  }
  delete(t) {
    const n = this._data.indexOf(t);
    this._data.splice(n, 1);
  }
  getData() {
    return this._data;
  }
}
class iu {
  constructor() {
    p(this, "_data", /* @__PURE__ */ new Map());
  }
  static create() {
    return new iu();
  }
  add(t, n) {
    this._data.has(t) || this._data.set(t, n);
  }
  delete(t) {
    this._data.delete(t);
  }
  getData() {
    return this._data;
  }
}
function l1(e) {
  const t = new MessageChannel();
  let n = !1;
  const r = () => {
    n || e();
  };
  return t.port1.onmessage = r, t.port2.postMessage(null), () => {
    n = !0, t.port1.onmessage = null, t.port1.close(), t.port2.close();
  };
}
async function Qf(e) {
  for (const [t, n] of e.entries())
    try {
      if (!await n())
        return {
          index: t,
          result: !1
        };
    } catch (r) {
      return {
        index: t,
        result: !1,
        error: r
      };
    }
  return {
    result: !0,
    index: -1
  };
}
function em(e) {
  for (const [t, n] of e.entries())
    try {
      if (!n())
        return {
          index: t,
          result: !1
        };
    } catch (r) {
      return {
        index: t,
        result: !1,
        error: r
      };
    }
  return {
    result: !0,
    index: -1
  };
}
function u1(e, t) {
  return t.forEach((n) => e.add(n)), e;
}
function tm(e) {
  return e instanceof Ec || e instanceof ot || e && "closed" in e && typeof e.unsubscribe < "u";
}
function We(e) {
  let t = !1;
  return e ? tm(e) ? {
    dispose: () => e.unsubscribe()
  } : typeof e == "function" ? {
    dispose: () => {
      t || (t = !0, e());
    }
  } : e : We(() => {
  });
}
function c1(e) {
  return We(() => {
    e.unsubscribe();
  });
}
class ao {
  constructor() {
    p(this, "_disposables", /* @__PURE__ */ new Set());
  }
  add(t) {
    const n = We(t);
    return this._disposables.add(n), {
      dispose: (r = !1) => {
        r || n.dispose(), this._disposables.delete(n);
      }
    };
  }
  dispose() {
    this._disposables.forEach((t) => {
      t.dispose();
    }), this._disposables.clear();
  }
}
class Ve {
  constructor() {
    p(this, "_disposed", !1);
    p(this, "_collection", new ao());
  }
  disposeWithMe(t) {
    return this._collection.add(t);
  }
  ensureNotDisposed() {
    if (this._disposed)
      throw new Error("[Disposable]: object is disposed!");
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._collection.dispose());
  }
}
class h1 extends Ve {
  constructor() {
    super(...arguments);
    p(this, "dispose$", new ot());
  }
  dispose() {
    super.dispose(), this.dispose$.next(), this.dispose$.complete();
  }
}
class d1 extends Ve {
  constructor(n) {
    super();
    p(this, "_ref", 0);
    this._rootDisposable = n;
  }
  inc() {
    if (this._disposed)
      throw new Error("[RCDisposable]: should not ref to a disposed.");
    this._ref += 1;
  }
  dec() {
    this._ref -= 1, this._ref === 0 && (this._rootDisposable.dispose(), this.dispose());
  }
}
var we = /* @__PURE__ */ ((e) => (e[e.UNIVER_UNKNOWN = 0] = "UNIVER_UNKNOWN", e[e.UNIVER_DOC = 1] = "UNIVER_DOC", e[e.UNIVER_SHEET = 2] = "UNIVER_SHEET", e[e.UNIVER_SLIDE = 3] = "UNIVER_SLIDE", e[e.UNIVER_PROJECT = 4] = "UNIVER_PROJECT", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(we || {}), xt = /* @__PURE__ */ ((e) => (e[e.Reader = 0] = "Reader", e[e.Editor = 1] = "Editor", e[e.Owner = 2] = "Owner", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(xt || {}), Ri = /* @__PURE__ */ ((e) => (e[e.SomeCollaborator = 0] = "SomeCollaborator", e[e.AllCollaborator = 1] = "AllCollaborator", e[e.OneSelf = 2] = "OneSelf", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(Ri || {});
class lo extends Ve {
}
const nm = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let rm = (e) => crypto.getRandomValues(new Uint8Array(e)), sm = (e, t, n) => {
  let r = (2 << Math.log2(e.length - 1)) - 1, s = -~(1.6 * r * t / e.length);
  return (i = t) => {
    let o = "";
    for (; ; ) {
      let a = n(s), l = s | 0;
      for (; l--; )
        if (o += e[a[l] & r] || "", o.length >= i) return o;
    }
  };
}, im = (e, t = 21) => sm(e, t | 0, rm), om = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += nm[n[e] & 63];
  return t;
};
const ou = /* @__PURE__ */ new Set([
  "ac",
  "ad",
  "ae",
  "aero",
  "af",
  "ag",
  "ai",
  "al",
  "am",
  "ao",
  "aq",
  "ar",
  "arpa",
  "as",
  "asia",
  "at",
  "au",
  "aw",
  "ax",
  "az",
  "ba",
  "bb",
  "bd",
  "be",
  "bf",
  "bg",
  "bh",
  "bi",
  "biz",
  "bj",
  "bm",
  "bn",
  "bo",
  "br",
  "bs",
  "bt",
  "bv",
  "bw",
  "by",
  "bz",
  "ca",
  "cat",
  "cc",
  "cd",
  "cf",
  "cg",
  "ch",
  "ci",
  "ck",
  "cl",
  "cm",
  "cn",
  "co",
  "com",
  "coop",
  "cr",
  "cu",
  "cv",
  "cw",
  "cx",
  "cy",
  "cz",
  "de",
  "dj",
  "dk",
  "dm",
  "do",
  "dz",
  "ec",
  "edu",
  "ee",
  "eg",
  "er",
  "es",
  "et",
  "eu",
  "fi",
  "fj",
  "fk",
  "fm",
  "fo",
  "fr",
  "ga",
  "gb",
  "gd",
  "ge",
  "gf",
  "gg",
  "gh",
  "gi",
  "gl",
  "gm",
  "gn",
  "gov",
  "gp",
  "gq",
  "gr",
  "gs",
  "gt",
  "gu",
  "gw",
  "gy",
  "hk",
  "hm",
  "hn",
  "hr",
  "ht",
  "hu",
  "id",
  "ie",
  "il",
  "im",
  "in",
  "info",
  "int",
  "io",
  "iq",
  "ir",
  "is",
  "it",
  "je",
  "jm",
  "jo",
  "jobs",
  "jp",
  "ke",
  "kg",
  "kh",
  "ki",
  "km",
  "kn",
  "kp",
  "kr",
  "kw",
  "ky",
  "kz",
  "la",
  "lb",
  "lc",
  "li",
  "lk",
  "lr",
  "ls",
  "lt",
  "lu",
  "lv",
  "ly",
  "ma",
  "mc",
  "md",
  "me",
  "mg",
  "mh",
  "mil",
  "mk",
  "ml",
  "mm",
  "mn",
  "mo",
  "mobi",
  "mp",
  "mq",
  "mr",
  "ms",
  "mt",
  "mu",
  "museum",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "name",
  "nc",
  "ne",
  "net",
  "nf",
  "ng",
  "ni",
  "nl",
  "no",
  "np",
  "nr",
  "nu",
  "nz",
  "om",
  "onion",
  "org",
  "pa",
  "pe",
  "pf",
  "pg",
  "ph",
  "pk",
  "pl",
  "pm",
  "pn",
  "post",
  "pr",
  "pro",
  "ps",
  "pt",
  "pw",
  "py",
  "qa",
  "re",
  "ro",
  "rs",
  "ru",
  "rw",
  "sa",
  "sb",
  "sc",
  "sd",
  "se",
  "sg",
  "sh",
  "si",
  "sj",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sr",
  "ss",
  "st",
  "su",
  "sv",
  "sx",
  "sy",
  "sz",
  "tc",
  "td",
  "tel",
  "tf",
  "tg",
  "th",
  "tj",
  "tk",
  "tl",
  "tm",
  "tn",
  "to",
  "tr",
  "tt",
  "tv",
  "tw",
  "tz",
  "ua",
  "ug",
  "uk",
  "us",
  "uy",
  "uz",
  "va",
  "vc",
  "ve",
  "vg",
  "vi",
  "vn",
  "vu",
  "wf",
  "ws",
  "yt",
  "za",
  "zm",
  "zw"
]), am = new RegExp(
  "^(?:(?:(?:https?|ftp):)?\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$",
  "i"
);
function lm(e) {
  if (!Number.isNaN(+e))
    return !1;
  if (e.startsWith("http://localhost:3002") || e.startsWith("localhost:3002"))
    return !0;
  if (am.test(e)) {
    if (au(e))
      return !0;
    try {
      const r = new URL(lu(e)).hostname.split(".").pop();
      if (r && ou.has(r))
        return !0;
    } catch {
      return !1;
    }
  }
  return !1;
}
function au(e) {
  return /^[a-zA-Z]+:\/\//.test(e);
}
function um(e) {
  return /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(e);
}
function lu(e) {
  return au(e) ? e : um(e) ? `mailto://${e}` : `https://${e}`;
}
const Xt = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z"
];
function uo(e, t) {
  const n = J.getValueType(e), r = J.getValueType(t);
  return n !== r ? !1 : J.isArray(e) ? cm(e, t) : J.isObject(e) ? hm(e, t) : J.isDate(e) ? e.getTime() === t.getTime() : J.isRegExp(e) ? e.toString() === t.toString() : e === t;
}
function cm(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0, r = e.length; n < r; n++) {
    const s = e[n], i = t[n];
    if (!uo(s, i))
      return !1;
  }
  return !0;
}
function hm(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (const s of n) {
    if (!r.includes(s))
      return !1;
    const i = e[s], o = t[s];
    if (!uo(i, o))
      return !1;
  }
  return !0;
}
class J {
  static deleteNull(t) {
    for (const n in t)
      (t[n] === null || t[n] === void 0) && delete t[n];
    return t;
  }
  static stringAt(t) {
    let n = "", r = t;
    for (; r >= Xt.length; )
      r /= Xt.length, r -= 1, n += Xt[r % Xt.length];
    const s = t % Xt.length;
    return n += Xt[s], n;
  }
  static indexAt(t) {
    let n = 0;
    for (let r = 0; r < t.length - 1; r += 1) {
      const s = t.charCodeAt(r) - 65, i = t.length - 1 - r;
      n += Xt.length ** i + Xt.length * s;
    }
    return n += t.charCodeAt(t.length - 1) - 65, n;
  }
  static deleteBlank(t) {
    return J.isString(t) ? t.replace(/\s/g, "") : t;
  }
  // eslint-disable-next-line complexity
  static getSystemType() {
    const t = navigator.userAgent, n = navigator.platform === "Win32" || navigator.platform === "Windows", r = navigator.platform === "Mac68K" || navigator.platform === "MacPPC" || navigator.platform === "Macintosh" || navigator.platform === "MacIntel";
    if (r) return "Mac";
    if (navigator.platform === "X11" && !n && !r) return "Unix";
    if (String(navigator.platform).indexOf("Linux") > -1) return "Linux";
    if (n) {
      if (t.indexOf("Windows NT 5.0") > -1 || t.indexOf("Windows 2000") > -1) return "Windows 2000";
      if (t.indexOf("Windows NT 5.1") > -1 || t.indexOf("Windows XP") > -1) return "Windows XP";
      if (t.indexOf("Windows NT 5.2") > -1 || t.indexOf("Windows 2003") > -1) return "Windows 2003";
      if (t.indexOf("Windows NT 6.0") > -1 || t.indexOf("Windows Vista") > -1) return "Windows Vista";
      if (t.indexOf("Windows NT 6.1") > -1 || t.indexOf("Windows 7") > -1) return "Windows 7";
      if (t.indexOf("Windows NT 10") > -1 || t.indexOf("Windows 10") > -1) return "Windows 10";
      if (t.indexOf("Windows NT 11") > -1 || t.indexOf("Windows 11") > -1) return "Windows 11";
    }
    return "Unknown system";
  }
  static getBrowserType() {
    const t = navigator.userAgent, n = t.indexOf("Opera") > -1, r = t.indexOf("compatible") > -1 && t.indexOf("MSIE") > -1 && !n, s = t.indexOf("Trident") > -1 && t.indexOf("rv:11.0") > -1, i = t.indexOf("Edge") > -1, o = t.indexOf("Firefox") > -1, a = t.indexOf("Safari") > -1 && t.indexOf("Chrome") === -1, l = t.indexOf("Chrome") > -1 && t.indexOf("Safari") > -1;
    if (r) {
      new RegExp("MSIE (\\d+\\.\\d+);").test(t);
      const c = Number.parseFloat(RegExp.$1);
      return c === 7 ? "IE7" : c === 8 ? "IE8" : c === 9 ? "IE9" : c === 10 ? "IE10" : "0";
    }
    return o ? "FF" : n ? "Opera" : a ? "Safari" : l ? "Chrome" : i ? "Edge" : s ? "IE11" : "Unknown browser";
  }
  static getClassName(t) {
    return t.constructor.name;
  }
  /** @deprecated This method is deprecated, please use `import { merge } from '@univerjs/core` instead */
  static deepMerge(t, ...n) {
    n.forEach((o) => o && i(o));
    function r(o, a) {
      o.forEach((l, u) => {
        var c, h;
        if (J.isArray(l)) {
          const d = (c = a[u]) != null ? c : [];
          a[u] = d, r(l, d);
          return;
        }
        if (J.isObject(l)) {
          const d = (h = a[u]) != null ? h : {};
          a[u] = d, s(l, d);
          return;
        }
        a[u] = l;
      });
    }
    function s(o, a) {
      Object.keys(o).forEach((l) => {
        var c, h;
        const u = o[l];
        if (J.isObject(u)) {
          const d = (c = a[l]) != null ? c : {};
          a[l] = d, s(u, d);
          return;
        }
        if (J.isArray(u)) {
          const d = (h = a[l]) != null ? h : [];
          a[l] = d, r(u, d);
          return;
        }
        a[l] = u;
      });
    }
    function i(o) {
      Object.keys(o).forEach((a) => {
        var u, c;
        const l = o[a];
        if (J.isArray(l)) {
          const h = (u = t[a]) != null ? u : [];
          t[a] = h, r(l, h);
          return;
        }
        if (J.isObject(l)) {
          const h = (c = t[a]) != null ? c : {};
          t[a] = h, s(l, h);
          return;
        }
        t[a] = l;
      });
    }
    return t;
  }
  static numberFixed(t, n) {
    return Number(Number(t).toFixed(n));
  }
  static diffValue(t, n) {
    return uo(t, n);
  }
  static deepClone(t) {
    if (!this.isDefine(t))
      return t;
    if (this.isRegExp(t))
      return new RegExp(t);
    if (this.isDate(t))
      return new Date(t);
    if (this.isArray(t)) {
      const n = [];
      return t.forEach((r, s) => {
        n[s] = J.deepClone(r);
      }), n;
    }
    if (this.isObject(t)) {
      const n = {};
      return Object.keys(t).forEach((r) => {
        const s = t[r];
        n[r] = J.deepClone(s);
      }), Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n;
    }
    return t;
  }
  static getLanguage() {
    const t = "en-US";
    return globalThis.navigator && (navigator.languages && navigator.languages[0] || navigator.language) || t;
  }
  static getValueType(t) {
    return Object.prototype.toString.apply(t);
  }
  static isDefine(t) {
    return t != null;
  }
  static isBlank(t) {
    return this.isDefine(t) ? this.isString(t) ? t.trim() === "" : !1 : !0;
  }
  static isPlainObject(t) {
    return this.isDefine(t) ? Object.getPrototypeOf(t) === Object.getPrototypeOf({}) : !1;
  }
  static isDate(t) {
    return this.getValueType(t) === "[object Date]";
  }
  static isRegExp(t) {
    return this.getValueType(t) === "[object RegExp]";
  }
  static isArray(t) {
    return this.getValueType(t) === "[object Array]";
  }
  static isString(t) {
    return this.getValueType(t) === "[object String]";
  }
  static isNumber(t) {
    return this.getValueType(t) === "[object Number]";
  }
  static isStringNumber(t) {
    return !isNaN(Number.parseFloat(t)) && isFinite(t);
  }
  static isObject(t) {
    return this.getValueType(t) === "[object Object]";
  }
  static isEmptyObject(t) {
    for (const n in t)
      return !1;
    return !0;
  }
  static isTablet() {
    return /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
  }
  static isIPhone() {
    return /iPhone/i.test(navigator.userAgent);
  }
  static isLegalUrl(t) {
    return lm(t);
  }
  static normalizeUrl(t) {
    return lu(t);
  }
  static topLevelDomainCombiningString() {
    return [...ou].join("|");
  }
  /**
   * remove all null from object
   * @param obj
   * @returns
   */
  static removeNull(t) {
    return this.isObject(t) && Object.keys(t).forEach((n) => {
      const r = t[n];
      r == null ? delete t[n] : J.removeNull(r);
    }), t;
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  static fillTwoDimensionalArray(t, n, r) {
    return new Array(t).fill(r).map((s) => new Array(n).fill(r));
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  // static fillObjectMatrix<T>(rows: number, columns: number, value: T): IObjectMatrixPrimitiveType<T> {
  //     const matrix = new ObjectMatrix<T>();
  //     for (let r = 0; r < rows; r++) {
  //         for (let c = 0; c < columns; c++) {
  //             matrix.setValue(r, c, value);
  //         }
  //     }
  //     return matrix.getData();
  // }
  static numToWord(t) {
    let n = "";
    for (; t > 0; ) {
      let r = t % 26;
      r = r === 0 ? r = 26 : r, n = String.fromCharCode(96 + r) + n, t = (t - r) / 26;
    }
    return n.toLocaleUpperCase();
  }
  /**
   * Column subscript letter to number
   *
   * @param a - Column subscript letter,e.g.,"A1"
   * @returns Column subscript number,e.g.,0
   *
   */
  static ABCatNum(t) {
    if (t == null || t.length === 0)
      return Number.NaN;
    const n = t.toLowerCase().split(""), r = n.length;
    let s = 0, i = 0;
    for (let o = 0; o < r; o++)
      i = n[o].charCodeAt(0) - 96, s += i * 26 ** (r - o - 1);
    return s === 0 ? Number.NaN : s - 1;
  }
  /**
   * Column subscript number to letter
   *
   * @param n Column subscript number,e.g.,0
   * @returns Column subscript letter,e.g.,"A1"
   */
  static chatAtABC(t) {
    let i = "";
    for (; t >= 0; )
      i = String.fromCharCode(t % 26 + 97) + i, t = Math.floor(t / 26) - 1;
    return i.toUpperCase();
  }
  /**
   * extend two objects
   * @param originJson
   * @param extendJson
   * @returns
   */
  static commonExtend(t, n) {
    const r = {};
    for (const s in t)
      r[s] = t[s];
    for (const s in n)
      n[s] != null && (r[s] = n[s]);
    return r;
  }
  static hasIntersectionBetweenTwoRanges(t, n, r, s) {
    return n >= r && s >= t;
  }
  static isStartValidPosition(t) {
    return /^[A-Za-z--_]/.test(t);
  }
  static isValidParameter(t) {
    const n = /[~!@#$%^&*()+=\-{}\[\]\|:;"'<>,?\/ ]+/.test(t), r = t.length <= 255;
    return !n && r;
  }
  static clamp(t, n, r) {
    return Math.max(n, Math.min(r, t));
  }
  static now() {
    return performance && performance.now ? performance.now() : Date.now();
  }
}
function et(e = 21, t) {
  return t ? im(t, e)() : om(e);
}
function xr(...e) {
  const t = {}, n = e.length;
  for (let r = n - 1; r >= 0; r--) {
    const s = e[r];
    if (s) {
      const i = Object.keys(s);
      for (const o of i)
        t[o] === void 0 && (t[o] = s[o]);
    }
  }
  return t;
}
const f1 = () => typeof process < "u" && process.versions != null && process.versions.node != null;
function m1(e) {
  const n = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/\\\*/g, ".*").replace(/\\\?/g, ".");
  return new RegExp(`^${n}$`, "i");
}
var dm = /* @__PURE__ */ ((e) => (e[e.DEFAULT_SERIES = 0] = "DEFAULT_SERIES", e[e.ALTERNATE_SERIES = 1] = "ALTERNATE_SERIES", e))(dm || {}), Le = /* @__PURE__ */ ((e) => (e[e.NONE = 0] = "NONE", e[e.THIN = 1] = "THIN", e[e.HAIR = 2] = "HAIR", e[e.DOTTED = 3] = "DOTTED", e[e.DASHED = 4] = "DASHED", e[e.DASH_DOT = 5] = "DASH_DOT", e[e.DASH_DOT_DOT = 6] = "DASH_DOT_DOT", e[e.DOUBLE = 7] = "DOUBLE", e[e.MEDIUM = 8] = "MEDIUM", e[e.MEDIUM_DASHED = 9] = "MEDIUM_DASHED", e[e.MEDIUM_DASH_DOT = 10] = "MEDIUM_DASH_DOT", e[e.MEDIUM_DASH_DOT_DOT = 11] = "MEDIUM_DASH_DOT_DOT", e[e.SLANT_DASH_DOT = 12] = "SLANT_DASH_DOT", e[e.THICK = 13] = "THICK", e))(Le || {}), fm = /* @__PURE__ */ ((e) => (e.TOP = "top", e.BOTTOM = "bottom", e.LEFT = "left", e.RIGHT = "right", e.NONE = "none", e.ALL = "all", e.OUTSIDE = "outside", e.INSIDE = "inside", e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e.TLBR = "tlbr", e.TLBC_TLMR = "tlbc_tlmr", e.TLBR_TLBC_TLMR = "tlbr_tlbc_tlmr", e.BLTR = "bl_tr", e.MLTR_BCTR = "mltr_bctr", e))(fm || {}), At = /* @__PURE__ */ ((e) => (e[e.UNSUPPORTED = 0] = "UNSUPPORTED", e[e.RGB = 1] = "RGB", e[e.HEX = 2] = "HEX", e[e.THEME = 3] = "THEME", e))(At || {}), mm = /* @__PURE__ */ ((e) => (e[e.ON = 0] = "ON", e[e.OFF = 1] = "OFF", e))(mm || {}), gm = /* @__PURE__ */ ((e) => (e[e.PASTE_NORMAL = 0] = "PASTE_NORMAL", e[e.PASTE_NO_BORDERS = 1] = "PASTE_NO_BORDERS", e[e.PASTE_FORMAT = 2] = "PASTE_FORMAT", e[e.PASTE_FORMULA = 3] = "PASTE_FORMULA", e[e.PASTE_DATA_VALIDATION = 4] = "PASTE_DATA_VALIDATION", e[e.PASTE_VALUES = 5] = "PASTE_VALUES", e[e.PASTE_CONDITIONAL_FORMATTING = 6] = "PASTE_CONDITIONAL_FORMATTING", e[e.PASTE_COLUMN_WIDTHS = 7] = "PASTE_COLUMN_WIDTHS", e))(gm || {}), _m = /* @__PURE__ */ ((e) => (e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e))(_m || {}), pm = /* @__PURE__ */ ((e) => (e[e.DOCUMENT = 0] = "DOCUMENT", e[e.PROJECT = 1] = "PROJECT", e))(pm || {}), Em = /* @__PURE__ */ ((e) => (e[e.COLUMNS = 0] = "COLUMNS", e[e.ROWS = 1] = "ROWS", e))(Em || {}), Cm = /* @__PURE__ */ ((e) => (e[e.UP = 0] = "UP", e[e.RIGHT = 1] = "RIGHT", e[e.DOWN = 2] = "DOWN", e[e.LEFT = 3] = "LEFT", e))(Cm || {});
function g1(e) {
  switch (e) {
    case 3:
      return 1;
    case 1:
      return 3;
    case 0:
      return 2;
    case 2:
      return 0;
  }
}
var Rm = /* @__PURE__ */ ((e) => (e[e.INTERPOLATION_POINT_TYPE_UNSPECIFIED = 0] = "INTERPOLATION_POINT_TYPE_UNSPECIFIED", e[e.MIN = 1] = "MIN", e[e.MAX = 2] = "MAX", e[e.NUMBER = 3] = "NUMBER", e[e.PERCENT = 4] = "PERCENT", e[e.PERCENTILE = 5] = "PERCENTILE", e))(Rm || {}), Ns = /* @__PURE__ */ ((e) => (e.EN_US = "enUS", e.FR_FR = "frFR", e.ZH_CN = "zhCN", e.RU_RU = "ruRU", e.ZH_TW = "zhTW", e.VI_VN = "viVN", e.FA_IR = "faIR", e.KO_KR = "koKR", e.ES_ES = "esES", e.CA_ES = "caES", e))(Ns || {}), Ii = /* @__PURE__ */ ((e) => (e[e.PERSON = 0] = "PERSON", e[e.FILE = 1] = "FILE", e[e.DATE = 2] = "DATE", e[e.LOCATION = 3] = "LOCATION", e[e.EVENT = 4] = "EVENT", e))(Ii || {}), Im = /* @__PURE__ */ ((e) => (e[e.RANGE = 0] = "RANGE", e[e.SHEET = 1] = "SHEET", e))(Im || {}), wm = /* @__PURE__ */ ((e) => (e.Line = "line", e.LineInv = "lineInv", e.Triangle = "triangle", e.RtTriangle = "rtTriangle", e.Rect = "rect", e.Diamond = "diamond", e.Parallelogram = "parallelogram", e.Trapezoid = "trapezoid", e.NonIsocelesTrapezoid = "nonIsocelesTrapezoid", e.Pentagon = "pentagon", e.Hexagon = "hexagon", e.Heptagon = "heptagon", e.Octagon = "octagon", e.Decagon = "decagon", e.Dodecagon = "dodecagon", e.Star4 = "star4", e.Star5 = "star5", e.Star6 = "star6", e.Star7 = "star7", e.Star8 = "star8", e.Star10 = "star10", e.Star12 = "star12", e.Star16 = "star16", e.Star24 = "star24", e.Star32 = "star32", e.RoundRect = "roundRect", e.Round1Rect = "round1Rect", e.Round2SameRect = "round2SameRect", e.Round2DiagRect = "round2DiagRect", e.Ellipse = "ellipse", e))(wm || {}), Sm = /* @__PURE__ */ ((e) => (e.RightArrow = "rightArrow", e.LeftArrow = "leftArrow", e.UpArrow = "upArrow", e.DownArrow = "downArrow", e.LeftRightArrow = "leftRightArrow", e.UpDownArrow = "upDownArrow", e.QuadArrow = "quadArrow", e.LeftRightUpArrow = "leftRightUpArrow", e.BentArrow = "bentArrow", e.UturnArrow = "uturnArrow", e.CircularArrow = "circularArrow", e.NotchedRightArrow = "notchedRightArrow", e.HomePlate = "homePlate", e.Chevron = "chevron", e.LeftCircularArrow = "leftCircularArrow", e.LeftRightCircularArrow = "leftRightCircularArrow", e))(Sm || {}), Om = /* @__PURE__ */ ((e) => (e.Plaque = "plaque", e.Can = "can", e.Cube = "cube", e.Bevel = "bevel", e.Donut = "donut", e.NoSmoking = "noSmoking", e.BlockArc = "blockArc", e.FoldedCorner = "foldedCorner", e))(Om || {}), vm = /* @__PURE__ */ ((e) => (e.SmileyFace = "smileyFace", e.Heart = "heart", e.LightningBolt = "lightningBolt", e.Sun = "sun", e.Moon = "moon", e.Cloud = "cloud", e.Arc = "arc", e.Backpack = "backpack", e.Frame = "frame", e.HalfFrame = "halfFrame", e.Corner = "corner", e.Chord = "chord", e.Pie = "pie", e.Teardrop = "teardrop", e.WedgeRectCallout = "wedgeRectCallout", e.WedgeRRectCallout = "wedgeRRectCallout", e.WedgeEllipseCallout = "wedgeEllipseCallout", e.CloudCallout = "cloudCallout", e.BorderCallout1 = "borderCallout1", e.BorderCallout2 = "borderCallout2", e.BorderCallout3 = "borderCallout3", e.AccentCallout1 = "accentCallout1", e.AccentCallout2 = "accentCallout2", e.AccentCallout3 = "accentCallout3", e.Callout1 = "callout1", e.Callout2 = "callout2", e.Callout3 = "callout3", e.ActionButtonBackPrevious = "actionButtonBackPrevious", e.ActionButtonEnd = "actionButtonEnd", e.ActionButtonForwardNext = "actionButtonForwardNext", e.ActionButtonHelp = "actionButtonHelp", e.ActionButtonHome = "actionButtonHome", e.ActionButtonInformation = "actionButtonInformation", e.ActionButtonMovie = "actionButtonMovie", e.ActionButtonReturn = "actionButtonReturn", e.ActionButtonSound = "actionButtonSound", e))(vm || {}), bm = /* @__PURE__ */ ((e) => (e[e.RELATIVE_DATE_UNSPECIFIED = 0] = "RELATIVE_DATE_UNSPECIFIED", e[e.PAST_YEAR = 1] = "PAST_YEAR", e[e.PAST_MONTH = 2] = "PAST_MONTH", e[e.PAST_WEEK = 3] = "PAST_WEEK", e[e.YESTERDAY = 4] = "YESTERDAY", e[e.TODAY = 5] = "TODAY", e[e.TOMORROW = 6] = "TOMORROW", e))(bm || {}), Am = /* @__PURE__ */ ((e) => (e[e.GRID = 0] = "GRID", e[e.KANBAN = 1] = "KANBAN", e[e.GANTT = 2] = "GANTT", e))(Am || {}), ms = /* @__PURE__ */ ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LEFT_TO_RIGHT = 1] = "LEFT_TO_RIGHT", e[e.RIGHT_TO_LEFT = 2] = "RIGHT_TO_LEFT", e))(ms || {}), ym = /* @__PURE__ */ ((e) => (e[e.DASH = 0] = "DASH", e[e.DASH_DOT_DOT_HEAVY = 1] = "DASH_DOT_DOT_HEAVY", e[e.DASH_DOT_HEAVY = 2] = "DASH_DOT_HEAVY", e[e.DASHED_HEAVY = 3] = "DASHED_HEAVY", e[e.DASH_LONG = 4] = "DASH_LONG", e[e.DASH_LONG_HEAVY = 5] = "DASH_LONG_HEAVY", e[e.DOT_DASH = 6] = "DOT_DASH", e[e.DOT_DOT_DASH = 7] = "DOT_DOT_DASH", e[e.DOTTED = 8] = "DOTTED", e[e.DOTTED_HEAVY = 9] = "DOTTED_HEAVY", e[e.DOUBLE = 10] = "DOUBLE", e[e.NONE = 11] = "NONE", e[e.SINGLE = 12] = "SINGLE", e[e.THICK = 13] = "THICK", e[e.WAVE = 14] = "WAVE", e[e.WAVY_DOUBLE = 15] = "WAVY_DOUBLE", e[e.WAVY_HEAVY = 16] = "WAVY_HEAVY", e[e.WORDS = 17] = "WORDS", e))(ym || {}), Ut = /* @__PURE__ */ ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LEFT = 1] = "LEFT", e[e.CENTER = 2] = "CENTER", e[e.RIGHT = 3] = "RIGHT", e[e.JUSTIFIED = 4] = "JUSTIFIED", e[e.BOTH = 5] = "BOTH", e[e.DISTRIBUTED = 6] = "DISTRIBUTED", e))(Ut || {}), xn = /* @__PURE__ */ ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.TOP = 1] = "TOP", e[e.MIDDLE = 2] = "MIDDLE", e[e.BOTTOM = 3] = "BOTTOM", e))(xn || {}), Bn = /* @__PURE__ */ ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.OVERFLOW = 1] = "OVERFLOW", e[e.CLIP = 2] = "CLIP", e[e.WRAP = 3] = "WRAP", e))(Bn || {}), wi = /* @__PURE__ */ ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.ITALIC = 1] = "ITALIC", e))(wi || {}), Si = /* @__PURE__ */ ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.BOLD = 1] = "BOLD", e))(Si || {}), Zt = /* @__PURE__ */ ((e) => (e[e.NORMAL = 1] = "NORMAL", e[e.SUBSCRIPT = 2] = "SUBSCRIPT", e[e.SUPERSCRIPT = 3] = "SUPERSCRIPT", e))(Zt || {}), ie = /* @__PURE__ */ ((e) => (e[e.FALSE = 0] = "FALSE", e[e.TRUE = 1] = "TRUE", e))(ie || {}), fn = /* @__PURE__ */ ((e) => (e[e.STRING = 1] = "STRING", e[e.NUMBER = 2] = "NUMBER", e[e.BOOLEAN = 3] = "BOOLEAN", e[e.FORCE_STRING = 4] = "FORCE_STRING", e))(fn || {}), st = /* @__PURE__ */ ((e) => (e[e.DARK1 = 0] = "DARK1", e[e.LIGHT1 = 1] = "LIGHT1", e[e.DARK2 = 2] = "DARK2", e[e.LIGHT2 = 3] = "LIGHT2", e[e.ACCENT1 = 4] = "ACCENT1", e[e.ACCENT2 = 5] = "ACCENT2", e[e.ACCENT3 = 6] = "ACCENT3", e[e.ACCENT4 = 7] = "ACCENT4", e[e.ACCENT5 = 8] = "ACCENT5", e[e.ACCENT6 = 9] = "ACCENT6", e[e.HYPERLINK = 10] = "HYPERLINK", e[e.FOLLOWED_HYPERLINK = 11] = "FOLLOWED_HYPERLINK", e))(st || {}), co = /* @__PURE__ */ ((e) => (e.OFFICE = "Office", e.OFFICE_2007_2010 = "Office 2007-2010", e.GRAYSCALE = "Grayscale", e.BLUE_WARM = "Blue Warm", e.BLUE = "Blue", e.BLUE_II = "Blue II", e.BLUE_GREEN = "Blue Green", e.GREEN = "Green", e.GREEN_YELLOW = "Green Yellow", e.YELLOW = "Yellow", e.YELLOW_ORANGE = "Yellow Orange", e.ORANGE = "Orange", e.ORANGE_RED = "Orange Red", e.RED_ORANGE = "Red Orange", e.RED = "Red", e.RED_VIOLET = "Red Violet", e.VIOLET = "Violet", e.VIOLET_II = "Violet II", e.MEDIAN = "Median", e.PAPER = "Paper", e.MARQUEE = "Marquee", e.SLIPSTREAM = "Slipstream", e.Aspect = "Aspect", e))(co || {}), Nm = /* @__PURE__ */ ((e) => (e[e.character = 0] = "character", e[e.paragraph = 1] = "paragraph", e[e.table = 2] = "table", e[e.numbering = 3] = "numbering", e))(Nm || {}), Tm = /* @__PURE__ */ ((e) => (e[e.TAB = 0] = "TAB", e[e.SPACE = 1] = "SPACE", e[e.NOTHING = 2] = "NOTHING", e))(Tm || {}), me = /* @__PURE__ */ ((e) => (e[e.BULLET = 0] = "BULLET", e[e.NONE = 1] = "NONE", e[e.DECIMAL = 2] = "DECIMAL", e[e.DECIMAL_ZERO = 3] = "DECIMAL_ZERO", e[e.UPPER_LETTER = 4] = "UPPER_LETTER", e[e.LOWER_LETTER = 5] = "LOWER_LETTER", e[e.UPPER_ROMAN = 6] = "UPPER_ROMAN", e[e.LOWER_ROMAN = 7] = "LOWER_ROMAN", e[e.ORDINAL = 8] = "ORDINAL", e[e.CARDINAL_TEXT = 9] = "CARDINAL_TEXT", e[e.ORDINAL_TEXT = 10] = "ORDINAL_TEXT", e[e.HEX = 11] = "HEX", e[e.CHICAGO = 12] = "CHICAGO", e[e.IDEOGRAPH_DIGITAL = 13] = "IDEOGRAPH_DIGITAL", e[e.JAPANESE_COUNTING = 14] = "JAPANESE_COUNTING", e[e.AIUEO = 15] = "AIUEO", e[e.IROHA = 16] = "IROHA", e[e.DECIMAL_FULL_WIDTH = 17] = "DECIMAL_FULL_WIDTH", e[e.DECIMAL_HALF_WIDTH = 18] = "DECIMAL_HALF_WIDTH", e[e.JAPANESE_LEGAL = 19] = "JAPANESE_LEGAL", e[e.JAPANESE_DIGITAL_TEN_THOUSAND = 20] = "JAPANESE_DIGITAL_TEN_THOUSAND", e[e.DECIMAL_ENCLOSED_CIRCLE = 21] = "DECIMAL_ENCLOSED_CIRCLE", e[e.DECIMAL_FULL_WIDTH2 = 22] = "DECIMAL_FULL_WIDTH2", e[e.AIUEO_FULL_WIDTH = 23] = "AIUEO_FULL_WIDTH", e[e.IROHA_FULL_WIDTH = 24] = "IROHA_FULL_WIDTH", e[e.GANADA = 25] = "GANADA", e[e.CHOSUNG = 26] = "CHOSUNG", e[e.DECIMAL_ENCLOSED_FULLSTOP = 27] = "DECIMAL_ENCLOSED_FULLSTOP", e[e.DECIMAL_ENCLOSED_PAREN = 28] = "DECIMAL_ENCLOSED_PAREN", e[e.DECIMAL_ENCLOSED_CIRCLE_CHINESE = 29] = "DECIMAL_ENCLOSED_CIRCLE_CHINESE", e[e.IDEOGRAPH_ENCLOSED_CIRCLE = 30] = "IDEOGRAPH_ENCLOSED_CIRCLE", e[e.IDEOGRAPH_TRADITIONAL = 31] = "IDEOGRAPH_TRADITIONAL", e[e.IDEOGRAPH_ZODIAC = 32] = "IDEOGRAPH_ZODIAC", e[e.IDEOGRAPH_ZODIAC_TRADITIONAL = 33] = "IDEOGRAPH_ZODIAC_TRADITIONAL", e[e.TAIWANESE_COUNTING = 34] = "TAIWANESE_COUNTING", e[e.IDEOGRAPH_LEGAL_TRADITIONAL = 35] = "IDEOGRAPH_LEGAL_TRADITIONAL", e[e.TAIWANESE_COUNTING_THOUSAND = 36] = "TAIWANESE_COUNTING_THOUSAND", e[e.TAIWANESE_DIGITAL = 37] = "TAIWANESE_DIGITAL", e[e.CHINESE_COUNTING = 38] = "CHINESE_COUNTING", e[e.CHINESE_LEGAL_SIMPLIFIED = 39] = "CHINESE_LEGAL_SIMPLIFIED", e[e.CHINESE_COUNTING_THOUSAND = 40] = "CHINESE_COUNTING_THOUSAND", e[e.KOREAN_DIGITAL = 41] = "KOREAN_DIGITAL", e[e.KOREAN_COUNTING = 42] = "KOREAN_COUNTING", e[e.KOREAN_LEGAL = 43] = "KOREAN_LEGAL", e[e.KOREAN_DIGITAL2 = 44] = "KOREAN_DIGITAL2", e[e.VIETNAMESE_COUNTING = 45] = "VIETNAMESE_COUNTING", e[e.RUSSIAN_LOWER = 46] = "RUSSIAN_LOWER", e[e.RUSSIAN_UPPER = 47] = "RUSSIAN_UPPER", e[e.NUMBER_IN_DASH = 48] = "NUMBER_IN_DASH", e[e.HEBREW1 = 49] = "HEBREW1", e[e.HEBREW2 = 50] = "HEBREW2", e[e.ARABIC_ALPHA = 51] = "ARABIC_ALPHA", e[e.ARABIC_ABJAD = 52] = "ARABIC_ABJAD", e[e.HINDI_VOWELS = 53] = "HINDI_VOWELS", e[e.HINDI_CONSONANTS = 54] = "HINDI_CONSONANTS", e[e.HINDI_NUMBERS = 55] = "HINDI_NUMBERS", e[e.HINDI_COUNTING = 56] = "HINDI_COUNTING", e[e.THAI_LETTERS = 57] = "THAI_LETTERS", e[e.THAI_NUMBERS = 58] = "THAI_NUMBERS", e[e.THAI_COUNTING = 59] = "THAI_COUNTING", e[e.CUSTOM = 60] = "CUSTOM", e))(me || {}), Ts = /* @__PURE__ */ ((e) => (e[e.BULLET_ALIGNMENT_UNSPECIFIED = 0] = "BULLET_ALIGNMENT_UNSPECIFIED", e[e.START = 1] = "START", e[e.CENTER = 2] = "CENTER", e[e.END = 3] = "END", e[e.BOTH = 4] = "BOTH", e))(Ts || {}), pn = /* @__PURE__ */ ((e) => (e[e.HYPERLINK = 0] = "HYPERLINK", e[e.FIELD = 1] = "FIELD", e[e.SDT = 2] = "SDT", e[e.BOOKMARK = 3] = "BOOKMARK", e[e.COMMENT = 4] = "COMMENT", e[e.CUSTOM = 5] = "CUSTOM", e[e.MENTION = 6] = "MENTION", e[e.UNI_FORMULA = 7] = "UNI_FORMULA", e[e.DELTED = 9999] = "DELTED", e))(pn || {}), Dn = /* @__PURE__ */ ((e) => (e[e.COMMENT = 0] = "COMMENT", e[e.DELETED = 9999] = "DELETED", e))(Dn || {}), Mm = /* @__PURE__ */ ((e) => (e[e.DRAWING = 0] = "DRAWING", e[e.CUSTOM = 1] = "CUSTOM", e))(Mm || {}), uu = /* @__PURE__ */ ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.TRADITIONAL = 1] = "TRADITIONAL", e[e.MODERN = 2] = "MODERN", e))(uu || {}), Lm = /* @__PURE__ */ ((e) => (e[e.DEFAULT = 0] = "DEFAULT", e[e.LINES = 1] = "LINES", e[e.LINES_AND_CHARS = 2] = "LINES_AND_CHARS", e[e.SNAP_TO_CHARS = 3] = "SNAP_TO_CHARS", e))(Lm || {}), xm = /* @__PURE__ */ ((e) => (e[e.SECTION_TYPE_UNSPECIFIED = 0] = "SECTION_TYPE_UNSPECIFIED", e[e.CONTINUOUS = 1] = "CONTINUOUS", e[e.NEXT_PAGE = 2] = "NEXT_PAGE", e[e.EVEN_PAGE = 3] = "EVEN_PAGE", e[e.ODD_PAGE = 4] = "ODD_PAGE", e))(xm || {}), Dm = /* @__PURE__ */ ((e) => (e[e.COLUMN_SEPARATOR_STYLE_UNSPECIFIED = 0] = "COLUMN_SEPARATOR_STYLE_UNSPECIFIED", e[e.NONE = 1] = "NONE", e[e.BETWEEN_EACH_COLUMN = 2] = "BETWEEN_EACH_COLUMN", e))(Dm || {}), Um = /* @__PURE__ */ ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.TBRL = 1] = "TBRL", e[e.LRTBV = 2] = "LRTBV", e))(Um || {}), km = /* @__PURE__ */ ((e) => (e[e.TEXT_RUN = 0] = "TEXT_RUN", e[e.AUTO_TEXT = 1] = "AUTO_TEXT", e[e.PAGE_BREAK = 2] = "PAGE_BREAK", e[e.COLUMN_BREAK = 3] = "COLUMN_BREAK", e[e.FOOT_NOTE_REFERENCE = 4] = "FOOT_NOTE_REFERENCE", e[e.HORIZONTAL_RULE = 5] = "HORIZONTAL_RULE", e[e.EQUATION = 6] = "EQUATION", e[e.DRAWING = 7] = "DRAWING", e[e.PERSON = 8] = "PERSON", e[e.RICH_LINK = 9] = "RICH_LINK", e))(km || {}), Pm = /* @__PURE__ */ ((e) => (e[e.BOTH_SIDES = 0] = "BOTH_SIDES", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.LARGEST = 3] = "LARGEST", e))(Pm || {}), Fm = /* @__PURE__ */ ((e) => (e[e.INLINE = 0] = "INLINE", e[e.WRAP_NONE = 1] = "WRAP_NONE", e[e.WRAP_POLYGON = 2] = "WRAP_POLYGON", e[e.WRAP_SQUARE = 3] = "WRAP_SQUARE", e[e.WRAP_THROUGH = 4] = "WRAP_THROUGH", e[e.WRAP_TIGHT = 5] = "WRAP_TIGHT", e[e.WRAP_TOP_AND_BOTTOM = 6] = "WRAP_TOP_AND_BOTTOM", e))(Fm || {}), qe = /* @__PURE__ */ ((e) => (e[e.NAMED_STYLE_TYPE_UNSPECIFIED = 0] = "NAMED_STYLE_TYPE_UNSPECIFIED", e[e.NORMAL_TEXT = 1] = "NORMAL_TEXT", e[e.TITLE = 2] = "TITLE", e[e.SUBTITLE = 3] = "SUBTITLE", e[e.HEADING_1 = 4] = "HEADING_1", e[e.HEADING_2 = 5] = "HEADING_2", e[e.HEADING_3 = 6] = "HEADING_3", e[e.HEADING_4 = 7] = "HEADING_4", e[e.HEADING_5 = 8] = "HEADING_5", e))(qe || {}), $m = /* @__PURE__ */ ((e) => (e[e.AUTO = 0] = "AUTO", e[e.AT_LEAST = 1] = "AT_LEAST", e[e.EXACT = 2] = "EXACT", e))($m || {}), Hm = /* @__PURE__ */ ((e) => (e[e.DASH_STYLE_UNSPECIFIED = 0] = "DASH_STYLE_UNSPECIFIED", e[e.SOLID = 1] = "SOLID", e[e.DOT = 2] = "DOT", e[e.DASH = 3] = "DASH", e))(Hm || {}), Bm = /* @__PURE__ */ ((e) => (e[e.TAB_STOP_ALIGNMENT_UNSPECIFIED = 0] = "TAB_STOP_ALIGNMENT_UNSPECIFIED", e[e.START = 1] = "START", e[e.CENTER = 2] = "CENTER", e[e.END = 3] = "END", e))(Bm || {}), jm = /* @__PURE__ */ ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.SPECIFIED = 1] = "SPECIFIED", e))(jm || {}), Wm = /* @__PURE__ */ ((e) => (e[e.START = 0] = "START", e[e.CENTER = 1] = "CENTER", e[e.END = 2] = "END", e))(Wm || {}), Ym = /* @__PURE__ */ ((e) => (e[e.AUTO_FIT = 0] = "AUTO_FIT", e[e.FIXED = 1] = "FIXED", e))(Ym || {}), zm = /* @__PURE__ */ ((e) => (e[e.NONE = 0] = "NONE", e[e.WRAP = 1] = "WRAP", e))(zm || {}), Vm = /* @__PURE__ */ ((e) => (e[e.AUTO = 0] = "AUTO", e[e.AT_LEAST = 1] = "AT_LEAST", e[e.EXACT = 2] = "EXACT", e))(Vm || {}), Gm = /* @__PURE__ */ ((e) => (e[e.CONTENT_ALIGNMENT_UNSPECIFIED = 0] = "CONTENT_ALIGNMENT_UNSPECIFIED", e[e.BOTH = 1] = "BOTH", e[e.TOP = 2] = "TOP", e[e.CENTER = 3] = "CENTER", e[e.BOTTOM = 4] = "BOTTOM", e))(Gm || {}), ir = /* @__PURE__ */ ((e) => (e.NORMAL = "normal", e.BOLD = "bold", e.ITALIC = "italic", e))(ir || {}), Km = /* @__PURE__ */ ((e) => (e[e.PAGE = 0] = "PAGE", e[e.COLUMN = 1] = "COLUMN", e[e.CHARACTER = 2] = "CHARACTER", e[e.MARGIN = 3] = "MARGIN", e[e.INSIDE_MARGIN = 4] = "INSIDE_MARGIN", e[e.OUTSIDE_MARGIN = 5] = "OUTSIDE_MARGIN", e[e.LEFT_MARGIN = 6] = "LEFT_MARGIN", e[e.RIGHT_MARGIN = 7] = "RIGHT_MARGIN", e))(Km || {}), Xm = /* @__PURE__ */ ((e) => (e[e.PAGE = 0] = "PAGE", e[e.PARAGRAPH = 1] = "PARAGRAPH", e[e.LINE = 2] = "LINE", e[e.MARGIN = 3] = "MARGIN", e[e.TOP_MARGIN = 4] = "TOP_MARGIN", e[e.BOTTOM_MARGIN = 5] = "BOTTOM_MARGIN", e[e.INSIDE_MARGIN = 6] = "INSIDE_MARGIN", e[e.OUTSIDE_MARGIN = 7] = "OUTSIDE_MARGIN", e))(Xm || {}), qm = /* @__PURE__ */ ((e) => (e[e.POINT = 0] = "POINT", e[e.LINE = 1] = "LINE", e[e.CHARACTER = 2] = "CHARACTER", e[e.PIXEL = 3] = "PIXEL", e[e.PERCENT = 4] = "PERCENT", e))(qm || {}), Zm = /* @__PURE__ */ ((e) => (e[e.CENTER = 0] = "CENTER", e[e.INSIDE = 1] = "INSIDE", e[e.LEFT = 2] = "LEFT", e[e.OUTSIDE = 3] = "OUTSIDE", e[e.RIGHT = 4] = "RIGHT", e[e.BOTH = 5] = "BOTH", e[e.DISTRIBUTE = 6] = "DISTRIBUTE", e))(Zm || {}), Jm = /* @__PURE__ */ ((e) => (e[e.BOTTOM = 0] = "BOTTOM", e[e.CENTER = 1] = "CENTER", e[e.INSIDE = 2] = "INSIDE", e[e.OUTSIDE = 3] = "OUTSIDE", e[e.TOP = 4] = "TOP", e))(Jm || {}), Qm = /* @__PURE__ */ ((e) => (e[e.compressPunctuation = 0] = "compressPunctuation", e[e.compressPunctuationAndJapaneseKana = 1] = "compressPunctuationAndJapaneseKana", e[e.doNotCompress = 2] = "doNotCompress", e))(Qm || {}), eg = /* @__PURE__ */ ((e) => (e[e.PORTRAIT = 0] = "PORTRAIT", e[e.LANDSCAPE = 1] = "LANDSCAPE", e))(eg || {}), gt = /* @__PURE__ */ ((e) => (e.Letter = "Letter", e.Tabloid = "Tabloid", e.Legal = "Legal", e.Statement = "Statement", e.Executive = "Executive", e.Folio = "Folio", e.A3 = "A3", e.A4 = "A4", e.A5 = "A5", e.B4 = "B4", e.B5 = "B5", e))(gt || {});
const _1 = [
  "A3",
  "A4",
  "A5",
  "B4",
  "B5",
  "Letter",
  "Tabloid",
  "Legal",
  "Statement",
  "Executive",
  "Folio"
  /* Folio */
];
var tg = /* @__PURE__ */ ((e) => (e[e.forward = 0] = "forward", e[e.backward = 1] = "backward", e[e.front = 2] = "front", e[e.back = 3] = "back", e))(tg || {}), ng = /* @__PURE__ */ ((e) => (e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e[e.DRAWING_IMAGE = 0] = "DRAWING_IMAGE", e[e.DRAWING_SHAPE = 1] = "DRAWING_SHAPE", e[e.DRAWING_CHART = 2] = "DRAWING_CHART", e[e.DRAWING_TABLE = 3] = "DRAWING_TABLE", e[e.DRAWING_SMART_ART = 4] = "DRAWING_SMART_ART", e[e.DRAWING_VIDEO = 5] = "DRAWING_VIDEO", e[e.DRAWING_GROUP = 6] = "DRAWING_GROUP", e[e.DRAWING_UNIT = 7] = "DRAWING_UNIT", e[e.DRAWING_DOM = 8] = "DRAWING_DOM", e))(ng || {}), cu = /* @__PURE__ */ ((e) => (e[e.SLIDE = 0] = "SLIDE", e[e.MASTER = 1] = "MASTER", e[e.LAYOUT = 2] = "LAYOUT", e[e.HANDOUT_MASTER = 3] = "HANDOUT_MASTER", e[e.NOTES_MASTER = 4] = "NOTES_MASTER", e))(cu || {}), rg = /* @__PURE__ */ ((e) => (e[e.SHAPE = 0] = "SHAPE", e[e.IMAGE = 1] = "IMAGE", e[e.TEXT = 2] = "TEXT", e[e.SPREADSHEET = 3] = "SPREADSHEET", e[e.DOCUMENT = 4] = "DOCUMENT", e[e.SLIDE = 5] = "SLIDE", e))(rg || {}), sg = /* @__PURE__ */ ((e) => (e[e.RELATIVE_SLIDE_LINK_UNSPECIFIED = 0] = "RELATIVE_SLIDE_LINK_UNSPECIFIED", e[e.NEXT_SLIDE = 1] = "NEXT_SLIDE", e[e.PREVIOUS_SLIDE = 2] = "PREVIOUS_SLIDE", e[e.FIRST_SLIDE = 3] = "FIRST_SLIDE", e[e.LAST_SLIDE = 4] = "LAST_SLIDE", e))(sg || {});
function ig(e = et(6), t = Ns.EN_US, n = "") {
  return {
    id: e,
    locale: t,
    title: n,
    // title should get from request.
    tableSource: {},
    drawings: {},
    drawingsOrder: [],
    headers: {},
    footers: {},
    body: {
      dataStream: `\r
`,
      textRuns: [],
      customBlocks: [],
      tables: [],
      paragraphs: [
        {
          startIndex: 0,
          paragraphStyle: {
            spaceAbove: { v: 5 },
            lineSpacing: 1,
            spaceBelow: { v: 0 }
          }
        }
      ],
      sectionBreaks: [
        {
          startIndex: 1
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: 793.3333333333334,
        height: 1122.6666666666667
      },
      documentFlavor: uu.TRADITIONAL,
      marginTop: 50,
      marginBottom: 50,
      marginRight: 50,
      marginLeft: 50,
      renderConfig: {
        zeroWidthParagraphBreak: ie.FALSE,
        vertexAngle: 0,
        centerAngle: 0,
        background: {
          rgb: "#ccc"
        }
      },
      autoHyphenation: ie.TRUE,
      doNotHyphenateCaps: ie.FALSE,
      consecutiveHyphenLimit: 2,
      defaultHeaderId: "",
      defaultFooterId: "",
      evenPageHeaderId: "",
      evenPageFooterId: "",
      firstPageHeaderId: "",
      firstPageFooterId: "",
      evenAndOddHeaders: ie.FALSE,
      useFirstPageHeaderFooter: ie.FALSE,
      marginHeader: 30,
      marginFooter: 30
    },
    settings: {}
  };
}
var an = {}, Zn = {}, Dr = {}, wa;
function og() {
  if (wa) return Dr;
  wa = 1, Object.defineProperty(Dr, "__esModule", { value: !0 });
  function e(r, s) {
    if (Array.isArray(s))
      return !1;
    for (let i in r)
      if (!n(r[i], s[i]))
        return !1;
    for (let i in s)
      if (r[i] === void 0)
        return !1;
    return !0;
  }
  function t(r, s) {
    if (!Array.isArray(s) || r.length !== s.length)
      return !1;
    for (let i = 0; i < r.length; i++)
      if (!n(r[i], s[i]))
        return !1;
    return !0;
  }
  function n(r, s) {
    return r === s ? !0 : r === null || s === null || typeof r != "object" || typeof s != "object" ? !1 : Array.isArray(r) ? t(r, s) : e(r, s);
  }
  return Dr.default = n, Dr;
}
var Ur = {}, Sa;
function ag() {
  if (Sa) return Ur;
  Sa = 1, Object.defineProperty(Ur, "__esModule", { value: !0 });
  function e(t) {
    if (t === null)
      return null;
    if (Array.isArray(t))
      return t.map(e);
    if (typeof t == "object") {
      const n = {};
      for (let r in t)
        n[r] = e(t[r]);
      return n;
    } else
      return t;
  }
  return Ur.default = e, Ur;
}
var qs = {}, Oa;
function hu() {
  return Oa || (Oa = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.eachChildOf = e.advancer = e.readCursor = e.writeCursor = e.WriteCursor = e.ReadCursor = e.isValidPathItem = void 0;
    function t(c, h) {
      if (!c)
        throw new Error(h);
    }
    const n = (c) => c != null && typeof c == "object" && !Array.isArray(c), r = (c, h) => (
      // All the numbers, then all the letters. Just as the gods of ascii intended.
      typeof c == typeof h ? c > h : typeof c == "string" && typeof h == "number"
    );
    function s(c, h) {
      for (let d in c) {
        const f = d;
        h.write(f, c[f]);
      }
    }
    e.isValidPathItem = (c) => typeof c == "number" || typeof c == "string" && c !== "__proto__";
    class i {
      constructor(h = null) {
        this.parents = [], this.indexes = [], this.lcIdx = -1, this.idx = -1, this.container = h;
      }
      ascend() {
        t(this.parents.length === this.indexes.length / 2), this.idx === 0 ? this.parents.length ? (this.lcIdx = this.indexes.pop(), this.container = this.parents.pop(), this.idx = this.indexes.pop()) : (this.lcIdx = 0, this.idx = -1) : (t(this.idx > 0), this.idx--, n(this.container[this.idx]) && this.idx--);
      }
      getPath() {
        const h = [];
        let d = this.container, f = this.parents.length - 1, g = this.idx;
        for (; g >= 0; )
          h.unshift(d[g]), g === 0 ? (g = this.indexes[f * 2], d = this.parents[f--]) : g -= n(d[g - 1]) ? 2 : 1;
        return h;
      }
    }
    class o extends i {
      get() {
        return this.container ? this.container.slice(this.idx + 1) : null;
      }
      // Its only valid to call this after descending into a child.
      getKey() {
        return t(this.container != null, "Invalid call to getKey before cursor descended"), this.container[this.idx];
      }
      getComponent() {
        let h;
        return this.container && this.container.length > this.idx + 1 && n(h = this.container[this.idx + 1]) ? h : null;
      }
      descendFirst() {
        let h = this.idx + 1;
        if (!this.container || h >= this.container.length || n(this.container[h]) && h + 1 >= this.container.length)
          return !1;
        n(this.container[h]) && h++;
        const d = this.container[h];
        return Array.isArray(d) ? (this.indexes.push(this.idx), this.parents.push(this.container), this.indexes.push(h), this.idx = 0, this.container = d) : this.idx = h, !0;
      }
      nextSibling() {
        if (t(this.parents.length === this.indexes.length / 2), this.idx > 0 || this.parents.length === 0)
          return !1;
        const h = this.indexes[this.indexes.length - 1] + 1, d = this.parents[this.parents.length - 1];
        return h >= d.length ? !1 : (t(!isNaN(h)), this.indexes[this.indexes.length - 1] = h, this.container = d[h], !0);
      }
      _init(h, d, f, g) {
        this.container = h, this.idx = d, this.parents = f.slice(), this.indexes = g.slice();
      }
      clone() {
        const h = new o();
        return h._init(this.container, this.idx, this.parents, this.indexes), h;
      }
      *[Symbol.iterator]() {
        if (this.descendFirst()) {
          do
            yield this.getKey();
          while (this.nextSibling());
          this.ascend();
        }
      }
      // TODO(cleanup): Consider moving these functions out of cursor, since
      // they're really just helper methods.
      // It'd be really nice to do this using generators.
      traverse(h, d) {
        const f = this.getComponent();
        f && d(f, h);
        for (const g of this)
          h && h.descend(g), this.traverse(h, d), h && h.ascend();
      }
      eachPick(h, d) {
        this.traverse(h, (f, g) => {
          f.p != null && d(f.p, g);
        });
      }
      eachDrop(h, d) {
        this.traverse(h, (f, g) => {
          f.d != null && d(f.d, g);
        });
      }
    }
    e.ReadCursor = o;
    class a extends i {
      constructor(h = null) {
        super(h), this.pendingDescent = [], this._op = h;
      }
      flushDescent() {
        t(this.parents.length === this.indexes.length / 2), this.container === null && (this._op = this.container = []);
        for (let h = 0; h < this.pendingDescent.length; h++) {
          const d = this.pendingDescent[h];
          let f = this.idx + 1;
          if (f < this.container.length && n(this.container[f]) && f++, t(f === this.container.length || !n(this.container[f])), f === this.container.length)
            this.container.push(d), this.idx = f;
          else if (this.container[f] === d)
            this.idx = f;
          else {
            if (!Array.isArray(this.container[f])) {
              const g = this.container.splice(f, this.container.length - f);
              this.container.push(g), this.lcIdx > -1 && (this.lcIdx = f);
            }
            for (this.indexes.push(this.idx), this.parents.push(this.container), this.lcIdx !== -1 && (t(r(d, this.container[this.lcIdx][0])), f = this.lcIdx + 1, this.lcIdx = -1); f < this.container.length && r(d, this.container[f][0]); )
              f++;
            if (this.indexes.push(f), this.idx = 0, f < this.container.length && this.container[f][0] === d)
              this.container = this.container[f];
            else {
              const g = [d];
              this.container.splice(f, 0, g), this.container = g;
            }
          }
        }
        this.pendingDescent.length = 0;
      }
      reset() {
        this.lcIdx = -1;
      }
      // Creates and returns a component, creating one if need be. You should
      // probably write to it immediately - ops are not valid with empty
      // components.
      getComponent() {
        this.flushDescent();
        const h = this.idx + 1;
        if (h < this.container.length && n(this.container[h]))
          return this.container[h];
        {
          const d = {};
          return this.container.splice(h, 0, d), d;
        }
      }
      write(h, d) {
        const f = this.getComponent();
        t(f[h] == null || f[h] === d, "Internal consistency error: Overwritten component. File a bug"), f[h] = d;
      }
      get() {
        return this._op;
      }
      descend(h) {
        if (!e.isValidPathItem(h))
          throw Error("Invalid JSON key");
        this.pendingDescent.push(h);
      }
      descendPath(h) {
        return this.pendingDescent.push(...h), this;
      }
      ascend() {
        this.pendingDescent.length ? this.pendingDescent.pop() : super.ascend();
      }
      mergeTree(h, d = s) {
        if (h === null)
          return;
        if (t(Array.isArray(h)), h === this._op)
          throw Error("Cannot merge into my own tree");
        const f = this.lcIdx, g = this.parents.length;
        let _ = 0;
        for (let R = 0; R < h.length; R++) {
          const b = h[R];
          typeof b == "string" || typeof b == "number" ? (_++, this.descend(b)) : Array.isArray(b) ? this.mergeTree(b, d) : typeof b == "object" && d(b, this);
        }
        for (; _--; )
          this.ascend();
        this.lcIdx = this.parents.length === g ? f : -1;
      }
      at(h, d) {
        this.descendPath(h), d(this);
        for (let f = 0; f < h.length; f++)
          this.ascend();
        return this;
      }
      // This is used by helpers, so the strict ordering guarantees are
      // relaxed.
      writeAtPath(h, d, f) {
        return this.at(h, () => this.write(d, f)), this.reset(), this;
      }
      writeMove(h, d, f = 0) {
        return this.writeAtPath(h, "p", f).writeAtPath(d, "d", f);
      }
      getPath() {
        const h = super.getPath();
        return h.push(...this.pendingDescent), h;
      }
    }
    e.WriteCursor = a, e.writeCursor = () => new a(), e.readCursor = (c) => new o(c);
    function l(c, h, d) {
      let f, g;
      g = f = c ? c.descendFirst() : !1;
      function _(R) {
        let b;
        for (; g; ) {
          const H = b = c.getKey();
          if (R != null) {
            let P = !1;
            if (h && typeof H == "number" && (b = h(H, c.getComponent()), b < 0 && (b = ~b, P = !0)), r(b, R))
              return null;
            if (b === R && !P)
              return c;
          }
          d && typeof b == "number" && d(b, c.getComponent()), g = c.nextSibling();
        }
        return null;
      }
      return _.end = () => {
        f && c.ascend();
      }, _;
    }
    e.advancer = l;
    function u(c, h, d) {
      let f, g, _, R;
      for (f = g = c && c.descendFirst(), _ = R = h && h.descendFirst(); f || _; ) {
        let b = f ? c.getKey() : null, H = _ ? h.getKey() : null;
        b !== null && H !== null && (r(H, b) ? H = null : b !== H && (b = null)), d(b == null ? H : b, b != null ? c : null, H != null ? h : null), b != null && f && (f = c.nextSibling()), H != null && _ && (_ = h.nextSibling());
      }
      g && c.ascend(), R && h.ascend();
    }
    e.eachChildOf = u;
  })(qs)), qs;
}
var Zs = {}, va;
function du() {
  return va || (va = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConflictType = void 0, (function(t) {
      t[t.RM_UNEXPECTED_CONTENT = 1] = "RM_UNEXPECTED_CONTENT", t[t.DROP_COLLISION = 2] = "DROP_COLLISION", t[t.BLACKHOLE = 3] = "BLACKHOLE";
    })(e.ConflictType || (e.ConflictType = {}));
  })(Zs)), Zs;
}
var vt = {}, ln = {}, ba;
function ho() {
  return ba || (ba = 1, Object.defineProperty(ln, "__esModule", { value: !0 }), ln.uniToStrPos = ln.strPosToUni = void 0, ln.strPosToUni = (e, t = e.length) => {
    let n = 0, r = 0;
    for (; r < t; r++) {
      const s = e.charCodeAt(r);
      s >= 55296 && s <= 57343 && (n++, r++);
    }
    if (r !== t)
      throw Error("Invalid offset - splits unicode bytes");
    return r - n;
  }, ln.uniToStrPos = (e, t) => {
    let n = 0;
    for (; t > 0; t--) {
      const r = e.charCodeAt(n);
      n += r >= 55296 && r <= 57343 ? 2 : 1;
    }
    return n;
  }), ln;
}
var Js = {}, Aa;
function Oi() {
  return Aa || (Aa = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.uniSlice = e.dlen = e.eachOp = void 0;
    const t = ho(), n = (w) => {
      if (!Array.isArray(w))
        throw Error("Op must be an array of components");
      let C = null;
      for (let v = 0; v < w.length; v++) {
        const y = w[v];
        switch (typeof y) {
          case "object":
            if (typeof y.d != "number" && typeof y.d != "string")
              throw Error("Delete must be number or string");
            if (e.dlen(y.d) <= 0)
              throw Error("Deletes must not be empty");
            break;
          case "string":
            if (!(y.length > 0))
              throw Error("Inserts cannot be empty");
            break;
          case "number":
            if (!(y > 0))
              throw Error("Skip components must be >0");
            if (typeof C == "number")
              throw Error("Adjacent skip components should be combined");
            break;
        }
        C = y;
      }
      if (typeof C == "number")
        throw Error("Op has a trailing skip");
    };
    function r(w, C) {
      let v = 0, y = 0;
      for (let F = 0; F < w.length; F++) {
        const $ = w[F];
        switch (C($, v, y), typeof $) {
          case "object":
            v += e.dlen($.d);
            break;
          case "string":
            y += t.strPosToUni($);
            break;
          case "number":
            v += $, y += $;
            break;
        }
      }
    }
    e.eachOp = r;
    function s(w, C) {
      const v = [], y = a(v);
      return r(w, (F, $, m) => {
        y(C(F, $, m));
      }), h(v);
    }
    const i = (w) => w, o = (w) => s(w, i);
    e.dlen = (w) => typeof w == "number" ? w : t.strPosToUni(w);
    const a = (w) => (C) => {
      if (!(!C || C.d === 0 || C.d === "")) if (w.length === 0)
        w.push(C);
      else if (typeof C == typeof w[w.length - 1])
        if (typeof C == "object") {
          const v = w[w.length - 1];
          v.d = typeof v.d == "string" && typeof C.d == "string" ? v.d + C.d : e.dlen(v.d) + e.dlen(C.d);
        } else
          w[w.length - 1] += C;
      else
        w.push(C);
    }, l = (w) => typeof w == "number" ? w : typeof w == "string" ? t.strPosToUni(w) : typeof w.d == "number" ? w.d : t.strPosToUni(w.d);
    e.uniSlice = (w, C, v) => {
      const y = t.uniToStrPos(w, C), F = v == null ? 1 / 0 : t.uniToStrPos(w, v);
      return w.slice(y, F);
    };
    const u = (w, C, v) => typeof w == "number" ? v == null ? w - C : Math.min(w, v) - C : e.uniSlice(w, C, v), c = (w) => {
      let C = 0, v = 0;
      return { take: ($, m) => {
        if (C === w.length)
          return $ === -1 ? null : $;
        const D = w[C];
        let S;
        if (typeof D == "number")
          return $ === -1 || D - v <= $ ? (S = D - v, ++C, v = 0, S) : (v += $, $);
        if (typeof D == "string") {
          if ($ === -1 || m === "i" || t.strPosToUni(D.slice(v)) <= $)
            return S = D.slice(v), ++C, v = 0, S;
          {
            const T = v + t.uniToStrPos(D.slice(v), $);
            return S = D.slice(v, T), v = T, S;
          }
        } else {
          if ($ === -1 || m === "d" || e.dlen(D.d) - v <= $)
            return S = { d: u(D.d, v) }, ++C, v = 0, S;
          {
            let T = u(D.d, v, v + $);
            return v += $, { d: T };
          }
        }
      }, peek: () => w[C] };
    }, h = (w) => (w.length > 0 && typeof w[w.length - 1] == "number" && w.pop(), w);
    function d(w, C, v) {
      if (v !== "left" && v !== "right")
        throw Error("side (" + v + ") must be 'left' or 'right'");
      n(w), n(C);
      const y = [], F = a(y), { take: $, peek: m } = c(w);
      for (let S = 0; S < C.length; S++) {
        const T = C[S];
        let A, O;
        switch (typeof T) {
          case "number":
            for (A = T; A > 0; )
              O = $(A, "i"), F(O), typeof O != "string" && (A -= l(O));
            break;
          case "string":
            v === "left" && typeof m() == "string" && F($(-1)), F(t.strPosToUni(T));
            break;
          case "object":
            for (A = e.dlen(T.d); A > 0; )
              switch (O = $(A, "i"), typeof O) {
                case "number":
                  A -= O;
                  break;
                case "string":
                  F(O);
                  break;
                case "object":
                  A -= e.dlen(O.d);
              }
            break;
        }
      }
      let D;
      for (; D = $(-1); )
        F(D);
      return h(y);
    }
    function f(w, C) {
      n(w), n(C);
      const v = [], y = a(v), { take: F } = c(w);
      for (let m = 0; m < C.length; m++) {
        const D = C[m];
        let S, T;
        switch (typeof D) {
          case "number":
            for (S = D; S > 0; )
              T = F(S, "d"), y(T), typeof T != "object" && (S -= l(T));
            break;
          case "string":
            y(D);
            break;
          case "object":
            S = e.dlen(D.d);
            let A = 0;
            for (; A < S; )
              switch (T = F(S - A, "d"), typeof T) {
                case "number":
                  y({ d: u(D.d, A, A + T) }), A += T;
                  break;
                case "string":
                  A += t.strPosToUni(T);
                  break;
                case "object":
                  y(T);
              }
            break;
        }
      }
      let $;
      for (; $ = F(-1); )
        y($);
      return h(v);
    }
    const g = (w, C) => {
      let v = 0;
      for (let y = 0; y < C.length && w > v; y++) {
        const F = C[y];
        switch (typeof F) {
          case "number": {
            v += F;
            break;
          }
          case "string":
            const $ = t.strPosToUni(F);
            v += $, w += $;
            break;
          case "object":
            w -= Math.min(e.dlen(F.d), w - v);
            break;
        }
      }
      return w;
    }, _ = (w, C) => typeof w == "number" ? g(w, C) : w.map((v) => g(v, C));
    function R(w, C, v) {
      return s(w, (y, F) => typeof y == "object" && typeof y.d == "number" ? { d: v.slice(C, F, F + y.d) } : y);
    }
    function b(w) {
      return s(w, (C) => {
        switch (typeof C) {
          case "object":
            if (typeof C.d == "number")
              throw Error("Cannot invert text op: Deleted characters missing from operation. makeInvertible must be called first.");
            return C.d;
          // delete -> insert
          case "string":
            return { d: C };
          // Insert -> delete
          case "number":
            return C;
        }
      });
    }
    function H(w) {
      return s(w, (C) => typeof C == "object" && typeof C.d == "string" ? { d: t.strPosToUni(C.d) } : C);
    }
    function P(w) {
      let C = !0;
      return r(w, (v) => {
        typeof v == "object" && typeof v.d == "number" && (C = !1);
      }), C;
    }
    function W(w) {
      return {
        name: "text-unicode",
        uri: "http://sharejs.org/types/text-unicode",
        trim: h,
        normalize: o,
        checkOp: n,
        /** Create a new text snapshot.
         *
         * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
         * @returns {Snap} Initial document snapshot object
         */
        create(C = "") {
          if (typeof C != "string")
            throw Error("Initial data must be a string");
          return w.create(C);
        },
        /** Apply an operation to a document snapshot
         */
        apply(C, v) {
          n(v);
          const y = w.builder(C);
          for (let F = 0; F < v.length; F++) {
            const $ = v[F];
            switch (typeof $) {
              case "number":
                y.skip($);
                break;
              case "string":
                y.append($);
                break;
              case "object":
                y.del(e.dlen($.d));
                break;
            }
          }
          return y.build();
        },
        transform: d,
        compose: f,
        transformPosition: g,
        transformSelection: _,
        isInvertible: P,
        makeInvertible(C, v) {
          return R(C, v, w);
        },
        stripInvertible: H,
        invert: b,
        invertWithDoc(C, v) {
          return b(R(C, v, w));
        },
        isNoop: (C) => C.length === 0
      };
    }
    e.default = W;
  })(Js)), Js;
}
var kr = {}, ya;
function lg() {
  if (ya) return kr;
  ya = 1, Object.defineProperty(kr, "__esModule", { value: !0 });
  const e = Oi(), t = ho();
  function n(r, s) {
    return {
      // Returns the text content of the document
      get: r,
      // Returns the number of characters in the string
      getLength() {
        return r().length;
      },
      // Insert the specified text at the given position in the document
      insert(i, o, a) {
        const l = t.strPosToUni(r(), i);
        return s([l, o], a);
      },
      remove(i, o, a) {
        const l = t.strPosToUni(r(), i);
        return s([l, { d: o }], a);
      },
      // When you use this API, you should implement these two methods
      // in your editing context.
      //onInsert: function(pos, text) {},
      //onRemove: function(pos, removedLength) {},
      _onOp(i) {
        e.eachOp(i, (o, a, l) => {
          switch (typeof o) {
            case "string":
              this.onInsert && this.onInsert(l, o);
              break;
            case "object":
              const u = e.dlen(o.d);
              this.onRemove && this.onRemove(l, u);
          }
        });
      },
      onInsert: null,
      onRemove: null
    };
  }
  return kr.default = n, n.provides = { text: !0 }, kr;
}
var Na;
function ug() {
  return Na || (Na = 1, (function(e) {
    var t = vt && vt.__createBinding || (Object.create ? (function(d, f, g, _) {
      _ === void 0 && (_ = g), Object.defineProperty(d, _, { enumerable: !0, get: function() {
        return f[g];
      } });
    }) : (function(d, f, g, _) {
      _ === void 0 && (_ = g), d[_] = f[g];
    })), n = vt && vt.__setModuleDefault || (Object.create ? (function(d, f) {
      Object.defineProperty(d, "default", { enumerable: !0, value: f });
    }) : function(d, f) {
      d.default = f;
    }), r = vt && vt.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var f = {};
      if (d != null) for (var g in d) Object.hasOwnProperty.call(d, g) && t(f, d, g);
      return n(f, d), f;
    }, s = vt && vt.__importDefault || function(d) {
      return d && d.__esModule ? d : { default: d };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.type = e.remove = e.insert = void 0;
    const i = ho(), o = r(Oi()), a = s(lg()), l = {
      create(d) {
        return d;
      },
      toString(d) {
        return d;
      },
      builder(d) {
        if (typeof d != "string")
          throw Error("Invalid document snapshot: " + d);
        const f = [];
        return {
          skip(g) {
            let _ = i.uniToStrPos(d, g);
            if (_ > d.length)
              throw Error("The op is too long for this document");
            f.push(d.slice(0, _)), d = d.slice(_);
          },
          append(g) {
            f.push(g);
          },
          del(g) {
            d = d.slice(i.uniToStrPos(d, g));
          },
          build() {
            return f.join("") + d;
          }
        };
      },
      slice: o.uniSlice
    }, u = o.default(l), c = Object.assign(Object.assign({}, u), { api: a.default });
    e.type = c, e.insert = (d, f) => f.length === 0 ? [] : d === 0 ? [f] : [d, f], e.remove = (d, f) => o.dlen(f) === 0 ? [] : d === 0 ? [{ d: f }] : [d, { d: f }];
    var h = Oi();
    Object.defineProperty(e, "makeType", { enumerable: !0, get: function() {
      return h.default;
    } });
  })(vt)), vt;
}
var Ta;
function cg() {
  return Ta || (Ta = 1, (function(e) {
    var t = Zn && Zn.__importDefault || function(I) {
      return I && I.__esModule ? I : {
        default: I
      };
    };
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.editOp = e.replaceOp = e.insertOp = e.moveOp = e.removeOp = e.type = void 0;
    const n = t(og()), r = t(ag()), s = hu(), i = du();
    function o(I, x) {
      if (!I) throw new Error(x);
    }
    e.type = {
      name: "json1",
      uri: "http://sharejs.org/types/JSONv1",
      readCursor: s.readCursor,
      writeCursor: s.writeCursor,
      create: (I) => I,
      isNoop: (I) => I == null,
      setDebug(I) {
      },
      registerSubtype: b,
      checkValidOp: F,
      normalize: $,
      apply: m,
      transformPosition: D,
      compose: S,
      tryTransform: L,
      transform: q,
      makeInvertible: O,
      invert: T,
      invertWithDoc: N,
      RM_UNEXPECTED_CONTENT: i.ConflictType.RM_UNEXPECTED_CONTENT,
      DROP_COLLISION: i.ConflictType.DROP_COLLISION,
      BLACKHOLE: i.ConflictType.BLACKHOLE,
      transformNoConflict: (I, x, Y) => le(() => !0, I, x, Y),
      typeAllowingConflictsPred: (I) => Object.assign(Object.assign({}, e.type), {
        transform: (x, Y, z) => le(I, x, Y, z)
      })
    };
    const a = (I) => I ? I.getComponent() : null;
    function l(I) {
      return I && typeof I == "object" && !Array.isArray(I);
    }
    const u = (I) => Array.isArray(I) ? I.slice() : I !== null && typeof I == "object" ? Object.assign({}, I) : I, c = (I) => I && (I.p != null || I.r !== void 0), h = (I) => I && (I.d != null || I.i !== void 0);
    function d(I, x) {
      return o(I != null), typeof x == "number" ? (o(Array.isArray(I), "Invalid key - child is not an array"), (I = I.slice()).splice(x, 1)) : (o(l(I), "Invalid key - child is not an object"), delete (I = Object.assign({}, I))[x]), I;
    }
    function f(I, x, Y) {
      return typeof x == "number" ? (o(I != null, "Container is missing for key"), o(Array.isArray(I), "Cannot use numerical key for object container"), o(I.length >= x, "Cannot insert into out of bounds index"), I.splice(x, 0, Y)) : (o(l(I), "Cannot insert into missing item"), o(I[x] === void 0, "Trying to overwrite value at key. Your op needs to remove it first"), I[x] = Y), Y;
    }
    e.removeOp = (I, x = !0) => s.writeCursor().writeAtPath(I, "r", x).get(), e.moveOp = (I, x) => s.writeCursor().writeMove(I, x).get(), e.insertOp = (I, x) => s.writeCursor().writeAtPath(I, "i", x).get(), e.replaceOp = (I, x, Y) => s.writeCursor().at(I, (z) => {
      z.write("r", x), z.write("i", Y);
    }).get(), e.editOp = (I, x, Y, z = !1) => s.writeCursor().at(I, (B) => C(B, x, Y, z)).get();
    const g = (I, x) => I != null && (typeof x == "number" ? Array.isArray(I) : typeof I == "object"), _ = (I, x) => g(I, x) ? I[x] : void 0, R = {};
    function b(I) {
      let x = I.type ? I.type : I;
      x.name && (R[x.name] = x), x.uri && (R[x.uri] = x);
    }
    const H = (I) => {
      const x = R[I];
      if (x) return x;
      throw Error("Missing type: " + I);
    };
    b(ug());
    const P = (I, x) => I + x;
    b({
      name: "number",
      apply: P,
      compose: P,
      invert: (I) => -I,
      transform: (I) => I
    });
    const W = (I) => I == null ? null : I.et ? H(I.et) : I.es ? R["text-unicode"] : I.ena != null ? R.number : null, w = (I) => I.es ? I.es : I.ena != null ? I.ena : I.e, C = (I, x, Y, z = !1) => {
      const [B, j] = typeof x == "string" ? [H(x), x] : [x, x.name];
      !z && B.isNoop && B.isNoop(Y) || (j === "number" ? I.write("ena", Y) : j === "text-unicode" ? I.write("es", Y) : (I.write("et", j), I.write("e", Y)));
    };
    function v(I) {
      o(typeof I == "number"), o(I >= 0), o(I === (0 | I));
    }
    function y(I) {
      typeof I == "number" ? v(I) : o(typeof I == "string");
    }
    function F(I) {
      if (I === null) return;
      const x = /* @__PURE__ */ new Set(), Y = /* @__PURE__ */ new Set(), z = (j) => {
        let Q = !0, ee = !1;
        for (let U in j) {
          const G = j[U];
          if (Q = !1, o(U === "p" || U === "r" || U === "d" || U === "i" || U === "e" || U === "es" || U === "ena" || U === "et", "Invalid component item '" + U + "'"), U === "p") v(G), o(!x.has(G)), x.add(G), o(j.r === void 0);
          else if (U === "d") v(G), o(!Y.has(G)), Y.add(G), o(j.i === void 0);
          else if (U === "e" || U === "es" || U === "ena") {
            o(!ee), ee = !0;
            const X = W(j);
            o(X, "Missing type in edit"), X.checkValidOp && X.checkValidOp(w(j));
          }
        }
        o(!Q);
      }, B = (j, Q, ee) => {
        if (!Array.isArray(j)) throw Error("Op must be null or a list");
        if (j.length === 0) throw Error("Empty descent");
        Q || y(j[0]);
        let U = 1, G = 0, X = 0;
        for (let ne = 0; ne < j.length; ne++) {
          const de = j[ne];
          if (o(de != null), Array.isArray(de)) {
            const _e = B(de, !1);
            if (G) {
              const K = typeof X, ce = typeof _e;
              K === ce ? o(X < _e, "descent keys are not in order") : o(K === "number" && ce === "string");
            }
            X = _e, G++, U = 3;
          } else typeof de == "object" ? (o(U === 1, `Prev not scalar - instead ${U}`), z(de), U = 2) : (o(U !== 3), y(de), o(s.isValidPathItem(de), "Invalid path key"), U = 1);
        }
        return o(G !== 1, "Operation makes multiple descents. Remove some []"), o(U === 2 || U === 3), j[0];
      };
      B(I, !0), o(x.size === Y.size, "Mismatched picks and drops in op");
      for (let j = 0; j < x.size; j++) o(x.has(j)), o(Y.has(j));
    }
    function $(I) {
      let x = 0, Y = [];
      const z = s.writeCursor();
      return z.mergeTree(I, (B, j) => {
        const Q = W(B);
        if (Q) {
          const U = w(B);
          C(j, Q, Q.normalize ? Q.normalize(U) : U);
        }
        for (const U of ["r", "p", "i", "d"]) if (B[U] !== void 0) {
          const G = U === "p" || U === "d" ? (ee = B[U], Y[ee] == null && (Y[ee] = x++), Y[ee]) : B[U];
          j.write(U, G);
        }
        var ee;
      }), z.get();
    }
    function m(I, x) {
      if (F(x), x === null) return I;
      const Y = [];
      return (function z(B, j) {
        let Q = B, ee = 0, U = {
          root: B
        }, G = 0, X = U, ne = "root";
        function de() {
          for (; G < ee; G++) {
            let _e = j[G];
            typeof _e != "object" && (o(g(X, ne)), X = X[ne] = u(X[ne]), ne = _e);
          }
        }
        for (; ee < j.length; ee++) {
          const _e = j[ee];
          if (Array.isArray(_e)) {
            const K = z(Q, _e);
            K !== Q && K !== void 0 && (de(), Q = X[ne] = K);
          } else if (typeof _e == "object") {
            _e.d != null ? (de(), Q = f(X, ne, Y[_e.d])) : _e.i !== void 0 && (de(), Q = f(X, ne, _e.i));
            const K = W(_e);
            if (K) de(), Q = X[ne] = K.apply(Q, w(_e));
            else if (_e.e !== void 0) throw Error("Subtype " + _e.et + " undefined");
          } else Q = _(Q, _e);
        }
        return U.root;
      })(I = (function z(B, j) {
        const Q = [];
        let ee = 0;
        for (; ee < j.length; ee++) {
          const ne = j[ee];
          if (Array.isArray(ne)) break;
          typeof ne != "object" && (Q.push(B), B = _(B, ne));
        }
        for (let ne = j.length - 1; ne >= ee; ne--) B = z(B, j[ne]);
        for (--ee; ee >= 0; ee--) {
          const ne = j[ee];
          if (typeof ne != "object") {
            const de = Q.pop();
            B = B === _(de, ne) ? de : B === void 0 ? d(de, ne) : (G = ne, X = B, (U = u(U = de))[G] = X, U);
          } else c(ne) && (o(B !== void 0, "Cannot pick up or remove undefined"), ne.p != null && (Y[ne.p] = B), B = void 0);
        }
        var U, G, X;
        return B;
      })(I, x), x);
    }
    function D(I, x) {
      I = I.slice(), F(x);
      const Y = s.readCursor(x);
      let z, B, j = !1;
      const Q = [];
      for (let U = 0; ; U++) {
        const G = I[U], X = Y.getComponent();
        if (X && (X.r !== void 0 ? j = !0 : X.p != null && (j = !1, z = X.p, B = U)), U >= I.length) break;
        let ne = 0;
        const de = s.advancer(Y, void 0, (K, ce) => {
          c(ce) && ne++;
        });
        Q.unshift(de);
        const _e = de(G);
        if (typeof G == "number" && (I[U] -= ne), !_e) break;
      }
      if (Q.forEach((U) => U.end()), j) return null;
      const ee = () => {
        let U = 0;
        if (z != null) {
          const G = Y.getPath();
          U = G.length, I = G.concat(I.slice(B));
        }
        for (; U < I.length; U++) {
          const G = I[U], X = a(Y), ne = W(X);
          if (ne) {
            const K = w(X);
            ne.transformPosition && (I[U] = ne.transformPosition(I[U], K));
            break;
          }
          let de = 0;
          const _e = s.advancer(Y, (K, ce) => h(ce) ? ~(K - de) : K - de, (K, ce) => {
            h(ce) && de++;
          })(G);
          if (typeof G == "number" && (I[U] += de), !_e) break;
        }
      };
      return z != null ? Y.eachDrop(null, (U) => {
        U === z && ee();
      }) : ee(), I;
    }
    function S(I, x) {
      if (F(I), F(x), I == null) return x;
      if (x == null) return I;
      let Y = 0;
      const z = s.readCursor(I), B = s.readCursor(x), j = s.writeCursor(), Q = [], ee = [], U = [], G = [], X = [], ne = [], de = /* @__PURE__ */ new Set();
      z.traverse(null, (K) => {
        K.p != null && (U[K.p] = z.clone());
      }), B.traverse(null, (K) => {
        K.d != null && (G[K.d] = B.clone());
      });
      const _e = s.writeCursor();
      return (function K(ce, Me, Ae, Re, Pe, $t, Qe, Ge) {
        o(Me || Ae);
        const Fe = a(Me), dt = a(Ae), It = !!dt && dt.r !== void 0, rn = !!Fe && Fe.i !== void 0, ft = Fe ? Fe.d : null, at = dt ? dt.p : null, Ht = ($t || It) && at == null;
        if (at != null) Re = G[at], Qe = ee[at] = new s.WriteCursor();
        else if (dt && dt.r !== void 0) Re = null;
        else {
          const se = a(Re);
          se && se.d != null && (Re = null);
        }
        const ve = a(Re);
        if (ft != null) if (ce = U[ft], Ge = Q[ft] = new s.WriteCursor(), Ht) $t && !It && Ge.write("r", !0);
        else {
          const se = X[ft] = Y++;
          Qe.write("d", se);
        }
        else if (Fe && Fe.i !== void 0) ce = null;
        else {
          const se = a(ce);
          se && se.p != null && (ce = null);
        }
        let ae;
        rn ? (o(Pe === void 0), ae = Fe.i) : ae = Pe;
        const Ee = (at == null ? !rn || $t || It : ae === void 0) ? null : Qe.getComponent();
        if (at != null) {
          if (!(Pe !== void 0 || rn)) {
            const se = ft != null ? X[ft] : Y++;
            ne[at] = se, Ge.write("p", se);
          }
        } else It && (rn || Pe !== void 0 || (dt.r, Ge.write("r", dt.r)));
        const ue = Ht ? null : W(Fe), re = W(ve);
        if ((ue || re) && (ue && ue.name, re && re.name), ue && re) {
          o(ue === re);
          const se = w(Fe), Ce = w(ve), ze = ue.compose(se, Ce);
          C(Qe, ue, ze), de.add(ve);
        } else ue ? C(Qe, ue, w(Fe)) : re && (C(Qe, re, w(ve)), de.add(ve));
        const he = typeof ae == "object" && ae != null;
        let Oe = !1, Se = 0, be = 0, Ye = 0, Be = 0, $e = 0;
        const Ze = s.advancer(Re, (se, Ce) => h(Ce) ? Be - se - 1 : se - Be, (se, Ce) => {
          h(Ce) && Be++;
        }), Ie = s.advancer(ce, (se, Ce) => c(Ce) ? Se - se - 1 : se - Se, (se, Ce) => {
          c(Ce) && Se++;
        });
        if (s.eachChildOf(Me, Ae, (se, Ce, ze) => {
          let nt, Bt, sn = se, wt = se, Xn = se;
          if (typeof se == "number") {
            let Ke = se + Ye;
            Bt = Ze(Ke), wt = Ke + Be;
            let He = se + be;
            nt = Ie(He), h(a(Bt)) && (nt = null), sn = He + Se, Xn = se + $e, o(sn >= 0, "p1PickKey is negative"), o(wt >= 0, "p2DropKey is negative");
            const St = h(a(Ce)), jt = c(a(ze));
            (St || jt && !Ht) && $e--, St && be--, jt && Ye--;
          } else nt = Ie(se), Bt = Ze(se);
          Ge.descend(sn), Qe.descend(wt);
          const Rn = he && !h(a(Ce)) ? ae[Xn] : void 0, Tt = K(nt, Ce, ze, Bt, Rn, Ht, Qe, Ge);
          var Mt, fe, De;
          he && !Ht ? Rn !== Tt && (Oe || (ae = Array.isArray(ae) ? ae.slice() : Object.assign({}, ae), Oe = !0), Mt = ae, De = Tt, typeof (fe = Xn) == "number" ? (o(Array.isArray(Mt)), o(fe < Mt.length)) : (o(!Array.isArray(Mt)), o(Mt[fe] !== void 0)), De === void 0 ? typeof fe == "number" ? Mt.splice(fe, 1) : delete Mt[fe] : Mt[fe] = De) : o(Tt === void 0), Qe.ascend(), Ge.ascend();
        }), Ie.end(), Ze.end(), Ee != null) Ee.i = ae;
        else if (!$t && !It && at == null) return ae;
      })(z, z.clone(), B, B.clone(), void 0, !1, j, _e), j.reset(), j.mergeTree(_e.get()), j.reset(), j.get(), Q.map((K) => K.get()), ee.map((K) => K.get()), z.traverse(j, (K, ce) => {
        const Me = K.p;
        if (Me != null) {
          const Ae = X[Me];
          Ae != null && ce.write("p", Ae);
          const Re = Q[Me];
          Re && Re.get(), Re && ce.mergeTree(Re.get());
        } else K.r !== void 0 && ce.write("r", K.r);
      }), j.reset(), j.get(), B.traverse(j, (K, ce) => {
        const Me = K.d;
        if (Me != null) {
          const Re = ne[Me];
          Re != null && ce.write("d", Re);
          const Pe = ee[Me];
          Pe && ce.mergeTree(Pe.get());
        } else K.i !== void 0 && ce.write("i", K.i);
        const Ae = W(K);
        Ae && !de.has(K) && C(ce, Ae, w(K));
      }), j.get();
    }
    function T(I) {
      if (I == null) return null;
      const x = new s.ReadCursor(I), Y = new s.WriteCursor();
      let z;
      const B = [], j = [];
      return (function Q(ee, U, G) {
        const X = ee.getComponent();
        let ne, de = !1;
        if (X) {
          X.p != null && (U.write("d", X.p), B[X.p] = ee.clone()), X.r !== void 0 && U.write("i", X.r), X.d != null && (U.write("p", X.d), G = void 0), X.i !== void 0 && (G = ne = X.i);
          const K = W(X);
          K && (G === void 0 ? (z || (z = /* @__PURE__ */ new Set()), z.add(X)) : (w(X), G = K.apply(G, w(X)), de = !0));
        }
        let _e = 0;
        for (const K of ee) {
          U.descend(K);
          const ce = typeof K == "number" ? K - _e : K, Me = _(G, ce);
          h(ee.getComponent()) && _e++;
          const Ae = Q(ee, U, Me);
          if (G !== void 0 && Ae !== void 0) {
            if (de || (de = !0, G = u(G)), !g(G, ce)) throw Error("Cannot modify child - invalid operation");
            G[ce] = Ae;
          }
          U.ascend();
        }
        if (ne === void 0) return de ? G : void 0;
        U.write("r", G);
      })(x, Y, void 0), z && (Y.reset(), (function Q(ee, U, G) {
        const X = U.getComponent();
        if (X) {
          const K = X.d;
          if (K != null && (ee = B[K], G = j[K] = s.writeCursor()), z.has(X)) {
            const ce = W(X);
            if (!ce.invert) throw Error(`Cannot invert subtype ${ce.name}`);
            C(G, ce, ce.invert(w(X)));
          }
        }
        let ne = 0, de = 0;
        const _e = s.advancer(ee, (K, ce) => c(ce) ? ne - K - 1 : K - ne, (K, ce) => {
          c(ce) && ne++;
        });
        for (const K of U) if (typeof K == "number") {
          const ce = K - de, Me = _e(ce), Ae = ce + ne;
          G.descend(Ae), Q(Me, U, G), h(U.getComponent()) && de++, G.ascend();
        } else G.descend(K), Q(_e(K), U, G), G.ascend();
        _e.end();
      })(x.clone(), x, Y), j.length && (Y.reset(), x.traverse(Y, (Q, ee) => {
        const U = Q.p;
        if (U != null) {
          const G = j[U];
          G && G.get(), G && ee.mergeTree(G.get());
        }
      }))), Y.get();
    }
    const A = (I, x) => I.some((Y) => typeof Y == "object" && (Array.isArray(Y) ? A(Y, x) : x(Y)));
    function O(I, x) {
      if (I == null || !A(I, (U) => {
        var G;
        return U.r !== void 0 || ((G = W(U)) === null || G === void 0 ? void 0 : G.makeInvertible) != null;
      })) return I;
      const Y = new s.ReadCursor(I), z = new s.WriteCursor();
      let B = !1;
      const j = [], Q = [], ee = (U, G, X) => {
        const ne = U.getComponent();
        let de = !1;
        if (ne) {
          ne.d != null && G.write("d", ne.d), ne.i !== void 0 && G.write("i", ne.i);
          const K = ne.p;
          if (K != null && (j[K] = U.clone(), o(X !== void 0, "Operation picks up at an invalid key"), Q[K] = X, G.write("p", ne.p)), ne.r !== void 0 && X === void 0) throw Error("Invalid doc / op in makeInvertible: removed item missing from doc");
          const ce = W(ne);
          ce && (ce.makeInvertible ? B = !0 : C(G, ce, w(ne), !0));
        }
        let _e = 0;
        for (const K of U) {
          G.descend(K);
          const ce = typeof K == "number" ? K - _e : K, Me = _(X, ce), Ae = ee(U, G, Me);
          Me !== Ae && (de || (de = !0, X = u(X)), Ae === void 0 ? (X = d(X, ce), typeof K == "number" && _e++) : X[ce] = Ae), G.ascend();
        }
        return ne && (ne.r !== void 0 ? (G.write("r", r.default(X)), X = void 0) : ne.p != null && (X = void 0)), X;
      };
      return ee(Y, z, x), z.get(), B && (z.reset(), (function U(G, X, ne, de, _e) {
        const K = X.getComponent();
        if (K) {
          K.i !== void 0 ? (de = K.i, _e = !0) : K.d != null && (de = Q[K.d], G = j[K.d], _e = !1, K.d);
          let Re = W(K);
          if (Re && Re.makeInvertible) {
            const Pe = w(K);
            C(ne, Re, Re.makeInvertible(Pe, de), !0);
          }
        }
        let ce = 0, Me = 0;
        const Ae = s.advancer(G, (Re, Pe) => c(Pe) ? ce - Re - 1 : Re - ce, (Re, Pe) => {
          c(Pe) && ce++;
        });
        for (const Re of X) if (typeof Re == "number") {
          const Pe = Re - Me, $t = Ae(Pe), Qe = Pe + ce, Ge = _(de, _e ? Pe : Qe);
          ne.descend(Re), U($t, X, ne, Ge, _e), h(X.getComponent()) && Me++, ne.ascend();
        } else {
          const Pe = _(de, Re);
          ne.descend(Re), U(Ae(Re), X, ne, Pe, _e), ne.ascend();
        }
        Ae.end();
      })(Y.clone(), Y, z, x, !1)), z.get();
    }
    function N(I, x) {
      return T(O(I, x));
    }
    const M = (I) => {
      if (I == null) return null;
      const x = I.slice();
      for (let Y = 0; Y < I.length; Y++) {
        const z = x[Y];
        Array.isArray(z) && (x[Y] = M(z));
      }
      return x;
    };
    function L(I, x, Y) {
      o(Y === "left" || Y === "right", "Direction must be left or right");
      const z = Y === "left" ? 0 : 1;
      if (x == null) return {
        ok: !0,
        result: I
      };
      F(I), F(x);
      let B = null;
      const j = [], Q = [], ee = [], U = [], G = [], X = [], ne = [], de = [], _e = [], K = [], ce = [], Me = [], Ae = [], Re = [], Pe = [];
      let $t = 0;
      const Qe = s.readCursor(I), Ge = s.readCursor(x), Fe = s.writeCursor();
      if ((function ve(ae, Ee = null, ue) {
        const re = a(Ee);
        re && (re.r !== void 0 ? ue = Ee.clone() : re.p != null && (ue = null, X[re.p] = ae.clone()));
        const he = ae.getComponent();
        let Oe;
        he && (Oe = he.p) != null && (G[Oe] = Ee ? Ee.clone() : null, ee[Oe] = ae.clone(), ue && (K[Oe] = !0, _e[Oe] = ue), re && re.p != null && (Re[Oe] = re.p));
        const Se = s.advancer(Ee);
        for (const be of ae) ve(ae, Se(be), ue);
        Se.end();
      })(Ge, Qe, null), (function ve(ae, Ee, ue, re, he) {
        const Oe = ue.getComponent();
        let Se, be = !1;
        Oe && ((Se = Oe.d) != null ? (U[Se] = ue.clone(), re != null && (Pe[re] == null && (Pe[re] = []), Pe[re].push(Se)), K[Se], ae = G[Se] || null, Ee = ee[Se] || null, K[Se] ? (he && (ce[Se] = !0), he = _e[Se] || null) : !he || z !== 1 && Re[Se] != null || B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.moveOp(Ee.getPath(), ue.getPath())
        }), be = !0) : Oe.i !== void 0 && (ae = Ee = null, be = !0, he && B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.insertOp(ue.getPath(), Oe.i)
        })));
        const Ye = a(ae);
        Ye && (Ye.r !== void 0 ? he = ae.clone() : Ye.p != null && (Ye.p, re = Ye.p, he = null));
        const Be = W(Oe);
        Be && he && B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.editOp(ue.getPath(), Be, w(Oe), !0)
        });
        let $e = 0, Ze = 0;
        const Ie = s.advancer(Ee, (Ce, ze) => c(ze) ? $e - Ce - 1 : Ce - $e, (Ce, ze) => {
          c(ze) && $e++;
        }), se = s.advancer(ae);
        for (const Ce of ue) if (typeof Ce == "number") {
          const ze = Ce - Ze, nt = Ie(ze);
          Ze += +ve(se(ze + $e), nt, ue, re, he);
        } else {
          const ze = Ie(Ce);
          ve(se(Ce), ze, ue, re, he);
        }
        return Ie.end(), se.end(), be;
      })(Qe, Ge, Ge.clone(), null, null), U.map((ve) => ve && ve.get()), B) return {
        ok: !1,
        conflict: B
      };
      ce.map((ve) => !!ve);
      const dt = [];
      let It = null;
      (function ve(ae, Ee, ue, re, he) {
        let Oe = !1;
        const Se = a(Ee);
        if (c(Se)) {
          const Ie = Se.p;
          Ie != null ? (ue = U[Ie], re = Me[Ie] = s.writeCursor(), Oe = !0, he = null) : (ue = null, he = Ee.clone());
        } else h(a(ue)) && (ue = null);
        const be = ae.getComponent();
        if (be) {
          const Ie = be.p;
          Ie != null ? (he && (de[Ie] = he), dt[Ie] = he || z === 1 && Oe ? null : re.getComponent(), j[Ie] = ae.clone(), ue && (ne[Ie] = ue.clone())) : be.r !== void 0 && (he || re.write("r", !0), (he || Oe) && (It == null && (It = /* @__PURE__ */ new Set()), It.add(be)));
        }
        let Ye = 0, Be = 0;
        const $e = s.advancer(Ee, void 0, (Ie, se) => {
          c(se) && Ye++;
        }), Ze = s.advancer(ue, (Ie, se) => h(se) ? ~(Ie - Be) : Ie - Be, (Ie, se) => {
          h(se) && Be++;
        });
        if (ae) for (const Ie of ae) if (typeof Ie == "string") {
          const se = $e(Ie), Ce = Ze(Ie);
          re.descend(Ie), ve(ae, se, Ce, re, he), re.ascend();
        } else {
          const se = $e(Ie), Ce = Ie - Ye, ze = c(a(se)) ? null : Ze(Ce), nt = Ce + Be;
          o(nt >= 0), re.descend(nt), ve(ae, se, ze, re, he), re.ascend();
        }
        $e.end(), Ze.end();
      })(Qe, Ge, Ge.clone(), Fe, null), Fe.reset();
      let rn = [];
      if ((function ve(ae, Ee, ue, re, he, Oe) {
        o(Ee);
        const Se = Ee.getComponent();
        let be = a(re), Ye = !1;
        const Be = (fe, De, Ke) => fe ? e.moveOp(fe.getPath(), De.getPath()) : e.insertOp(De.getPath(), Ke.i);
        if (h(Se)) {
          const fe = Se.d;
          fe != null && (Q[fe] = Ee.clone());
          const De = fe != null ? dt[fe] : null;
          let Ke = !1;
          if (Se.i !== void 0 || fe != null && De) {
            let He;
            be && (be.i !== void 0 || (He = be.d) != null && !K[He]) && (Ke = He != null ? fe != null && fe === Re[He] : n.default(be.i, Se.i), Ke || He != null && z !== 1 && Re[He] != null || B == null && (B = {
              type: i.ConflictType.DROP_COLLISION,
              op1: Be(fe != null ? j[fe] : null, Ee, Se),
              op2: Be(He != null ? ee[He] : null, re, be)
            })), Ke || (Oe ? B == null && (B = {
              type: i.ConflictType.RM_UNEXPECTED_CONTENT,
              op1: Be(fe != null ? j[fe] : null, Ee, Se),
              op2: e.removeOp(Oe.getPath())
            }) : (fe != null ? (rn[$t] = fe, he.write("d", De.p = $t++)) : he.write("i", r.default(Se.i)), Ye = !0));
          } else if (fe != null && !De) {
            const He = de[fe];
            He && (Oe = He.clone());
          }
          fe != null ? (ae = j[fe], ue = X[fe], re = ne[fe]) : Se.i !== void 0 && (ae = ue = null, Ke || (re = null));
        } else c(a(ae)) && (ae = ue = re = null);
        const $e = a(ae), Ze = a(ue);
        if (c(Ze)) {
          const fe = Ze.p;
          Ze.r !== void 0 && (!$e || $e.r === void 0) || K[fe] ? (re = null, Oe = ue.clone()) : fe != null && (re = U[fe], z !== 1 && Re[fe] != null || ((he = Ae[fe]) || (he = Ae[fe] = s.writeCursor()), he.reset(), Oe = null));
        } else !h(Se) && h(be) && (re = null);
        be = re != null ? re.getComponent() : null;
        const Ie = W(Se);
        if (Ie) {
          const fe = w(Se);
          if (Oe) B == null && (B = {
            type: i.ConflictType.RM_UNEXPECTED_CONTENT,
            op1: e.editOp(Ee.getPath(), Ie, fe, !0),
            op2: e.removeOp(Oe.getPath())
          });
          else {
            const De = W(be);
            let Ke;
            if (De) {
              if (Ie !== De) throw Error("Transforming incompatible types");
              const He = w(be);
              Ke = Ie.transform(fe, He, Y);
            } else Ke = r.default(fe);
            C(he, Ie, Ke);
          }
        }
        let se = 0, Ce = 0, ze = 0, nt = 0, Bt = 0, sn = 0, wt = ae != null && ae.descendFirst(), Xn = wt;
        const Rn = s.advancer(ue, void 0, (fe, De) => {
          c(De) && ze++;
        });
        let Tt = re != null && re.descendFirst(), Mt = Tt;
        for (const fe of Ee) if (typeof fe == "number") {
          let De;
          const Ke = h(Ee.getComponent()), He = fe - Ce;
          {
            let Gt;
            for (; wt && typeof (Gt = ae.getKey()) == "number"; ) {
              Gt += se;
              const Ot = ae.getComponent(), In = c(Ot);
              if (Gt > He || Gt === He && (!In || z === 0 && Ke)) break;
              if (In) {
                se--;
                const on = Ot.p;
                Re.includes(on), Ot.d, a(Ae[Ot.d]), c(a(Ae[Ot.d])), (Ot.r === void 0 || It && It.has(Ot)) && (on == null || !dt[on] || z !== 1 && Re.includes(on)) || Bt--;
              }
              wt = ae.nextSibling();
            }
            De = wt && Gt === He ? ae : null;
          }
          const St = He - se;
          let jt = Rn(St);
          const js = St - ze;
          let Tr = null;
          {
            let Gt, Ot;
            for (; Tt && typeof (Gt = re.getKey()) == "number"; ) {
              Ot = Gt - nt;
              const In = re.getComponent(), on = h(In);
              if (Ot > js) break;
              if (Ot === js) {
                if (!on) {
                  Tr = re;
                  break;
                }
                {
                  if (z === 0 && Ke) {
                    Tr = re;
                    break;
                  }
                  const Kt = jt && c(jt.getComponent());
                  if (z === 0 && Kt) break;
                }
              }
              if (on) {
                const Kt = In.d;
                K[Kt], Re[Kt], In.i === void 0 && (K[Kt] || Re[Kt] != null && z !== 1) ? (K[Kt] || Re[Kt] != null && z === 0) && (nt++, sn--) : nt++;
              }
              Tt = re.nextSibling();
            }
          }
          const ta = js + nt + Bt + sn;
          o(ta >= 0, "trying to descend to a negative index"), he.descend(ta), Ke && (De = jt = Tr = null, Ce++), ve(De, Ee, jt, Tr, he, Oe) && sn++, he.ascend();
        } else {
          let De;
          for (; wt && (De = ae.getKey(), typeof De != "string" || !(De > fe || De === fe)); ) wt = ae.nextSibling();
          const Ke = wt && De === fe ? ae : null, He = Rn(fe);
          let St;
          for (; Tt && (St = re.getKey(), typeof St != "string" || !(St > fe || St === fe)); ) Tt = re.nextSibling();
          const jt = Tt && St === fe ? re : null;
          he.descend(fe), ve(Ke, Ee, He, jt, he, Oe), he.ascend();
        }
        return Rn.end(), Xn && ae.ascend(), Mt && re.ascend(), Ye;
      })(Qe, Qe.clone(), Ge, Ge.clone(), Fe, null), B) return {
        ok: !1,
        conflict: B
      };
      Fe.reset();
      const ft = (ve, ae, Ee) => ve.traverse(ae, (ue, re) => {
        ue.d != null && Ee(ue.d, ve, re);
      });
      (K.length || Me.length) && (ft(Ge, Fe, (ve, ae, Ee) => {
        K[ve] && !ce[ve] && Ee.write("r", !0), Me[ve] && Ee.mergeTree(Me[ve].get());
      }), Fe.reset());
      const at = [], Ht = [];
      if ((Ae.length || K.length) && !B) {
        const ve = s.readCursor(M(Fe.get()));
        if (ft(ve, null, (ae, Ee) => {
          at[ae] = Ee.clone();
        }), Ae.forEach((ae) => {
          ae && ft(s.readCursor(ae.get()), null, (Ee, ue) => {
            at[Ee] = ue.clone();
          });
        }), (function ae(Ee, ue, re, he, Oe, Se) {
          const be = a(ue);
          if (be && c(be)) if (be.p != null) {
            const se = be.p;
            at[se].getPath(), re = at[se], he = Ht[se] = s.writeCursor();
          } else be.r !== void 0 && (re = null);
          else h(a(re)) && (re = null);
          const Ye = Ee.getComponent();
          if (Ye) {
            let se;
            if ((se = Ye.d) != null) {
              const Ce = Ae[se];
              Ce && (Ce.get(), he.mergeTree(Ce.get()), re = s.readCursor(Ce.get()));
            }
          }
          let Be = 0, $e = 0;
          const Ze = s.advancer(ue, void 0, (se, Ce) => {
            c(Ce) && Be--;
          }), Ie = s.advancer(re, (se, Ce) => h(Ce) ? -(se - $e) - 1 : se - $e, (se, Ce) => {
            h(Ce) && $e++;
          });
          for (const se of Ee) if (typeof se == "number") {
            const Ce = Ze(se), ze = se + Be, nt = Ie(ze), Bt = ze + $e;
            he.descend(Bt), ae(Ee, Ce, nt, he), he.ascend();
          } else he.descend(se), ae(Ee, Ze(se), Ie(se), he), he.ascend();
          Ze.end(), Ie.end();
        })(Ge, ve, ve.clone(), Fe), Fe.reset(), B) return {
          ok: !1,
          conflict: B
        };
        if (Fe.get(), Ht.length) {
          const ae = Ht.map((ue) => ue ? ue.get() : null), Ee = s.readCursor(M(Fe.get()));
          if (ft(Ee, Fe, (ue, re, he) => {
            const Oe = ae[ue];
            Oe && (he.mergeTree(Oe), ae[ue] = null);
          }), ae.find((ue) => ue)) {
            const ue = s.writeCursor(), re = s.writeCursor();
            let he = 0, Oe = 0;
            ae.forEach((Se) => {
              Se != null && ft(s.readCursor(Se), null, (be) => {
                const Ye = rn[be];
                ue.writeMove(j[Ye].getPath(), Q[Ye].getPath(), he++);
                const Be = Pe[Ye];
                Be && Be.forEach(($e) => {
                  K[$e] || z !== 1 && Re[$e] != null || re.writeMove(ee[$e].getPath(), U[$e].getPath(), Oe++);
                });
              });
            }), B = {
              type: i.ConflictType.BLACKHOLE,
              op1: ue.get(),
              op2: re.get()
            };
          }
        }
      }
      return B ? {
        ok: !1,
        conflict: B
      } : {
        ok: !0,
        result: Fe.get()
      };
    }
    const k = (I) => {
      const x = new Error("Transform detected write conflict");
      throw x.conflict = I, x.type = x.name = "writeConflict", x;
    };
    function q(I, x, Y) {
      const z = L(I, x, Y);
      if (z.ok) return z.result;
      k(z.conflict);
    }
    const V = (I) => {
      const x = s.writeCursor();
      return s.readCursor(I).traverse(x, (Y, z) => {
        (h(Y) || W(Y)) && z.write("r", !0);
      }), x.get();
    }, oe = (I, x) => {
      const { type: Y, op1: z, op2: B } = I;
      switch (Y) {
        case i.ConflictType.DROP_COLLISION:
          return x === "left" ? [null, V(B)] : [V(z), null];
        case i.ConflictType.RM_UNEXPECTED_CONTENT:
          let j = !1;
          return s.readCursor(z).traverse(null, (Q) => {
            Q.r !== void 0 && (j = !0);
          }), j ? [null, V(B)] : [V(z), null];
        case i.ConflictType.BLACKHOLE:
          return [V(z), V(B)];
        default:
          throw Error("Unrecognised conflict: " + Y);
      }
    };
    function le(I, x, Y, z) {
      let B = null;
      for (; ; ) {
        const j = L(x, Y, z);
        if (j.ok) return S(B, j.result);
        {
          const { conflict: Q } = j;
          I(Q) || k(Q);
          const [ee, U] = oe(Q, z);
          x = S($(x), ee), Y = S($(Y), U), B = S(B, U);
        }
      }
    }
  })(Zn)), Zn;
}
var Ma;
function hg() {
  return Ma || (Ma = 1, (function(e) {
    var t = an && an.__createBinding || (Object.create ? (function(i, o, a, l) {
      l === void 0 && (l = a), Object.defineProperty(i, l, { enumerable: !0, get: function() {
        return o[a];
      } });
    }) : (function(i, o, a, l) {
      l === void 0 && (l = a), i[l] = o[a];
    })), n = an && an.__exportStar || function(i, o) {
      for (var a in i) a !== "default" && !o.hasOwnProperty(a) && t(o, i, a);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), n(cg(), e);
    var r = hu();
    Object.defineProperty(e, "ReadCursor", { enumerable: !0, get: function() {
      return r.ReadCursor;
    } }), Object.defineProperty(e, "WriteCursor", { enumerable: !0, get: function() {
      return r.WriteCursor;
    } });
    var s = du();
    Object.defineProperty(e, "ConflictType", { enumerable: !0, get: function() {
      return s.ConflictType;
    } });
  })(an)), an;
}
var it = hg();
const dg = /* @__PURE__ */ Rt(it), p1 = /* @__PURE__ */ Tc({
  __proto__: null,
  default: dg
}, [it]);
var pe = /* @__PURE__ */ ((e) => (e[e.COVER = 0] = "COVER", e[e.REPLACE = 1] = "REPLACE", e))(pe || {}), Z = /* @__PURE__ */ ((e) => (e.RETAIN = "r", e.INSERT = "i", e.DELETE = "d", e))(Z || {});
const Nr = ht("univer.context-service");
class fg extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_contextChanged$", new ot());
    p(this, "contextChanged$", this._contextChanged$.asObservable());
    p(this, "_contextMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._contextChanged$.complete(), this._contextMap.clear();
  }
  getContextValue(n) {
    var r;
    return (r = this._contextMap.get(n)) != null ? r : !1;
  }
  setContextValue(n, r) {
    this._contextMap.set(n, r), this._contextChanged$.next({ [n]: r });
  }
  subscribeContextValue$(n) {
    return new br((r) => {
      const s = this._contextChanged$.pipe(Rr((i) => typeof i[n] < "u")).subscribe((i) => r.next(i[n]));
      return this._contextMap.has(n) && r.next(this._contextMap.get(n)), () => s.unsubscribe();
    });
  }
}
var mg = /* @__PURE__ */ ((e) => (e[e.SILENT = 0] = "SILENT", e[e.ERROR = 1] = "ERROR", e[e.WARN = 2] = "WARN", e[e.INFO = 3] = "INFO", e[e.VERBOSE = 4] = "VERBOSE", e))(mg || {});
const yt = ht("univer.log");
class gg extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_logLevel", 3);
    p(this, "_deduction", /* @__PURE__ */ new Set());
  }
  dispose() {
    super.dispose(), this._logLevel = 3, this._deduction.clear();
  }
  debug(...n) {
    this._logLevel >= 4 && this._log(console.debug, ...n);
  }
  log(...n) {
    this._logLevel >= 3 && this._log(console.log, ...n);
  }
  warn(...n) {
    this._logLevel >= 2 && this._log(console.warn, ...n);
  }
  error(...n) {
    this._logLevel >= 1 && this._log(console.error, ...n);
  }
  deprecate(...n) {
    this._logLevel >= 2 && this._logWithDeduplication(console.error, ...n);
  }
  setLogLevel(n) {
    this._logLevel = n;
  }
  _log(n, ...r) {
    const s = r[0];
    /^\[(.*?)\]/g.test(s) ? n(`\x1B[97;104m${s}\x1B[0m`, ...r.slice(1)) : n(...r);
  }
  _logWithDeduplication(n, ...r) {
    const s = _g(...r);
    this._deduction.has(s) || (this._deduction.add(s), this._log(n, ...r));
  }
}
function _g(...e) {
  return e.map((t) => JSON.stringify(t)).join("");
}
var pg = Object.getOwnPropertyDescriptor, Eg = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? pg(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, La = (e, t) => (n, r) => t(n, r, e), Ms = /* @__PURE__ */ ((e) => (e[e.COMMAND = 0] = "COMMAND", e[e.OPERATION = 1] = "OPERATION", e[e.MUTATION = 2] = "MUTATION", e))(Ms || {});
const Ls = ht("univer.core.command-service");
class Cg {
  constructor() {
    p(this, "_commands", /* @__PURE__ */ new Map());
    p(this, "_commandTypes", /* @__PURE__ */ new Map());
  }
  registerCommand(t) {
    if (this._commands.has(t.id))
      throw new Error(`[CommandRegistry]: command "${t.id}" has been registered before.`);
    return this._commands.set(t.id, t), this._commandTypes.set(t.id, t.type), We(() => {
      this.unregisterCommand(t.id);
    });
  }
  unregisterCommand(t) {
    this._commands.delete(t), this._commandTypes.delete(t);
  }
  hasCommand(t) {
    return this._commands.has(t);
  }
  getCommand(t) {
    return this._commands.has(t) ? [this._commands.get(t)] : null;
  }
  getCommandType(t) {
    return this._commandTypes.get(t);
  }
}
const Rg = {
  id: "nil",
  type: 0,
  handler: () => !0
};
let vi = class extends Ve {
  constructor(t, n) {
    super();
    p(this, "_commandRegistry");
    p(this, "_beforeCommandExecutionListeners", []);
    p(this, "_commandExecutedListeners", []);
    p(this, "_multiCommandDisposables", /* @__PURE__ */ new Map());
    p(this, "_commandExecutingLevel", 0);
    p(this, "_commandExecutionStack", []);
    this._injector = t, this._logService = n, this._commandRegistry = new Cg(), this.registerCommand(Rg);
  }
  dispose() {
    super.dispose(), this._commandExecutedListeners.length = 0, this._beforeCommandExecutionListeners.length = 0;
  }
  hasCommand(t) {
    return this._commandRegistry.hasCommand(t);
  }
  registerCommand(t) {
    return this._commandRegistry.registerCommand(t);
  }
  unregisterCommand(t) {
    var n;
    this._commandRegistry.unregisterCommand(t), (n = this._multiCommandDisposables.get(t)) == null || n.dispose();
  }
  registerMultipleCommand(t) {
    return this._registerMultiCommand(t);
  }
  beforeCommandExecuted(t) {
    if (this._beforeCommandExecutionListeners.indexOf(t) === -1)
      return this._beforeCommandExecutionListeners.push(t), We(() => {
        const n = this._beforeCommandExecutionListeners.indexOf(t);
        this._beforeCommandExecutionListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  onCommandExecuted(t) {
    if (this._commandExecutedListeners.indexOf(t) === -1)
      return this._commandExecutedListeners.push(t), We(() => {
        const n = this._commandExecutedListeners.indexOf(t);
        this._commandExecutedListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  async executeCommand(t, n, r) {
    try {
      const s = this._commandRegistry.getCommand(t);
      if (s) {
        const [i] = s, o = {
          id: i.id,
          type: i.type,
          params: n
        }, a = this._pushCommandExecutionStack(o), l = r != null ? r : {};
        this._beforeCommandExecutionListeners.forEach((c) => c(o, l));
        const u = await this._execute(i, n, l);
        return this._commandExecutedListeners.forEach((c) => c(o, l)), a.dispose(), u;
      }
      throw new Error(`[CommandService]: command "${t}" is not registered.`);
    } catch (s) {
      if (s instanceof _i)
        return !1;
      throw s;
    }
  }
  syncExecuteCommand(t, n, r) {
    var s;
    try {
      const i = this._commandRegistry.getCommand(t);
      if (i) {
        const [o] = i, a = {
          id: o.id,
          type: o.type,
          params: n
        };
        if (o.type === 2) {
          const h = Uc(
            this._commandExecutionStack,
            (d) => d.type === 0
            /* COMMAND */
          );
          h && (a.params = (s = a.params) != null ? s : {}, a.params.trigger = h.id);
        }
        const l = this._pushCommandExecutionStack(a), u = r != null ? r : {};
        this._beforeCommandExecutionListeners.forEach((h) => h(a, u));
        const c = this._syncExecute(o, n, u);
        return this._commandExecutedListeners.forEach((h) => h(a, u)), l.dispose(), c;
      }
      throw new Error(`[CommandService]: command "${t}" is not registered.`);
    } catch (i) {
      if (i instanceof _i)
        return !1;
      throw i;
    }
  }
  _pushCommandExecutionStack(t) {
    return this._commandExecutionStack.push(t), We(() => Os(this._commandExecutionStack, t));
  }
  _registerMultiCommand(t) {
    const n = this._commandRegistry.getCommand(t.id);
    let r;
    if (n) {
      if (n[0].multi !== !0)
        throw new Error("Command has registered as a single command.");
      r = n[0];
    } else {
      r = new Ig(t.id);
      const i = new ao();
      i.add(this._commandRegistry.registerCommand(r)), i.add(
        We(() => {
          this._multiCommandDisposables.delete(t.id);
        })
      ), this._multiCommandDisposables.set(t.id, i);
    }
    const s = r.registerImplementation(t);
    return We(() => {
      var i;
      s.dispose(), r.hasImplementations() || (i = this._multiCommandDisposables.get(t.id)) == null || i.dispose();
    });
  }
  async _execute(t, n, r) {
    this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(this._commandExecutingLevel, 0))}executing command "${t.id}"`
    ), this._commandExecutingLevel++;
    let s;
    try {
      s = await this._injector.invoke(t.handler, n, r), this._commandExecutingLevel--;
    } catch (i) {
      throw s = !1, this._commandExecutingLevel = 0, i;
    }
    return s;
  }
  _syncExecute(t, n, r) {
    this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(0, this._commandExecutingLevel))}executing command "${t.id}".`
    ), this._commandExecutingLevel++;
    let s;
    try {
      if (s = this._injector.invoke(t.handler, n, r), s instanceof Promise)
        throw new TypeError("[CommandService]: Command handler should not return a promise.");
      this._commandExecutingLevel--;
    } catch (i) {
      throw s = !1, this._commandExecutingLevel = 0, i;
    }
    return s;
  }
};
vi = Eg([
  La(0, Nt(Yn)),
  La(1, yt)
], vi);
class Ig {
  constructor(t) {
    p(this, "name");
    p(this, "multi", !0);
    p(this, "type", 0);
    p(this, "priority", 0);
    p(this, "_implementations", []);
    p(this, "handler", async (t, n) => {
      if (!this._implementations.length)
        return !1;
      const r = t.get(yt), s = t.get(Nr), i = t.get(Yn);
      for (const o of this._implementations) {
        const a = o.command.preconditions;
        if ((!a || a && a(s)) && (r.debug("[MultiCommand]", `executing implementation "${o.command.name}".`), await i.invoke(o.command.handler, n)))
          return !0;
      }
      return !1;
    });
    this.id = t, this.name = t;
  }
  registerImplementation(t) {
    const n = { command: t };
    return this._implementations.push(n), this._implementations.sort((r, s) => s.command.priority - r.command.priority), We(() => {
      const r = this._implementations.indexOf(n);
      this._implementations.splice(r, 1);
    });
  }
  hasImplementations() {
    return this._implementations.length > 0;
  }
}
function fo(e, t, n) {
  const r = e.map((s) => () => t.syncExecuteCommand(s.id, s.params, n));
  return em(r);
}
function E1(e, t, n) {
  const r = e.map((s) => () => t.executeCommand(s.id, s.params, n));
  return Qf(r);
}
function wg(e) {
  return new br((t) => {
    const n = e((...r) => t.next(r));
    return () => n == null ? void 0 : n.dispose();
  });
}
function xa(e) {
  return function(n) {
    return new br((r) => (n.subscribe({
      next: (s) => {
        r.next(s), e(s) && r.complete();
      },
      complete: () => r.complete(),
      error: (s) => r.error(s)
    }), () => r.unsubscribe()));
  };
}
function C1(e = 0) {
  return (t) => {
    let n = [];
    return t.pipe(
      na((r) => n.push(r)),
      Ic(e),
      Ji(() => n),
      na(() => n = [])
    );
  };
}
function R1(e) {
  const t = new Cc(1);
  return setTimeout(() => t.next(), e), t.pipe(Rc(1));
}
function I1(e, t) {
  const n = new tt(t);
  return e.subscribe(n), n;
}
const w1 = (e) => new Promise((t) => {
  Ll(
    wg(e.onCommandExecuted.bind(e)).pipe(bc(([n]) => n.type === Ms.MUTATION)),
    wc(300)
  ).pipe(Ac(16), yc()).subscribe(() => {
    t();
  });
});
function Sg(e, t) {
  let n = 0, r = e.length - 1;
  if (t < e[0]) return 0;
  if (t >= e[e.length - 1]) return e.length - 1;
  for (; n <= r; ) {
    if (e[n] === t) {
      for (; n < e.length && e[n] === t; )
        n++;
      return n;
    }
    if (t > e[n] && t < e[n + 1])
      return n + 1;
    if (e[r] === t) {
      for (; r < e.length && e[r] === t; )
        r++;
      return r;
    }
    if (t > e[r - 1] && t < e[r])
      return r;
    n++, r--;
  }
  return -1;
}
function S1(e, t) {
  let n = 0, r = e.length - 1;
  for (; n <= r; ) {
    const s = Math.floor((r + n) / 2);
    if (t < e[s] && (s === 0 || t >= e[s - 1]))
      return s;
    if (t >= e[s])
      n = s + 1;
    else if (t < e[s])
      r = s - 1;
    else
      return -1;
  }
  return -1;
}
function Og(e, t) {
  let n = 0, r = e.length;
  for (; n < r; ) {
    const s = Math.floor((n + r) / 2);
    e[s] <= t ? n = s + 1 : r = s;
  }
  return n < e.length ? n : e.length - 1;
}
function Pr(e, t, n = !1) {
  let r = e.length - 1;
  if (t < 0 || t < e[0])
    return 0;
  if (e.length < 40 || t <= e[20] || t >= e[r - 20] ? r = Sg(e, t) : r = Og(e, t), n) {
    const s = e[r];
    return e.indexOf(s);
  }
  return r;
}
function O1(e) {
  const t = new Blob([e], { type: "text/javascript" });
  return window.URL.createObjectURL(t);
}
const Fr = 2, vg = 1;
function v1(e, t) {
  if (t == null || e == null)
    return !0;
  const { left: n = 0, top: r = 0, height: s = 0, width: i = 0, angle: o = 0 } = t, { left: a = 0, top: l = 0, height: u = 0, width: c = 0, angle: h = 0 } = e, d = c, f = u, g = i, _ = s;
  return Math.abs(a - n) > Fr || Math.abs(l - r) > Fr || Math.abs(d - g) > Fr || Math.abs(f - _) > Fr || Math.abs(h - o) > vg;
}
function Qs(e, t, n) {
  const { dataStream: r, textRuns: s = [] } = e;
  let i = t;
  const o = [];
  for (const a of s) {
    const { st: l, ed: u } = a;
    J.hasIntersectionBetweenTwoRanges(t, n, l, u) && (l > i ? (o.push(r.slice(i, l)), o.push(Da(r, {
      ...a,
      ed: Math.min(u, n)
    }))) : o.push(Da(r, {
      ...a,
      st: i,
      ed: Math.min(u, n)
    }))), i = Math.max(t, Math.min(u, n));
  }
  return i !== n && o.push(r.slice(i, n)), o.join("");
}
function b1(e, t = !0) {
  var n;
  if (t && ((n = e.paragraphs) != null && n.length)) {
    const { dataStream: r, paragraphs: s = [] } = e;
    let i = "", o = -1;
    for (const a of s) {
      const { startIndex: l, paragraphStyle: u = {} } = a, { spaceAbove: c, spaceBelow: h, lineSpacing: d } = u, f = [];
      c != null && (typeof c == "number" ? f.push(`margin-top: ${c}px`) : f.push(`margin-top: ${c.v}px`)), h != null && (typeof h == "number" ? f.push(`margin-bottom: ${h}px`) : f.push(`margin-bottom: ${h.v}px`)), d != null && f.push(`line-height: ${d}`), l > o + 1 ? i += `<p class="UniverNormal" ${f.length ? `style="${f.join("; ")};"` : ""}>${Qs(e, o + 1, l)}</p>` : i += `<p class="UniverNormal" ${f.length ? `style="${f.join("; ")};"` : ""}></p>`, o = l;
    }
    return o !== r.length && (i += Qs(e, o, r.length)), i;
  } else
    return Qs(e, 0, e.dataStream.length);
}
function Da(e, t) {
  const { st: n, ed: r, ts: s = {} } = t, { ff: i, fs: o, it: a, bl: l, ul: u, st: c, ol: h, bg: d, cl: f, va: g } = s;
  let _ = e.slice(n, r);
  const R = [];
  return a === ie.TRUE && (_ = `<i>${_}</i>`), g === Zt.SUPERSCRIPT ? _ = `<sup>${_}</sup>` : g === Zt.SUBSCRIPT && (_ = `<sub>${_}</sub>`), (u == null ? void 0 : u.s) === ie.TRUE && (_ = `<u>${_}</u>`), (c == null ? void 0 : c.s) === ie.TRUE && (_ = `<s>${_}</s>`), l === ie.TRUE && (_ = `<strong>${_}</strong>`), i && R.push(`font-family: ${i}`), f && R.push(`color: ${f.rgb}`), o && R.push(`font-size: ${o}pt`), h && R.push("text-decoration: overline"), d && R.push(`background: ${d.rgb}`), R.length ? `<span style="${R.join("; ")};">${_}</span>` : _;
}
const bg = {
  [co.OFFICE]: {
    [st.ACCENT1]: "#4472C4",
    [st.ACCENT2]: "#ED7D31",
    [st.ACCENT3]: "#A5A5A5",
    [st.ACCENT4]: "#70AD47",
    [st.ACCENT5]: "#5B9BD5",
    [st.ACCENT6]: "#70AD47",
    [st.DARK1]: "#000000",
    [st.DARK2]: "#44546A",
    [st.LIGHT1]: "#FFFFFF",
    [st.LIGHT2]: "#E7E6E6",
    [st.HYPERLINK]: "#0563C1",
    [st.FOLLOWED_HYPERLINK]: "#954F72"
  }
};
class mo {
  constructor() {
    p(this, "_themeValue", st.LIGHT1);
    p(this, "_themeColors");
    p(this, "_themeTint");
    p(this, "_rgbValue", "");
    p(this, "_colorType");
    this._colorType = At.UNSUPPORTED, this._themeColors = co.OFFICE, this._themeTint = 0;
  }
  asRgbColor() {
    return new bi(this._rgbValue, this);
  }
  asThemeColor() {
    return new Ai(this._themeValue, this._themeTint, this._themeColors, this);
  }
  build() {
    switch (this._colorType) {
      case At.THEME:
        return this.asThemeColor();
      case At.RGB:
        return this.asRgbColor();
      case At.UNSUPPORTED:
        throw new Error("unsupported color type");
    }
  }
  setRgbColor(t) {
    return this._colorType = At.RGB, this._rgbValue = t, this;
  }
  setThemeColors(t) {
    this._colorType = At.THEME, this._themeColors = t;
  }
  setThemeTint(t) {
    this._colorType = At.THEME, this._themeTint = t;
  }
  setThemeColor(t) {
    return this._colorType = At.THEME, this._themeValue = t, this;
  }
  getColorType() {
    return this._colorType;
  }
}
class jn {
  constructor(t) {
    p(this, "_builder");
    this._builder = t;
  }
  static rgbColorToHexValue(t) {
    return `#${((1 << 24) + (t.getRed() << 16) + (t.getGreen() << 8) + t.getBlue()).toString(16).slice(1)}`;
  }
  static hexValueToRgbColor(t) {
    t ? t.indexOf("#") > -1 && (t = t.substring(1)) : t = "#000000";
    const n = +`0x${t[0]}${t[1]}`, r = +`0x${t[2]}${t[3]}`, s = +`0x${t[4]}${t[5]}`;
    return new mo().setRgbColor(`rgb(${n},${r},${s})`).asRgbColor();
  }
  static hexToRgbString(t) {
    const n = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    t = t.replace(n, (i, o, a, l) => o + o + a + a + l + l);
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    let s = null;
    if (r) {
      const i = Number.parseInt(r[1], 16), o = Number.parseInt(r[2], 16), a = Number.parseInt(r[3], 16);
      s = `rgba(${i},${o},${a})`;
    }
    return s;
  }
  asRgbColor() {
    return this._builder.asRgbColor();
  }
  asThemeColor() {
    return this._builder.asThemeColor();
  }
  getColorType() {
    return this._builder.getColorType();
  }
  clone() {
    return new jn(this._builder);
  }
  equals(t) {
    return !1;
  }
}
class Ag {
  constructor(t) {
    p(this, "_saturation", 0);
    p(this, "_hue", 0);
    p(this, "_lightness", 0);
    p(this, "_alpha", 0);
    const n = t.getRed() / 255, r = t.getGreen() / 255, s = t.getBlue() / 255, i = t.getAlpha() / 255, o = Math.min(n, Math.min(r, s)), a = Math.max(n, Math.max(r, s)), l = a - o;
    if (a === o) {
      this._hue = 0, this._saturation = 0, this._lightness = a;
      return;
    }
    this._lightness = (o + a) / 2, this._lightness < 0.5 ? this._saturation = l / (a + o) : this._saturation = l / (2 - a - o), n === a && (this._hue = (r - s) / l), r === a && (this._hue = 2 + (s - n) / l), s === a && (this._hue = 4 + (n - r) / l), this._hue *= 60, this._hue < 0 && (this._hue += 360), this._alpha = i;
  }
  asRgbColor() {
    const t = new mo();
    if (this._saturation === 0)
      return t.setRgbColor(
        `rgba(${this._lightness * 255},${this._lightness * 255},${this._lightness * 255},${this._alpha * 255})`
      ), t.asRgbColor();
    let n;
    this._lightness < 0.5 ? n = this._lightness * (1 + this._saturation) : n = this._lightness + this._saturation - this._lightness * this._saturation;
    const r = 2 * this._lightness - n, s = this._hue / 360, i = s + 1 / 3, o = this.setColor(n, r, i), a = this.setColor(n, r, s), l = s - 1 / 3, u = this.setColor(n, r, l);
    return t.setRgbColor(
      `rgba(${Math.round(o * 255)},${Math.round(a * 255)},${Math.round(u * 255)},${this._alpha * 255})`
    ), t.asRgbColor();
  }
  getLightness() {
    return this._lightness;
  }
  getHue() {
    return this._hue;
  }
  getSaturation() {
    return this._saturation;
  }
  getAlpha() {
    return this._alpha;
  }
  setColor(t, n, r) {
    r < 0 && (r += 1), r > 1 && (r -= 1);
    let s;
    return 6 * r < 1 ? s = n + (t - n) * 6 * r : 2 * r < 1 ? s = t : 3 * r < 2 ? s = n + (t - n) * (2 / 3 - r) * 6 : s = n, s;
  }
  setLightness(t) {
    this._lightness = t;
  }
}
const _t = class _t extends jn {
  constructor(n, r) {
    super(r);
    p(this, "_cssString");
    p(this, "_red");
    p(this, "_green");
    p(this, "_blue");
    p(this, "_alpha");
    let s = n.match(_t.RGBA_EXTRACT);
    if (s) {
      const i = +s[1], o = +s[2], a = +s[3], l = +s[4];
      this._cssString = n, this._red = i, this._green = o, this._blue = a, this._alpha = l;
      return;
    }
    if (s = n.match(_t.RGB_EXTRACT), s) {
      const i = +s[1], o = +s[2], a = +s[3];
      this._cssString = n, this._red = i, this._green = o, this._blue = a, this._alpha = 1;
      return;
    }
    throw new Error("Invalid rgba or rgb color");
  }
  asHexString() {
    return jn.rgbColorToHexValue(this);
  }
  getRed() {
    let n = this._red + _t.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getGreen() {
    let n = this._green + _t.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getBlue() {
    let n = this._blue + _t.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getAlpha() {
    return this._alpha;
  }
  getColorType() {
    return At.RGB;
  }
  clone() {
    return new _t(this._cssString, this._builder);
  }
  asThemeColor() {
    throw new Error("rgb color not support to themeColor");
  }
  equals(n) {
    return n instanceof _t ? n._red === this._red && n._blue === this._blue && n._green === this._green && n._alpha === this._alpha : !1;
  }
  getCssString() {
    return this._cssString;
  }
};
p(_t, "RGB_COLOR_AMT", 0), p(_t, "RGBA_EXTRACT", new RegExp(
  "\\s*rgba\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d.\\d|\\d\\s*)\\)\\s*"
)), p(_t, "RGB_EXTRACT", new RegExp("\\s*rgb\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*)\\)\\s*"));
let bi = _t;
const qt = class qt extends jn {
  constructor(n, r, s, i) {
    super(i);
    p(this, "_themeColorType");
    p(this, "_themeTint");
    p(this, "_themeColors");
    this._themeColorType = n, this._themeTint = r, this._themeColors = s;
  }
  lumValue(n, r) {
    if (n == null)
      return r;
    let s;
    return n < 0 ? s = r * (1 + n) : s = r * (1 - n) + (255 - 255 * (1 - n)), s;
  }
  asRgbColor() {
    const n = bg[this._themeColors];
    if (n == null)
      throw new Error("not find themeColors type");
    const r = n[this._themeColorType];
    if (r == null)
      throw new Error("not find themeColors value");
    let s;
    if (qt._cacheThemeColor.has(this._themeColors)) {
      if (s = qt._cacheThemeColor.get(this._themeColors), s.has(this._themeColorType))
        return s.get(this._themeColorType);
    } else
      s = /* @__PURE__ */ new Map(), qt._cacheThemeColor.set(this._themeColors, s);
    const i = new Ag(jn.hexValueToRgbColor(r));
    i.setLightness(this.lumValue(this._themeTint, i.getLightness() * 255) / 255);
    const o = i.asRgbColor();
    return s.set(this._themeColorType, o), o;
  }
  clone() {
    return new qt(this._themeColorType, this._themeTint, this._themeColors, this._builder);
  }
  equals(n) {
    return n instanceof qt ? n._themeColorType === this._themeColorType : !1;
  }
  getColorType() {
    return At.THEME;
  }
  getThemeColorType() {
    return this._themeColorType;
  }
};
p(qt, "_cacheThemeColor", /* @__PURE__ */ new Map());
let Ai = qt;
const A1 = "rgb(", y1 = "rgba(", Ua = {
  aliceBlue: [240, 248, 255],
  antiqueWhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blancheAlmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueViolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlyWood: [222, 184, 135],
  cadetBlue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornFlowerBlue: [100, 149, 237],
  cornSilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkBlue: [0, 0, 139],
  darkCyan: [0, 139, 139],
  darkGoldenrod: [184, 132, 11],
  darkGray: [169, 169, 169],
  darkGreen: [0, 100, 0],
  darkGrey: [169, 169, 169],
  darkKhaki: [189, 183, 107],
  darkMagenta: [139, 0, 139],
  darkOliveGreen: [85, 107, 47],
  darkOrange: [255, 140, 0],
  darkOrchid: [153, 50, 204],
  darkRed: [139, 0, 0],
  darkSalmon: [233, 150, 122],
  darkSeaGreen: [143, 188, 143],
  darkSlateBlue: [72, 61, 139],
  darkSlateGray: [47, 79, 79],
  darkSlateGrey: [47, 79, 79],
  darkTurquoise: [0, 206, 209],
  darkViolet: [148, 0, 211],
  darkYellow: [139, 128, 0],
  deepPink: [255, 20, 147],
  deepSkyBlue: [0, 191, 255],
  dimGray: [105, 105, 105],
  dimGrey: [105, 105, 105],
  dodgerBlue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralWhite: [255, 255, 240],
  forestGreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostWhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenYellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotPink: [255, 105, 180],
  indianRed: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderBlush: [255, 240, 245],
  lawnGreen: [124, 252, 0],
  lemonChiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightCoral: [240, 128, 128],
  lightCyan: [224, 255, 255],
  lightGoldenrodYellow: [250, 250, 210],
  lightGray: [211, 211, 211],
  lightGreen: [144, 238, 144],
  lightGrey: [211, 211, 211],
  lightPink: [255, 182, 193],
  lightSalmon: [255, 160, 122],
  lightSeaGreen: [32, 178, 170],
  lightSkyBlue: [135, 206, 250],
  lightSlateGray: [119, 136, 153],
  lightSlateGrey: [119, 136, 153],
  lightSteelBlue: [176, 196, 222],
  lightYellow: [255, 255, 224],
  lime: [0, 255, 0],
  limeGreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumAquamarine: [102, 205, 170],
  mediumBlue: [0, 0, 205],
  mediumOrchid: [186, 85, 211],
  mediumPurple: [147, 112, 219],
  mediumSeaGreen: [60, 179, 113],
  mediumSlateBlue: [123, 104, 238],
  mediumSpringGreen: [0, 250, 154],
  mediumTurquoise: [72, 209, 204],
  mediumVioletRed: [199, 21, 133],
  midBightBlue: [25, 25, 112],
  mintCream: [245, 255, 250],
  mistyRose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajoWhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldLace: [253, 245, 230],
  olive: [128, 128, 0],
  oliveDrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangeRed: [255, 69, 0],
  orchid: [218, 112, 214],
  paleGoldenrod: [238, 232, 170],
  paleGreen: [152, 251, 152],
  paleTurquoise: [175, 238, 238],
  paleVioletRed: [219, 112, 147],
  papayaWhip: [255, 239, 213],
  peachPuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderBlue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccaPurple: [102, 51, 153],
  red: [255, 0, 0],
  rosyBrown: [188, 143, 143],
  royalBlue: [65, 105, 225],
  saddleBrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandyBrown: [244, 164, 96],
  seaGreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyBlue: [135, 206, 235],
  slateBlue: [106, 90, 205],
  slateGray: [119, 128, 144],
  slateGrey: [119, 128, 144],
  snow: [255, 255, 250],
  springGreen: [0, 255, 127],
  steelBlue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  transparent: [255, 255, 255, 0],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whiteSmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowGreen: [154, 205, 5]
};
class bt {
  constructor(t) {
    p(this, "_color");
    p(this, "_rgbColor");
    p(this, "_isValid", !1);
    if (t == null) {
      this._setNullColor();
      return;
    }
    if (t instanceof bt) {
      this._color = { ...t._color }, this._rgbColor = { ...t._rgbColor };
      return;
    }
    const n = fu(t);
    if (n == null) {
      this._setNullColor();
      return;
    }
    this._color = n;
    const r = Lg(this._color);
    if (r == null) {
      this._setNullColor();
      return;
    }
    this._rgbColor = r, this._isValid = !0;
  }
  static mix(t, n, r) {
    var u, c;
    r = Math.min(1, Math.max(0, r));
    const s = new bt(t).toRgb(), i = new bt(n).toRgb(), o = (u = s.a) != null ? u : 1, a = (c = i.a) != null ? c : 1, l = {
      r: (i.r - s.r) * r + s.r,
      g: (i.g - s.g) * r + s.g,
      b: (i.b - s.b) * r + s.b,
      a: (a - o) * r + o
    };
    return new bt(l);
  }
  static getContrastRatio(t, n) {
    const r = new bt(t).getLuminance(), s = new bt(n).getLuminance();
    return (Math.max(r, s) + 0.05) / (Math.min(r, s) + 0.05);
  }
  get isValid() {
    return this._isValid;
  }
  toRgb() {
    return this._rgbColor;
  }
  toRgbString() {
    const { r: t, g: n, b: r, a: s = 1 } = this.toRgb(), i = s < 1;
    return `rgb${i ? "a" : ""}(${t},${n},${r}${i ? `,${s}` : ""})`;
  }
  toString() {
    return this.toRgbString();
  }
  toHexString(t) {
    const { r: n, g: r, b: s, a: i = 1 } = this.toRgb(), o = i < 1, a = [
      $r(Math.round(n).toString(16)),
      $r(Math.round(r).toString(16)),
      $r(Math.round(s).toString(16)),
      $r(Math.round(i * 255).toString(16))
    ];
    return t && a[0][0] === a[0][1] && a[1][0] === a[1][1] && a[2][0] === a[2][1] && a[3][0] === a[3][1] ? o ? `#${a[0][0]}${a[1][0]}${a[2][0]}${a[3][0]}` : `#${a[0][0]}${a[1][0]}${a[2][0]}` : o ? `#${a[0]}${a[1]}${a[2]}${a[3]}` : `#${a[0]}${a[1]}${a[2]}`;
  }
  toHsv() {
    return kg(this.toRgb());
  }
  toHsl() {
    return Ug(this.toRgb());
  }
  lighten(t = 10) {
    const n = this.toHsl();
    return n.l += t, n.l = Math.min(Math.max(n.l, 0), 100), new bt(n);
  }
  darken(t = 10) {
    const n = this.toHsl();
    return n.l -= t, n.l = Math.min(Math.max(n.l, 0), 100), new bt(n);
  }
  setAlpha(t) {
    return new bt({ ...this._rgbColor, a: t });
  }
  getLuminance() {
    let { r: t, g: n, b: r } = this.toRgb();
    return t = ei(t), n = ei(n), r = ei(r), Number((0.2126 * t + 0.7152 * n + 0.0722 * r).toFixed(3));
  }
  getBrightness() {
    const { r: t, g: n, b: r } = this.toRgb();
    return (t * 299 + n * 587 + r * 114) / 1e3;
  }
  getAlpha() {
    var t;
    return (t = this._color.a) != null ? t : 1;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  _setNullColor() {
    this._isValid = !1, this._color = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    }, this._rgbColor = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    };
  }
}
const $r = (e) => e.length === 1 ? `0${e}` : e, ei = (e) => (e /= 255, e <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4), fu = (e) => {
  if (Fg(e)) {
    if ("r" in e) {
      const r = {
        r: Math.round(e.r),
        g: Math.round(e.g),
        b: Math.round(e.b)
      };
      return e.a !== void 0 && (r.a = e.a), r;
    }
    if ("l" in e) {
      const r = {
        h: Math.round(e.h),
        s: e.s,
        l: e.l
      };
      return e.a !== void 0 && (r.a = e.a), r;
    }
    const n = {
      h: Math.round(e.h),
      s: e.s,
      v: e.v
    };
    return e.a !== void 0 && (n.a = e.a), n;
  }
  const t = e.trim();
  if (Ua[t]) {
    const n = Ua[t], r = {
      r: Math.round(n[0]),
      g: Math.round(n[1]),
      b: Math.round(n[2])
    };
    return r.a = n[3] || 1, r;
  }
  if (t.startsWith("#"))
    return yg(t);
  if (t.startsWith("rgb"))
    return Ng(t);
  if (t.startsWith("hsl"))
    return Tg(t);
  if (t.startsWith("hsv"))
    return Mg(t);
}, yg = (e) => {
  const t = e.substring(1), n = new RegExp(`.{1,${t.length >= 6 ? 2 : 1}}`, "g");
  let r = t.match(n);
  if (!r || r.length < 3)
    throw new Error(`The color '${e}' is illegal hex color`);
  r[0].length === 1 && (r = r.map((i) => i + i));
  const s = {
    r: Number.parseInt(r[0], 16),
    g: Number.parseInt(r[1], 16),
    b: Number.parseInt(r[2], 16)
  };
  return r.length > 3 && (s.a = Number.parseInt(r[3], 16) / 255), s;
}, Ng = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal rgb color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal rgb color`);
  const r = {
    r: Number.parseInt(n[0], 10),
    g: Number.parseInt(n[1], 10),
    b: Number.parseInt(n[2], 10)
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
}, Tg = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal hsl color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal hsl color`);
  const r = {
    h: Number.parseInt(n[0], 10),
    s: Number.parseFloat(n[1]),
    l: Number.parseFloat(n[2])
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
}, Mg = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal hsv color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal hsv color`);
  const r = {
    h: Number.parseInt(n[0], 10),
    s: Number.parseFloat(n[1]),
    v: Number.parseFloat(n[2])
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
}, Lg = (e) => {
  const t = fu(e);
  if (t != null)
    return "r" in t ? t : "l" in t ? xg(t) : Dg(t);
}, ti = (e, t, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e), xg = (e) => {
  let { h: t, s: n, l: r } = e;
  t /= 360, n /= 100, r /= 100;
  let s = 0, i = 0, o = 0;
  if (n === 0)
    s = i = o = r;
  else {
    const l = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - l;
    s = ti(u, l, t + 1 / 3), i = ti(u, l, t), o = ti(u, l, t - 1 / 3);
  }
  const a = {
    r: Math.round(s * 255),
    g: Math.round(i * 255),
    b: Math.round(o * 255)
  };
  return e.a !== void 0 && (a.a = e.a), a;
}, Dg = (e) => {
  let { h: t, s: n, v: r } = e;
  t = t / 360 * 6, n /= 100, r /= 100;
  const s = Math.floor(t), i = t - s, o = r * (1 - n), a = r * (1 - i * n), l = r * (1 - (1 - i) * n), u = s % 6, c = [r, a, o, o, l, r][u], h = [l, r, r, a, o, o][u], d = [o, o, l, r, r, a][u], f = {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
  return e.a !== void 0 && (f.a = e.a), f;
}, Ug = (e) => {
  let { r: t, g: n, b: r } = e;
  t /= 255, n /= 255, r /= 255;
  const s = Math.max(t, n, r), i = Math.min(t, n, r), o = (s + i) / 2;
  let a, l;
  if (s === i)
    a = l = 0;
  else {
    const c = s - i;
    switch (l = o > 0.5 ? c / (2 - s - i) : c / (s + i), s) {
      case t:
        a = (n - r) / c + (n < r ? 6 : 0);
        break;
      case n:
        a = (r - t) / c + 2;
        break;
      default:
        a = (t - n) / c + 4;
        break;
    }
    a /= 6;
  }
  const u = {
    h: Math.round(a * 360),
    s: Math.round(l * 100),
    l: Math.round(o * 100)
  };
  return e.a !== void 0 && (u.a = e.a), u;
}, kg = (e) => {
  let { r: t, g: n, b: r } = e;
  t /= 255, n /= 255, r /= 255;
  const s = Math.max(t, n, r), i = Math.min(t, n, r);
  let o;
  const a = s, l = s - i, u = s === 0 ? 0 : l / s;
  if (s === i)
    o = 0;
  else {
    switch (s) {
      case t:
        o = (n - r) / l + (n < r ? 6 : 0);
        break;
      case n:
        o = (r - t) / l + 2;
        break;
      default:
        o = (t - n) / l + 4;
        break;
    }
    o /= 6;
  }
  const c = {
    h: Math.round(o * 360),
    s: Math.round(u * 100),
    v: Math.round(a * 100)
  };
  return e.a !== void 0 && (c.a = e.a), c;
}, Pg = (e) => e == null, Fg = (e) => !Pg(e) && typeof e == "object";
function N1(e) {
  const t = /^#(?:[0]{3}|[0]{6})\b/, n = /^rgb\s*\(\s*0+\s*,\s*0+\s*,\s*0+\s*\)$/, r = /^rgba\s*\(\s*0+\s*,\s*0+\s*,\s*0+\s*,\s*(1|1\.0*|0?\.\d+)\)$/, s = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*0%*\s*\)$/, i = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*0%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
  return !!(t.test(e) || n.test(e) || r.test(e) || s.test(e) || i.test(e));
}
function T1(e) {
  const t = /^#(?:[Ff]{3}|[Ff]{6})\b/, n = /^rgb\s*\(\s*255\s*,\s*255\s*,\s*255\s*\)$/, r = /^rgba\s*\(\s*255\s*,\s*255\s*,\s*255\s*,\s*(1|1\.0*|0?\.\d+)\)$/, s = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*\)$/, i = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
  return !!(t.test(e) || n.test(e) || r.test(e) || s.test(e) || i.test(e));
}
function $g(e) {
  return e && (e.s !== void 0 || e.p !== void 0 || e.v !== void 0 || e.t !== void 0 || e.f !== void 0 || e.si !== void 0 || e.custom !== void 0);
}
function M1(e) {
  if (e.t !== void 0)
    return e.t;
  if (typeof e.v == "string")
    return fn.STRING;
  if (typeof e.v == "number")
    return fn.NUMBER;
  if (typeof e.v == "boolean")
    return fn.BOOLEAN;
}
function L1(e) {
  if (e == null)
    return !0;
  const { v: t, f: n, si: r, p: s, custom: i } = e;
  return !(!(t == null || typeof t == "string" && t.length === 0) || n != null && n.length > 0 || r != null && r.length > 0 || s != null || i != null);
}
function Hg(e) {
  return e != null && (typeof e == "string" || typeof e == "number" || typeof e == "boolean");
}
var ge = /* @__PURE__ */ ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL", e))(ge || {}), ye = /* @__PURE__ */ ((e) => (e[e.NONE = 0] = "NONE", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL", e))(ye || {});
function x1(e) {
  return [e.startRow, e.startColumn, e.endRow, e.endColumn];
}
var Bg = /* @__PURE__ */ ((e) => (e.NONE = "none", e.BACKWARD = "backward", e.FORWARD = "forward", e))(Bg || {}), jg = /* @__PURE__ */ ((e) => (e.RECT = "RECT", e.TEXT = "TEXT", e))(jg || {});
function D1(e, t, n) {
  let r = !1, s = !1, i = e, o = t, a = e, l = t;
  if (n == null)
    return {
      actualRow: e,
      actualColumn: t,
      isMergedMainCell: s,
      isMerged: r,
      endRow: i,
      endColumn: o,
      startRow: a,
      startColumn: l
    };
  for (let u = 0; u < n.length; u++) {
    const {
      startRow: c,
      endRow: h,
      startColumn: d,
      endColumn: f
    } = n[u];
    if (e === c && t === d) {
      i = h, o = f, a = c, l = d, s = !0;
      break;
    }
    if (e >= c && e <= h && t >= d && t <= f) {
      i = h, o = f, a = c, l = d, r = !0;
      break;
    }
  }
  return {
    actualRow: e,
    actualColumn: t,
    isMergedMainCell: s,
    isMerged: r,
    endRow: i,
    endColumn: o,
    startRow: a,
    startColumn: l
  };
}
var or = /* @__PURE__ */ ((e) => (e.Raw = "raw", e.Intercepted = "intercepted", e.Both = "both", e))(or || {});
function U1(e, t) {
  const n = {};
  for (const r in e) {
    const s = Number(r), i = e[s];
    for (const o in i) {
      const a = Number(o), l = i[a], u = t(s, a, l);
      u !== void 0 && (n[s] ? n[s][a] = u : n[s] = {
        [a]: u
      });
    }
  }
  return n;
}
function mn(e) {
  let t = 0;
  const n = Object.keys(e);
  for (const r of n) {
    const s = Number(r);
    t = Math.max(t, s);
  }
  return t + 1;
}
function k1(e, t, n) {
  const r = mn(n), s = n;
  for (let i = r - 1; i >= e; i--)
    s[i + 1] = s[i];
  s[e] = t;
}
function ka(e, t, n) {
  const r = Object.keys(n).reduce((s, i) => Math.max(s, Number.parseInt(i)), 0) + 1;
  for (let s = e; s < r; s++)
    s < e + t ? delete n[s] : n[s] !== void 0 && (n[s - t] = n[s], delete n[s]);
}
function P1(e, t) {
  const n = e, r = Object.keys(n), s = r.length, i = t, o = Object.keys(i), a = o.length, l = {};
  let u = 0;
  for (let c = 0; c < s; c++, u++) {
    const h = r[c];
    l[u] = n[h];
  }
  for (let c = 0; c < a; c++, u++) {
    const h = o[c];
    l[u] = i[h];
  }
  return l;
}
function F1(e, t, n) {
  const r = n;
  if (mn(n) > 0) {
    const i = {};
    let o = 0;
    for (let a = e; a <= t; a++)
      r[a] && (i[o] = r[a], o++);
    return i;
  }
  return {};
}
function Pa(e, t, n, r) {
  const s = e > n;
  if (!s && e + t > n)
    throw new Error("Invalid move operation");
  s ? Wg(e, t, n, r) : Yg(e, t, n, r);
}
function Wg(e, t, n, r) {
  const s = r, i = [];
  for (let o = e; o < e + t; o++)
    i.push(s[o]);
  for (let o = e - 1; o >= n; o--) {
    const a = s[o];
    s[o + t] = a, a === void 0 && delete s[o + t];
  }
  i.forEach((o, a) => {
    s[n + a] = o, o === void 0 && delete s[n + a];
  });
}
function Yg(e, t, n, r) {
  const s = r, i = [];
  for (let o = e; o < e + t; o++)
    i.push(s[o]);
  for (let o = e + t; o < n; o++) {
    const a = s[o];
    s[o - t] = a, a === void 0 && delete s[o - t];
  }
  i.forEach((o, a) => {
    s[n + a - t] = o, o === void 0 && delete s[n + a - t];
  });
}
class pt {
  constructor(t = {}) {
    p(this, "_matrix");
    this._setOriginValue(t);
  }
  static MakeObjectMatrixSize(t) {
    return new pt({
      [t - 1]: {}
    });
  }
  getMatrix() {
    return this._matrix;
  }
  forEach(t) {
    const n = this._matrix, r = Object.keys(n);
    for (const s of r) {
      const i = Number(s), o = n[i];
      if (t(i, o) === !1)
        return this;
    }
    return this;
  }
  forRow(t) {
    const n = this._matrix, r = Object.keys(n);
    for (const s of r) {
      const i = Number(s), o = n[i];
      if (t(
        i,
        Object.keys(o).map((l) => Number(l))
      ) === !1)
        return this;
    }
    return this;
  }
  /**
   * Iterate the object matrix with row priority, which means it scan the whole range row by row.
   */
  forValue(t) {
    const n = this._matrix;
    for (const r in n) {
      const s = Number(r), i = n[s];
      if (i)
        for (const o in i) {
          const a = Number(o), l = i[a];
          if (t(s, a, l) === !1)
            return this;
        }
    }
    return this;
  }
  swapRow(t, n) {
    const r = this._matrix[t], s = this._matrix[n];
    this._matrix[t] = s, this._matrix[n] = r;
  }
  getRow(t) {
    return this._matrix[t];
  }
  getRowOrCreate(t) {
    let n = this.getRow(t);
    return n == null && (n = {}, this._matrix[t] = n), n;
  }
  reset() {
    this._setOriginValue({});
  }
  hasValue() {
    const t = this._matrix, n = Object.keys(t);
    if (n.length === 0)
      return !1;
    for (const r of n) {
      const s = Number(r), i = t[s];
      if (Object.keys(i).length > 0)
        return !0;
    }
    return !1;
  }
  getValue(t, n) {
    var r, s;
    return (s = (r = this._matrix) == null ? void 0 : r[t]) == null ? void 0 : s[n];
  }
  setValue(t, n, r) {
    const s = this.getRowOrCreate(t);
    s[n] = r;
  }
  /**
   * 
   * Please +1 , who fell into this pit.
   * @deprecated use `realDelete` or `splice`
   */
  deleteValue(t, n) {
    var r, s;
    (s = (r = this._matrix) == null ? void 0 : r[t]) == null || delete s[n];
  }
  realDeleteValue(t, n) {
    var r, s, i;
    if ((s = (r = this._matrix) == null ? void 0 : r[t]) == null || delete s[n], this.getRow(t)) {
      const o = this.getRow(t);
      if (o == null)
        return;
      Object.keys(o).length === 0 && ((i = this._matrix) == null || delete i[t]);
    }
  }
  setRow(t, n) {
    this._matrix[t] = n;
  }
  moveRows(t, n, r) {
    Pa(t, n, r, this._matrix);
  }
  moveColumns(t, n, r) {
    this.forEach((s, i) => {
      Pa(t, n, r, i);
    });
  }
  insertRows(t, n) {
    const r = Object.keys(this._matrix);
    for (let s = r.length - 1; s >= 0; s--) {
      const i = Number(r[s]);
      if (i >= t) {
        const o = this._matrix[i];
        delete this._matrix[i], this._matrix[i + n] = o;
      }
    }
  }
  insertColumns(t, n) {
    const r = Object.keys(this._matrix);
    for (let s = 0; s < r.length; s++) {
      const i = Number(r[s]), o = this._matrix[i], a = Object.keys(o);
      for (let l = a.length - 1; l >= 0; l--) {
        const u = Number(a[l]);
        if (u >= t) {
          const c = o[u];
          delete o[u], o[u + n] = c;
        }
      }
    }
  }
  removeRows(t, n) {
    ka(t, n, this._matrix);
  }
  removeColumns(t, n) {
    this.forEach((r, s) => {
      s && ka(t, n, s);
    });
  }
  /**
   * Return a fragment of the original data matrix. Note that the returned matrix's row matrix would start from
   * 0 not `startRow`. Neither does its column matrix. If you want to get the original matrix, use `getSlice`.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getFragment(t, n, r, s) {
    const i = new pt();
    let o = 0;
    for (let a = t; a <= n; a++) {
      const l = {};
      let u = 0;
      for (let c = r; c <= s; c++) {
        const h = this.getValue(a, c);
        l[u] = h, u++;
      }
      i.setRow(o, l), o++;
    }
    return i;
  }
  /**
   * Return a slice of the original data matrix. Note that the returned matrix's row matrix would start from
   * `startRow` not 0, and the same does its column index. You may be looking for `getFragment` if you want
   * both of the indexes start from 0.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getSlice(t, n, r, s) {
    const i = new pt();
    for (let o = t; o <= n; o++)
      for (let a = r; a <= s; a++) {
        const l = this.getValue(o, a);
        l && i.setValue(o, a, J.deepClone(l));
      }
    return i;
  }
  getSizeOf() {
    return Object.keys(this._matrix).length;
  }
  getLength() {
    return mn(this._matrix);
  }
  getRange() {
    const r = this.getLength() - 1;
    let s = 0;
    const i = this.getLength();
    for (let o = 0; o < i; o++) {
      const a = this.getRow(o);
      if (a) {
        const l = mn(a) - 1;
        s = l > s ? l : s;
      }
    }
    return {
      startRow: 0,
      startColumn: 0,
      endRow: r,
      endColumn: s
    };
  }
  toNativeArray() {
    const t = new Array();
    return this.forValue((n, r, s) => {
      t.push(s);
    }), t;
  }
  toArray() {
    const t = [];
    return this.forRow((n, r) => {
      t[n] == null && (t[n] = []), r.forEach((s) => {
        t[n][s] = this.getValue(n, s);
      });
    }), t;
  }
  toFullArray() {
    const t = this.getRange(), { endColumn: n, endRow: r } = t, s = [];
    for (let i = 0; i <= r; i++) {
      const o = new Array(n + 1).fill(void 0);
      s.push(o);
    }
    return this.forValue((i, o, a) => {
      s[i][o] = a;
    }), s;
  }
  /**
   * @deprecated Use getMatrix as a substitute.
   */
  toJSON() {
    return this._matrix;
  }
  clone() {
    const t = JSON.stringify(this._matrix);
    return JSON.parse(t);
  }
  /**
   * @deprecated Use clone as a substitute.
   */
  getData() {
    const t = JSON.stringify(this._matrix);
    return JSON.parse(t);
  }
  getArrayData() {
    let t = 0, n = 0, r = !1, s = !1;
    const i = new pt();
    return this.forEach((o, a) => {
      r || (r = !0, t = o), Object.keys(a).forEach((l) => {
        const u = Number(l);
        s ? u < n && (n = u) : (s = !0, n = u);
        const c = this.getValue(o, u);
        i.setValue(o - t, u - n, c);
      });
    }), i.getData();
  }
  /**
   * the function can only be used in all the row and column are positive integer
   * @description the positive integer in V8 Object is stored in a fast memory space and it is sorted  when we get the keys
   * @returns {IRange} the start and end scope of the matrix
   */
  getStartEndScope() {
    let t = 1 / 0, n = -1 / 0, r = 1 / 0, s = -1 / 0;
    const i = Object.keys(this._matrix);
    i.length > 0 && (t = +i[0], n = +i[i.length - 1]);
    for (const o of i) {
      const a = Object.keys(this._matrix[o]);
      a.length > 0 && (r = Math.min(r, +a[0]), s = Math.max(s, +a[a.length - 1]));
    }
    return { startRow: t, endRow: n, startColumn: r, endColumn: s };
  }
  getDataRange() {
    let t = 0, n = 0, r = 0, s = -1, i = !1, o = !1;
    return this.forEach((a, l) => {
      if (i || (i = !0, t = a), l == null)
        return;
      const u = mn(l) - 1;
      u > r && (r = u), Object.keys(l).forEach((c) => {
        const h = Number(c);
        o ? h < n && (n = h) : (o = !0, n = h);
      }), a > s && (s = a);
    }), {
      startRow: t,
      startColumn: n,
      endRow: s,
      endColumn: r
    };
  }
  getDiscreteRanges() {
    const t = [];
    return this.forEach((n, r) => {
      Object.keys(r).forEach((s) => {
        const i = Number(s);
        let o = !1;
        for (const a of t)
          if (n >= a.startRow && n <= a.endRow + 1 && i >= a.startColumn && i <= a.endColumn + 1) {
            a.endRow = Math.max(n, a.endRow), a.endColumn = Math.max(i, a.endColumn), o = !0;
            break;
          }
        o || t.push({
          startRow: n,
          endRow: n,
          startColumn: i,
          endColumn: i
        });
      });
    }), t;
  }
  merge(t) {
    this.forValue((n, r) => {
      const s = t.getValue(n, r);
      s != null && this.setValue(n, r, s);
    });
  }
  _setOriginValue(t = {}) {
    this._matrix = t;
  }
}
function zg(e) {
  const { actualRow: t, actualColumn: n, isMerged: r, isMergedMainCell: s, mergeInfo: i } = e;
  let { startY: o, endY: a, startX: l, endX: u } = e, c = t, h = n, d = t, f = n;
  if (r && i) {
    const {
      startRow: g,
      startColumn: _,
      endRow: R,
      endColumn: b,
      startY: H,
      endY: P,
      startX: W,
      endX: w
    } = i;
    c = g, h = _, d = R, f = b, o = H, a = P, l = W, u = w;
  }
  return s && (o = i.startY, a = i.endY, l = i.startX, u = i.endX, d = i.endRow, f = i.endColumn), {
    startRow: c,
    startColumn: h,
    endRow: d,
    endColumn: f,
    startY: o,
    endY: a,
    startX: l,
    endX: u
  };
}
const $1 = zg;
function H1(e) {
  if (!e)
    return;
  const {
    actualRow: t,
    actualColumn: n,
    isMerged: r,
    isMergedMainCell: s,
    startRow: i,
    startColumn: o,
    endRow: a,
    endColumn: l
  } = e;
  let u = t, c = n, h = t, d = n;
  return (r || s) && (u = i, c = o, h = a, d = l), {
    startRow: u,
    startColumn: c,
    endRow: h,
    endColumn: d
  };
}
function Vg(e) {
  var n;
  return !e || (((n = e == null ? void 0 : e.v) == null ? void 0 : n.toString()) || "").length === 0 && !e.p;
}
function Fa(e) {
  return Vg(e) && (e == null ? void 0 : e.coverable) !== !1;
}
function Wt(e) {
  if (e) {
    if (e.rgb)
      return new bt(e.rgb).toHexString();
    if (e.th)
      return new mo().setThemeColor(e.th).asThemeColor().asRgbColor().getCssString();
  }
  return null;
}
function Gg(e) {
  return J.isString(e) && e.substring(0, 1) === "=" && e.length > 1;
}
function B1(e) {
  return J.isString(e) && e.length > 0;
}
function j1(e, t = !1) {
  var i;
  let n = "";
  const r = /* @__PURE__ */ new Map([
    [
      "ff",
      () => {
        e.ff && (n += `font-family: ${e.ff}; `);
      }
    ],
    [
      "fs",
      () => {
        if (e.fs) {
          let o = e.fs;
          e.va && (o /= 2), n += `font-size: ${o}pt; `;
        }
      }
    ],
    [
      "it",
      () => {
        e.it && (n += "font-style: italic; ");
      }
    ],
    [
      "bl",
      () => {
        e.bl && (n += "font-weight: bold; ");
      }
    ],
    [
      "ul",
      () => {
        var o;
        (o = e.ul) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} underline`) : n += "text-decoration: underline; ", e.ul.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Wt(e.ul.cl)}; `), e.ul.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.ul.t} `));
      }
    ],
    [
      "st",
      () => {
        var o;
        (o = e.st) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} line-through`) : n += "text-decoration-line: line-through; ", e.st.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Wt(e.st.cl)}; `), e.st.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.st.t} `));
      }
    ],
    [
      "ol",
      () => {
        var o;
        (o = e.ol) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} overline`) : n += "text-decoration-line: overline; ", e.ol.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Wt(e.ol.cl)}; `), e.ol.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.ol.t} `));
      }
    ],
    [
      "bg",
      () => {
        e.bg && (n += `background: ${Wt(e.bg)}; `);
      }
    ],
    [
      "bd",
      () => {
        var o, a, l, u, c, h, d, f, g, _, R, b;
        (o = e.bd) != null && o.b && (n += `border-bottom: ${Hr((a = e.bd) == null ? void 0 : a.b.s)} ${(l = Wt(e.bd.b.cl)) != null ? l : ""}; `), (u = e.bd) != null && u.t && (n += `border-top: ${Hr((c = e.bd) == null ? void 0 : c.t.s)} ${(h = Wt(e.bd.t.cl)) != null ? h : ""}; `), (d = e.bd) != null && d.r && (n += `border-right: ${Hr((f = e.bd) == null ? void 0 : f.r.s)} ${(g = Wt(e.bd.r.cl)) != null ? g : ""}; `), (_ = e.bd) != null && _.l && (n += `border-left: ${Hr((R = e.bd) == null ? void 0 : R.l.s)} ${(b = Wt(e.bd.l.cl)) != null ? b : ""}; `);
      }
    ],
    [
      "cl",
      () => {
        e.cl && (n += `color: ${Wt(e.cl)}; `);
      }
    ],
    [
      "va",
      () => {
        e.va === Zt.SUBSCRIPT ? n += "vertical-align: sub; " : e.va === Zt.SUPERSCRIPT && (n += "vertical-align: super; ");
      }
    ],
    [
      "td",
      () => {
        e.td === ms.LEFT_TO_RIGHT ? n += "direction: ltr; " : e.td === ms.RIGHT_TO_LEFT && (n += "direction: rtl; ");
      }
    ],
    [
      "tr",
      () => {
        var o, a, l;
        e.tr && (n += `--data-rotate: (${(o = e.tr) == null ? void 0 : o.a}deg${(a = e.tr) != null && a.v ? ` ,${(l = e.tr) == null ? void 0 : l.v}` : ""});`);
      }
    ],
    [
      "ht",
      () => {
        e.ht === Ut.LEFT ? n += "text-align: left; " : e.ht === Ut.RIGHT ? n += "text-align: right; " : e.ht === Ut.CENTER ? n += "text-align: center; " : e.ht === Ut.JUSTIFIED && (n += "text-align: justify; ");
      }
    ],
    [
      "vt",
      () => {
        e.vt === xn.BOTTOM ? n += "vertical-align: bottom; " : e.vt === xn.TOP ? n += "vertical-align: top; " : e.vt === xn.MIDDLE && (n += "vertical-align: middle; ");
      }
    ],
    [
      "tb",
      () => {
        e.tb === Bn.CLIP ? n += "white-space: nowrap; overflow-x: hidden; " : e.tb === Bn.WRAP && (n += "white-space: normal;");
      }
    ],
    [
      "pd",
      () => {
        var c, h, d, f, g, _, R, b;
        const o = `${(c = e.pd) == null ? void 0 : c.b}pt`, a = `${(h = e.pd) == null ? void 0 : h.t}pt`, l = `${(d = e.pd) == null ? void 0 : d.l}pt`, u = `${(f = e.pd) == null ? void 0 : f.r}pt`;
        (g = e.pd) != null && g.b && (n += `padding-bottom: ${o}; `), (_ = e.pd) != null && _.t && (n += `padding-top: ${a}; `), (R = e.pd) != null && R.l && (n += `padding-left: ${l}; `), (b = e.pd) != null && b.r && (n += `padding-right: ${u}; `);
      }
    ]
  ]), s = ["bd", "tr", "tb"];
  for (const o in e)
    t && s.includes(o) || (i = r.get(o)) == null || i();
  return n;
}
function Hr(e) {
  let t = "";
  return e === Le.NONE ? t = "none" : e === Le.THIN ? t = "0.5pt solid" : e === Le.HAIR ? t = "0.5pt double" : e === Le.DOTTED ? t = "0.5pt dotted" : e === Le.DASHED || e === Le.DASH_DOT ? t = "0.5pt dashed" : e === Le.DASH_DOT_DOT ? t = "0.5pt dotted" : e === Le.DOUBLE ? t = "0.5pt double" : e === Le.MEDIUM ? t = "1pt solid" : e === Le.MEDIUM_DASHED || e === Le.MEDIUM_DASH_DOT ? t = "1pt dashed" : e === Le.MEDIUM_DASH_DOT_DOT ? t = "1pt dotted" : e === Le.SLANT_DASH_DOT ? t = "0.5pt dashed" : e === Le.THICK && (t = "1.5pt solid"), t;
}
function W1(e) {
  let t = 0;
  if (e = e.trim(), e === "none")
    t = Le.NONE;
  else if (e === "0.5pt solid")
    t = Le.THIN;
  else if (e === "0.5pt double")
    t = Le.HAIR;
  else if (e === "0.5pt dotted")
    t = Le.DOTTED;
  else if (e === "0.5pt dashed")
    t = Le.DASHED;
  else if (e === "1pt solid")
    t = Le.MEDIUM;
  else if (e === "1pt dashed")
    t = Le.MEDIUM_DASHED;
  else if (e === "1pt dotted")
    t = Le.MEDIUM_DASH_DOT_DOT;
  else if (e === "1.5pt solid")
    t = Le.THICK;
  else if (!e.includes("none"))
    t = Le.THIN;
  else
    return Le.NONE;
  return t;
}
function Y1(e, t) {
  let n = e.body;
  if (t) {
    const { headers: r, footers: s } = e;
    r != null && r[t] ? n = r[t].body : s != null && s[t] && (n = s[t].body);
  }
  return n;
}
function z1(e, t) {
  const { startRow: n, endRow: r, startColumn: s, endColumn: i, rangeType: o } = e;
  if (n < 0 || s < 0 || r < 0 || i < 0 || !(Number.isNaN(n) && Number.isNaN(r)) && o === ge.COLUMN || !(Number.isNaN(s) && Number.isNaN(i)) && o === ge.ROW || o !== ge.ROW && o !== ge.COLUMN && (Number.isNaN(s) || Number.isNaN(n) || Number.isNaN(i) || Number.isNaN(r)))
    return !1;
  if (t) {
    const a = t.getRowCount(), l = t.getColumnCount();
    if (r >= a || i >= l)
      return !1;
  }
  return !0;
}
function V1(e, t) {
  return { startRow: e, endRow: e, startColumn: t, endColumn: t };
}
function $a(e) {
  return Gg(e) ? {
    f: e,
    v: null,
    p: null
  } : Hg(e) ? {
    v: e,
    p: null,
    f: null
  } : ($g(e), e);
}
function G1(e, t) {
  const n = new pt(), { startRow: r, startColumn: s, endRow: i, endColumn: o } = t;
  if (J.isArray(e))
    for (let a = 0; a <= i - r; a++)
      for (let l = 0; l <= o - s; l++)
        n.setValue(a + r, l + s, $a(e[a][l]));
  else
    new pt(e).forValue((l, u, c) => {
      n.setValue(l, u, $a(c));
    });
  return n.getMatrix();
}
function mu(e, t) {
  return Object.prototype.toString.call(e) === Object.prototype.toString.call(t) ? Object.prototype.toString.call(e) === "[object Object]" || Object.prototype.toString.call(e) === "[object Array]" ? Object.keys(e).length !== Object.keys(t).length ? !1 : Object.keys(e).every((n) => mu(e[n], t[n])) : e === t : !1;
}
function Kg(e, t) {
  const n = e.ts || {}, r = t.ts || {};
  return e.sId !== t.sId ? !1 : mu(n, r);
}
function K1(e, t) {
  return t.some((n) => e.indexOf(n) > -1);
}
var es = { exports: {} }, Xg = es.exports, Ha;
function qg() {
  return Ha || (Ha = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(Xg, (function() {
      var n = 1e3, r = 6e4, s = 36e5, i = "millisecond", o = "second", a = "minute", l = "hour", u = "day", c = "week", h = "month", d = "quarter", f = "year", g = "date", _ = "Invalid Date", R = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, H = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(T) {
        var A = ["th", "st", "nd", "rd"], O = T % 100;
        return "[" + T + (A[(O - 20) % 10] || A[O] || A[0]) + "]";
      } }, P = function(T, A, O) {
        var N = String(T);
        return !N || N.length >= A ? T : "" + Array(A + 1 - N.length).join(O) + T;
      }, W = { s: P, z: function(T) {
        var A = -T.utcOffset(), O = Math.abs(A), N = Math.floor(O / 60), M = O % 60;
        return (A <= 0 ? "+" : "-") + P(N, 2, "0") + ":" + P(M, 2, "0");
      }, m: function T(A, O) {
        if (A.date() < O.date()) return -T(O, A);
        var N = 12 * (O.year() - A.year()) + (O.month() - A.month()), M = A.clone().add(N, h), L = O - M < 0, k = A.clone().add(N + (L ? -1 : 1), h);
        return +(-(N + (O - M) / (L ? M - k : k - M)) || 0);
      }, a: function(T) {
        return T < 0 ? Math.ceil(T) || 0 : Math.floor(T);
      }, p: function(T) {
        return { M: h, y: f, w: c, d: u, D: g, h: l, m: a, s: o, ms: i, Q: d }[T] || String(T || "").toLowerCase().replace(/s$/, "");
      }, u: function(T) {
        return T === void 0;
      } }, w = "en", C = {};
      C[w] = H;
      var v = "$isDayjsObject", y = function(T) {
        return T instanceof D || !(!T || !T[v]);
      }, F = function T(A, O, N) {
        var M;
        if (!A) return w;
        if (typeof A == "string") {
          var L = A.toLowerCase();
          C[L] && (M = L), O && (C[L] = O, M = L);
          var k = A.split("-");
          if (!M && k.length > 1) return T(k[0]);
        } else {
          var q = A.name;
          C[q] = A, M = q;
        }
        return !N && M && (w = M), M || !N && w;
      }, $ = function(T, A) {
        if (y(T)) return T.clone();
        var O = typeof A == "object" ? A : {};
        return O.date = T, O.args = arguments, new D(O);
      }, m = W;
      m.l = F, m.i = y, m.w = function(T, A) {
        return $(T, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
      };
      var D = (function() {
        function T(O) {
          this.$L = F(O.locale, null, !0), this.parse(O), this.$x = this.$x || O.x || {}, this[v] = !0;
        }
        var A = T.prototype;
        return A.parse = function(O) {
          this.$d = (function(N) {
            var M = N.date, L = N.utc;
            if (M === null) return /* @__PURE__ */ new Date(NaN);
            if (m.u(M)) return /* @__PURE__ */ new Date();
            if (M instanceof Date) return new Date(M);
            if (typeof M == "string" && !/Z$/i.test(M)) {
              var k = M.match(R);
              if (k) {
                var q = k[2] - 1 || 0, V = (k[7] || "0").substring(0, 3);
                return L ? new Date(Date.UTC(k[1], q, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, V)) : new Date(k[1], q, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, V);
              }
            }
            return new Date(M);
          })(O), this.init();
        }, A.init = function() {
          var O = this.$d;
          this.$y = O.getFullYear(), this.$M = O.getMonth(), this.$D = O.getDate(), this.$W = O.getDay(), this.$H = O.getHours(), this.$m = O.getMinutes(), this.$s = O.getSeconds(), this.$ms = O.getMilliseconds();
        }, A.$utils = function() {
          return m;
        }, A.isValid = function() {
          return this.$d.toString() !== _;
        }, A.isSame = function(O, N) {
          var M = $(O);
          return this.startOf(N) <= M && M <= this.endOf(N);
        }, A.isAfter = function(O, N) {
          return $(O) < this.startOf(N);
        }, A.isBefore = function(O, N) {
          return this.endOf(N) < $(O);
        }, A.$g = function(O, N, M) {
          return m.u(O) ? this[N] : this.set(M, O);
        }, A.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, A.valueOf = function() {
          return this.$d.getTime();
        }, A.startOf = function(O, N) {
          var M = this, L = !!m.u(N) || N, k = m.p(O), q = function(B, j) {
            var Q = m.w(M.$u ? Date.UTC(M.$y, j, B) : new Date(M.$y, j, B), M);
            return L ? Q : Q.endOf(u);
          }, V = function(B, j) {
            return m.w(M.toDate()[B].apply(M.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(j)), M);
          }, oe = this.$W, le = this.$M, I = this.$D, x = "set" + (this.$u ? "UTC" : "");
          switch (k) {
            case f:
              return L ? q(1, 0) : q(31, 11);
            case h:
              return L ? q(1, le) : q(0, le + 1);
            case c:
              var Y = this.$locale().weekStart || 0, z = (oe < Y ? oe + 7 : oe) - Y;
              return q(L ? I - z : I + (6 - z), le);
            case u:
            case g:
              return V(x + "Hours", 0);
            case l:
              return V(x + "Minutes", 1);
            case a:
              return V(x + "Seconds", 2);
            case o:
              return V(x + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, A.endOf = function(O) {
          return this.startOf(O, !1);
        }, A.$set = function(O, N) {
          var M, L = m.p(O), k = "set" + (this.$u ? "UTC" : ""), q = (M = {}, M[u] = k + "Date", M[g] = k + "Date", M[h] = k + "Month", M[f] = k + "FullYear", M[l] = k + "Hours", M[a] = k + "Minutes", M[o] = k + "Seconds", M[i] = k + "Milliseconds", M)[L], V = L === u ? this.$D + (N - this.$W) : N;
          if (L === h || L === f) {
            var oe = this.clone().set(g, 1);
            oe.$d[q](V), oe.init(), this.$d = oe.set(g, Math.min(this.$D, oe.daysInMonth())).$d;
          } else q && this.$d[q](V);
          return this.init(), this;
        }, A.set = function(O, N) {
          return this.clone().$set(O, N);
        }, A.get = function(O) {
          return this[m.p(O)]();
        }, A.add = function(O, N) {
          var M, L = this;
          O = Number(O);
          var k = m.p(N), q = function(le) {
            var I = $(L);
            return m.w(I.date(I.date() + Math.round(le * O)), L);
          };
          if (k === h) return this.set(h, this.$M + O);
          if (k === f) return this.set(f, this.$y + O);
          if (k === u) return q(1);
          if (k === c) return q(7);
          var V = (M = {}, M[a] = r, M[l] = s, M[o] = n, M)[k] || 1, oe = this.$d.getTime() + O * V;
          return m.w(oe, this);
        }, A.subtract = function(O, N) {
          return this.add(-1 * O, N);
        }, A.format = function(O) {
          var N = this, M = this.$locale();
          if (!this.isValid()) return M.invalidDate || _;
          var L = O || "YYYY-MM-DDTHH:mm:ssZ", k = m.z(this), q = this.$H, V = this.$m, oe = this.$M, le = M.weekdays, I = M.months, x = M.meridiem, Y = function(j, Q, ee, U) {
            return j && (j[Q] || j(N, L)) || ee[Q].slice(0, U);
          }, z = function(j) {
            return m.s(q % 12 || 12, j, "0");
          }, B = x || function(j, Q, ee) {
            var U = j < 12 ? "AM" : "PM";
            return ee ? U.toLowerCase() : U;
          };
          return L.replace(b, (function(j, Q) {
            return Q || (function(ee) {
              switch (ee) {
                case "YY":
                  return String(N.$y).slice(-2);
                case "YYYY":
                  return m.s(N.$y, 4, "0");
                case "M":
                  return oe + 1;
                case "MM":
                  return m.s(oe + 1, 2, "0");
                case "MMM":
                  return Y(M.monthsShort, oe, I, 3);
                case "MMMM":
                  return Y(I, oe);
                case "D":
                  return N.$D;
                case "DD":
                  return m.s(N.$D, 2, "0");
                case "d":
                  return String(N.$W);
                case "dd":
                  return Y(M.weekdaysMin, N.$W, le, 2);
                case "ddd":
                  return Y(M.weekdaysShort, N.$W, le, 3);
                case "dddd":
                  return le[N.$W];
                case "H":
                  return String(q);
                case "HH":
                  return m.s(q, 2, "0");
                case "h":
                  return z(1);
                case "hh":
                  return z(2);
                case "a":
                  return B(q, V, !0);
                case "A":
                  return B(q, V, !1);
                case "m":
                  return String(V);
                case "mm":
                  return m.s(V, 2, "0");
                case "s":
                  return String(N.$s);
                case "ss":
                  return m.s(N.$s, 2, "0");
                case "SSS":
                  return m.s(N.$ms, 3, "0");
                case "Z":
                  return k;
              }
              return null;
            })(j) || k.replace(":", "");
          }));
        }, A.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, A.diff = function(O, N, M) {
          var L, k = this, q = m.p(N), V = $(O), oe = (V.utcOffset() - this.utcOffset()) * r, le = this - V, I = function() {
            return m.m(k, V);
          };
          switch (q) {
            case f:
              L = I() / 12;
              break;
            case h:
              L = I();
              break;
            case d:
              L = I() / 3;
              break;
            case c:
              L = (le - oe) / 6048e5;
              break;
            case u:
              L = (le - oe) / 864e5;
              break;
            case l:
              L = le / s;
              break;
            case a:
              L = le / r;
              break;
            case o:
              L = le / n;
              break;
            default:
              L = le;
          }
          return M ? L : m.a(L);
        }, A.daysInMonth = function() {
          return this.endOf(h).$D;
        }, A.$locale = function() {
          return C[this.$L];
        }, A.locale = function(O, N) {
          if (!O) return this.$L;
          var M = this.clone(), L = F(O, N, !0);
          return L && (M.$L = L), M;
        }, A.clone = function() {
          return m.w(this.$d, this);
        }, A.toDate = function() {
          return new Date(this.valueOf());
        }, A.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, A.toISOString = function() {
          return this.$d.toISOString();
        }, A.toString = function() {
          return this.$d.toUTCString();
        }, T;
      })(), S = D.prototype;
      return $.prototype = S, [["$ms", i], ["$s", o], ["$m", a], ["$H", l], ["$W", u], ["$M", h], ["$y", f], ["$D", g]].forEach((function(T) {
        S[T[1]] = function(A) {
          return this.$g(A, T[0], T[1]);
        };
      })), $.extend = function(T, A) {
        return T.$i || (T(A, D, $), T.$i = !0), $;
      }, $.locale = F, $.isDayjs = y, $.unix = function(T) {
        return $(1e3 * T);
      }, $.en = C[w], $.Ls = C, $.p = {}, $;
    }));
  })(es)), es.exports;
}
var Zg = qg();
const tn = /* @__PURE__ */ Rt(Zg);
var ts = { exports: {} }, Jg = ts.exports, Ba;
function Qg() {
  return Ba || (Ba = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(Jg, (function() {
      return function(n, r) {
        var s = r.prototype, i = s.format;
        s.format = function(o) {
          var a = this, l = this.$locale();
          if (!this.isValid()) return i.bind(this)(o);
          var u = this.$utils(), c = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(h) {
            switch (h) {
              case "Q":
                return Math.ceil((a.$M + 1) / 3);
              case "Do":
                return l.ordinal(a.$D);
              case "gggg":
                return a.weekYear();
              case "GGGG":
                return a.isoWeekYear();
              case "wo":
                return l.ordinal(a.week(), "W");
              case "w":
              case "ww":
                return u.s(a.week(), h === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return u.s(a.isoWeek(), h === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return u.s(String(a.$H === 0 ? 24 : a.$H), h === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(a.$d.getTime() / 1e3);
              case "x":
                return a.$d.getTime();
              case "z":
                return "[" + a.offsetName() + "]";
              case "zzz":
                return "[" + a.offsetName("long") + "]";
              default:
                return h;
            }
          }));
          return i.bind(this)(c);
        };
      };
    }));
  })(ts)), ts.exports;
}
var e_ = Qg();
const t_ = /* @__PURE__ */ Rt(e_);
var ns = { exports: {} }, n_ = ns.exports, ja;
function r_() {
  return ja || (ja = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(n_, (function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, s = /\d/, i = /\d\d/, o = /\d\d?/, a = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(R) {
        return (R = +R) + (R > 68 ? 1900 : 2e3);
      }, c = function(R) {
        return function(b) {
          this[R] = +b;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(R) {
        (this.zone || (this.zone = {})).offset = (function(b) {
          if (!b || b === "Z") return 0;
          var H = b.match(/([+-]|\d\d)/g), P = 60 * H[1] + (+H[2] || 0);
          return P === 0 ? 0 : H[0] === "+" ? -P : P;
        })(R);
      }], d = function(R) {
        var b = l[R];
        return b && (b.indexOf ? b : b.s.concat(b.f));
      }, f = function(R, b) {
        var H, P = l.meridiem;
        if (P) {
          for (var W = 1; W <= 24; W += 1) if (R.indexOf(P(W, 0, b)) > -1) {
            H = W > 12;
            break;
          }
        } else H = R === (b ? "pm" : "PM");
        return H;
      }, g = { A: [a, function(R) {
        this.afternoon = f(R, !1);
      }], a: [a, function(R) {
        this.afternoon = f(R, !0);
      }], Q: [s, function(R) {
        this.month = 3 * (R - 1) + 1;
      }], S: [s, function(R) {
        this.milliseconds = 100 * +R;
      }], SS: [i, function(R) {
        this.milliseconds = 10 * +R;
      }], SSS: [/\d{3}/, function(R) {
        this.milliseconds = +R;
      }], s: [o, c("seconds")], ss: [o, c("seconds")], m: [o, c("minutes")], mm: [o, c("minutes")], H: [o, c("hours")], h: [o, c("hours")], HH: [o, c("hours")], hh: [o, c("hours")], D: [o, c("day")], DD: [i, c("day")], Do: [a, function(R) {
        var b = l.ordinal, H = R.match(/\d+/);
        if (this.day = H[0], b) for (var P = 1; P <= 31; P += 1) b(P).replace(/\[|\]/g, "") === R && (this.day = P);
      }], w: [o, c("week")], ww: [i, c("week")], M: [o, c("month")], MM: [i, c("month")], MMM: [a, function(R) {
        var b = d("months"), H = (d("monthsShort") || b.map((function(P) {
          return P.slice(0, 3);
        }))).indexOf(R) + 1;
        if (H < 1) throw new Error();
        this.month = H % 12 || H;
      }], MMMM: [a, function(R) {
        var b = d("months").indexOf(R) + 1;
        if (b < 1) throw new Error();
        this.month = b % 12 || b;
      }], Y: [/[+-]?\d+/, c("year")], YY: [i, function(R) {
        this.year = u(R);
      }], YYYY: [/\d{4}/, c("year")], Z: h, ZZ: h };
      function _(R) {
        var b, H;
        b = R, H = l && l.formats;
        for (var P = (R = b.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function($, m, D) {
          var S = D && D.toUpperCase();
          return m || H[D] || n[D] || H[S].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(T, A, O) {
            return A || O.slice(1);
          }));
        }))).match(r), W = P.length, w = 0; w < W; w += 1) {
          var C = P[w], v = g[C], y = v && v[0], F = v && v[1];
          P[w] = F ? { regex: y, parser: F } : C.replace(/^\[|\]$/g, "");
        }
        return function($) {
          for (var m = {}, D = 0, S = 0; D < W; D += 1) {
            var T = P[D];
            if (typeof T == "string") S += T.length;
            else {
              var A = T.regex, O = T.parser, N = $.slice(S), M = A.exec(N)[0];
              O.call(m, M), $ = $.replace(M, "");
            }
          }
          return (function(L) {
            var k = L.afternoon;
            if (k !== void 0) {
              var q = L.hours;
              k ? q < 12 && (L.hours += 12) : q === 12 && (L.hours = 0), delete L.afternoon;
            }
          })(m), m;
        };
      }
      return function(R, b, H) {
        H.p.customParseFormat = !0, R && R.parseTwoDigitYear && (u = R.parseTwoDigitYear);
        var P = b.prototype, W = P.parse;
        P.parse = function(w) {
          var C = w.date, v = w.utc, y = w.args;
          this.$u = v;
          var F = y[1];
          if (typeof F == "string") {
            var $ = y[2] === !0, m = y[3] === !0, D = $ || m, S = y[2];
            m && (S = y[2]), l = this.$locale(), !$ && S && (l = H.Ls[S]), this.$d = (function(N, M, L, k) {
              try {
                if (["x", "X"].indexOf(M) > -1) return new Date((M === "X" ? 1e3 : 1) * N);
                var q = _(M)(N), V = q.year, oe = q.month, le = q.day, I = q.hours, x = q.minutes, Y = q.seconds, z = q.milliseconds, B = q.zone, j = q.week, Q = /* @__PURE__ */ new Date(), ee = le || (V || oe ? 1 : Q.getDate()), U = V || Q.getFullYear(), G = 0;
                V && !oe || (G = oe > 0 ? oe - 1 : Q.getMonth());
                var X, ne = I || 0, de = x || 0, _e = Y || 0, K = z || 0;
                return B ? new Date(Date.UTC(U, G, ee, ne, de, _e, K + 60 * B.offset * 1e3)) : L ? new Date(Date.UTC(U, G, ee, ne, de, _e, K)) : (X = new Date(U, G, ee, ne, de, _e, K), j && (X = k(X).week(j).toDate()), X);
              } catch {
                return /* @__PURE__ */ new Date("");
              }
            })(C, F, v, H), this.init(), S && S !== !0 && (this.$L = this.locale(S).$L), D && C != this.format(F) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
          } else if (F instanceof Array) for (var T = F.length, A = 1; A <= T; A += 1) {
            y[1] = F[A - 1];
            var O = H.apply(this, y);
            if (O.isValid()) {
              this.$d = O.$d, this.$L = O.$L, this.init();
              break;
            }
            A === T && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else W.call(this, w);
        };
      };
    }));
  })(ns)), ns.exports;
}
var s_ = r_();
const i_ = /* @__PURE__ */ Rt(s_);
var rs = { exports: {} }, o_ = rs.exports, Wa;
function a_() {
  return Wa || (Wa = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(o_, (function() {
      return function(n, r, s) {
        var i = r.prototype, o = function(h) {
          return h && (h.indexOf ? h : h.s);
        }, a = function(h, d, f, g, _) {
          var R = h.name ? h : h.$locale(), b = o(R[d]), H = o(R[f]), P = b || H.map((function(w) {
            return w.slice(0, g);
          }));
          if (!_) return P;
          var W = R.weekStart;
          return P.map((function(w, C) {
            return P[(C + (W || 0)) % 7];
          }));
        }, l = function() {
          return s.Ls[s.locale()];
        }, u = function(h, d) {
          return h.formats[d] || (function(f) {
            return f.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(g, _, R) {
              return _ || R.slice(1);
            }));
          })(h.formats[d.toUpperCase()]);
        }, c = function() {
          var h = this;
          return { months: function(d) {
            return d ? d.format("MMMM") : a(h, "months");
          }, monthsShort: function(d) {
            return d ? d.format("MMM") : a(h, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return h.$locale().weekStart || 0;
          }, weekdays: function(d) {
            return d ? d.format("dddd") : a(h, "weekdays");
          }, weekdaysMin: function(d) {
            return d ? d.format("dd") : a(h, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(d) {
            return d ? d.format("ddd") : a(h, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(d) {
            return u(h.$locale(), d);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        i.localeData = function() {
          return c.bind(this)();
        }, s.localeData = function() {
          var h = l();
          return { firstDayOfWeek: function() {
            return h.weekStart || 0;
          }, weekdays: function() {
            return s.weekdays();
          }, weekdaysShort: function() {
            return s.weekdaysShort();
          }, weekdaysMin: function() {
            return s.weekdaysMin();
          }, months: function() {
            return s.months();
          }, monthsShort: function() {
            return s.monthsShort();
          }, longDateFormat: function(d) {
            return u(h, d);
          }, meridiem: h.meridiem, ordinal: h.ordinal };
        }, s.months = function() {
          return a(l(), "months");
        }, s.monthsShort = function() {
          return a(l(), "monthsShort", "months", 3);
        }, s.weekdays = function(h) {
          return a(l(), "weekdays", null, null, h);
        }, s.weekdaysShort = function(h) {
          return a(l(), "weekdaysShort", "weekdays", 3, h);
        }, s.weekdaysMin = function(h) {
          return a(l(), "weekdaysMin", "weekdays", 2, h);
        };
      };
    }));
  })(rs)), rs.exports;
}
var l_ = a_();
const u_ = /* @__PURE__ */ Rt(l_);
var ss = { exports: {} }, c_ = ss.exports, Ya;
function h_() {
  return Ya || (Ya = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(c_, (function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(r, s, i) {
        var o = s.prototype, a = o.format;
        i.en.formats = n, o.format = function(l) {
          l === void 0 && (l = "YYYY-MM-DDTHH:mm:ssZ");
          var u = this.$locale().formats, c = (function(h, d) {
            return h.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(f, g, _) {
              var R = _ && _.toUpperCase();
              return g || d[_] || n[_] || d[R].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(b, H, P) {
                return H || P.slice(1);
              }));
            }));
          })(l, u === void 0 ? {} : u);
          return a.call(this, c);
        };
      };
    }));
  })(ss)), ss.exports;
}
var d_ = h_();
const f_ = /* @__PURE__ */ Rt(d_);
var is = { exports: {} }, m_ = is.exports, za;
function g_() {
  return za || (za = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(m_, (function() {
      var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, s = /([+-]|\d\d)/g;
      return function(i, o, a) {
        var l = o.prototype;
        a.utc = function(_) {
          var R = { date: _, utc: !0, args: arguments };
          return new o(R);
        }, l.utc = function(_) {
          var R = a(this.toDate(), { locale: this.$L, utc: !0 });
          return _ ? R.add(this.utcOffset(), n) : R;
        }, l.local = function() {
          return a(this.toDate(), { locale: this.$L, utc: !1 });
        };
        var u = l.parse;
        l.parse = function(_) {
          _.utc && (this.$u = !0), this.$utils().u(_.$offset) || (this.$offset = _.$offset), u.call(this, _);
        };
        var c = l.init;
        l.init = function() {
          if (this.$u) {
            var _ = this.$d;
            this.$y = _.getUTCFullYear(), this.$M = _.getUTCMonth(), this.$D = _.getUTCDate(), this.$W = _.getUTCDay(), this.$H = _.getUTCHours(), this.$m = _.getUTCMinutes(), this.$s = _.getUTCSeconds(), this.$ms = _.getUTCMilliseconds();
          } else c.call(this);
        };
        var h = l.utcOffset;
        l.utcOffset = function(_, R) {
          var b = this.$utils().u;
          if (b(_)) return this.$u ? 0 : b(this.$offset) ? h.call(this) : this.$offset;
          if (typeof _ == "string" && (_ = (function(w) {
            w === void 0 && (w = "");
            var C = w.match(r);
            if (!C) return null;
            var v = ("" + C[0]).match(s) || ["-", 0, 0], y = v[0], F = 60 * +v[1] + +v[2];
            return F === 0 ? 0 : y === "+" ? F : -F;
          })(_), _ === null)) return this;
          var H = Math.abs(_) <= 16 ? 60 * _ : _;
          if (H === 0) return this.utc(R);
          var P = this.clone();
          if (R) return P.$offset = H, P.$u = !1, P;
          var W = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          return (P = this.local().add(H + W, n)).$offset = H, P.$x.$localOffset = W, P;
        };
        var d = l.format;
        l.format = function(_) {
          var R = _ || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return d.call(this, R);
        }, l.valueOf = function() {
          var _ = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * _;
        }, l.isUTC = function() {
          return !!this.$u;
        }, l.toISOString = function() {
          return this.toDate().toISOString();
        }, l.toString = function() {
          return this.toDate().toUTCString();
        };
        var f = l.toDate;
        l.toDate = function(_) {
          return _ === "s" && this.$offset ? a(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : f.call(this);
        };
        var g = l.diff;
        l.diff = function(_, R, b) {
          if (_ && this.$u === _.$u) return g.call(this, _, R, b);
          var H = this.local(), P = a(_).local();
          return g.call(H, P, R, b);
        };
      };
    }));
  })(is)), is.exports;
}
var __ = g_();
const p_ = /* @__PURE__ */ Rt(__);
var os = { exports: {} }, E_ = os.exports, Va;
function C_() {
  return Va || (Va = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(E_, (function() {
      return function(n, r) {
        r.prototype.weekday = function(s) {
          var i = this.$locale().weekStart || 0, o = this.$W, a = (o < i ? o + 7 : o) - i;
          return this.$utils().u(s) ? a : this.subtract(a, "day").add(s, "day");
        };
      };
    }));
  })(os)), os.exports;
}
var R_ = C_();
const I_ = /* @__PURE__ */ Rt(R_);
var as = { exports: {} }, w_ = as.exports, Ga;
function S_() {
  return Ga || (Ga = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(w_, (function() {
      var n = "week", r = "year";
      return function(s, i, o) {
        var a = i.prototype;
        a.week = function(l) {
          if (l === void 0 && (l = null), l !== null) return this.add(7 * (l - this.week()), "day");
          var u = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var c = o(this).startOf(r).add(1, r).date(u), h = o(this).endOf(n);
            if (c.isBefore(h)) return 1;
          }
          var d = o(this).startOf(r).date(u).startOf(n).subtract(1, "millisecond"), f = this.diff(d, n, !0);
          return f < 0 ? o(this).startOf("week").week() : Math.ceil(f);
        }, a.weeks = function(l) {
          return l === void 0 && (l = null), this.week(l);
        };
      };
    }));
  })(as)), as.exports;
}
var O_ = S_();
const v_ = /* @__PURE__ */ Rt(O_);
var ls = { exports: {} }, b_ = ls.exports, Ka;
function A_() {
  return Ka || (Ka = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(b_, (function() {
      return function(n, r) {
        r.prototype.weekYear = function() {
          var s = this.month(), i = this.week(), o = this.year();
          return i === 1 && s === 11 ? o + 1 : s === 0 && i >= 52 ? o - 1 : o;
        };
      };
    }));
  })(ls)), ls.exports;
}
var y_ = A_();
const N_ = /* @__PURE__ */ Rt(y_);
tn.extend(i_);
tn.extend(t_);
tn.extend(I_);
tn.extend(u_);
tn.extend(v_);
tn.extend(N_);
tn.extend(p_);
tn.extend(f_);
function go(e, t, n, r) {
  if (e > t)
    throw new Error("a1 should be less than a2");
  if (n > r)
    throw new Error("b1 should be less than b2");
  if (t < n || r < e)
    return [e, t];
  if (n <= e && r >= t)
    return [];
  const s = r - n + 1;
  return e < n && t > r ? [e, t - s] : n <= e && r < t ? [r + 1 - s, t - s] : n > e && r >= t ? [e, n - 1] : [e, t];
}
function X1(e) {
  if (e == null)
    return !1;
  const t = e.bullet;
  return (t == null ? void 0 : t.listId) != null;
}
function q1(e) {
  if (e == null)
    return !1;
  const t = e.paragraphStyle;
  return T_(t);
}
function T_(e) {
  var t;
  return !(e == null || (e.indentStart == null || e.indentStart.v === 0) && e.hanging == null || ((t = e.hanging) == null ? void 0 : t.v) === 0);
}
function M_(e, t, n) {
  return e.slice(0, t) + n + e.slice(t);
}
function L_(e, t, n) {
  return t > n ? e : e.slice(0, t) + e.slice(n);
}
function Z1(e) {
  if (e == null || typeof e == "boolean")
    return !1;
  if (typeof e == "number")
    return !isNaN(e);
  if (typeof e == "string") {
    const t = e.trim();
    return t === "" ? !1 : !isNaN(Number(t));
  }
  return !1;
}
function J1(e) {
  let t = 0;
  for (let n = 0; n < e.length; n++)
    t = e.charCodeAt(n) + (t << 6) + (t << 16) - t;
  return t >>> 0;
}
function Q1(...e) {
  let t;
  return e.length === 1 && Array.isArray(e[0]) ? t = e[0] : t = e, oo({}, ...t);
}
const Te = Symbol("newer"), Xe = Symbol("older");
class x_ {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: !1, value: t.key }) : { done: !0, value: void 0 };
  }
}
class D_ {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: !1, value: t.value }) : { done: !0, value: void 0 };
  }
}
class U_ {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: !1, value: [t.key, t.value] }) : { done: !0, value: void 0 };
  }
}
var Tl, Ml;
Ml = Te, Tl = Xe;
class Xa {
  constructor(t, n) {
    p(this, "key");
    p(this, "value");
    p(this, Ml);
    p(this, Tl);
    this.key = t, this.value = n, this[Te] = void 0, this[Xe] = void 0;
  }
  toJSON() {
    return {
      key: this.key,
      value: this.value
    };
  }
}
class gs {
  constructor(...t) {
    p(this, "_keymap");
    p(this, "size", 0);
    p(this, "limit");
    p(this, "oldest");
    p(this, "newest");
    p(this, "_onShiftListeners", []);
    if (Br.hasLength(t, 1)) {
      if (Br.isNumber(t[0])) {
        const n = t[0];
        this._initialize(n, void 0);
        return;
      }
      if (Br.isIterable(t[0])) {
        const n = t[0];
        this._initialize(0, n);
        return;
      }
      return;
    }
    if (Br.hasLength(t, 2)) {
      const n = t[0], r = t[1];
      this._initialize(n, r);
    }
  }
  onShift(t) {
    if (this._onShiftListeners.indexOf(t) === -1)
      return this._onShiftListeners.push(t), We(() => Os(this._onShiftListeners, t));
    throw new Error("[LRUMap]: the listener has been registered!");
  }
  _initialize(t, n) {
    this.oldest = void 0, this.newest = void 0, this.size = 0, this.limit = t, this._keymap = /* @__PURE__ */ new Map(), n && (this.assign(n), t < 1 && (this.limit = this.size));
  }
  _markEntryAsUsed(t) {
    t !== this.newest && (t[Te] && (t === this.oldest && (this.oldest = t[Te]), t[Te][Xe] = t[Xe]), t[Xe] && (t[Xe][Te] = t[Te]), t[Te] = void 0, t[Xe] = this.newest, this.newest && (this.newest[Te] = t), this.newest = t);
  }
  assign(t) {
    let n, r = this.limit || Number.MAX_VALUE;
    this._keymap.clear();
    const s = t[Symbol.iterator]();
    for (let i = s.next(); !i.done; i = s.next()) {
      const o = new Xa(i.value[0], i.value[1]);
      if (this._keymap.set(o.key, o), n ? (n[Te] = o, o[Xe] = n) : this.oldest = o, n = o, r-- === 0)
        throw new Error("overflow");
    }
    this.newest = n, this.size = this._keymap.size;
  }
  set(t, n) {
    let r = this._keymap.get(t);
    return r ? (r.value = n, this._markEntryAsUsed(r), this) : (this._keymap.set(t, r = new Xa(t, n)), this.newest ? (this.newest[Te] = r, r[Xe] = this.newest) : this.oldest = r, this.newest = r, ++this.size, this.size > this.limit && this.shift(), this);
  }
  shift() {
    const t = this.oldest;
    if (t)
      return this.oldest && this.oldest[Te] ? (this.oldest = this.oldest[Te], this.oldest[Xe] = void 0) : (this.oldest = void 0, this.newest = void 0), t[Te] = t[Xe] = void 0, this._keymap.delete(t.key), --this.size, this._onShiftListeners.forEach((n) => n(t)), [t.key, t.value];
  }
  get(t) {
    const n = this._keymap.get(t);
    if (n)
      return this._markEntryAsUsed(n), n.value;
  }
  has(t) {
    return this._keymap.has(t);
  }
  find(t) {
    const n = this._keymap.get(t);
    return n ? n.value : void 0;
  }
  delete(t) {
    const n = this._keymap.get(t);
    if (n)
      return this._keymap.delete(n.key), n[Te] && n[Xe] ? (n[Xe][Te] = n[Te], n[Te][Xe] = n[Xe]) : n[Te] ? (n[Te][Xe] = void 0, this.oldest = n[Te]) : n[Xe] ? (n[Xe][Te] = void 0, this.newest = n[Xe]) : this.oldest = this.newest = void 0, this.size--, n.value;
  }
  clear() {
    this.oldest = void 0, this.newest = void 0, this.size = 0, this._keymap.clear();
  }
  keys() {
    return new x_(this.oldest);
  }
  values() {
    return new D_(this.oldest);
  }
  entries() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new U_(this.oldest);
  }
  forEach(t, n) {
    typeof n != "object" && (n = this);
    let r = this.oldest;
    for (; r; )
      t.call(n, r.value, r.key, this), r = r[Te];
  }
  toJSON() {
    const t = new Array(this.size);
    let n = 0, r = this.oldest;
    for (; r; )
      t[n++] = { key: r.key, value: r.value }, r = r[Te];
    return t;
  }
  toString() {
    let t = "", n = this.oldest;
    for (; n; )
      t += `${String(n.key)}:${n.value}`, n = n[Te], n && (t += " < ");
    return t;
  }
}
class Br {
  static hasLength(t, n) {
    return t.length === n;
  }
  static getValueType(t) {
    return Object.prototype.toString.apply(t);
  }
  static isObject(t) {
    return this.getValueType(t) === "[object Object]";
  }
  static isIterable(t) {
    return t[Symbol.iterator] != null;
  }
  static isNumber(t) {
    return this.getValueType(t) === "[object Number]";
  }
}
const ar = 2, lr = 2 ** 2, us = 2 ** 3, ur = 2 ** 4, cr = 2 ** 5, hr = 2 ** 6, yi = 2 ** 7, Ni = 2 ** 8, Ti = 2 ** 9, k_ = 0, P_ = 2958466, F_ = -694324, $_ = 35830291, H_ = -1, qa = 1, Un = 6, _o = "general", po = "hash", kn = "zero", Eo = "qmark", Co = "slash", wr = "group", _s = "scale", Ro = "comma", Io = "break", xs = "text", wo = "plus", So = "minus", ps = "point", Oo = "space", vo = "percent", Ds = "digit", bo = "calendar", Sr = "error", Ao = "datetime", yo = "duration", No = "condition", To = "dbnum", Mo = "natnum", Lo = "locale", xo = "color", gu = "modifier", Do = "ampm", Uo = "escaped", ko = "string", Po = "skip", Fo = "exp", $o = "fill", Ho = "paren", Us = "char", B_ = [
  "#000",
  "#FFF",
  "#F00",
  "#0F0",
  "#00F",
  "#FF0",
  "#F0F",
  "#0FF",
  "#000",
  "#FFF",
  "#F00",
  "#0F0",
  "#00F",
  "#FF0",
  "#F0F",
  "#0FF",
  "#800",
  "#080",
  "#008",
  "#880",
  "#808",
  "#088",
  "#CCC",
  "#888",
  "#99F",
  "#936",
  "#FFC",
  "#CFF",
  "#606",
  "#F88",
  "#06C",
  "#CCF",
  "#008",
  "#F0F",
  "#FF0",
  "#0FF",
  "#808",
  "#800",
  "#088",
  "#00F",
  "#0CF",
  "#CFF",
  "#CFC",
  "#FF9",
  "#9CF",
  "#F9C",
  "#C9F",
  "#FC9",
  "#36F",
  "#3CC",
  "#9C0",
  "#FC0"
], Mi = [
  "",
  "$",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], Li = new RegExp("[" + Mi.join("") + "]"), ni = Object.freeze({
  1078: "af",
  // Afrikaans
  1052: "sq",
  // Albanian
  1118: "am",
  // Amharic
  5121: "ar_DZ",
  // Arabic - Algeria
  15361: "ar_BH",
  // Arabic - Bahrain
  3073: "ar_EG",
  // Arabic - Egypt
  2049: "ar_IQ",
  // Arabic - Iraq
  11265: "ar_JO",
  // Arabic - Jordan
  13313: "ar_KW",
  // Arabic - Kuwait
  12289: "ar_LB",
  // Arabic - Lebanon
  4097: "ar_LY",
  // Arabic - Libya
  6145: "ar_MA",
  // Arabic - Morocco
  8193: "ar_OM",
  // Arabic - Oman
  16385: "ar_QA",
  // Arabic - Qatar
  1025: "ar_SA",
  // Arabic - Saudi Arabia
  10241: "ar_SY",
  // Arabic - Syria
  7169: "ar_TN",
  // Arabic - Tunisia
  14337: "ar_AE",
  // Arabic - United Arab Emirates
  9217: "ar_YE",
  // Arabic - Yemen
  1067: "hy",
  // Armenian
  1101: "as",
  // Assamese
  2092: "az_AZ",
  // Azeri - Cyrillic
  1068: "az_AZ",
  // Azeri - Latin
  1069: "eu",
  // Basque
  1059: "be",
  // Belarusian
  2117: "bn",
  // Bengali - Bangladesh
  1093: "bn_IN",
  // Bengali - India
  5146: "bs",
  // Bosnian
  1026: "bg",
  // Bulgarian
  1109: "my",
  // Burmese
  1027: "ca",
  // Catalan
  2052: "zh_CN",
  // Chinese - China
  3076: "zh_HK",
  // Chinese - Hong Kong SAR
  5124: "zh_MO",
  // Chinese - Macau SAR
  4100: "zh_SG",
  // Chinese - Singapore
  1028: "zh_TW",
  // Chinese - Taiwan
  1050: "hr",
  // Croatian
  1029: "cs",
  // Czech
  1030: "da",
  // Danish
  1125: "dv",
  // Divehi; Dhivehi; Maldivian
  2067: "nl_BE",
  // Dutch - Belgium
  1043: "nl_NL",
  // Dutch - Netherlands
  1126: "bin",
  // Edo
  3081: "en_AU",
  // English - Australia
  10249: "en_BZ",
  // English - Belize
  4105: "en_CA",
  // English - Canada
  9225: "en_CB",
  // English - Caribbean
  2057: "en_GB",
  // English - Great Britain
  16393: "en_IN",
  // English - India
  6153: "en_IE",
  // English - Ireland
  8201: "en_JM",
  // English - Jamaica
  5129: "en_NZ",
  // English - New Zealand
  13321: "en_PH",
  // English - Phillippines
  7177: "en_ZA",
  // English - Southern Africa
  11273: "en_TT",
  // English - Trinidad
  1033: "en_US",
  // English - United States
  12297: "en_ZW",
  // English - Zimbabwe
  1061: "et",
  // Estonian
  1071: "mk",
  // FYRO Macedonia
  1080: "fo",
  // Faroese
  1065: "fa",
  // Farsi - Persian
  1124: "fil",
  // Filipino
  1035: "fi",
  // Finnish
  2060: "fr_BE",
  // French - Belgium
  11276: "fr_CM",
  // French - Cameroon
  3084: "fr_CA",
  // French - Canada
  9228: "fr_CG",
  // French - Congo
  12300: "fr_CI",
  // French - Cote d'Ivoire
  1036: "fr_FR",
  // French - France
  5132: "fr_LU",
  // French - Luxembourg
  13324: "fr_ML",
  // French - Mali
  6156: "fr_MC",
  // French - Monaco
  14348: "fr_MA",
  // French - Morocco
  10252: "fr_SN",
  // French - Senegal
  4108: "fr_CH",
  // French - Switzerland
  7180: "fr",
  // French - West Indies
  1122: "fy_NL",
  // Frisian - Netherlands
  2108: "gd_IE",
  // Gaelic - Ireland
  1084: "gd",
  // Gaelic - Scotland
  1110: "gl",
  // Galician
  1079: "ka",
  // Georgian
  3079: "de_AT",
  // German - Austria
  1031: "de_DE",
  // German - Germany
  5127: "de_LI",
  // German - Liechtenstein
  4103: "de_LU",
  // German - Luxembourg
  2055: "de_CH",
  // German - Switzerland
  1032: "el",
  // Greek
  1140: "gn",
  // Guarani - Paraguay
  1095: "gu",
  // Gujarati
  1279: "en",
  // HID (Human Interface Device)
  1037: "he",
  // Hebrew
  1081: "hi",
  // Hindi
  1038: "hu",
  // Hungarian
  1039: "is",
  // Icelandic
  1136: "ig_NG",
  // Igbo - Nigeria
  1057: "id",
  // Indonesian
  1040: "it_IT",
  // Italian - Italy
  2064: "it_CH",
  // Italian - Switzerland
  1041: "ja",
  // Japanese
  1099: "kn",
  // Kannada
  1120: "ks",
  // Kashmiri
  1087: "kk",
  // Kazakh
  1107: "km",
  // Khmer
  1111: "kok",
  // Konkani
  1042: "ko",
  // Korean
  1088: "ky",
  // Kyrgyz - Cyrillic
  1108: "lo",
  // Lao
  1142: "la",
  // Latin
  1062: "lv",
  // Latvian
  1063: "lt",
  // Lithuanian
  2110: "ms_BN",
  // Malay - Brunei
  1086: "ms_MY",
  // Malay - Malaysia
  1100: "ml",
  // Malayalam
  1082: "mt",
  // Maltese
  1112: "mni",
  // Manipuri
  1153: "mi",
  // Maori
  1102: "mr",
  // Marathi
  1104: "mn",
  // Mongolian
  2128: "mn",
  // Mongolian
  1121: "ne",
  // Nepali
  1044: "no_NO",
  // Norwegian - Bokml
  2068: "no_NO",
  // Norwegian - Nynorsk
  1096: "or",
  // Oriya
  1045: "pl",
  // Polish
  1046: "pt_BR",
  // Portuguese - Brazil
  2070: "pt_PT",
  // Portuguese - Portugal
  1094: "pa",
  // Punjabi
  1047: "rm",
  // Raeto-Romance
  2072: "ro_MO",
  // Romanian - Moldova
  1048: "ro_RO",
  // Romanian - Romania
  1049: "ru",
  // Russian
  2073: "ru_MO",
  // Russian - Moldova
  1083: "se",
  // Sami Lappish
  1103: "sa",
  // Sanskrit
  3098: "sr_SP",
  // Serbian - Cyrillic
  2074: "sr_SP",
  // Serbian - Latin
  1072: "st",
  // Sesotho (Sutu)
  1074: "tn",
  // Setsuana
  1113: "sd",
  // Sindhi
  1115: "si",
  // Sinhala; Sinhalese
  1051: "sk",
  // Slovak
  1060: "sl",
  // Slovenian
  1143: "so",
  // Somali
  1070: "sb",
  // Sorbian
  11274: "es_AR",
  // Spanish - Argentina
  16394: "es_BO",
  // Spanish - Bolivia
  13322: "es_CL",
  // Spanish - Chile
  9226: "es_CO",
  // Spanish - Colombia
  5130: "es_CR",
  // Spanish - Costa Rica
  7178: "es_DO",
  // Spanish - Dominican Republic
  12298: "es_EC",
  // Spanish - Ecuador
  17418: "es_SV",
  // Spanish - El Salvador
  4106: "es_GT",
  // Spanish - Guatemala
  18442: "es_HN",
  // Spanish - Honduras
  2058: "es_MX",
  // Spanish - Mexico
  19466: "es_NI",
  // Spanish - Nicaragua
  6154: "es_PA",
  // Spanish - Panama
  15370: "es_PY",
  // Spanish - Paraguay
  10250: "es_PE",
  // Spanish - Peru
  20490: "es_PR",
  // Spanish - Puerto Rico
  1034: "es_ES",
  // Spanish - Spain (Traditional)
  14346: "es_UY",
  // Spanish - Uruguay
  8202: "es_VE",
  // Spanish - Venezuela
  1089: "sw",
  // Swahili
  2077: "sv_FI",
  // Swedish - Finland
  1053: "sv_SE",
  // Swedish - Sweden
  1114: "syc",
  // Syriac
  1064: "tg",
  // Tajik
  1097: "ta",
  // Tamil
  1092: "tt",
  // Tatar
  1098: "te",
  // Telugu
  1054: "th",
  // Thai
  1105: "bo",
  // Tibetan
  1073: "ts",
  // Tsonga
  1055: "tr",
  // Turkish
  1090: "tk",
  // Turkmen
  1058: "uk",
  // Ukrainian
  1056: "ur",
  // Urdu
  2115: "uz_UZ",
  // Uzbek - Cyrillic
  1091: "uz_UZ",
  // Uzbek - Latin
  1075: "ve",
  // Venda
  1066: "vi",
  // Vietnamese
  1106: "cy",
  // Welsh
  1076: "xh",
  // Xhosa
  1085: "yi",
  // Yiddish
  1077: "zu"
  // Zulu
}), _u = /^([a-z\d]+)(?:[_-]([a-z\d]+))?(?:\.([a-z\d]+))?(?:@([a-z\d]+))?$/i, Nn = {}, E = (e, t = "") => e.replace(/~/g, t).split(";"), xe = (e, t = 0, n = 0) => (e.mmm || (e.mmm = t < 1 ? e.mmmm.concat() : e.mmmm.map((r) => {
  const s = r.slice(0, t % 10);
  return s + (t < 10 || r === s ? "" : ".");
})), e.ddd || (e.ddd = n < 1 ? e.dddd.concat() : e.dddd.map((r) => {
  const s = r.slice(0, n % 10);
  return s + (n < 10 || r === s ? "" : ".");
})), !e.mmm6 && e.mmmm6 && (e.mmm6 = e.mmmm6), e), j_ = {
  group: "",
  decimal: ".",
  positive: "+",
  negative: "-",
  percent: "%",
  exponent: "E",
  nan: "NaN",
  infinity: "",
  ampm: E("AM;PM"),
  mmmm6: E("Muharram;Safar;Rabi I;Rabi II;Jumada I;Jumada II;Rajab;Shaban;Ramadan;Shawwal;Dhul-Qidah;Dhul-Hijjah"),
  mmm6: E("Muh.;Saf.;Rab. I;Rab. II;Jum. I;Jum. II;Raj.;Sha.;Ram.;Shaw.;Dhul-Q.;Dhul-H."),
  mmmm: E("January;February;March;April;May;June;July;August;September;October;November;December"),
  mmm: E("Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec"),
  dddd: E("Sunday;Monday;Tuesday;Wednesday;Thursday;Friday;Saturday"),
  ddd: E("Sun;Mon;Tue;Wed;Thu;Fri;Sat"),
  bool: E("TRUE;FALSE"),
  preferMDY: !1
};
function Bo(e) {
  const t = _u.exec(e);
  if (!t)
    throw new SyntaxError(`Malformed locale: ${e}`);
  return {
    lang: t[1] + (t[2] ? "_" + t[2] : ""),
    language: t[1],
    territory: t[2] || ""
  };
}
function jo(e) {
  if (typeof e == "number")
    return ni[e & 65535] || null;
  const t = parseInt(e, 16);
  return isFinite(t) && ni[t & 65535] ? ni[t & 65535] || null : _u.test(e) ? e : null;
}
function Kn(e) {
  const t = jo(e);
  let n = null;
  if (t) {
    const r = Bo(t);
    n = Nn[r.lang] || Nn[r.language] || null;
  }
  return n;
}
function xi(e) {
  return Object.assign({}, j_, e);
}
function te(e, t) {
  const n = typeof t == "object" ? t : Bo(t);
  return Nn[n.lang] = xi(e), n.language !== n.lang && !Nn[n.language] && (Nn[n.language] = xi(e)), Nn[n.lang];
}
const Jt = xi({ group: ",", preferMDY: !0 });
Jt.isDefault = !0;
te({
  group: ",",
  ampm: E(";"),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "zh_CN");
const Wo = {
  group: ",",
  ampm: E(";"),
  mmmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
};
te({
  ...Wo,
  nan: "",
  dddd: E("~;~;~;~;~;~;~", "")
}, "zh_TW");
te({
  ...Wo,
  dddd: E("~;~;~;~;~;~;~", "")
}, "zh_HK");
te({
  ...Wo,
  ampm: E(";"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "ja");
te({
  group: ",",
  ampm: E(";"),
  mmmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "ko");
te({
  group: ",",
  ampm: E(";"),
  mmmm: E("~;;~;;~;;~;~;;~;;~", ""),
  mmm: E("..;..;..;..;..;..;..;..;..;..;..;.."),
  dddd: E(";;;;;;"),
  ddd: E(".;.;.;.;.;.;.")
}, "th");
te(xe({
  decimal: ",",
  ampm: E("dop.;odp."),
  mmmm: E("ledna;nora;bezna;dubna;kvtna;ervna;ervence;srpna;z;jna;listopadu;prosince"),
  mmm: E("I;II;III;IV;V;VI;VII;VIII;IX;X;XI;XII"),
  dddd: E("nedle;pondl;ter;steda;tvrtek;ptek;sobota"),
  bool: E("PRAVDA;NEPRAVDA")
}, -1, 2), "cs");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("januar;februar;marts;april;maj;juni;juli;august;september;oktober;november;december"),
  dddd: E("sn~;man~;tirs~;ons~;tors~;fre~;lr~", "dag"),
  bool: E("SAND;FALSK")
}, 13, 13), "da");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("januari;februari;maart;april;mei;juni;juli;augustus;september;oktober;november;december"),
  mmm: E("jan.;feb.;mrt.;apr.;mei;jun.;jul.;aug.;sep.;okt.;nov.;dec."),
  dddd: E("zondag;maandag;dinsdag;woensdag;donderdag;vrijdag;zaterdag"),
  bool: E("WAAR;ONWAAR")
}, -1, 2), "nl");
te({ group: ",", preferMDY: !0 }, "en");
te({ group: ",", preferMDY: !0 }, "en_US");
te({ group: "," }, "en_AU");
te({ group: "," }, "en_CA");
te({ group: "," }, "en_GB");
te({ group: ",", mmm: E("Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sept;Oct;Nov;Dec") }, "en_IE");
te(xe({
  decimal: ",",
  nan: "epluku",
  ampm: E("ap.;ip."),
  mmmm: E("tammi~;helmi~;maalis~;huhti~;touko~;kes~;hein~;elo~;syys~;loka~;marras~;joulu~", "kuuta"),
  mmm: E("tammik.;helmik.;maalisk.;huhtik.;toukok.;kesk.;heink.;elok.;syysk.;lokak.;marrask.;jouluk."),
  dddd: E("sunnun~;maanan~;tiis~;keskiviikkona;tors~;perjan~;lauan~", "taina"),
  bool: E("TOSI;EPTOSI")
}, -1, 2), "fi");
const Yo = xe({
  group: "",
  decimal: ",",
  mmmm: E("janvier;fvrier;mars;avril;mai;juin;juillet;aot;septembre;octobre;novembre;dcembre"),
  mmm: E("janv.;fvr.;mars;avr.;mai;juin;juil.;aot;sept.;oct.;nov.;dc."),
  dddd: E("~manche;lun~;mar~;mercre~;jeu~;vendre~;same~", "di"),
  bool: E("VRAI;FAUX")
}, -1, 13);
te({ ...Yo }, "fr");
te({ ...Yo, mmm: E("janv.;fvr.;mars;avr.;mai;juin;juill.;aot;sept.;oct.;nov.;dc.") }, "fr_CA");
te({ group: "'", decimal: ".", ...Yo }, "fr_CH");
const pu = xe({
  mmmm: E("Januar;Februar;Mrz;April;Mai;Juni;Juli;August;September;Oktober;November;Dezember"),
  mmm: E("Jan.;Feb.;Mrz;Apr.;Mai;Juni;Juli;Aug.;Sept.;Okt.;Nov.;Dez."),
  dddd: E("Sonn~;Mon~;Diens~;Mittwoch;Donners~;Frei~;Sams~", "tag"),
  bool: E("WAHR;FALSCH")
}, -1, 12);
te({ group: ".", decimal: ",", ...pu }, "de");
te({ group: "'", decimal: ".", ...pu }, "de_CH");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E("..;.."),
  mmmm: E("~;~;~;~;;~;~;;~;~;~;~", ""),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, -1, 3), "el");
te({
  decimal: ",",
  ampm: E("de.;du."),
  mmmm: E("janur;februr;mrcius;prilis;mjus;jnius;jlius;augusztus;szeptember;oktber;november;december"),
  mmm: E("jan.;febr.;mrc.;pr.;mj.;jn.;jl.;aug.;szept.;okt.;nov.;dec."),
  dddd: E("vasrnap;htf;kedd;szerda;cstrtk;pntek;szombat"),
  ddd: E("V;H;K;Sze;Cs;P;Szo"),
  bool: E("IGAZ;HAMIS")
}, "hu");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E("f.h.;e.h."),
  mmmm: E("janar;febrar;mars;aprl;ma;jn;jl;gst;september;oktber;nvember;desember"),
  dddd: E("sunnu~;mnu~;riju~;miviku~;fimmtu~;fstu~;laugar~", "dagur")
}, 13, 13), "is");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("Januari;Februari;Maret;April;Mei;Juni;Juli;Agustus;September;Oktober;November;Desember"),
  dddd: E("Minggu;Senin;Selasa;Rabu;Kamis;Jumat;Sabtu")
}, 3, 3), "id");
const Eu = xe({
  mmmm: E("gennaio;febbraio;marzo;aprile;maggio;giugno;luglio;agosto;settembre;ottobre;novembre;dicembre"),
  dddd: E("domenica;luned;marted;mercoled;gioved;venerd;sabato"),
  bool: E("VERO;FALSO")
}, 3, 3);
te({ group: ".", decimal: ",", ...Eu }, "it");
te({ group: "'", decimal: ".", ...Eu }, "it_CH");
const Cu = {
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("januar;februar;mars;april;mai;juni;juli;august;september;oktober;november;desember"),
  mmm: E("jan.;feb.;mar.;apr.;mai;jun.;jul.;aug.;sep.;okt.;nov.;des."),
  dddd: E("sn~;man~;tirs~;ons~;tors~;fre~;lr~", "dag"),
  bool: E("SANN;USANN")
};
te(xe({ ...Cu }, -1, 13), "nb");
te(xe({ ...Cu }, -1, 13), "no");
te(xe({
  decimal: ",",
  mmmm: E("stycznia;lutego;marca;kwietnia;maja;czerwca;lipca;sierpnia;wrzenia;padziernika;listopada;grudnia"),
  dddd: E("niedziela;poniedziaek;wtorek;roda;czwartek;pitek;sobota"),
  ddd: E("niedz.;pon.;wt.;r.;czw.;pt.;sob."),
  bool: E("PRAWDA;FASZ")
}, 3, -1), "pl");
const Ru = {
  group: ".",
  decimal: ",",
  mmmm: E("janeiro;fevereiro;maro;abril;maio;junho;julho;agosto;setembro;outubro;novembro;dezembro"),
  dddd: E("domingo;segunda-feira;tera-feira;quarta-feira;quinta-feira;sexta-feira;sbado"),
  bool: E("VERDADEIRO;FALSO")
};
te(xe(Ru, 13, 13), "pt");
te(xe(Ru, 13, 13), "pt_BR");
te({
  decimal: ",",
  nan: "",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;;.;.;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  mmmm6: E(";;-;-;;--;--;--;--;;;"),
  mmm6: E(".;.;-.;-.;.;. I;. II;. I;. II;.;.;."),
  bool: E(";")
}, "ru");
te(xe({
  decimal: ",",
  mmmm: E("janura;februra;marca;aprla;mja;jna;jla;augusta;septembra;oktbra;novembra;decembra"),
  dddd: E("nedea;pondelok;utorok;streda;tvrtok;piatok;sobota")
}, 3, 2), "sk");
const Ft = {
  group: ".",
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("enero;febrero;marzo;abril;mayo;junio;julio;agosto;septiem~;octu~;noviem~;diciem~", "bre"),
  mmm: E("ene;feb;mar;abr;may;jun;jul;ago;sept;oct;nov;dic"),
  dddd: E("domingo;lunes;martes;mircoles;jueves;viernes;sbado"),
  ddd: E("dom;lun;mar;mi;jue;vie;sb"),
  bool: E("VERDADERO;FALSO")
}, W_ = E("ene;feb;mar;abr;may;jun;jul;ago;sep;oct;nov;dic"), zo = E("ene.;feb.;mar.;abr.;may.;jun.;jul.;ago.;sept.;oct.;nov.;dic.");
te({ ...Ft }, "es");
te({ ...Ft }, "es_AR");
te({ ...Ft }, "es_BO");
te({ ...Ft }, "es_CL");
te({ ...Ft }, "es_CO");
te({ ...Ft }, "es_EC");
te({ ...Ft, mmm: W_, ampm: E("a.m.;p.m.") }, "es_MX");
te({ ...Ft, mmm: zo }, "es_PY");
te({ ...Ft, mmm: zo }, "es_UY");
te({ ...Ft, mmm: zo, mmmm: E("enero;febrero;marzo;abril;mayo;junio;julio;agosto;setiembre;octubre;noviembre;diciembre") }, "es_VE");
te({
  decimal: ",",
  ampm: E("fm;em"),
  mmmm: E("januari;februari;mars;april;maj;juni;juli;augusti;september;oktober;november;december"),
  mmm: E("jan.;feb.;mars;apr.;maj;juni;juli;aug.;sep.;okt.;nov.;dec."),
  dddd: E("sn~;mn~;tis~;ons~;tors~;fre~;lr~", "dag"),
  ddd: E("sn;mn;tis;ons;tors;fre;lr")
}, "sv");
te(xe({
  group: ".",
  decimal: ",",
  ampm: E(";S"),
  mmmm: E("Ocak;ubat;Mart;Nisan;Mays;Haziran;Temmuz;Austos;Eyll;Ekim;Kasm;Aralk"),
  mmm: E("Oca;ub;Mar;Nis;May;Haz;Tem;Au;Eyl;Eki;Kas;Ara"),
  dddd: E("Pazar;Pazartesi;Sal;aramba;Perembe;Cuma;Cumartesi"),
  ddd: E("Paz;Pzt;Sal;ar;Per;Cum;Cmt"),
  bool: E("DORU;YANLI")
}, 3, -1), "tr");
te({
  group: ",",
  ampm: E("yb;yh"),
  mmmm: E("Ionawr;Chwefror;Mawrth;Ebrill;Mai;Mehefin;Gorffennaf;Awst;Medi;Hydref;Tachwedd;Rhagfyr"),
  mmm: E("Ion;Chwef;Maw;Ebr;Mai;Meh;Gorff;Awst;Medi;Hyd;Tach;Rhag"),
  dddd: E("Dydd Sul;Dydd Llun;Dydd Mawrth;Dydd Mercher;Dydd Iau;Dydd Gwener;Dydd Sadwrn"),
  ddd: E("Sul;Llun;Maw;Mer;Iau;Gwen;Sad")
}, "cy");
te({
  group: ".",
  decimal: ",",
  mmmm: E("yanvar;fevral;mart;aprel;may;iyun;iyul;avqust;sentyabr;oktyabr;noyabr;dekabr"),
  mmm: E("yan;fev;mar;apr;may;iyn;iyl;avq;sen;okt;noy;dek"),
  dddd: E("bazar;bazar ertsi;rnb axam;rnb;cm axam;cm;nb"),
  ddd: E("B.;B.e.;.a.;.;C.a.;C.;.")
}, "az");
te(xe({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, 3, -1), "be");
te({
  decimal: ",",
  ampm: E("..;.."),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  bool: E(";")
}, "bg");
te({
  group: ".",
  decimal: ",",
  mmmm: E("de gener;de febrer;de mar;dabril;de maig;de juny;de juliol;dagost;de setembre;doctubre;de novembre;de desembre"),
  mmm: E("de gen.;de febr.;de mar;dabr.;de maig;de juny;de jul.;dag.;de set.;doct.;de nov.;de des."),
  dddd: E("diumenge;dilluns;dimarts;dimecres;dijous;divendres;dissabte"),
  ddd: E("dg.;dl.;dt.;dc.;dj.;dv.;ds."),
  ampm: E("a.m.;p.m.")
}, "ca");
te(xe({
  group: ",",
  decimal: ".",
  mmmm: E("Enero;Pebrero;Marso;Abril;Mayo;Hunyo;Hulyo;Agosto;Setyembre;Oktubre;Nobyembre;Disyembre"),
  dddd: E("Linggo;Lunes;Martes;Miyerkules;Huwebes;Biyernes;Sabado")
}, 3, 3), "fil");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "gu");
te({
  group: ",",
  decimal: ".",
  ampm: E(";"),
  dddd: E("~;~;~;~;~;~;~", " "),
  ddd: E("~;~;~;~;~;~;", " "),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  mmmm6: E(";; ; ;; ; ; ; ;;;"),
  mmm6: E(";; ; ;; ; ; ; ;;;")
}, "he");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("sijenja;veljae;oujka;travnja;svibnja;lipnja;srpnja;kolovoza;rujna;listopada;studenoga;prosinca"),
  mmm: E("sij;velj;ou;tra;svi;lip;srp;kol;ruj;lis;stu;pro"),
  dddd: E("nedjelja;ponedjeljak;utorak;srijeda;etvrtak;petak;subota")
}, -1, 3), "hr");
te({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "hy");
te(xe({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, 3, 3), "ka");
te(xe({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, 13, -1), "kk");
te({
  group: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;"),
  ampm: E(";")
}, "kn");
te({
  decimal: ",",
  mmmm: E("sausio;vasario;kovo;balandio;gegus;birelio;liepos;rugpjio;rugsjo;spalio;lapkriio;gruodio"),
  mmm: E("saus.;vas.;kov.;bal.;geg.;bir.;liep.;rugp.;rugs.;spal.;lapkr.;gruod."),
  dddd: E("sekmadienis;pirmadienis;antradienis;treiadienis;ketvirtadienis;penktadienis;etadienis"),
  ddd: E("sk;pr;an;tr;kt;pn;t"),
  ampm: E("priepiet;popiet")
}, "lt");
te({
  decimal: ",",
  mmmm: E("janvris;februris;marts;aprlis;maijs;jnijs;jlijs;augusts;septembris;oktobris;novembris;decembris"),
  mmm: E("janv.;febr.;marts;apr.;maijs;jn.;jl.;aug.;sept.;okt.;nov.;dec."),
  dddd: E("svtdiena;pirmdiena;otrdiena;trediena;ceturtdiena;piektdiena;sestdiena"),
  ddd: E("svtd.;pirmd.;otrd.;tred.;ceturtd.;piektd.;sestd."),
  ampm: E("priekpusdien;pcpusdien")
}, "lv");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "ml");
te({
  group: ",",
  decimal: ".",
  mmmm: E("~;~;~;~;~;~;~;~;~;~; ~; ~", " "),
  mmm: E("1~;2~;3~;4~;5~;6~;7~;8~;9~;10~;11~;12~", "- "),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("..;..")
}, "mn");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "mr");
te(xe({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ampm: E(";")
}, -1, 0), "my");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("..;..")
}, "pa");
te({
  group: ".",
  decimal: ",",
  mmmm: E("ianuarie;februarie;martie;aprilie;mai;iunie;iulie;august;septem~;octom~;noiem~;decem~", "brie"),
  mmm: E("ian.;feb.;mar.;apr.;mai;iun.;iul.;aug.;sept.;oct.;nov.;dec."),
  dddd: E("duminic;luni;mari;miercuri;joi;vineri;smbt"),
  ddd: E("dum.;lun.;mar.;mie.;joi;vin.;sm."),
  ampm: E("a.m.;p.m.")
}, "ro");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E("januar;februar;marec;april;maj;junij;julij;avgust;september;oktober;november;december"),
  mmm: E("jan.;feb.;mar.;apr.;maj;jun.;jul.;avg.;sep.;okt.;nov.;dec."),
  dddd: E("nedelja;ponedeljek;torek;sreda;etrtek;petek;sobota"),
  ampm: E("dop.;pop.")
}, -1, 13), "sl");
te(xe({
  group: ".",
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, 3, 3), "sr");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;;;;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(".;.;.;.;.;.;")
}, "ta");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "te");
te({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;.;.;.;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E(";")
}, "uk");
te({
  group: ".",
  decimal: ",",
  mmmm: E("~1;~2;~3;~4;~5;~6;~7;~8;~9;~10;~11;~12", "thng "),
  mmm: E("~1;~2;~3;~4;~5;~6;~7;~8;~9;~10;~11;~12", "thg "),
  dddd: E("Ch Nht;Th Hai;Th Ba;Th T;Th Nm;Th Su;Th By"),
  ddd: E("CN;Th 2;Th 3;Th 4;Th 5;Th 6;Th 7"),
  ampm: E("SA;CH")
}, "vi");
te(xe({
  group: "",
  decimal: "",
  ampm: E(";"),
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  mmmm6: E(";; ; ;; ; ; ; ;;;")
}, 0, 0), "ar");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "bn");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("am;pm")
}, "hi");
const Iu = {
  // Overflow error string
  overflow: "######",
  // dateErrorThrow needs to be off! [prev in locale]
  // Should it throw when there is an overflow error?
  dateErrorThrows: !1,
  // Should it emit a number when date has an overflow error? (Sheets does this)
  dateErrorNumber: !0,
  // dateErrorThrow needs to be off!
  // Should it emit a number when bigint has an is an overflow error?
  bigintErrorNumber: !1,
  // Sheets mode (see #3)
  dateSpanLarge: !0,
  // Simulate the Lotus 1-2-3 leap year bug
  leap1900: !0,
  // Emit regular vs. non-breaking spaces
  nbsp: !1,
  // Robust/throw mode
  throws: !0,
  // What is emitted when robust mode fails to parse (###### currently)
  invalid: "######",
  // Locale
  locale: "",
  // Don't adjust dates to UTC when converting them to serial time
  ignoreTimezone: !1,
  // Integer digit grouping
  grouping: [3, 3],
  // resolve indexed colors to hex
  indexColors: !0,
  // Skip-next signifier character
  skipChar: "",
  // Repear-next signifier character
  repeatChar: ""
};
function Et(e, t = 0) {
  if (typeof e != "number")
    return e;
  if (e < 0)
    return -Et(-e, t);
  if (t) {
    const n = 10 ** t || 1;
    return Et(e * n, 0) / n;
  }
  return Math.round(e);
}
const Y_ = 1e-13;
function wu(e, t = 2, n = 2) {
  const r = e < 0 ? -1 : 1, s = 10 ** (t || 2), i = 10 ** (n || 2);
  let o = Math.abs(e), a = 0, l = 0, u = 0, c = 1, h, d;
  if (e = o, e % 1 === 0)
    d = [e * r, 1];
  else if (e < 1e-19)
    d = [r, 1e19];
  else if (e > 1e19)
    d = [1e19 * r, 1];
  else {
    do
      if (o = 1 / (o - Math.floor(o)), h = c, c = c * Math.floor(o) + a, a = h, l = u, u = Math.floor(e * c + 0.5), u >= s || c >= i)
        return [r * l, a];
    while (Math.abs(e - u / c) >= Y_ && o !== Math.floor(o));
    d = [r * u, c];
  }
  return d;
}
const ut = Math.floor;
function Su(e, t = !0) {
  if (t && e >= 0) {
    if (e === 0)
      return [1900, 1, 0];
    if (e === 60)
      return [1900, 2, 29];
    if (e < 60)
      return [1900, e < 32 ? 1 : 2, (e - 1) % 31 + 1];
  }
  let n = e + 68569 + 2415019;
  const r = ut(4 * n / 146097);
  n = n - ut((146097 * r + 3) / 4);
  const s = ut(4e3 * (n + 1) / 1461001);
  n = n - ut(1461 * s / 4) + 31;
  const i = ut(80 * n / 2447), o = n - ut(2447 * i / 80);
  n = ut(i / 11);
  const a = i + 2 - 12 * n;
  return [100 * (r - 49) + s + n | 0, a | 0, o | 0];
}
function z_(e) {
  return Su(e + 1462);
}
function V_(e) {
  if (e === 60)
    throw new Error("#VALUE!");
  if (e <= 1)
    return [1317, 8, 29];
  if (e < 60)
    return [1317, e < 32 ? 9 : 10, 1 + (e - 2) % 30];
  const t = 10631 / 30, n = 8.01 / 60;
  let r = e + 466935;
  const s = ut(r / 10631);
  r = r - 10631 * s;
  const i = ut((r - n) / t);
  r = r - ut(i * t + n);
  const o = ut((r + 28.5001) / 29.5);
  return o === 13 ? [30 * s + i, 12, 30] : [30 * s + i, o, r - ut(29.5001 * o - 29)];
}
function Ou(e, t = 0, n = !0) {
  const r = ut(e);
  return t === Un ? V_(r) : t === H_ ? z_(r) : Su(r, n);
}
const jr = Math.floor, ri = 86400;
function Vo(e, t) {
  let n = null;
  if (Array.isArray(e)) {
    const [r, s, i, o, a, l] = e;
    n = Date.UTC(r, s == null ? 0 : s - 1, i != null ? i : 1, o || 0, a || 0, l || 0);
  } else if (e instanceof Date && (n = e * 1, !t || !t.ignoreTimezone)) {
    const r = /* @__PURE__ */ new Date();
    r.setUTCFullYear(
      e.getFullYear(),
      e.getMonth(),
      e.getDate()
    ), r.setUTCHours(
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    ), n = r * 1;
  }
  if (n != null && isFinite(n)) {
    const r = n / 864e5;
    return r - (r <= -25509 ? -25568 : -25569);
  }
  return null;
}
function G_(e, t) {
  let n = e | 0;
  const r = ri * (e - n);
  let s = jr(r);
  r - s > 0.9999 && (s += 1, s === ri && (s = 0, n += 1));
  const i = s < 0 ? ri + s : s, [o, a, l] = Ou(e, 0, t && t.leap1900), u = jr(i / 60 / 60) % 60, c = jr(i / 60) % 60, h = jr(i) % 60;
  return [o, a, l, u, c, h];
}
const K_ = [
  // day-month-year
  "!d-m-y",
  "!d-m-Y",
  "!j-m-y",
  "!j-m-Y",
  "!d-n-y",
  "!d-n-Y",
  "!j-n-y",
  "!j-n-Y",
  // month-day-year
  "?m-d-y",
  "?m-d-Y",
  "?m-j-y",
  "?m-j-Y",
  "?n-d-y",
  "?n-d-Y",
  "?n-j-y",
  "?n-j-Y",
  // unab
  "d-M-y",
  "d-M-Y",
  "j-M-y",
  "j-M-Y",
  "M-d-y",
  "M-d-Y",
  "M-j-y",
  "M-j-Y",
  "d-F-y",
  "d-F-Y",
  "F-d-y",
  "F-d-Y",
  "F-j-y",
  "F-j-Y",
  "j-F-y",
  "j-F-Y",
  "y-F-d",
  "y-F-j",
  "y-M-d",
  "y-M-j",
  "Y-F-d",
  "Y-F-j",
  "Y-M-d",
  "Y-m-d",
  "Y-M-j",
  "Y-m-j",
  "Y-n-d",
  "Y-n-j",
  "j-F",
  // 2-April
  "j-M",
  // 2-Apr
  "d-F",
  // 02-April
  "d-M",
  // 02-Apr
  "n-d",
  // 4-02
  "n-j",
  // 4-2
  "n-Y",
  // 4-1908
  "m-d",
  // 04-02
  "m-j",
  // 04-2
  "m-Y",
  // 04-1908
  "M-Y",
  // Apr-1908
  "M-y",
  // Apr-08
  "F-y",
  // April-08
  "F-Y",
  // April-1908
  "Y-M",
  // 1908-Apr
  "Y-n",
  // 1908-4
  "Y-m",
  // 1908-04
  "Y-F",
  // 1908-April
  "Y-M"
  // 1908-Apr
], X_ = { j: "d", d: "d", D: "ddd", l: "dddd", n: "m", m: "m", M: "mmm", F: "mmmm", y: "yy", Y: "yyyy" }, q_ = { j: "dd", d: "dd", D: "ddd", l: "dddd", n: "mm", m: "mm", M: "mmm", F: "mmmm", y: "yy", Y: "yyyy" }, vu = {}, bu = {};
function lt(e, t, n = 1) {
  if (e) {
    const r = e[0], s = e.slice(1);
    r === "!" ? lt(s, t, 4) : r === "?" ? lt(s, t, 2) : (t[r] = t[r] || {}, lt(s, t[r], n));
  } else
    t.$ = n;
}
function Za(e, t) {
  lt(e, t), lt(e + " x", t), lt(e + " l", t), lt(e + " l x", t), lt("l " + e, t), lt("l " + e + " x", t), lt(e + " D", t), lt(e + " D x", t), lt("D " + e, t), lt("D " + e + " x", t);
}
K_.forEach((e) => {
  e[0] !== "?" && Za(e, vu), e[0] !== "!" && Za(e, bu);
});
const Z_ = (/* @__PURE__ */ new Date()).getUTCFullYear(), Ja = ".", J_ = ",", si = " ", pr = "", Er = "", cs = "'", hs = "", Q_ = {
  ".": [J_, pr, Er, cs, hs],
  ",": [Ja, pr, Er, cs, hs],
  "": [Ja, pr, Er, cs, hs]
}, ii = (e) => e && e.length === 1 && e >= "0" && e <= "9";
function Go(e, t = {}) {
  const n = Kn(t.locale || "") || Jt, r = n.decimal, s = [...Q_[r] || [cs, hs]];
  !s.includes(n.group) && n.group !== si && n.group !== r && s.push(n.group);
  let i = "", o = "", a = 1, l = "", u = !1, c = !1, h = !1, d = !1, f = !1, g = null, _ = !1, R = 0;
  const b = [si, pr, Er, "+", "%", "(", "-"].concat(Mi);
  for (; b.includes(e[R]); ) {
    const v = e[R];
    if (v === "-") {
      if (u || c)
        return null;
      u = !0, a = -1;
    } else if (Li.test(v)) {
      if (f)
        return null;
      f = !0, g = v;
    } else if (v === "(") {
      if (c || u)
        return null;
      c = !0, a = -1;
    } else if (v === "%") {
      if (d)
        return null;
      d = !0;
    }
    R++;
  }
  let H = !1, P;
  if (e[R] === r || ii(e[R]))
    for (; R < e.length; ) {
      const v = e[R];
      if (!P && s.includes(v))
        P = v;
      else if (!(P && P === v)) if (v === r) {
        if (H)
          break;
        i += ".", H = !0;
      } else if (ii(v))
        i += v;
      else
        break;
      R++;
    }
  if (e[R] === "e" || e[R] === "E") {
    o += e[R], R++, (e[R] === "+" || e[R] === "-") && (o += e[R], R++);
    const v = R;
    for (; ii(e[R]); )
      o += e[R], R++;
    if (v === R)
      return null;
  }
  const W = [si, pr, Er, "%", "$", ")"].concat(Mi);
  for (; W.includes(e[R]); ) {
    const v = e[R];
    if (Li.test(v)) {
      if (f)
        return null;
      f = !0, g = v, _ = !0;
    } else if (v === ")") {
      if (h || !c)
        return null;
      h = !0;
    } else if (v === "%") {
      if (d)
        return null;
      d = !0;
    }
    R++;
  }
  if (R !== e.length)
    return null;
  let w = parseFloat(i + o);
  if (!isFinite(w))
    return null;
  if (o) {
    if (d || f)
      return null;
    l = "0.00E+00";
  } else if (d) {
    if (f)
      return null;
    l = i.includes(".") ? "0.00%" : "0%", w *= 0.01;
  } else if (f) {
    const v = i.includes(".") ? "#,##0.00" : "#,##0";
    _ ? l = v + g : l = g + v;
  } else P && (l = i.includes(".") ? "#,##0.00" : "#,##0");
  const C = { v: w * a };
  return l && (C.z = l), C;
}
function ep(e, t, n) {
  if (n < 1 || t < 1 || t > 12)
    return !1;
  if (t === 2) {
    const s = e % 4 === 0 && e % 100 !== 0 || e % 400 === 0 || e === 1900 ? 29 : 28;
    if (n > s)
      return !1;
  } else if ((t === 4 || t === 6 || t === 9 || t === 11) && n > 30 || (t === 1 || t === 3 || t === 5 || t === 7 || t === 8 || t === 10 || t === 12) && n > 31)
    return !1;
  return !0;
}
const Qa = (e, t, n = !1) => {
  for (const r of t)
    if (e.startsWith(r[0])) {
      let s = r[0].length;
      return n && (r[2] === "D" || r[2] === "M") && e[s] === "." && s++, [e.slice(0, s), r];
    }
  return ["", null];
}, Lt = (e, t, n, r) => {
  const s = n.path || "", i = Object.keys(t);
  for (let o = 0; o < i.length; o++) {
    let a;
    const l = i[o];
    if (t[l]) {
      if (l === "$" || l === "")
        e || (a = n);
      else if (l === "-") {
        const u = /^(\s*([./-]|,\s)\s*|\s+)/.exec(e);
        if (u) {
          const c = u[1] === "-" || u[1] === "/" || u[1] === "." ? u[1] : " ";
          if (!n.sep || n.sep === c) {
            const h = u[0].replace(/\s+/g, " ");
            a = Lt(e.slice(u[0].length), t[l], { ...n, sep: c, path: s + h }, r);
          }
        }
      } else if (l === " ") {
        const u = /^[,.]?\s+/.exec(e);
        if (u) {
          const c = u[0].replace(/\s+/g, " ");
          a = Lt(e.slice(u[0].length), t[l], { ...n, path: s + c }, r);
        }
      } else if (l === "j" || l === "d") {
        const u = /^(0?[1-9]|1\d|2\d|3[01])\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], { ...n, day: u[0], path: s + l }, r));
      } else if (l === "n" || l === "m") {
        const u = /^(0?[1-9]|1[012])\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], { ...n, month: +u[0], _mon: u[0], path: s + l }, r));
      } else if (l === "F" || l === "M") {
        const [u, c] = Qa(e, r.mon, r.mp);
        c && c[2] === l && (a = Lt(
          e.slice(u.length),
          t[l],
          { ...n, month: c[1], _mon: u, path: s + l },
          r
        ));
      } else if (l === "l" || l === "D") {
        const [u, c] = Qa(e, r.day, r.dp);
        c && c[2] === l && (a = Lt(e.slice(u.length), t[l], { ...n, path: s + l }, r));
      } else if (l === "y") {
        const u = /^\d\d\b/.exec(e);
        if (u) {
          const c = +u[0] >= 30 ? +u[0] + 1900 : +u[0] + 2e3;
          a = Lt(e.slice(u[0].length), t[l], { ...n, year: c, path: s + l }, r);
        }
      } else if (l === "Y") {
        const u = /^\d\d\d\d\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], { ...n, year: +u[0], path: s + l }, r));
      } else if (l === "x") {
        const u = ks(e, { locale: r.locale });
        u && (a = Lt("", t[l], { ...n, time: u.v, tf: u.z, path: s + l }, r));
      } else
        throw new Error(`Unknown date token "${l}"`);
      if (a && ep(n.year || 1916, n.month || 1, n.day ? +n.day : 1))
        return a;
    }
  }
}, Au = (e) => e.replace(/\s+/g, " ").trim().replace(//, "'").replace(/\.$/, "").toLowerCase(), Wr = (e, t) => {
  const n = e.map((r, s) => [Au(r), s + 1, t]);
  return n.sort((r, s) => s[0].length - r[0].length), n;
};
function Ko(e, t = {}) {
  var i;
  const n = Kn(t.locale || "") || Jt, r = {
    mon: Wr(n.mmmm, "F").concat(Wr(n.mmm, "M")),
    mp: n.mmm[0].at(-1) === ".",
    day: Wr(n.dddd, "l").concat(Wr(n.ddd, "D")),
    dp: n.ddd[0].at(-1) === ".",
    locale: t.locale
  }, s = Lt(
    Au(e),
    n.preferMDY ? bu : vu,
    { path: "" },
    r
  );
  if (s) {
    if (s.sep === "." && s.path.length === 3)
      return null;
    const o = +((i = s.year) != null ? i : Z_);
    s.day || (s.day = 1);
    let a = -1 / 0;
    if (o < 1900)
      return null;
    o <= 1900 && s.month <= 2 ? a = 25568 : o < 1e4 && (a = 25569);
    const l = Date.UTC(o, s.month - 1, s.day) / 864e5 + a + (s.time || 0);
    if (l >= 0 && l <= 2958465) {
      const u = (
        // either has a leading zero
        s._mon[0] === "0" || s.day[0] === "0" || // both are 2-digits long
        s._mon.length === 2 && s.day.length === 2
      ), c = s.path.replace(/[jdlDnmMFyYx]/g, (h) => h === "x" ? s.tf || "" : (u ? q_[h] : X_[h]) || h);
      return { v: l, z: c };
    }
  }
  return null;
}
const oi = (e) => e.replace(/\s+/g, "").trim().replace(/\./g, "").toLowerCase();
function ks(e, t = {}) {
  const n = Kn(t.locale || "") || Jt, r = /^\s*([10]?\d|2[0-4])(?::([0-5]\d|\d))?(?::([0-5]\d|\d))?(\.\d{1,10})?(?=\s*[^\s\d]|$)/.exec(e);
  let s = "";
  if (r) {
    const i = oi(e.slice(r[0].length));
    if (i === oi(n.ampm[0]) || i === "a" || i === "am")
      s = "a";
    else if (i === oi(n.ampm[1]) || i === "p" || i === "pm")
      s = "p";
    else if (i)
      return null;
  }
  if (r) {
    const [, i, o, a, l] = r;
    if (l && !a || !s && !o && !a)
      return null;
    let u = +(i || 0) * 1;
    if (s) {
      if (u >= 13)
        return null;
      s === "p" && (u += 12);
    }
    const c = +(o || 0) * 1, h = +(a || 0) * 1, d = +(l || 0) * 1;
    return {
      v: (u * 60 * 60 + c * 60 + h + d) / (3600 * 24),
      z: (i.length === 2 ? "hh" : "h") + ":mm" + (a ? ":ss" : "") + (s ? " AM/PM" : "")
    };
  }
  return null;
}
function yu(e, t = {}) {
  const n = Kn(t.locale || "") || Jt, r = e.trim().toLowerCase(), s = n.bool[0].toLowerCase();
  if (r === "true" || r === s)
    return { v: !0 };
  const i = n.bool[1].toLowerCase();
  return r === "false" || r === i ? { v: !1 } : null;
}
function tp(e, t) {
  var n, r, s;
  return (s = (r = (n = Go(e, t)) != null ? n : Ko(e, t)) != null ? r : ks(e, t)) != null ? s : yu(e, t);
}
function un(e, t, n) {
  return t[n + "_max"] = e.length, t[n + "_min"] = e.replace(/#/g, "").length, t;
}
function je(e, t) {
  typeof e == "string" ? t.push({ type: "string", value: e }) : t.push(e);
}
function el(e, t) {
  const n = e && e.type;
  return n === po || n === kn || n === Eo || n === Ds && t === "den";
}
function dr(e) {
  var P, W, w;
  const t = [], n = {
    scale: 1,
    percent: !1,
    text: !1,
    date: 0,
    date_eval: !1,
    date_system: qa,
    sec_decimals: 0,
    general: !1,
    clock: 24,
    int_pattern: [],
    frac_pattern: [],
    man_pattern: [],
    den_pattern: [],
    num_pattern: [],
    tokens: t
  };
  let r = "int", s = null;
  const i = [];
  let o, a = !1, l = -1, u = !1, c = "", h = !1;
  for (; ++l < e.length && !u; ) {
    const C = e[l], v = C.type || Sr;
    if (c += C.raw, v === _o)
      n.general = !0, je(C, t);
    else if (el(C, r)) {
      const y = n[r + "_pattern"];
      el(o, r) || (o == null ? void 0 : o.type) === wr ? (y.push((y.pop() || "") + C.value), s.num += C.value) : (y.push(C.value), s = { type: r, num: C.value }, je(s, t));
    } else if (v === Ho)
      C.value === "(" && (n.parens = !0), je(C.value, t);
    else if (v === Ds)
      je(C.value, t);
    else if (v === Co)
      if (h = !0, n[r + "_pattern"].length) {
        if (!s)
          throw new SyntaxError("Format pattern is missing a numerator");
        n.fractions = !0, n.num_pattern.push(n[r + "_pattern"].pop()), s.type = "num", r = "den", je({ type: "div" }, t);
      } else
        je(C.value, t);
    else if (v === Ro)
      je(",", t);
    else if (v === _s)
      n.scale = 1e-3 ** C.raw.length;
    else if (v === wr) {
      if (r === "int" && (n.grouping = !0), r === "den")
        throw new SyntaxError("Cannot group denominator digits");
    } else if (v === Oo)
      je(C, t);
    else if (v === Io) {
      u = !0;
      break;
    } else if (v === xs)
      n.text = !0, je(C, t);
    else if (v === wo || v === So)
      je(C, t);
    else if (v === yo) {
      const y = C.value.toLowerCase(), F = y[0], $ = { type: "", size: 0, date: 1, pad: y.length };
      F === "h" ? ($.size = ur, $.type = "hour-elap") : F === "m" ? ($.size = cr, $.type = "min-elap") : ($.size = hr, $.type = "sec-elap"), n.date = n.date | $.size, i.push($), je($, t);
    } else if (n.date && v === ps && ((P = e[l + 1]) == null ? void 0 : P.type) === kn) {
      let y = 1;
      l++;
      let F = "0";
      ((W = e[l + 1]) == null ? void 0 : W.type) === kn && (F += "0", y = 2, l++), ((w = e[l + 1]) == null ? void 0 : w.type) === kn && (F += "0", y = 3, l++), c += F;
      const $ = [hr, yi, Ni, Ti][y];
      n.date = n.date | $, n.date_eval = !0, n.sec_decimals = Math.max(n.sec_decimals, y), je({
        type: "subsec",
        size: $,
        decimals: y,
        date: 1
      }, t);
    } else if (v === bo)
      a || (C.value === "B2" || C.value === "b2" ? n.date_system = Un : n.date_system = qa);
    else if (v === Ao) {
      const y = { type: "", size: 0, date: 1 }, F = C.value.toLowerCase(), $ = F[0];
      if (F === "y" || F === "yy")
        y.size = ar, y.type = "year-short";
      else if ($ === "y" || $ === "e")
        y.size = ar, y.type = "year";
      else if (F === "b" || F === "bb")
        y.size = ar, y.type = "b-year-short";
      else if ($ === "b")
        y.size = ar, y.type = "b-year";
      else if (F === "d" || F === "dd")
        y.size = us, y.type = "day", y.pad = /dd/.test(F);
      else if (F === "ddd" || F === "aaa")
        y.size = us, y.type = "weekday-short";
      else if ($ === "d" || $ === "a")
        y.size = us, y.type = "weekday";
      else if ($ === "h")
        y.size = ur, y.type = "hour", y.pad = /hh/i.test(F);
      else if ($ === "m") {
        F.length === 3 ? (y.size = lr, y.type = "monthname-short") : F.length === 5 ? (y.size = lr, y.type = "monthname-single") : F.length >= 4 && (y.size = lr, y.type = "monthname");
        const m = i[i.length - 1];
        !y.type && m && !m.used && m.size & (ur | hr) && (m.used = !0, y.size = cr, y.type = "min", y.pad = /mm/.test(F)), y.type || (y.size = lr, y.type = "month", y.pad = /mm/.test(F), y.indeterminate = !0);
      } else if ($ === "s") {
        y.size = hr, y.type = "sec", y.pad = /ss/.test(F);
        const m = i[i.length - 1];
        m && m.size & cr ? y.used = !0 : m && m.indeterminate && (delete m.indeterminate, m.size = cr, m.type = "min", y.used = !0);
      }
      n.date = n.date | y.size, n.date_eval = !0, i.push(y), je(y, t);
    } else if (v === Do)
      n.clock = 12, n.date = n.date | ur, n.date_eval = !0, C.short = C.value === "A/P", je(C, t);
    else if (v === ko || v === Uo || v === Us)
      je(C.value, t);
    else if (v === No)
      n.condition = [
        C.value[0],
        // operator
        parseFloat(C.value[1])
        // operand
      ];
    else if (v === Lo) {
      const y = C.value.split("-"), F = y.length < 2 ? "" : y.slice(1).join("-"), $ = y[0];
      $ && je($, t);
      const m = jo(F);
      m && (n.locale = m);
      const D = parseInt(F, 16);
      isFinite(D) && D & 16711680 && (D >> 16 & 255) === 6 && (n.date_system = Un), a = !0;
    } else if (v === xo) {
      let y, F = C.value.toLowerCase();
      (y = /^color\s*(\d+)$/i.exec(F)) && (F = parseInt(y[1], 10)), n.color = F;
    } else if (v === vo)
      n.scale = 100, n.percent = !0, je("%", t);
    else if (v === ps)
      je(C, t), n.date || (n.dec_fractions = !0, r = "frac");
    else if (v === Fo)
      n.exponential = !0, n.exp_plus = C.value.includes("+"), r = "man", je({ type: "exp", plus: n.exp_plus }, t);
    else if (v === Po)
      je(C, t);
    else if (v === $o)
      je(C, t);
    else if (!(v === To || v === Mo)) throw v === Sr ? new SyntaxError(`Illegal character: ${c}`) : new SyntaxError(`Unknown token ${v} in ${c}`);
    o = C;
  }
  if (n.tokensUsed = l, n.pattern = c, /^((?:\[[^\]]+\])+)(;|$)/.test(n.pattern) && !/^\[(?:h+|m+|s+)\]/.test(n.pattern) && je({ type: "text" }, t), n.fractions && n.dec_fractions || n.grouping && !n.int_pattern.length || n.fractions && n.exponential || n.fractions && n.den_pattern.length * n.num_pattern.length === 0 || h && !n.fractions && !n.date || n.exponential && (n.int_pattern.length || n.frac_pattern.length) * n.man_pattern.length === 0)
    throw new SyntaxError(`Invalid pattern: ${c}`);
  const d = n.int_pattern.join(""), f = n.man_pattern.join(""), g = n.frac_pattern.join("");
  un(d, n, "int");
  let _ = 0;
  for (let C = 0; C < d.length; C++) {
    const v = d[d.length - 1 - C];
    /^[0-9?]/.test(v) && (_ = C + 1);
  }
  n.int_min = _, un(g, n, "frac"), un(f, n, "man");
  let R = n.num_pattern.join(""), b = n.den_pattern[0] || "";
  if (b.includes("?") || R.includes("?") ? (b = b.replace(/\d/g, "?"), b = b.replace(/#$/g, "?"), un(R, n, "num"), un(b, n, "den"), R = R.replace(/#$/g, "?")) : (un(R, n, "num"), un(b, n, "den")), n.int_p = d, n.man_p = f, n.num_p = R, n.den_p = b, n.den_pattern.length && (n.denominator = parseInt(n.den_pattern.join("").replace(/\D/g, ""), 10)), n.integer = !!d.length, !n.integer && !n.exponential && g.length) {
    const C = n.tokens.findIndex((v) => v.type === "point");
    n.tokens.splice(C, 0, { type: "int", value: "#" }), n.integer = !0, n.int_pattern = ["#"], n.int_p = "#";
  }
  if (n.fractions)
    for (let C = 0; C < t.length - 1; C++) {
      const v = t[C];
      if (v.type !== "string" && v.type !== "space")
        continue;
      const y = t[C + 1].type;
      y === "num" ? v.rule = "num+int" : y === "div" ? v.rule = "num" : y === "den" && (v.rule = "den");
    }
  return n.grouping && n.int_pattern.length > 1 && (n.grouping = !1), n;
}
function np(e) {
  if (e === 0)
    return e;
  const t = Math.ceil(Math.log10(e < 0 ? -e : e)), n = 10 ** (16 - Math.floor(t));
  return isFinite(n) ? Math.round(e * n) / n : 0;
}
function Nu(e, t = 0) {
  const n = Math.floor(Math.log10(e));
  return t > 1 ? Math.floor(n / t) * t : n;
}
function Tu(e, t = 1) {
  return t < -300 ? parseFloat(e.toExponential().split("e")[0]) : e * 10 ** -t;
}
const rp = {
  total: 1,
  sign: 0,
  period: 0,
  int: 1,
  frac: 0
};
function sp(e, t = !0) {
  const n = Math.abs(e);
  if (!n)
    return rp;
  const r = t && e < 0 ? 1 : 0, s = Math.floor(n), i = Math.floor(Math.log10(n) + 1);
  let o = 0, a = 0;
  if (s !== n) {
    o = 1;
    const l = String(
      Et(n * 10 ** -i, 15)
    );
    let u = l.length, c = !0, h = 0;
    for (; h <= l.length; ) {
      if (l[h] === ".") {
        u--;
        break;
      } else l[h] === "0" && c ? u-- : c = !1;
      h++;
    }
    a = u - i, a < 0 && (a = 0, o = 0);
  }
  return {
    total: r + Math.max(i, 1) + o + a,
    digits: Math.max(i, 0) + a,
    sign: r,
    period: o,
    int: Math.max(i, 1),
    frac: a
  };
}
const bn = (e, t) => e.replace(/\./, t.decimal), tl = (e, t, n) => {
  const r = Math.abs(t);
  let s;
  return e === 1 ? s = e : s = Et(e, 5), [
    bn(s + "", n),
    n.exponent,
    t < 0 ? n.negative : n.positive,
    r < 10 ? "0" : "",
    r
  ];
};
function nl(e, t, n, r) {
  const s = n | 0;
  if (typeof n == "string")
    e.push(n);
  else if (n === s)
    e.push(Math.abs(s));
  else {
    const i = Math.abs(n);
    let o = Nu(i), a = Tu(i, o);
    a === 10 && (a = 1, o++);
    const l = sp(i);
    if (o >= -4 && o <= -1) {
      const u = i.toPrecision(10 + o).replace(/\.?0+$/, "");
      e.push(bn(u, r));
    } else if (o === 10) {
      const u = i.toFixed(10).slice(0, 12).replace(/\.$/, "");
      e.push(bn(u, r));
    } else if (Math.abs(o) <= 9)
      if (l.total <= 11) {
        const u = Et(i, 9).toFixed(l.frac);
        e.push(bn(u, r));
      } else o === 9 ? e.push(Math.floor(i)) : o >= 0 && o < 9 ? e.push(bn(String(Et(i, 9 - o)), r)) : e.push(...tl(a, o, r));
    else l.total >= 12 ? e.push(...tl(a, o, r)) : e.push(bn(Et(i, 9).toFixed(l.frac), r));
  }
  return e;
}
function cn(e, t = !1) {
  return e === "0" ? "0" : e === "?" ? t ? "" : " " : "";
}
const Jn = 86400, ip = (e, t, n) => n ? e < F_ || t >= $_ : e < k_ || t >= P_;
function rl(e, t, n, r) {
  var A, O;
  let s = "", i = "", o = "", a = "", l = "", u = "", c = 0, h = 0;
  if (typeof e == "bigint") {
    if (e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER)
      e = Number(e);
    else
      return n.bigintErrorNumber ? String(e) : n.overflow;
    h = e;
  } else
    h = Math.trunc(e);
  let d = 0, f = 0, g = 1, _ = 0, R = 0, b = 0, H = 0, P = 0, W = 0;
  const w = r || Jt;
  if (!t.text && isFinite(t.scale) && t.scale !== 1 && (e = np(e * t.scale)), t.exponential) {
    let N = Math.abs(e);
    N && (c = Nu(N, t.int_max)), e && !t.integer && c++, N = Tu(N, c), t.int_max === 1 && Et(N, t.frac_max) === 10 && (N = 1, c++), e = e < 0 ? -N : N, s += Math.abs(c);
  }
  if (t.integer) {
    const N = Math.abs(Et(e, t.fractions ? 1 : t.frac_max));
    u += N < 1 ? "" : Math.floor(N);
  }
  const C = (A = n.grouping[0]) != null ? A : 3, v = (O = n.grouping[1]) != null ? O : C;
  t.dec_fractions && (l = String(Et(e, t.frac_max)).split(".")[1] || "");
  const y = !t.error && (t.num_p.includes("0") || t.den_p.includes("0"));
  let F = y;
  if (t.fractions) {
    F = y || !!(e % 1);
    const N = Math.abs(t.integer ? e % 1 : e);
    if (N)
      if (F = !0, t.denominator && isFinite(t.denominator))
        a += t.denominator, o += Et(N * t.denominator), o === "0" && (o = "", a = "", F = y);
      else {
        const M = wu(N, 1 / 0, t.den_max);
        o += M[0], a += M[1], t.integer && o === "0" && (o = "", a = "", F = y);
      }
    else !e && !t.integer && (F = !0, o = "0", a = "1");
    t.integer && !F && !Math.trunc(e) && (u = "0");
  }
  if (t.date) {
    h = Math.trunc(e);
    const N = Jn * (e - h);
    if (d = Math.floor(N), W = N - d, Math.abs(W) < 1e-6 ? W = 0 : W > 0.9999 && (W = 0, d += 1, d === Jn && (d = 0, h += 1)), W) {
      const M = t.date & Ti || t.date & Ni || t.date & yi;
      (M === Ti && W > 0.9995 || M === Ni && W > 0.995 || M === yi && W > 0.95 || !M && W >= 0.5) && (d++, W = 0);
    }
    if (h || t.date_system) {
      const M = Ou(e, t.date_system, n.leap1900);
      f = M[0], g = M[1], _ = M[2];
    }
    if (d) {
      const M = d < 0 ? Jn + d : d;
      P = Math.floor(M) % 60, H = Math.floor(M / 60) % 60, b = Math.floor(M / 60 / 60) % 60;
    }
    if (R = (6 + h) % 7, t.date_eval && ip(e, h + d / Jn, n.dateSpanLarge)) {
      if (n.dateErrorThrows)
        throw new Error("Date out of bounds");
      if (n.dateErrorNumber) {
        const M = e < 0 ? [w.negative] : [];
        return nl(M, {}, e, w).join("");
      }
      return n.overflow;
    }
  }
  const $ = cn("?", n.nbsp);
  c < 0 ? i = "-" : t.exp_plus && (i = "+");
  const m = [], D = (N, M, L, k) => {
    const q = !k && N.length > M.length ? L.length + N.length - M.length : L.length;
    N.length < M.length && (k += N.length - M.length);
    for (let V = 0; V < q; V++)
      m.push(N[V + k] || cn(L[V], n.nbsp));
    return q;
  };
  let S = !1;
  const T = { int: 0, frac: 0, man: 0, num: 0, den: 0 };
  for (let N = 0, M = t.tokens.length; N < M; N++) {
    const L = t.tokens[N], k = L.type, q = L.num ? L.num.length : 0;
    if (k === "string")
      L.rule ? L.rule === "num" ? F ? m.push(L.value.replace(/ /g, $)) : (t.num_min > 0 || t.den_min > 0) && m.push(L.value.replace(/./g, $)) : L.rule === "num+int" ? F && u ? m.push(L.value.replace(/ /g, $)) : t.den_min > 0 && (u || t.num_min) && m.push(L.value.replace(/./g, $)) : L.rule === "den" && (F ? m.push(L.value.replace(/ /g, $)) : (t.den_min > 0 || t.den_min > 0) && m.push(L.value.replace(/./g, $))) : m.push(L.value.replace(/ /g, $));
    else if (k === "space")
      L.rule === "num+int" ? (F || t.num_min || t.den_min) && (u || t.num_min) && m.push($) : m.push($);
    else if (k === "error")
      m.push(n.invalid);
    else if (k === "point")
      m.push(t.date ? L.value : w.decimal);
    else if (k === "general")
      nl(m, t, e, w);
    else if (k === "exp")
      m.push(w.exponent);
    else if (k === "minus")
      L.volatile && t.date || L.volatile && (e >= 0 || typeof e != "number") || (L.volatile && !t.fractions && (t.integer || t.dec_fractions) ? (e < 0 && u && u !== "0" || l) && m.push(w.negative) : m.push(w.negative));
    else if (k === "plus")
      m.push(w.positive);
    else if (k === "text")
      m.push(e);
    else if (k === "fill")
      n.fillChar && m.push(n.fillChar, L.value);
    else if (k === "skip")
      n.skipChar ? m.push(n.skipChar, L.value) : m.push(n.nbsp ? "" : " ");
    else if (k === "div")
      F ? m.push("/") : t.num_min > 0 || t.den_min > 0 ? m.push($) : m.push(cn("#", n.nbsp));
    else if (k === "int")
      if (t.int_pattern.length === 1) {
        const V = t.int_p, oe = Math.max(t.int_min, u.length);
        let le = "";
        for (let I = oe; I > 0; I--) {
          const x = u.charAt(u.length - I), Y = x ? "" : V.charAt(V.length - I) || V[0];
          let z = "";
          if (t.grouping) {
            const B = I - 1 - C;
            B >= 0 && !(B % v) && (z = x || Y === "0" ? w.group : cn("?", n.nbsp));
          }
          le += (x || cn(Y, n.nbsp)) + z;
        }
        m.push(le);
      } else
        T.int += D(u, t.int_p, L.num, T.int);
    else if (k === "frac") {
      const V = T.frac;
      for (let oe = 0; oe < q; oe++)
        m.push(l[oe + V] || cn(L.num[oe], n.nbsp));
      T.frac += q;
    } else if (k === "man")
      !T[k] && !T.man && m.push(i), T.man += D(s, t.man_p, L.num, T.man);
    else if (k === "num")
      T.num += D(o, t.num_p, L.num, T.num);
    else if (k === "den") {
      const V = T.den;
      for (let oe = 0; oe < q; oe++) {
        let le = a[oe + V];
        if (!le) {
          const I = L.num[oe];
          "123456789".includes(I) || S && I === "0" ? (S = !0, le = n.nbsp ? "" : " ") : !S && oe === q - 1 && I === "0" && !a ? le = "1" : le = cn(I, n.nbsp);
        }
        m.push(le);
      }
      T.den += q;
    } else if (k === "year")
      f < 0 && m.push(w.negative), m.push(String(Math.abs(f)).padStart(4, "0"));
    else if (k === "year-short") {
      const V = f % 100;
      m.push(V < 10 ? "0" : "", V);
    } else if (k === "month")
      m.push(L.pad && g < 10 ? "0" : "", g);
    else if (k === "monthname-single")
      t.date_system === Un ? m.push(w.mmmm6[g - 1].charAt(0)) : m.push(w.mmmm[g - 1].charAt(0));
    else if (k === "monthname-short")
      t.date_system === Un ? m.push(w.mmm6[g - 1]) : m.push(w.mmm[g - 1]);
    else if (k === "monthname")
      t.date_system === Un ? m.push(w.mmmm6[g - 1]) : m.push(w.mmmm[g - 1]);
    else if (L.type === "weekday-short")
      m.push(w.ddd[R]);
    else if (k === "weekday")
      m.push(w.dddd[R]);
    else if (k === "day")
      m.push(L.pad && _ < 10 ? "0" : "", _);
    else if (k === "hour") {
      const V = b % t.clock || (t.clock < 24 ? t.clock : 0);
      m.push(L.pad && V < 10 ? "0" : "", V);
    } else if (k === "min")
      m.push(L.pad && H < 10 ? "0" : "", H);
    else if (k === "sec")
      m.push(L.pad && P < 10 ? "0" : "", P);
    else if (k === "subsec") {
      m.push(w.decimal);
      const V = W.toFixed(t.sec_decimals);
      m.push(V.slice(2, 2 + L.decimals));
    } else if (k === "ampm") {
      const V = b < 12 ? 0 : 1;
      L.short && !r ? m.push("AP"[V]) : m.push(w.ampm[V]);
    } else if (k === "hour-elap") {
      e < 0 && m.push(w.negative);
      const V = h * 24 + Math.floor(Math.abs(d) / 3600);
      m.push(String(Math.abs(V)).padStart(L.pad, "0"));
    } else if (k === "min-elap") {
      e < 0 && m.push(w.negative);
      const V = h * 1440 + Math.floor(Math.abs(d) / 60);
      m.push(String(Math.abs(V)).padStart(L.pad, "0"));
    } else if (k === "sec-elap") {
      e < 0 && m.push(w.negative);
      const V = h * Jn + Math.abs(d);
      m.push(String(Math.abs(V)).padStart(L.pad, "0"));
    } else if (k === "b-year")
      m.push(f + 543);
    else if (k === "b-year-short") {
      const V = (f + 543) % 100;
      m.push(V < 10 ? "0" : "", V);
    }
  }
  return m.join("");
}
const op = dr([
  { type: xs, value: "@", raw: "@" }
]);
function Mu(e, t) {
  for (let n = 0; n < 3; n++) {
    const r = t[n];
    if (r) {
      let s;
      if (r.condition) {
        const i = r.condition[0], o = r.condition[1];
        i === "=" ? s = e === o : i === ">" ? s = e > o : i === "<" ? s = e < o : i === ">=" ? s = e >= o : i === "<=" ? s = e <= o : i === "<>" && (s = e !== o);
      } else
        s = !0;
      if (s)
        return r;
    }
  }
}
function ap(e, t, n) {
  const r = t.partitions;
  let s = r[3], i = null;
  return (typeof e == "number" || typeof e == "bigint") && isFinite(e) && (s = Mu(e, r)), s && s.color && (i = s.color), i && typeof i == "number" && n.indexColors && (i = B_[i - 1] || "#000"), i;
}
function lp(e, t, n) {
  const r = t.partitions, s = Kn(t.locale || n.locale), i = r[3] ? r[3] : op;
  if (typeof e == "boolean" && (e = (s || Jt).bool[e ? 0 : 1]), e == null)
    return "";
  const o = typeof e == "bigint";
  if (typeof e != "number" && !o)
    return rl(e, i, n, s);
  if (!o && !isFinite(e)) {
    const l = s || Jt;
    return isNaN(e) ? l.nan : (e < 0 ? l.negative : "") + l.infinity;
  }
  const a = Mu(e, r);
  return a ? rl(e, a, n, s) : n.overflow;
}
function Lu(e) {
  return !!(e[0] && e[0].percent || e[1] && e[1].percent || e[2] && e[2].percent || e[3] && e[3].percent);
}
function xu(e) {
  return !!(e[0] && e[0].date || e[1] && e[1].date || e[2] && e[2].date || e[3] && e[3].date);
}
function Du(e) {
  const [t, n, r, s] = e;
  return !!((!t || t.generated) && (!n || n.generated) && (!r || r.generated) && s && s.text && !s.generated);
}
const up = {
  text: 15,
  datetime: 10.8,
  date: 10.8,
  time: 10.8,
  percent: 10.6,
  currency: 10.4,
  grouped: 10.2,
  scientific: 6,
  number: 4,
  fraction: 2,
  general: 0,
  error: 0
}, cp = [
  ["DMY", 1],
  ["DM", 2],
  ["MY", 3],
  ["MDY", 4],
  ["MD", 5],
  ["hmsa", 6],
  ["hma", 7],
  ["hms", 8],
  ["hm", 9]
];
function hp(e, t = null) {
  var h;
  const [n, r] = e, s = n.frac_max, i = {
    type: "general",
    isDate: xu(e),
    isText: Du(e),
    isPercent: Lu(e),
    maxDecimals: n.general ? 9 : s,
    scale: (h = n.scale) != null ? h : 1,
    color: 0,
    parentheses: 0,
    grouped: n.grouping ? 1 : 0
  }, o = !i.isDate && !i.isText && !n.error && n.tokens.some((d) => d.type === "string" && (t ? d.value === t : Li.test(d.value)));
  let a = "G", l = s >= 0 ? Math.min(15, s) : "", u = "", c = "";
  if (r && r.color && (c = "-", i.color = 1), n.parens && (u = "()", i.parentheses = 1), o)
    a = "C", i.type = "currency";
  else if (n.error)
    i.type = "error", i.maxDecimals = 0;
  else if (i.isDate) {
    let d = 0, f = 0, g = "";
    n.tokens.forEach((R) => {
      const b = R.type;
      /^(b-)?year/.test(b) ? (g += "Y", f++) : b.startsWith("month") ? (g += "M", f++) : /^(week)?day/.test(b) ? (g += "D", f++) : (b === "hour" || b === "min" || b === "sec" || b === "ampm") && (g += b[0], d++);
    }), i.type = "date", f && d ? i.type = "datetime" : !f && d && (i.type = "time");
    const _ = cp.find((R) => g.startsWith(R[0]));
    a = _ ? "D" : "G", l = _ ? _[1] : "";
  } else i.isText ? (a = "G", i.type = "text", l = "", i.maxDecimals = 0) : n.general ? (a = "G", i.type = "general", l = "") : n.fractions ? (a = "G", i.type = "fraction", l = "") : n.exponential ? (a = "S", i.type = "scientific") : i.isPercent ? (a = "P", i.type = "percent") : n.grouping ? (a = ",", i.type = "grouped") : (n.int_max || s) && (a = "F", i.type = "number");
  return i.code = a + l + c + u, i.level = up[i.type], Object.freeze(i);
}
function dp(e) {
  const [t] = e;
  return {
    year: !!(t.date & ar),
    month: !!(t.date & lr),
    day: !!(t.date & us),
    hours: !!(t.date & ur),
    minutes: !!(t.date & cr),
    seconds: !!(t.date & hr),
    clockType: t.clock === 12 ? 12 : 24
  };
}
const fp = [
  [_o, /^General/i, 0],
  [po, /^#/, 0],
  [kn, /^0/, 0],
  [Eo, /^\?/, 0],
  [Co, /^\//, 0],
  // Commas are dealt with as a special case in the tokenizer but will end up
  // as one of these:
  // [ TOKEN_GROUP, /^(,),*/, 1 ],
  // [ TOKEN_SCALE, /^(,),*/, 1 ],
  // [ TOKEN_COMMA, /^(,),*/, 1 ],
  [Io, /^;/, 0],
  [xs, /^@/, 0],
  [wo, /^\+/, 0],
  [So, /^-/, 0],
  [ps, /^\./, 0],
  [Oo, /^ /, 0],
  [vo, /^%/, 0],
  [Ds, /^[1-9]/, 0],
  [bo, /^(?:B[12])/i, 0],
  [Sr, /^B$/, 0],
  // pattern must not end in a "B"
  [Ao, /^(?:[hH]+|[mM]+|[sS]+|[yY]+|[bB]+|[dD]+|[gG]+|[aA]{3,}|e+)/, 0],
  [yo, /^(?:\[(h+|m+|s+)\])/i, 1],
  [No, /^\[(<[=>]?|>=?|=)\s*(-?[.\d]+)\]/, [1, 2]],
  [To, /^\[(DBNum[0-4]?\d)\]/i, 1],
  [Mo, /^\[(NatNum[0-4]?\d)\]/i, 1],
  [Lo, /^\[\$([^\]]+)\]/, 1],
  [xo, /^\[(black|blue|cyan|green|magenta|red|white|yellow|color\s*\d+)\]/i, 1],
  // conditionally allow these open ended directions?
  [gu, /^\[([^\]]+)\]/, 1],
  [Do, /^(?:AM\/PM|am\/pm|A\/P)/, 0],
  [Uo, /^\\(.)/, 1],
  [ko, /^"([^"]*?)"/, 1],
  [Po, /^_(\\.|.)/, 1],
  // Google Sheets and Excel diverge on "e": Excel only accepts E.
  [Fo, /^[Ee]([+-])/, 1],
  [$o, /^\*(\\.|.)/, 1],
  [Ho, /^[()]/, 0],
  [Sr, /^[ENn["*/\\_]/, 0],
  [Us, /^./, 0]
], mp = 63, gp = 35, _p = 48, pp = 57, ai = (e) => {
  const t = (e || "\0").charCodeAt(0);
  return t === mp || t === gp || t >= _p && t <= pp;
};
function Tn(e) {
  let t = 0;
  const n = [], r = [];
  for (; t < e.length; ) {
    const s = e.slice(t);
    let i = 0;
    const o = /^(,+)(.)?/.exec(s);
    if (o) {
      const a = o[1];
      i = a.length;
      const l = e[t - 1] || "";
      let u = !1, c = !1;
      ai(l) ? (u = !0, c = !0) : l === "." && (c = !0);
      const h = o[2] || "";
      if (u && (!h || h === ";") && (u = !1), c && ai(h) && (c = !1), u && !c)
        n.push({ type: wr, value: ",", raw: a });
      else if (!u && c)
        n.push({ type: _s, value: ",", raw: a });
      else if (u && c) {
        const d = { type: _s, value: ",", raw: a };
        n.push(d), r.push(d);
      } else
        n.push({ type: Ro, value: ",", raw: a });
    } else {
      let a;
      for (const [l, u, c] of fp) {
        const h = u.exec(s);
        if (h) {
          const d = Array.isArray(c) ? c.map((f) => h[f]) : h[c || 0];
          a = { type: l, value: d, raw: h[0] }, n.push(a), i = h[0].length;
          break;
        }
      }
      r.length && a.raw === ";" && (r.length = 0), r.length && ai(a.raw) && (r.forEach((l) => l.type = wr), r.length = 0);
    }
    if (!i) {
      const a = s[0];
      i = 1, n.push({ type: Us, value: a, raw: a });
    }
    t += i;
  }
  return n;
}
const li = (e) => {
  const t = e.condition;
  t && t[1] < 0 && (t[0] === "<" || t[0] === "<=" || t[0] === "=") || e.tokens.unshift({
    type: "minus",
    volatile: !0
  });
}, sl = (e, t = null) => {
  const n = {};
  for (const r in e)
    Array.isArray(e[r]) ? n[r] = [...e[r]] : n[r] = e[r];
  return t && n.tokens.unshift(t), n.generated = !0, n;
};
function Ep(e) {
  var h;
  const t = [];
  let n = !1, r, s = null, i = 0, o = !1, a = 0, l = 0, u = Tn(e);
  do {
    if (o = dr(u), (o.date || o.general) && (o.int_pattern.length || o.frac_pattern.length || o.scale !== 1 || o.text))
      throw new Error("Illegal format");
    if (o.condition && (l++, n = !0), o.text) {
      if (s)
        throw new Error("Unexpected partition");
      s = o;
    }
    o.locale && (r = jo(o.locale)), t.push(o), i = ((h = u[o.tokensUsed]) == null ? void 0 : h.type) === "break" ? 1 : 0, u = u.slice(o.tokensUsed + i), a++;
  } while (i && a < 4 && l < 3);
  if (i)
    throw new Error("Unexpected partition");
  if (l > 2)
    throw new Error("Unexpected condition");
  const c = t[3];
  if (c && (c.int_pattern.length || c.frac_pattern.length || c.date))
    throw new Error("Unexpected partition");
  if (n) {
    const d = t.length;
    if (d === 1 && (t[1] = dr(Tn("General")), t[1].generated = !0), d < 3) {
      const f = t[0], g = t[1];
      if (li(f), g.condition)
        li(g);
      else {
        const _ = f.condition;
        (_[0] === "=" || _[1] >= 0 && (_[0] === ">" || _[0] === ">=")) && g.tokens.unshift({
          type: "minus",
          volatile: !0
        });
      }
    } else
      t.forEach(li);
  } else {
    if (t.length < 4 && s)
      for (let d = 0, f = t.length; d < f; d++)
        t[d] === s && t.splice(d, 1);
    if (t.length < 1 && s && (t[0] = dr(Tn("General")), t[0].generated = !0), t.length < 2) {
      const d = { type: "minus", volatile: !0 };
      t.push(sl(t[0], d));
    }
    if (t.length < 3 && t.push(sl(t[0])), t.length < 4)
      if (s)
        t.push(s);
      else {
        const d = dr(Tn("@"));
        d.generated = !0, t.push(d);
      }
    t[0].condition = [">", 0], t[1].condition = ["<", 0], t[2].condition = null;
  }
  return {
    pattern: e,
    partitions: t,
    locale: r
  };
}
const il = /* @__PURE__ */ Object.create({});
function nn(e, t = !1) {
  e || (e = "General");
  let n = il[e];
  if (!n)
    try {
      n = Ep(e), il[e] = n;
    } catch (r) {
      if (t)
        throw r;
      const s = {
        tokens: [{ type: "error" }],
        error: r.message
      };
      n = {
        pattern: e,
        partitions: [s, s, s, s],
        error: r.message,
        locale: null
      };
    }
  return n;
}
function Uu(e, t, n = {}) {
  var o;
  const r = Object.assign({}, Iu, n), s = nn(e, r.throws), i = (o = Vo(t, r)) != null ? o : t;
  return lp(i, s, r);
}
function Cp(e, t, n) {
  var o;
  const r = Object.assign({}, Iu, n), s = nn(e, r.throws), i = (o = Vo(t, r)) != null ? o : t;
  return ap(i, s, r);
}
function Rp(e) {
  const t = nn(e, !1);
  return xu(t.partitions);
}
function Ip(e) {
  const t = nn(e, !1);
  return Lu(t.partitions);
}
function wp(e) {
  const t = nn(e, !1);
  return Du(t.partitions);
}
function Sp(e) {
  try {
    return nn(e, !0), !0;
  } catch {
    return !1;
  }
}
function Op(e, t = {}) {
  const n = nn(e, !1);
  return n.info || (n.info = hp(n.partitions, t == null ? void 0 : t.currency)), n.info;
}
function vp(e) {
  const t = nn(e, !1);
  return t.dateInfo || (t.dateInfo = dp(t.partitions)), t.dateInfo;
}
const An = Object.freeze({
  AMPM: Do,
  BREAK: Io,
  CALENDAR: bo,
  CHAR: Us,
  COLOR: xo,
  COMMA: Ro,
  CONDITION: No,
  DATETIME: Ao,
  DBNUM: To,
  DIGIT: Ds,
  DURATION: yo,
  ERROR: Sr,
  ESCAPED: Uo,
  EXP: Fo,
  FILL: $o,
  GENERAL: _o,
  GROUP: wr,
  HASH: po,
  LOCALE: Lo,
  MINUS: So,
  MODIFIER: gu,
  NATNUM: Mo,
  PAREN: Ho,
  PERCENT: vo,
  PLUS: wo,
  POINT: ps,
  QMARK: Eo,
  SCALE: _s,
  SKIP: Po,
  SLASH: Co,
  SPACE: Oo,
  STRING: ko,
  TEXT: xs,
  ZERO: kn
}), eR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addLocale: te,
  dateFromSerial: G_,
  dateToSerial: Vo,
  dec2frac: wu,
  format: Uu,
  formatColor: Cp,
  getFormatDateInfo: vp,
  getFormatInfo: Op,
  getLocale: Kn,
  isDateFormat: Rp,
  isPercentFormat: Ip,
  isTextFormat: wp,
  isValidFormat: Sp,
  parseBool: yu,
  parseDate: Ko,
  parseLocale: Bo,
  parseNumber: Go,
  parseTime: ks,
  parseValue: tp,
  round: Et,
  tokenTypes: An,
  tokenize: Tn
}, Symbol.toStringTag, { value: "Module" })), bp = "@@@", Ap = "@", yp = "General";
function tR(e) {
  return e === bp || e === Ap;
}
function nR(e) {
  return e == null || e === yp;
}
const rR = (e, t) => {
  if (e && !t || !e && t)
    return !1;
  const n = (i) => {
    const o = Tn(i);
    let a = "", l = !1, u = !1;
    for (const c of o) {
      if (c.type === An.POINT) {
        l = !0;
        continue;
      }
      if (!(u && c.type === An.MINUS) && c.type !== An.SKIP) {
        if (c.type === An.COLOR) {
          u = !0;
          continue;
        } else
          u = !1;
        l && c.type === An.ZERO || (l = !1, l || (a += c.value || ""));
      }
    }
    return a;
  }, r = n(e), s = n(t);
  return r === s;
}, Np = /* @__PURE__ */ new Set(["m d"]), Tp = /* @__PURE__ */ new Set(["h:mm AM/PM", "hh:mm AM/PM"]), sR = (e) => {
  var s, i;
  const t = (i = (s = Ko(e)) != null ? s : ks(e)) != null ? i : Go(e);
  if (!t) return null;
  const { v: n, z: r } = t;
  return r && (Np.has(r) || Tp.has(r) && !/\s(A|AM|P|PM)$/i.test(e) || r.includes("#,##0") && Uu(r, n) !== e) ? null : t;
}, iR = {
  sheetId: "",
  range: {
    startRow: -1,
    endRow: -1,
    startColumn: -1,
    endColumn: -1
  }
}, oR = {
  startRow: -1,
  startColumn: -1,
  endRow: -1,
  endColumn: -1
}, aR = {
  startRow: 0,
  startColumn: 0,
  endRow: 0,
  endColumn: 0
}, lR = {
  row: 0,
  column: 0
}, rt = {
  /**
   * fontFamily
   */
  ff: "Arial",
  /**
   * fontSize
   */
  fs: 11,
  /**
   * italic
   * 0: false
   * 1: true
   */
  it: ie.FALSE,
  /**
   * bold
   * 0: false
   * 1: true
   */
  bl: ie.FALSE,
  /**
   * underline
   */
  ul: {
    s: ie.FALSE
  },
  /**
   * strikethrough
   */
  st: {
    s: ie.FALSE
  },
  /**
   * overline
   */
  ol: {
    s: ie.FALSE
  },
  /**
   * textRotation
   */
  tr: {
    a: 0,
    /**
     * true : 1
     * false : 0
     */
    v: ie.FALSE
  },
  /**
   * textDirection
   */
  td: ms.UNSPECIFIED,
  /**
   * color
   */
  cl: {
    rgb: "#000000"
  },
  /**
   * background
   */
  bg: {
    rgb: "#fff"
  },
  /**
   * horizontalAlignment
   */
  ht: Ut.UNSPECIFIED,
  /**
   * verticalAlignment
   */
  vt: xn.UNSPECIFIED,
  /**
   * wrapStrategy
   */
  tb: Bn.UNSPECIFIED,
  /**
   * padding
   */
  pd: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  n: null,
  /**
   * border
   */
  bd: {
    b: null,
    l: null,
    r: null,
    t: null
  }
}, Mp = {
  id: "default_slide",
  title: "defaultSlide",
  pageSize: {
    width: 300,
    height: 300
  }
}, uR = [Dl, Hc, Ul], cR = {
  [qe.HEADING_1]: { fs: 20, bl: 1 },
  // Heading 1: 20pt, bold
  [qe.HEADING_2]: { fs: 18, bl: 1 },
  // Heading 2: 18pt, bold
  [qe.HEADING_3]: { fs: 16, bl: 1 },
  // Heading 3: 16pt, bold
  [qe.HEADING_4]: { fs: 14, bl: 1 },
  // Heading 4: 14pt, bold
  [qe.HEADING_5]: { fs: 12, bl: 1 },
  // Heading 5: 12pt, bold
  [qe.NORMAL_TEXT]: null,
  // Normal text: using global font size
  [qe.TITLE]: { fs: 26, bl: 1 },
  // Title: 26pt, bold
  [qe.SUBTITLE]: { fs: 15, cl: { rgb: "#999999" } },
  // Subtitle: 15pt
  [qe.NAMED_STYLE_TYPE_UNSPECIFIED]: null
}, wn = 4, hR = {
  [qe.HEADING_1]: {
    spaceAbove: {
      v: 20
    },
    spaceBelow: {
      v: 6 + wn
    }
  },
  [qe.HEADING_2]: {
    spaceAbove: {
      v: 18
    },
    spaceBelow: {
      v: 6 + wn
    }
  },
  [qe.HEADING_3]: {
    spaceAbove: {
      v: 16
    },
    spaceBelow: {
      v: 6 + wn
    }
  },
  [qe.HEADING_4]: {
    spaceAbove: {
      v: 14
    },
    spaceBelow: {
      v: 4 + wn
    }
  },
  [qe.HEADING_5]: {
    spaceAbove: {
      v: 12
    },
    spaceBelow: {
      v: 4 + wn
    }
  },
  [qe.NORMAL_TEXT]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 0
    }
  },
  [qe.TITLE]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 3 + wn
    }
  },
  [qe.SUBTITLE]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 16
    }
  },
  [qe.NAMED_STYLE_TYPE_UNSPECIFIED]: null
}, dR = "univer-sheets-chart-print-chart", fR = "univer-docs-drawing-printing";
var Lp = /* @__PURE__ */ ((e) => (e.ARRAY_CONVERTOR = "ARRAY_CONVERTOR", e.MATRIX_CONVERTOR = "MATRIX_CONVERTOR", e))(Lp || {});
const mR = {
  [gt.A3]: {
    width: 1123,
    height: 1587
  },
  [gt.A4]: {
    width: 794,
    height: 1124
  },
  [gt.A5]: {
    width: 559,
    height: 794
  },
  [gt.B4]: {
    width: 944,
    height: 1344
  },
  [gt.B5]: {
    width: 665,
    height: 944
  },
  [gt.Executive]: {
    width: 696,
    height: 1008
  },
  [gt.Folio]: {
    width: 816,
    height: 1248
  },
  [gt.Legal]: {
    width: 816,
    height: 1344
  },
  [gt.Letter]: {
    width: 816,
    height: 1056
  },
  [gt.Statement]: {
    width: 528,
    height: 816
  },
  [gt.Tabloid]: {
    width: 1056,
    height: 1632
  }
};
function Yr(e, t) {
  const { textRuns: n = [] } = t;
  let r = 0;
  for (const i of n) {
    const { ts: o = {}, st: a, ed: l } = i;
    if (o[e] == null)
      return ie.FALSE;
    switch (e) {
      case "bl":
      // fallthrough
      case "it": {
        if (o[e] === ie.FALSE)
          return ie.FALSE;
        break;
      }
      case "ul":
      // fallthrough
      case "st": {
        if (o[e].s === ie.FALSE)
          return ie.FALSE;
        break;
      }
      default:
        throw new Error(`unknown style key: ${e} in IStyleBase`);
    }
    r += l - a;
  }
  return t.dataStream.indexOf(`\r
`) === r ? ie.TRUE : ie.FALSE;
}
const Cr = class Cr {
  constructor(t, n, r) {
    p(this, "_range");
    p(this, "_worksheet");
    this._deps = r, this._range = n, this._worksheet = t;
  }
  static foreach(t, n) {
    const { startRow: r, startColumn: s, endRow: i, endColumn: o } = t;
    for (let a = r; a <= i; a++)
      for (let l = s; l <= o; l++)
        n(a, l);
  }
  /**
   * get current range data
   *
   * @returns current range
   */
  getRangeData() {
    return this._range;
  }
  /**
   * Returns the value of the top-left cell in the range. The value may be of type Number, Boolean, Date, or String
   * depending on the value of the cell. Empty cells return an empty string.
   * @returns  The value in this cell
   */
  getValue() {
    return this.getValues()[0][0];
  }
  /**
   * Returns the rectangular grid of values for this range.
   *
   * Returns a two-dimensional array of values, indexed by row, then by column. The values may be of type Number,
   * Boolean, Date, or String, depending on the value of the cell. Empty cells are represented by an empty string
   * in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
   *
   * In web apps, a Date value isn't a legal parameter. getValues() fails to return data to a web app if the range
   * contains a cell with a Date value. Instead, transform all the values retrieved from the sheet to a supported
   * JavaScript primitive like a Number, Boolean, or String.
   *
   * @returns  A two-dimensional array of values.
   */
  getValues() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = [];
    for (let o = t; o <= n; o++) {
      const a = [];
      for (let l = r; l <= s; l++)
        a.push(this.getMatrix().getValue(o, l) || null);
      i.push(a);
    }
    return i;
  }
  /**
   * get range matrix
   *
   * @returns range matrix
   */
  getMatrix() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = this._worksheet.getCellMatrix(), o = new pt();
    for (let a = t; a <= n; a++)
      for (let l = r; l <= s; l++)
        o.setValue(a, l, i.getValue(a, l) || null);
    return o;
  }
  /**
   * get range matrix object
   *
   * @returns range matrix object
   */
  getMatrixObject() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = this._worksheet.getCellMatrix(), o = new pt();
    for (let a = t; a <= n; a++)
      for (let l = r; l <= s; l++)
        o.setValue(a - t, l - r, i.getValue(a, l) || {});
    return o;
  }
  /**
   * Returns a string description of the range, in A1 notation.
   *
   * @returns The string description of the range in A1 notation.
   */
  getA1Notation() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range;
    let i, o;
    return r < s ? (i = J.numToWord(r + 1) + (t + 1), o = J.numToWord(s + 1) + (n + 1)) : (i = J.numToWord(s + 1) + (n + 1), o = J.numToWord(r + 1) + (t + 1)), i === o ? `${i}` : `${i}:${o}`;
  }
  /**
   * Returns the background color of the top-left cell in the range (for example, '#ffffff').
   *
   * @returns  The color code of the background.
   */
  getBackground() {
    return this.getBackgrounds()[0][0];
  }
  /**
   * Returns the background colors of the cells in the range (for example, '#ffffff').
   *
   * @returns   A two-dimensional array of color codes of the backgrounds.
   */
  getBackgrounds() {
    const t = this._deps.getStyles();
    return this.getValues().map(
      (n) => n.map((r) => {
        var i;
        const s = t.getStyleByCell(r);
        return ((i = s == null ? void 0 : s.bg) == null ? void 0 : i.rgb) || rt.bg.rgb;
      })
    );
  }
  /**
   * Returns a given cell within a range.
   *
   * The row and column here are relative to the range
   * e.g. "B2:D4", getCell(0,0) in this code returns the cell at B2
   * @returns   A range containing a single cell at the specified coordinates.
   */
  getCell(t, n) {
    const { startRow: r, startColumn: s } = this._range, i = {
      startRow: r + t,
      endRow: r + t,
      startColumn: s + n,
      endColumn: s + n
    };
    return new Cr(this._worksheet, i, this._deps);
  }
  /**
   * Returns the starting column position for this range
   *
   * @returns   The range's starting column position in the spreadsheet.
   */
  getColumn() {
    return this._range.startColumn;
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   */
  getObjectValue(t = {}) {
    return this.getObjectValues(t)[0][0];
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   *
   * @param options set whether to include style
   * @returns Returns a value in object format
   */
  getObjectValues(t = {}) {
    var a;
    const { startRow: n, endRow: r, startColumn: s, endColumn: i } = this._range, o = this._worksheet.getCellMatrix().getFragment(n, r, s, i).getData();
    if (t.isIncludeStyle) {
      const l = this._deps.getStyles();
      for (let u = 0; u <= r - n; u++)
        for (let c = 0; c <= i - s; c++) {
          if (o == null || ((a = o == null ? void 0 : o[u]) == null ? void 0 : a[c]) == null)
            continue;
          const h = o[u][c].s;
          h && (o[u][c].s = l.get(h));
        }
    }
    return o;
  }
  /**
   * Returns the font color of the cell in the top-left corner of the range, in CSS notation
   */
  getFontColor() {
    return this.getFontColors()[0][0];
  }
  /**
   * Returns the font colors of the cells in the range in CSS notation (such as '#ffffff' or 'white').
   */
  getFontColors() {
    const t = this._deps.getStyles();
    return this.getValues().map(
      (n) => n.map((r) => {
        var i;
        const s = t.getStyleByCell(r);
        return ((i = s == null ? void 0 : s.cl) == null ? void 0 : i.rgb) || rt.cl.rgb;
      })
    );
  }
  /**
   * Returns the font families of the cells in the range.
   */
  getFontFamilies() {
    return this._getStyles("ff");
  }
  /**
   * Returns the font family of the cell in the top-left corner of the range.
   */
  getFontFamily() {
    return this.getFontFamilies()[0][0];
  }
  /**
   * Returns the underlines of the cells in the range.
   */
  getUnderlines() {
    return this._getStyles("ul");
  }
  /**
   * Returns the underline of the cells in the range.
   */
  getUnderline() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("ul", t.body) === ie.TRUE ? {
      s: ie.TRUE
    } : {
      s: ie.FALSE
    } : this.getUnderlines()[0][0];
  }
  /**
   * Returns the overlines of the cells in the range.
   */
  getOverlines() {
    return this._getStyles("ol");
  }
  /**
   * Returns the overline of the cells in the range.
   */
  getOverline() {
    return this.getOverlines()[0][0];
  }
  /**
   * Returns the strikeThrough of the cells in the range.
   */
  getStrikeThrough() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("st", t.body) === ie.TRUE ? {
      s: ie.TRUE
    } : {
      s: ie.FALSE
    } : this.getStrikeThroughs()[0][0];
  }
  /**
   * Returns the strikeThroughs of the cells in the range.
   */
  getStrikeThroughs() {
    return this._getStyles("st");
  }
  /**
   * Returns the font size in point size of the cell in the top-left corner of the range.
   */
  getFontSize() {
    var n, r;
    const t = ((n = this.getValue()) == null ? void 0 : n.p) || {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? t.body.textRuns.some((s) => {
      var i;
      return ((i = s == null ? void 0 : s.ts) == null ? void 0 : i.fs) != null;
    }) ? Math.max(...t.body.textRuns.map((s) => {
      var i;
      return ((i = s == null ? void 0 : s.ts) == null ? void 0 : i.fs) || 0;
    })) : this.getFontSizes()[0][0] : this.getFontSizes()[0][0];
  }
  /**
   * Returns the font sizes of the cells in the range.
   */
  getFontSizes() {
    return this._getStyles("fs");
  }
  /**
   * Returns the border info of the cells in the range.
   */
  getBorder() {
    return this.getBorders()[0][0];
  }
  getBorders() {
    return this._getStyles("bd");
  }
  /**
   * Returns the font style ('italic' or 'normal') of the cell in the top-left corner of the range.
   */
  getFontStyle() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("it", t.body) === ie.TRUE ? wi.ITALIC : wi.NORMAL : this._getFontStyles()[0][0];
  }
  /**
   * Returns the font styles of the cells in the range.
   */
  _getFontStyles() {
    return this._getStyles("it");
  }
  /**
   * Returns the font weight (normal/bold) of the cell in the top-left corner of the range.
   * If the cell has rich text, the return value according to the textRuns of the rich text,
   * when all styles of textRuns are bold, it will return FontWeight.BOLD,
   * otherwise return FontWeight.NORMAL.
   */
  getFontWeight() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? Yr("bl", t.body) === ie.TRUE ? Si.BOLD : Si.NORMAL : this._getFontWeights()[0][0];
  }
  /**
   * Returns the font weights of the cells in the range.
   */
  _getFontWeights() {
    return this._getStyles("bl");
  }
  /**
   * Returns the grid ID of the range's parent sheet.
   */
  getGridId() {
    return this._worksheet.getSheetId();
  }
  /**
   * Returns the height of the range.
   */
  getHeight() {
    const { _range: t, _worksheet: n } = this, { startRow: r, endRow: s } = t;
    let i = 0;
    for (let o = 0; o <= s - r; o++) {
      const a = n.getRowHeight(o);
      i += a;
    }
    return i;
  }
  /**
   *     Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left corner of the range.
   */
  getHorizontalAlignment() {
    return this.getHorizontalAlignments()[0][0];
  }
  /**
   *Returns the horizontal alignments of the cells in the range.
   */
  getHorizontalAlignments() {
    return this._getStyles("ht");
  }
  /**
   * Returns the end column position.
   */
  getLastColumn() {
    return this._range.endColumn;
  }
  /**
   *     Returns the end row position.
   */
  getLastRow() {
    return this._range.endRow;
  }
  /**
   * Returns the number of columns in this range.
   */
  getNumColumns() {
    const { startColumn: t, endColumn: n } = this._range;
    return n - t + 1;
  }
  /**
   * Returns the number of rows in this range.
   */
  getNumRows() {
    const { startRow: t, endRow: n } = this._range;
    return n - t + 1;
  }
  /**
   * Returns the Rich Text value for the top left cell of the range, or null if the cell value is not text.
   */
  getRichTextValue() {
    return this.getRichTextValues()[0][0];
  }
  /**
   * Returns the Rich Text values for the cells in the range.
   */
  getRichTextValues() {
    return this.getValues().map((t) => t.map((n) => (n == null ? void 0 : n.p) || ""));
  }
  /**
   * Returns the row position for this range.
   */
  getRowIndex() {
    return this._range.startRow;
  }
  /**
   * Returns the sheet this range belongs to.
   */
  getSheet() {
    return this._worksheet;
  }
  /**
   * Returns the text direction for the top left cell of the range.
   */
  getTextDirection() {
    return this.getTextDirections()[0][0];
  }
  /**
   * Returns the text directions for the cells in the range.
   */
  getTextDirections() {
    return this._getStyles("td");
  }
  /**
   * Returns the text rotation settings for the top left cell of the range.
   */
  // getTextRotation(): number {
  getTextRotation() {
    return this.getTextRotations()[0][0];
  }
  /**
   * Returns the text rotation settings for the cells in the range.
   */
  // getTextRotations(): number[][] {
  getTextRotations() {
    return this._getStyles("tr");
  }
  /**
   *     Returns the text style for the top left cell of the range.
   */
  getTextStyle() {
    return this.getTextStyles()[0][0];
  }
  /**
   * Returns the text styles for the cells in the range.
   */
  getTextStyles() {
    const t = this._deps.getStyles();
    return this.getValues().map((n) => n.map((r) => t.getStyleByCell(r)));
  }
  /**
   * Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner of the range.
   */
  getVerticalAlignment() {
    return this.getVerticalAlignments()[0][0];
  }
  /**
   * Returns the vertical alignments of the cells in the range.
   */
  getVerticalAlignments() {
    return this._getStyles("vt");
  }
  /**
   * Returns the width of the range in columns.
   */
  getWidth() {
    const { _range: t, _worksheet: n } = this, { startColumn: r, endColumn: s } = t;
    let i = 0;
    for (let o = 0; o <= s - r; o++)
      i += n.getColumnWidth(o);
    return i;
  }
  /**
   * Returns whether the text in the cell wraps.
   */
  getWrap() {
    return this.getWrapStrategy() === Bn.WRAP ? ie.TRUE : ie.FALSE;
  }
  /**
   * Returns the text wrapping strategies for the cells in the range.
   */
  getWrapStrategies() {
    return this._getStyles("tb");
  }
  /**
   * Returns the text wrapping strategy for the top left cell of the range.
   */
  getWrapStrategy() {
    return this.getWrapStrategies()[0][0];
  }
  forEach(t) {
    Cr.foreach(this._range, t);
  }
  /**
   *
   * @param arg Shorthand for the style that gets
   * @returns style value
   */
  _getStyles(t) {
    const n = this._deps.getStyles();
    return this.getValues().map(
      (r) => r.map((s) => {
        const i = n && n.getStyleByCell(s);
        return i && i[t] || rt[t];
      })
    );
  }
};
p(Cr, "transformRange", (t, n) => {
  const r = n.getMaxColumns() - 1, s = n.getMaxRows() - 1;
  return t.rangeType === ge.ALL ? {
    startColumn: 0,
    startRow: 0,
    endColumn: r,
    endRow: s
  } : t.rangeType === ge.COLUMN ? {
    startRow: 0,
    endRow: s,
    startColumn: t.startColumn,
    endColumn: t.endColumn
  } : t.rangeType === ge.ROW ? {
    startColumn: 0,
    endColumn: r,
    startRow: t.startRow,
    endRow: t.endRow
  } : {
    startColumn: t.startColumn,
    endColumn: Math.min(t.endColumn, r),
    startRow: t.startRow,
    endRow: Math.min(t.endRow, s)
  };
});
let Or = Cr;
function ku(e, t, n = 0, r = e.length - 1, s = xp) {
  for (; r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, u = t - n + 1, c = Math.log(l), h = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * h * (l - h) / l) * (u - l / 2 < 0 ? -1 : 1), f = Math.max(n, Math.floor(t - u * h / l + d)), g = Math.min(r, Math.floor(t + (l - u) * h / l + d));
      ku(e, t, f, g, s);
    }
    const i = e[t];
    let o = n, a = r;
    for (Qn(e, n, t), s(e[r], i) > 0 && Qn(e, n, r); o < a; ) {
      for (Qn(e, o, a), o++, a--; s(e[o], i) < 0; ) o++;
      for (; s(e[a], i) > 0; ) a--;
    }
    s(e[n], i) === 0 ? Qn(e, n, a) : (a++, Qn(e, a, r)), a <= t && (n = a + 1), t <= a && (r = a - 1);
  }
}
function Qn(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function xp(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
class Di {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const r = [];
    if (!Vr(t, n)) return r;
    const s = this.toBBox, i = [];
    for (; n; ) {
      for (let o = 0; o < n.children.length; o++) {
        const a = n.children[o], l = n.leaf ? s(a) : a;
        Vr(t, l) && (n.leaf ? r.push(a) : ci(t, l) ? this._all(a, r) : i.push(a));
      }
      n = i.pop();
    }
    return r;
  }
  collides(t) {
    let n = this.data;
    if (!Vr(t, n)) return !1;
    const r = [];
    for (; n; ) {
      for (let s = 0; s < n.children.length; s++) {
        const i = n.children[s], o = n.leaf ? this.toBBox(i) : i;
        if (Vr(t, o)) {
          if (n.leaf || ci(t, o)) return !0;
          r.push(i);
        }
      }
      n = r.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let r = 0; r < t.length; r++)
        this.insert(t[r]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const r = this.data;
        this.data = n, n = r;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = yn([]), this;
  }
  remove(t, n) {
    if (!t) return this;
    let r = this.data;
    const s = this.toBBox(t), i = [], o = [];
    let a, l, u;
    for (; r || i.length; ) {
      if (r || (r = i.pop(), l = i[i.length - 1], a = o.pop(), u = !0), r.leaf) {
        const c = Dp(t, r.children, n);
        if (c !== -1)
          return r.children.splice(c, 1), i.push(r), this._condense(i), this;
      }
      !u && !r.leaf && ci(r, s) ? (i.push(r), o.push(a), a = 0, l = r, r = r.children[0]) : l ? (a++, r = l.children[a], u = !1) : r = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const r = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : r.push(...t.children), t = r.pop();
    return n;
  }
  _build(t, n, r, s) {
    const i = r - n + 1;
    let o = this._maxEntries, a;
    if (i <= o)
      return a = yn(t.slice(n, r + 1)), Sn(a, this.toBBox), a;
    s || (s = Math.ceil(Math.log(i) / Math.log(o)), o = Math.ceil(i / Math.pow(o, s - 1))), a = yn([]), a.leaf = !1, a.height = s;
    const l = Math.ceil(i / o), u = l * Math.ceil(Math.sqrt(o));
    ol(t, n, r, u, this.compareMinX);
    for (let c = n; c <= r; c += u) {
      const h = Math.min(c + u - 1, r);
      ol(t, c, h, l, this.compareMinY);
      for (let d = c; d <= h; d += l) {
        const f = Math.min(d + l - 1, h);
        a.children.push(this._build(t, d, f, s - 1));
      }
    }
    return Sn(a, this.toBBox), a;
  }
  _chooseSubtree(t, n, r, s) {
    for (; s.push(n), !(n.leaf || s.length - 1 === r); ) {
      let i = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < n.children.length; l++) {
        const u = n.children[l], c = ui(u), h = Pp(t, u) - c;
        h < o ? (o = h, i = c < i ? c : i, a = u) : h === o && c < i && (i = c, a = u);
      }
      n = a || n.children[0];
    }
    return n;
  }
  _insert(t, n, r) {
    const s = r ? t : this.toBBox(t), i = [], o = this._chooseSubtree(s, this.data, n, i);
    for (o.children.push(t), mr(o, s); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(s, i, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const r = t[n], s = r.children.length, i = this._minEntries;
    this._chooseSplitAxis(r, i, s);
    const o = this._chooseSplitIndex(r, i, s), a = yn(r.children.splice(o, r.children.length - o));
    a.height = r.height, a.leaf = r.leaf, Sn(r, this.toBBox), Sn(a, this.toBBox), n ? t[n - 1].children.push(a) : this._splitRoot(r, a);
  }
  _splitRoot(t, n) {
    this.data = yn([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, Sn(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, r) {
    let s, i = 1 / 0, o = 1 / 0;
    for (let a = n; a <= r - n; a++) {
      const l = fr(t, 0, a, this.toBBox), u = fr(t, a, r, this.toBBox), c = Fp(l, u), h = ui(l) + ui(u);
      c < i ? (i = c, s = a, o = h < o ? h : o) : c === i && h < o && (o = h, s = a);
    }
    return s || r - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, r) {
    const s = t.leaf ? this.compareMinX : Up, i = t.leaf ? this.compareMinY : kp, o = this._allDistMargin(t, n, r, s), a = this._allDistMargin(t, n, r, i);
    o < a && t.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, r, s) {
    t.children.sort(s);
    const i = this.toBBox, o = fr(t, 0, n, i), a = fr(t, r - n, r, i);
    let l = zr(o) + zr(a);
    for (let u = n; u < r - n; u++) {
      const c = t.children[u];
      mr(o, t.leaf ? i(c) : c), l += zr(o);
    }
    for (let u = r - n - 1; u >= n; u--) {
      const c = t.children[u];
      mr(a, t.leaf ? i(c) : c), l += zr(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, n, r) {
    for (let s = r; s >= 0; s--)
      mr(n[s], t);
  }
  _condense(t) {
    for (let n = t.length - 1, r; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (r = t[n - 1].children, r.splice(r.indexOf(t[n]), 1)) : this.clear() : Sn(t[n], this.toBBox);
  }
}
function Dp(e, t, n) {
  if (!n) return t.indexOf(e);
  for (let r = 0; r < t.length; r++)
    if (n(e, t[r])) return r;
  return -1;
}
function Sn(e, t) {
  fr(e, 0, e.children.length, t, e);
}
function fr(e, t, n, r, s) {
  s || (s = yn(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let i = t; i < n; i++) {
    const o = e.children[i];
    mr(s, e.leaf ? r(o) : o);
  }
  return s;
}
function mr(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function Up(e, t) {
  return e.minX - t.minX;
}
function kp(e, t) {
  return e.minY - t.minY;
}
function ui(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function zr(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Pp(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function Fp(e, t) {
  const n = Math.max(e.minX, t.minX), r = Math.max(e.minY, t.minY), s = Math.min(e.maxX, t.maxX), i = Math.min(e.maxY, t.maxY);
  return Math.max(0, s - n) * Math.max(0, i - r);
}
function ci(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function Vr(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function yn(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function ol(e, t, n, r, s) {
  const i = [t, n];
  for (; i.length; ) {
    if (n = i.pop(), t = i.pop(), n - t <= r) continue;
    const o = t + Math.ceil((n - t) / r / 2) * r;
    ku(e, o, t, n, s), i.push(t, o, o, n);
  }
}
function gR(e, t, n, r = !1) {
  if (t === 0 && n === 0)
    return e;
  let s = { ...e };
  const i = s.startAbsoluteRefType || ye.NONE, o = s.endAbsoluteRefType || ye.NONE, a = s.rangeType || ge.NORMAL;
  if (!r && i === ye.ALL && o === ye.ALL)
    return s;
  const l = al(s.startRow, n, s.startColumn, t, a), u = al(s.endRow, n, s.endColumn, t, a);
  return r || i === ye.NONE && o === ye.NONE ? s = {
    ...s,
    startRow: l.row,
    startColumn: l.column,
    endRow: u.row,
    endColumn: u.column
  } : (i === ye.NONE ? s = { ...s, startRow: l.row, startColumn: l.column } : i === ye.COLUMN ? s = { ...s, startRow: l.row } : i === ye.ROW && (s = { ...s, startColumn: l.column }), o === ye.NONE ? s = { ...s, endRow: u.row, endColumn: u.column } : o === ye.COLUMN ? s = { ...s, endRow: u.row } : o === ye.ROW && (s = { ...s, endColumn: u.column }), s);
}
function al(e, t, n, r, s) {
  return s === ge.NORMAL ? { row: e + t, column: n + r } : s === ge.ROW ? { row: e + t, column: n } : s === ge.COLUMN ? { row: e, column: n + r } : { row: e, column: n };
}
function Pu(e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (const o of e)
    t.add(o.startColumn), t.add(o.endColumn + 1), n.add(o.startRow), n.add(o.endRow + 1);
  const r = Array.from(t).sort((o, a) => o - a), s = Array.from(n).sort((o, a) => o - a);
  e.sort((o, a) => o.startRow - a.startRow || o.startColumn - a.startColumn);
  const i = [];
  for (let o = 0; o < s.length - 1; o++)
    for (let a = 0; a < r.length - 1; a++) {
      const l = r[a], u = r[a + 1] - 1, c = s[o], h = s[o + 1] - 1;
      for (const d of e) {
        if (d.startRow > h)
          break;
        if (d.startRow <= c && d.endRow >= h && d.startColumn <= l && d.endColumn >= u) {
          i.push({
            startColumn: l,
            endColumn: u,
            startRow: c,
            endRow: h
          });
          break;
        }
      }
    }
  return i;
}
function $p(e) {
  e.sort((r, s) => r.startRow - s.startRow || r.startColumn - s.startColumn);
  const t = {};
  for (const r of e)
    t[r.startRow] || (t[r.startRow] = []), t[r.startRow].push(r);
  const n = [];
  for (const r in t) {
    const s = t[+r];
    s.sort((o, a) => o.startColumn - a.startColumn);
    let i = s[0];
    for (let o = 1; o < s.length; o++) {
      const a = s[o];
      a.startColumn <= i.endColumn + 1 && a.startRow === i.startRow && a.endRow === i.endRow ? i.endColumn = Math.max(i.endColumn, a.endColumn) : (n.push(i), i = a);
    }
    n.push(i);
  }
  return n;
}
function Hp(e) {
  e.sort((r, s) => r.startColumn - s.startColumn || r.startRow - s.startRow);
  const t = {};
  for (const r of e)
    t[r.startColumn] || (t[r.startColumn] = []), t[r.startColumn].push(r);
  const n = [];
  for (const r in t) {
    const s = t[+r];
    s.sort((o, a) => o.startRow - a.startRow);
    let i = s[0];
    for (let o = 1; o < s.length; o++) {
      const a = s[o];
      a.startRow <= i.endRow + 1 && a.startColumn === i.startColumn && a.endColumn === i.endColumn ? i.endRow = Math.max(i.endRow, a.endRow) : (n.push(i), i = a);
    }
    n.push(i);
  }
  return n;
}
function Bp(e) {
  const t = Pu(e), n = $p(t);
  return Hp(n);
}
function jp(e, t) {
  const n = [];
  return e.forEach((r) => {
    n.push(...En.subtract(r, t));
  }), En.mergeRanges(n);
}
function Wp(e, t) {
  const n = ll(
    e.startRow,
    e.endRow,
    t.startRow,
    t.endRow
  ), r = ll(
    e.startColumn,
    e.endColumn,
    t.startColumn,
    t.endColumn
  );
  if (!n || !r)
    return null;
  const [s, i] = n, [o, a] = r, l = Yp(
    e.rangeType,
    t.rangeType,
    s,
    i,
    o,
    a
  );
  return {
    startRow: s,
    endRow: i,
    startColumn: o,
    endColumn: a,
    rangeType: l
  };
}
function ll(e, t, n, r) {
  const s = isNaN(e) ? -1 / 0 : e, i = isNaN(t) ? 1 / 0 : t, o = isNaN(n) ? -1 / 0 : n, a = isNaN(r) ? 1 / 0 : r, l = Math.max(s, o), u = Math.min(i, a);
  if (l <= u) {
    const c = l === -1 / 0 ? Number.NaN : l, h = u === 1 / 0 ? Number.NaN : u;
    return [c, h];
  } else
    return null;
}
function Yp(e, t, n, r, s, i) {
  const o = e !== void 0 ? e : ul(n, r, s, i), a = t !== void 0 ? t : ul(n, r, s, i);
  return o === ge.ALL || a === ge.ALL ? o === a ? o : o === ge.ALL ? a : o : o === a ? o : (o === ge.NORMAL || a === ge.NORMAL, ge.NORMAL);
}
function ul(e, t, n, r) {
  const s = !isNaN(e) && !isNaN(t), i = !isNaN(n) && !isNaN(r);
  return s && i ? ge.NORMAL : s ? ge.ROW : i ? ge.COLUMN : ge.ALL;
}
const Yt = class Yt {
  /**
   * Creates a deep copy of an IRange object
   * @param src
   * @example
   * ```typescript
   * const original = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const copy = Rectangle.clone(original);
   * // copy = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ```
   */
  static clone(t) {
    return t.rangeType !== void 0 ? {
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn,
      rangeType: t.rangeType
    } : {
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn
    };
  }
  /**
   * Checks if two ranges are equal by comparing their properties
   * @param src
   * @param target
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const areEqual = Rectangle.equals(range1, range2); // true
   * ```
   */
  static equals(t, n) {
    return t == null || n == null ? !1 : t.endRow === n.endRow && t.endColumn === n.endColumn && t.startRow === n.startRow && t.startColumn === n.startColumn && (t.rangeType === n.rangeType || t.rangeType === void 0 && n.rangeType === ge.NORMAL || n.rangeType === void 0 && t.rangeType === ge.NORMAL);
  }
  /**
   * Quickly checks if two normal ranges intersect. For specialized range types,
   * use the intersects() method instead.
   * @param rangeA
   * @param rangeB
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const doIntersect = Rectangle.simpleRangesIntersect(range1, range2); // true
   * ```
   */
  static simpleRangesIntersect(t, n) {
    const { startRow: r, endRow: s, startColumn: i, endColumn: o } = t, { startRow: a, endRow: l, startColumn: u, endColumn: c } = n, h = r <= l && s >= a, d = i <= c && o >= u;
    return h && d;
  }
  /**
   * Checks if two ranges intersect, handling special range types (ROW, COLUMN)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   startColumn: NaN, endColumn: NaN,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const colRange = {
   *   startRow: NaN, endRow: NaN,
   *   startColumn: 0, endColumn: 2,
   *   rangeType: RANGE_TYPE.COLUMN
   * };
   * const doIntersect = Rectangle.intersects(rowRange, colRange); // true
   * ```
   */
  static intersects(t, n) {
    if (t.rangeType === ge.ROW && n.rangeType === ge.COLUMN || t.rangeType === ge.COLUMN && n.rangeType === ge.ROW)
      return !0;
    if (t.rangeType === ge.ROW && n.rangeType === ge.ROW)
      return t.startRow <= n.endRow && t.endRow >= n.startRow;
    if (t.rangeType === ge.COLUMN && n.rangeType === ge.COLUMN)
      return t.startColumn <= n.endColumn && t.endColumn >= n.startColumn;
    const r = Math.floor(Number.MAX_SAFE_INTEGER / 10), s = Number.isNaN(t.startRow) ? 0 : t.startRow, i = Number.isNaN(t.endRow) ? r : t.endRow, o = Number.isNaN(t.startColumn) ? 0 : t.startColumn, a = Number.isNaN(t.endColumn) ? r : t.endColumn, l = Number.isNaN(n.startRow) ? 0 : n.startRow, u = Number.isNaN(n.endRow) ? r : n.endRow, c = Number.isNaN(n.startColumn) ? 0 : n.startColumn, h = Number.isNaN(n.endColumn) ? r : n.endColumn, d = Math.abs(o + a - c - h), f = Math.abs(o - a) + Math.abs(c - h), g = Math.abs(s + i - l - u), _ = Math.abs(s - i) + Math.abs(l - u);
    return d <= f && g <= _;
  }
  /**
   * Checks if any of the ranges in the target array intersect with any of the ranges in the source array.
   * Attention! Please make sure there is no NaN in the ranges.
   * @param src
   * @param target
   * @example
   * ```typescript
   * const ranges1 = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 3, startColumn: 3, endRow: 5, endColumn: 5 }
   * ];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 4, endColumn: 4 },
   *   { startRow: 6, startColumn: 6, endRow: 8, endColumn: 8 }
   * ];
   * const doIntersect = Rectangle.doAnyRangesIntersect(ranges1, ranges2); // true
   * ```
   */
  static doAnyRangesIntersect(t, n) {
    const r = new Di();
    return r.load(t.map((s) => ({ minX: s.startColumn, minY: s.startRow, maxX: s.endColumn, maxY: s.endRow }))), n.some((s) => r.search({ minX: s.startColumn, minY: s.startRow, maxX: s.endColumn, maxY: s.endRow }).length > 0);
  }
  /**
   * Gets the intersection range between two ranges
   * @param src
   * @param target
   * @deprecated use `getIntersectRange` instead
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const intersection = Rectangle.getIntersects(range1, range2);
   * // intersection = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ```
   */
  static getIntersects(t, n) {
    const r = t.startRow, s = t.endRow, i = t.startColumn, o = t.endColumn, a = n.startRow, l = n.endRow, u = n.startColumn, c = n.endColumn;
    let h, d, f, g;
    if (a <= s)
      a >= r ? d = a : d = r;
    else
      return null;
    if (l >= r)
      l >= s ? g = s : g = l;
    else
      return null;
    if (u <= o)
      u > i ? h = u : h = i;
    else
      return null;
    if (c >= i)
      c >= o ? f = o : f = c;
    else
      return null;
    return {
      startRow: d,
      endRow: g,
      startColumn: h,
      endColumn: f,
      rangeType: ge.NORMAL
      // TODO: this may not be accurate
    };
  }
  /**
   * Checks if one range completely contains another range
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const inner = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const contains = Rectangle.contains(outer, inner); // true
   * ```
   */
  static contains(t, n) {
    return t.startRow <= n.startRow && t.endRow >= n.endRow && t.startColumn <= n.startColumn && t.endColumn >= n.endColumn;
  }
  /**
   * Checks if one range strictly contains another range (not equal)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const same = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const realContains = Rectangle.realContain(outer, same); // false
   * ```
   */
  static realContain(t, n) {
    return Yt.contains(t, n) && (t.startRow < n.startRow || t.endRow > n.endRow || t.startColumn < n.startColumn || t.endColumn > n.endColumn);
  }
  /**
   * Creates a union range that encompasses all input ranges
   * @param {...any} ranges
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 };
   * const union = Rectangle.union(range1, range2);
   * // union = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }
   * ```
   */
  static union(...t) {
    return t.reduce(
      (n, r) => ({
        startRow: Math.min(n.startRow, r.startRow),
        startColumn: Math.min(n.startColumn, r.startColumn),
        endRow: Math.max(n.endRow, r.endRow),
        endColumn: Math.max(n.endColumn, r.endColumn),
        rangeType: ge.NORMAL
      }),
      t[0]
    );
  }
  /**
   * Creates a union range considering special range types (ROW, COLUMN)
   * @param {...any} ranges
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const normalRange = {
   *   startRow: 1, startColumn: 1,
   *   endRow: 3, endColumn: 3
   * };
   * const union = Rectangle.realUnion(rowRange, normalRange);
   * // Result will have NaN for columns due to ROW type
   * ```
   */
  static realUnion(...t) {
    const n = t.some((i) => i.rangeType === ge.COLUMN), r = t.some((i) => i.rangeType === ge.ROW), s = Yt.union(...t);
    return {
      startColumn: r ? Number.NaN : s.startColumn,
      endColumn: r ? Number.NaN : s.endColumn,
      startRow: n ? Number.NaN : s.startRow,
      endRow: n ? Number.NaN : s.endRow,
      rangeType: r ? ge.ROW : n ? ge.COLUMN : ge.NORMAL
    };
  }
  /**
   * Subtracts one range from another, returning the remaining areas as separate ranges
   * @param range1
   * @param range2
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const result = Rectangle.subtract(range1, range2);
   * // Results in up to 4 ranges representing the non-overlapping areas
   * ```
   */
  static subtract(t, n) {
    if (n.startRow > t.endRow || n.endRow < t.startRow || n.startColumn > t.endColumn || n.endColumn < t.startColumn)
      return [t];
    const r = [];
    n.startRow >= t.startRow && r.push({
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: n.startRow - 1,
      endColumn: t.endColumn
    }), n.endRow <= t.endRow && r.push({
      startRow: n.endRow + 1,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn
    });
    const s = Math.max(t.startRow, n.startRow), i = Math.min(t.endRow, n.endRow);
    return n.startColumn >= t.startColumn && r.push({
      startRow: s,
      startColumn: t.startColumn,
      endRow: i,
      endColumn: n.startColumn - 1
    }), n.endColumn <= t.endColumn && r.push({
      startRow: s,
      startColumn: n.endColumn + 1,
      endRow: i,
      endColumn: t.endColumn
    }), r.filter((a) => a.startRow <= a.endRow && a.startColumn <= a.endColumn);
  }
  /**
   * Merges overlapping or adjacent ranges into larger ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 },
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ];
   * const merged = Rectangle.mergeRanges(ranges);
   * // Combines overlapping ranges into larger ones
   * ```
   */
  static mergeRanges(t) {
    return Bp(t);
  }
  /**
   * Splits overlapping ranges into a grid of non-overlapping ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 }
   * ];
   * const grid = Rectangle.splitIntoGrid(ranges);
   * // Splits into non-overlapping grid sections
   * ```
   */
  static splitIntoGrid(t) {
    return Pu(t);
  }
  /**
   * Subtracts multiple ranges from multiple ranges
   * @param ranges1
   * @param ranges2
   * @example
   * ```typescript
   * const ranges1 = [{ startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 },
   *   { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 }
   * ];
   * const result = Rectangle.subtractMulti(ranges1, ranges2);
   * // Returns remaining non-overlapping areas
   * ```
   */
  static subtractMulti(t, n) {
    if (!n.length)
      return t;
    let r = t;
    return n.forEach((s) => {
      r = jp(r, s);
    }), r;
  }
  /**
   * Checks if two rectangles defined by left, top, right, bottom coordinates intersect
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersects = Rectangle.hasIntersectionBetweenTwoRect(rect1, rect2); // true
   * ```
   */
  static hasIntersectionBetweenTwoRect(t, n) {
    return !(t.left > n.right || // rect1  rect2 
    t.right < n.left || // rect1  rect2 
    t.top > n.bottom || // rect1  rect2 
    t.bottom < n.top);
  }
  /**
   * Gets the intersection area between two rectangles defined by LTRB coordinates
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersection = Rectangle.getIntersectionBetweenTwoRect(rect1, rect2);
   * // Returns { left: 5, top: 5, right: 10, bottom: 10, width: 5, height: 5 }
   * ```
   */
  static getIntersectionBetweenTwoRect(t, n) {
    const r = Math.max(t.left, n.left), s = Math.min(t.right, n.right), i = Math.max(t.top, n.top), o = Math.min(t.bottom, n.bottom);
    return s <= r || o <= i ? null : {
      left: r,
      right: s,
      top: i,
      bottom: o,
      width: s - r,
      height: o - i
    };
  }
  /**
   * Sorts an array of ranges by startRow, then by startColumn
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 1, startColumn: 0, endRow: 2, endColumn: 1 },
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ];
   * const sorted = Rectangle.sort(ranges);
   * // Ranges will be sorted by startRow first, then startColumn
   * ```
   */
  static sort(t) {
    return t.sort((n, r) => n.startRow - r.startRow || n.startColumn - r.startColumn);
  }
};
/**
 * Converts an absolute range to a relative range based on an origin range
 * @param range
 * @param originRange
 * @example
 * ```typescript
 * const range = { startRow: 5, startColumn: 5, endRow: 7, endColumn: 7 };
 * const origin = { startRow: 3, startColumn: 3, endRow: 8, endColumn: 8 };
 * const relative = Rectangle.getRelativeRange(range, origin);
 * // relative = { startRow: 2, startColumn: 2, endRow: 2, endColumn: 2 }
 * ```
 */
p(Yt, "getRelativeRange", (t, n) => ({
  startRow: t.startRow - n.startRow,
  endRow: t.endRow - t.startRow,
  startColumn: t.startColumn - n.startColumn,
  endColumn: t.endColumn - t.startColumn
})), /**
 * Converts a relative range back to an absolute range based on origin
 * @param relativeRange
 * @param originRange
 * @param absoluteRange
 * @example
 * ```typescript
 * const relative = { startRow: 2, startColumn: 2, endRow: 2, endColumn: 2 };
 * const origin = { startRow: 3, startColumn: 3, endRow: 8, endColumn: 8 };
 * const absolute = Rectangle.getPositionRange(relative, origin);
 * // absolute = { startRow: 5, startColumn: 5, endRow: 7, endColumn: 7 }
 * ```
 */
p(Yt, "getPositionRange", (t, n, r) => ({
  ...r || {},
  startRow: r && [ye.ROW, ye.ALL].includes(r.startAbsoluteRefType || 0) ? r.startRow : t.startRow + n.startRow,
  endRow: r && [ye.ROW, ye.ALL].includes(r.endAbsoluteRefType || 0) ? r.endRow : t.endRow + t.startRow + n.startRow,
  startColumn: r && [ye.COLUMN, ye.ALL].includes(r.startAbsoluteRefType || 0) ? r.startColumn : t.startColumn + n.startColumn,
  endColumn: r && [ye.COLUMN, ye.ALL].includes(r.endAbsoluteRefType || 0) ? r.endColumn : t.endColumn + t.startColumn + n.startColumn
})), /**
 * Moves a range horizontally by a specified step and optionally extends it
 * @param range
 * @param step
 * @param length
 * @example
 * ```typescript
 * const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
 * const moved = Rectangle.moveHorizontal(range, 2, 1);
 * // moved = { startRow: 0, startColumn: 2, endRow: 1, endColumn: 4 }
 * ```
 */
p(Yt, "moveHorizontal", (t, n = 0, r = 0) => ({
  ...t,
  startColumn: t.startColumn + n,
  endColumn: t.endColumn + n + r
})), /**
 * Moves a range vertically by a specified step and optionally extends it
 * @param range
 * @param step
 * @param length
 * @example
 * ```typescript
 * const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
 * const moved = Rectangle.moveVertical(range, 2, 1);
 * // moved = { startRow: 2, startColumn: 0, endRow: 4, endColumn: 1 }
 * ```
 */
p(Yt, "moveVertical", (t, n = 0, r = 0) => ({
  ...t,
  startRow: t.startRow + n,
  endRow: t.endRow + n + r
})), /**
 * Moves a range by specified offsets in both directions
 * @param range
 * @param offsetX
 * @param offsetY
 * @example
 * ```typescript
 * const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
 * const moved = Rectangle.moveOffset(range, 2, 3);
 * // moved = { startRow: 3, startColumn: 2, endRow: 4, endColumn: 3 }
 * ```
 */
p(Yt, "moveOffset", (t, n, r) => {
  const s = { ...t };
  switch (t.startAbsoluteRefType) {
    // The start absolute reference type is row absolute reference, then only the start column position is moved
    case ye.ROW:
      s.startColumn += n;
      break;
    // The start absolute reference type is column absolute reference, then only the start row position is moved
    case ye.COLUMN:
      s.startRow += r;
      break;
    // The start absolute reference type is both row and column absolute reference, then the start position is not moved
    case ye.ALL:
      break;
    // The start absolute reference type is not absolute reference, then both the start row and start column positions are moved
    case ye.NONE:
    default:
      s.startRow += r, s.startColumn += n;
      break;
  }
  switch (t.endAbsoluteRefType) {
    // The end absolute reference type is row absolute reference, then only the end column position is moved
    case ye.ROW:
      s.endColumn += n;
      break;
    // The end absolute reference type is column absolute reference, then only the end row position is moved
    case ye.COLUMN:
      s.endRow += r;
      break;
    // The end absolute reference type is both row and column absolute reference, then the end position is not moved
    case ye.ALL:
      break;
    // The end absolute reference type is not absolute reference, then both the end row and end column positions are moved
    case ye.NONE:
    default:
      s.endRow += r, s.endColumn += n;
      break;
  }
  return s;
});
let En = Yt;
function zp(e, t) {
  if (e.length === 0 || e[0].length === 0) return null;
  const n = new Array(e[0].length).fill(0);
  let r = 0, s = null;
  for (let i = 0; i < e.length; i++) {
    for (let a = 0; a < e[0].length; a++)
      n[a] = t(e[i][a]) ? n[a] + 1 : 0;
    const o = Vp(n);
    o.area > r && (r = o.area, s = {
      startColumn: o.start,
      startRow: i - o.height + 1,
      endColumn: o.end,
      endRow: i
    });
  }
  return s;
}
function Vp(e) {
  const t = [];
  let n = 0, r = { area: 0, height: 0, start: 0, end: 0 }, s = 0;
  for (; s < e.length; )
    if (t.length === 0 || e[s] >= e[t[t.length - 1]])
      t.push(s++);
    else {
      const i = e[t.pop()], o = t.length === 0 ? s : s - t[t.length - 1] - 1;
      i * o > n && (n = i * o, r = { area: n, height: i, start: t.length === 0 ? 0 : t[t.length - 1] + 1, end: s - 1 });
    }
  for (; t.length > 0; ) {
    const i = e[t.pop()], o = t.length === 0 ? s : s - t[t.length - 1] - 1;
    i * o > n && (n = i * o, r = { area: n, height: i, start: t.length === 0 ? 0 : t[t.length - 1] + 1, end: s - 1 });
  }
  return r;
}
function Gp(e, t) {
  Or.foreach(t, (n, r) => {
    e[n][r] = void 0;
  });
}
function _R(e, t) {
  const n = e.toFullArray(), r = [];
  for (; ; ) {
    const s = zp(n, t);
    if (!s)
      break;
    r.push(s), Gp(n, s);
  }
  return r;
}
class pR {
  constructor(t, n) {
    p(this, "_values", []);
    p(this, "_keys", []);
    p(this, "_keyMaps", /* @__PURE__ */ new Map());
    this._values = t, this._keys = n, t.forEach((r) => {
      this._initKeyMap(r);
    });
  }
  _initKeyMap(t) {
    this._keys.forEach((n) => {
      const r = t[n], s = this._keyMaps.get(n) || /* @__PURE__ */ new Map();
      s.set(r, t), this._keyMaps.set(n, s);
    });
  }
  /**
   * If a key group is specified, the order of values is determined by the key group, otherwise it depends on the keys at initialization
   * @param {string} key
   * @param {K[]} [keyGroup]
   * @return {*}
   * @memberof RefAlias
   */
  getValue(t, n) {
    const r = n || this._keys;
    for (let s = 0; s < r.length; s++) {
      const i = this._keyMaps.get(r[s]);
      if (i != null && i.has(t))
        return i.get(t);
    }
    return null;
  }
  hasValue(t) {
    for (let n = 0; n < this._keys.length; n++) {
      const r = this._keyMaps.get(this._keys[n]);
      if (r != null && r.has(t))
        return !0;
    }
    return !1;
  }
  addValue(t) {
    this._values.push(t), this._initKeyMap(t);
  }
  setValue(t, n, r) {
    const s = this.getValue(t);
    s && Object.keys(s).includes(n) && (s[n] = r);
  }
  deleteValue(t, n) {
    const r = this.getValue(t, n);
    if (r) {
      this._keys.forEach((i) => {
        const o = this._keyMaps.get(i), a = r[i];
        o == null || o.delete(a);
      });
      const s = this._values.findIndex((i) => i === r);
      this._values.splice(s, 1);
    }
  }
  getValues() {
    return this._values;
  }
  getKeyMap(t) {
    var n;
    return [...((n = this._keyMaps.get(t)) == null ? void 0 : n.keys()) || []];
  }
  clear() {
    this._values = [], this._keys = [], this._keyMaps.clear();
  }
}
function cl(e, t, n, r) {
  return {
    forEach(s) {
      for (let i = e; i <= t; i++)
        for (let o = n; o <= r; o++)
          s(i, o);
    }
  };
}
function ER(e) {
  if (e == null || e.length === 0)
    return Number.NaN;
  const t = e.toLowerCase().split(""), n = t.length, r = (o) => o.charCodeAt(0) - 96;
  let s = 0, i = 0;
  for (let o = 0; o < n; o++)
    i = r(t[o]), s += i * 26 ** (n - o - 1);
  return s === 0 ? Number.NaN : s - 1;
}
const Es = 65, Fu = 90, Kp = 97;
function CR(e) {
  const t = Fu - Es + 1;
  let n = "";
  for (; e >= 0; )
    n = String.fromCharCode(e % t + Es) + n, e = Math.floor(e / t) - 1;
  return n;
}
function Xp(e, t) {
  let n = "";
  for (; t > 0; )
    n += e, t--;
  return n;
}
function RR(e, t = !1) {
  const n = Fu - Es + 1;
  let r = Kp;
  t && (r = Es);
  const s = String.fromCharCode(e % n + r), i = Math.floor(e / n) + 1;
  return Xp(s, i);
}
function IR(e, t) {
  return e.zIndex > t.zIndex ? 1 : e.zIndex === t.zIndex ? 0 : -1;
}
function wR(e, t) {
  return e.zIndex > t.zIndex ? -1 : e.zIndex === t.zIndex ? 0 : 1;
}
function Ps(e = "index", t = 1) {
  return (n, r) => n[e] > r[e] ? t : n[e] === r[e] ? 0 : -t;
}
function Fs(e, t = !1) {
  const n = [];
  for (const r of e) {
    const { st: s, ed: i, ts: o } = r;
    if (r.sId === void 0 && delete r.sId, s === i || !t && J.isEmptyObject(o) && r.sId == null)
      continue;
    if (n.length === 0) {
      n.push(r);
      continue;
    }
    const a = n.pop();
    Kg(r, a) && J.hasIntersectionBetweenTwoRanges(a.st, a.ed, r.st, r.ed) ? n.push({
      ...r,
      st: a.st,
      ed: i
    }) : n.push(a, r);
  }
  return n;
}
function $u(e, t, n, r) {
  var u;
  const { textRuns: s } = e;
  if (s == null)
    return;
  const i = [], o = s.length;
  let a = !1;
  const l = (u = t.textRuns) != null ? u : [];
  if (l.length)
    for (const c of l)
      c.st += r, c.ed += r;
  for (let c = 0; c < o; c++) {
    const h = s[c], { st: d, ed: f } = h;
    if (f <= r)
      i.push(h);
    else if (r > d && r < f) {
      a = !0;
      const g = {
        ...h,
        ed: r
      };
      i.push(g), l.length && i.push(...l);
      const _ = {
        ...h,
        st: r + n,
        ed: f + n
      };
      i.push(_);
    } else
      h.st += n, h.ed += n, a || (a = !0, i.push(...l)), i.push(h);
  }
  a || (a = !0, i.push(...l)), e.textRuns = Fs(i);
}
function Hu(e, t, n, r) {
  const { paragraphs: s } = e;
  if (s == null)
    return;
  const { paragraphs: i } = t, o = [];
  for (let l = 0, u = s.length; l < u; l++) {
    const c = s[l], { startIndex: h } = c;
    h >= r && (c.startIndex += n), o.push(c.startIndex);
  }
  let a = -1;
  if (i) {
    for (let l = 0, u = i.length; l < u; l++) {
      const c = i[l];
      c.startIndex += r;
      const h = c.startIndex;
      a = o.indexOf(h);
    }
    a !== -1 && s.splice(a, 1), s.push(...i), s.sort(Ps("startIndex"));
  }
}
function Bu(e, t, n, r) {
  const { sectionBreaks: s } = e;
  if (s == null)
    return;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n);
  }
  const i = t.sectionBreaks;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r;
    }
    s.push(...i), s.sort(Ps("startIndex"));
  }
}
function ju(e, t, n, r) {
  const { customBlocks: s = [] } = e;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n);
  }
  const i = t.customBlocks;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r;
    }
    s.push(...i), s.sort(Ps("startIndex"));
  }
  s.length && !e.customBlocks && (e.customBlocks = s);
}
function Wu(e, t, n, r) {
  const { tables: s } = e;
  if (s == null)
    return;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u, endIndex: c } = l;
    u > r ? (l.startIndex += n, l.endIndex += n) : c > r && (l.endIndex += n);
  }
  const i = t.tables;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r, l.endIndex += r;
    }
    s.push(...i), s.sort(Ps("startIndex"));
  }
}
const Yu = "$", hl = (e) => e.split(Yu)[0];
function Xo(e) {
  if (e.length <= 1) return e;
  e.sort((s, i) => s.startIndex - i.startIndex);
  const t = [];
  let n = { ...e[0] };
  n.rangeId = hl(n.rangeId);
  for (let s = 1; s < e.length; s++) {
    const i = e[s];
    i.rangeId = hl(i.rangeId), i.rangeId === n.rangeId && Vc(n.properties, i.properties) && n.endIndex + 1 >= i.startIndex ? n.endIndex = i.endIndex : (t.push(n), n = { ...i });
  }
  t.push(n);
  const r = /* @__PURE__ */ Object.create(null);
  for (let s = 0, i = t.length; s < i; s++) {
    const o = t[s], a = o.rangeId;
    r[a] ? (o.rangeId = `${a}${Yu}${r[a]}`, r[a] = r[a] + 1) : r[a] = 1;
  }
  return t;
}
function Ui(e, t) {
  const n = e.findIndex((s) => s.startIndex < t && s.endIndex >= t), r = e[n];
  r && e.splice(n, 1, {
    rangeId: r.rangeId,
    rangeType: r.rangeType,
    startIndex: r.startIndex,
    endIndex: t - 1,
    properties: { ...r.properties }
  }, {
    rangeId: r.rangeId,
    rangeType: r.rangeType,
    startIndex: t,
    endIndex: r.endIndex,
    properties: { ...r.properties }
  });
}
function zu(e) {
  if (e.length <= 1) return e;
  e.sort((r, s) => r.startIndex - s.startIndex);
  const t = [];
  let n = { ...e[0] };
  for (let r = 1; r < e.length; r++) {
    const s = e[r];
    s.id === n.id && n.endIndex + 1 >= s.startIndex ? n.endIndex = s.endIndex : (t.push(n), n = { ...s });
  }
  return t.push(n), t;
}
function ki(e, t) {
  e.filter((r) => r.startIndex < t && r.endIndex >= t).forEach((r) => {
    const s = e.indexOf(r);
    e.splice(s, 1, {
      id: r.id,
      type: r.type,
      startIndex: r.startIndex,
      endIndex: t - 1
    }, {
      id: r.id,
      type: r.type,
      startIndex: t,
      endIndex: r.endIndex
    });
  });
}
function qp(e, t, n, r) {
  e.customRanges || (e.customRanges = []);
  const { customRanges: s } = e;
  Ui(s, r);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n, l.endIndex += n);
  }
  const i = [];
  if (t.customRanges) {
    for (let o = 0, a = t.customRanges.length; o < a; o++) {
      const l = t.customRanges[o];
      l.startIndex += r, l.endIndex += r, i.push(l);
    }
    s.push(...i);
  }
  e.customRanges = Xo(s);
}
function Zp(e, t, n, r) {
  e.customDecorations || (e.customDecorations = []);
  const { customDecorations: s } = e;
  ki(s, r);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n, l.endIndex += n);
  }
  const i = [];
  if (t.customDecorations) {
    for (let o = 0, a = t.customDecorations.length; o < a; o++) {
      const l = t.customDecorations[o];
      l.startIndex += r, l.endIndex += r, i.push(l);
    }
    s.push(...i);
  }
  e.customDecorations = zu(s);
}
function Vu(e, t, n) {
  const { textRuns: r } = e, s = n, i = n + t, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { st: h, ed: d } = c;
      if (s <= h && i >= d) {
        o.push({
          ...c,
          st: h - s,
          ed: d - s
        });
        continue;
      } else h <= s && d >= i ? (o.push({
        ...c,
        st: s - s,
        ed: i - s
      }), c.ed -= t) : s >= h && s < d ? (o.push({
        ...c,
        st: s - s,
        ed: d - s
      }), c.ed = s) : i > h && i <= d ? (o.push({
        ...c,
        st: h - s,
        ed: i - s
      }), c.st = i - t, c.ed -= t) : h >= i && (c.st -= t, c.ed -= t);
      a.push(c);
    }
    e.textRuns = a;
  }
  return o.length === 0 && o.push({
    st: 0,
    ed: t,
    ts: {}
  }), o;
}
function Gu(e, t, n) {
  const { paragraphs: r } = e, s = n, i = n + t, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h < i) {
        o.push({
          ...c,
          startIndex: h - n
        });
        continue;
      } else h >= i && (c.startIndex -= t);
      a.push(c);
    }
    e.paragraphs = a;
  }
  return o;
}
function Ku(e, t, n) {
  const { sectionBreaks: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h <= i) {
        o.push({
          ...c,
          startIndex: h - n
        });
        continue;
      } else h > i && (c.startIndex -= t);
      a.push(c);
    }
    e.sectionBreaks = a;
  }
  return o;
}
function Xu(e, t, n) {
  const { customBlocks: r = [] } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h <= i) {
        o.push({
          ...c,
          startIndex: h - n
        });
        continue;
      } else h > i && (c.startIndex -= t);
      a.push(c);
    }
    e.customBlocks = a;
  }
  return r.length && !e.customBlocks && (e.customBlocks = r), o;
}
function qu(e, t, n) {
  const { tables: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h, endIndex: d } = c;
      if (s <= h && i >= d) {
        o.push({
          ...c,
          startIndex: h - n,
          endIndex: d - n
        });
        continue;
      } else if (h <= s && d >= i) {
        const f = go(h, d, s, i);
        if (f.length === 0 || (c.startIndex = f[0], c.endIndex = f[1], c.startIndex === c.endIndex))
          continue;
      } else i < h && (c.startIndex -= t, c.endIndex -= t);
      a.push(c);
    }
    e.tables = a;
  }
  return o;
}
function Jp(e, t, n) {
  const { customRanges: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h, endIndex: d } = c;
      if (h >= s && d <= i) {
        o.push(c);
        continue;
      } else if (Math.max(s, h) <= Math.min(i, d)) {
        const f = go(h, d, s, i);
        if (f.length === 0)
          continue;
        c.startIndex = f[0], c.endIndex = f[1];
      } else i < h && (c.startIndex -= t, c.endIndex -= t);
      a.push(c);
    }
    e.customRanges = Xo(a);
  }
  return o;
}
function Qp(e, t, n, r = !0) {
  const { customDecorations: s } = e, i = n, o = n + t - 1, a = [];
  if (s) {
    const l = [];
    for (let u = 0, c = s.length; u < c; u++) {
      const h = s[u], { startIndex: d, endIndex: f } = h;
      if (d >= i && f <= o) {
        a.push(h);
        continue;
      } else if (Math.max(i, d) <= Math.min(o, f)) {
        const g = go(d, f, i, o);
        if (g.length === 0)
          continue;
        h.startIndex = g[0], h.endIndex = g[1];
      } else o < d && r && (h.startIndex -= t, h.endIndex -= t);
      l.push(h);
    }
    e.customDecorations = l;
  }
  return a;
}
var e0 = /* @__PURE__ */ ((e) => (e.ORDER_LIST_QUICK_1 = "1.", e.ORDER_LIST_QUICK_2 = "a)", e.ORDER_LIST_QUICK_3 = "a.", e.ORDER_LIST_QUICK_4 = "i.", e.ORDER_LIST_QUICK_5 = "A.", e.ORDER_LIST_QUICK_6 = "I.", e.ORDER_LIST_QUICK_7 = "01.", e.BULLET_LIST = "*", e))(e0 || {}), zt = /* @__PURE__ */ ((e) => (e.BULLET_LIST = "BULLET_LIST", e.BULLET_LIST_1 = "BULLET_LIST_1", e.BULLET_LIST_2 = "BULLET_LIST_2", e.BULLET_LIST_3 = "BULLET_LIST_3", e.BULLET_LIST_4 = "BULLET_LIST_4", e.BULLET_LIST_5 = "BULLET_LIST_5", e.ORDER_LIST = "ORDER_LIST", e.ORDER_LIST_1 = "ORDER_LIST_1", e.ORDER_LIST_2 = "ORDER_LIST_2", e.ORDER_LIST_3 = "ORDER_LIST_3", e.ORDER_LIST_4 = "ORDER_LIST_4", e.ORDER_LIST_5 = "ORDER_LIST_5", e.ORDER_LIST_QUICK_2 = "ORDER_LIST_QUICK_2", e.ORDER_LIST_QUICK_3 = "ORDER_LIST_QUICK_3", e.ORDER_LIST_QUICK_4 = "ORDER_LIST_QUICK_4", e.ORDER_LIST_QUICK_5 = "ORDER_LIST_QUICK_5", e.ORDER_LIST_QUICK_6 = "ORDER_LIST_QUICK_6", e.CHECK_LIST = "CHECK_LIST", e.CHECK_LIST_CHECKED = "CHECK_LIST_CHECKED", e))(zt || {});
const Gr = {
  "a)": { glyphFormat: "%1)", glyphType: me.DECIMAL },
  "1.": { glyphType: me.DECIMAL },
  "a.": { glyphFormat: "%1.", glyphType: me.LOWER_LETTER },
  "A.": { glyphType: me.UPPER_LETTER },
  "i.": { glyphFormat: "%1.", glyphType: me.LOWER_ROMAN },
  "I.": { glyphFormat: "%1.", glyphType: me.UPPER_LETTER }
}, On = (e) => [
  ...e,
  ...e,
  ...e
].map((t, n) => ({
  glyphFormat: ` %${n + 1}`,
  glyphSymbol: t,
  bulletAlignment: Ts.START,
  textStyle: {
    fs: 12
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * n }
  }
})), vn = (e) => e.map((t, n) => ({
  ...t,
  bulletAlignment: Ts.START,
  textStyle: {
    fs: 12
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * n }
  }
})), dl = (e, t) => new Array(9).fill(0).map((n, r) => ({
  glyphFormat: ` %${r + 1}`,
  glyphSymbol: e,
  bulletAlignment: Ts.START,
  textStyle: {
    fs: 16
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * r },
    textStyle: t
  }
})), $s = {
  BULLET_LIST: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_1: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_2: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_3: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_4: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  BULLET_LIST_5: {
    listType: "BULLET_LIST",
    nestingLevel: On(["", "", ""])
  },
  ORDER_LIST: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.DECIMAL },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.DECIMAL },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.DECIMAL },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_1: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1)", glyphType: me.DECIMAL },
      { glyphFormat: "%2)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3)", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4)", glyphType: me.DECIMAL },
      { glyphFormat: "%5)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6)", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7)", glyphType: me.DECIMAL },
      { glyphFormat: "%8)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9)", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_2: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      "%1.",
      "%1.%2.",
      "%1.%2.%3.",
      "%1.%2.%3.%4.",
      "%1.%2.%3.%4.%5.",
      "%1.%2.%3.%4.%5.%6.",
      "%1.%2.%3.%4.%5.%6.%7."
    ].map((e) => ({ glyphFormat: e, glyphType: me.DECIMAL })))
  },
  ORDER_LIST_3: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_4: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%2.", glyphType: me.DECIMAL },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%5.", glyphType: me.DECIMAL },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%8.", glyphType: me.DECIMAL },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_5: {
    listType: "ORDER_LIST",
    nestingLevel: vn([
      { glyphFormat: "%1.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  CHECK_LIST: {
    listType: "CHECK_LIST",
    nestingLevel: dl("")
  },
  CHECK_LIST_CHECKED: {
    listType: "CHECK_LIST_CHECKED",
    nestingLevel: dl(
      "",
      {
        st: {
          s: ie.TRUE
        }
      }
    )
  }
}, Kr = (e) => {
  const { glyphFormat: t, glyphType: n } = e, r = J.deepClone($s.ORDER_LIST);
  return r.nestingLevel[0].glyphFormat = t, r.nestingLevel[0].glyphType = n, r;
}, t0 = {
  ORDER_LIST_QUICK_2: Kr(Gr[
    "a)"
    /* ORDER_LIST_QUICK_2 */
  ]),
  ORDER_LIST_QUICK_3: Kr(Gr[
    "a."
    /* ORDER_LIST_QUICK_3 */
  ]),
  ORDER_LIST_QUICK_4: Kr(Gr[
    "i."
    /* ORDER_LIST_QUICK_4 */
  ]),
  ORDER_LIST_QUICK_6: Kr(Gr[
    "I."
    /* ORDER_LIST_QUICK_6 */
  ])
};
Object.assign($s, t0);
const SR = {
  "1.": "ORDER_LIST",
  "a)": "ORDER_LIST_QUICK_2",
  "a.": "ORDER_LIST_QUICK_3",
  "i.": "ORDER_LIST_QUICK_4",
  "A.": "ORDER_LIST_3",
  "I.": "ORDER_LIST_QUICK_6",
  "01.": "ORDER_LIST_5",
  "*": "BULLET_LIST"
  /* BULLET_LIST */
};
function n0(e, t, n, r, s) {
  const i = r0(e, t, n, r, s), o = s0(e, t, n, r, s), a = i0(e, t, n, r, s), l = o0(e, t, n, r, s), u = a0(e, t, n, r, s), c = l0(e, t, n, r), h = u0(e, t, n, r, s);
  return {
    dataStream: "",
    textRuns: i,
    paragraphs: o,
    sectionBreaks: a,
    customBlocks: l,
    tables: u,
    customRanges: c,
    customDecorations: h
  };
}
function r0(e, t, n, r, s) {
  const { textRuns: i } = e, { textRuns: o } = t;
  if (i == null || o == null)
    return;
  const a = Vu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = Zu(o, a, s);
    t.textRuns = l;
  }
  return $u(e, t, n, r), a;
}
function Zu(e, t, n) {
  if (t.length === 0)
    return e;
  e = J.deepClone(e), t = J.deepClone(t);
  const r = [], s = e.length, i = t.length;
  let o = 0, a = 0, l = null;
  function u() {
    return l ? (r.push(l), l = null, !0) : !1;
  }
  for (; o < s && a < i; ) {
    const { st: f, ed: g, ts: _ } = e[o], { st: R, ed: b, ts: H, sId: P } = t[a];
    let W;
    if (n === pe.COVER ? W = { ...H, ..._ } : W = { ..._ }, g < R)
      u() || r.push(e[o]), o++;
    else if (b < f)
      u() || r.push(t[a]), a++;
    else {
      const w = {
        st: Math.min(f, R),
        ed: Math.max(f, R),
        ts: f < R ? { ..._ } : { ...H },
        sId: f < R ? void 0 : P
      };
      w.ed > w.st && r.push(w), r.push({
        st: Math.max(f, R),
        ed: Math.min(g, b),
        ts: W,
        sId: P
      }), g < b ? (o++, t[a].st = g, t[a].st === t[a].ed && a++) : (a++, e[o].st = b, e[o].st === e[o].ed && o++);
      const C = {
        st: Math.min(g, b),
        ed: Math.max(g, b),
        ts: g < b ? { ...H } : { ..._ },
        sId: g < b ? P : void 0
      };
      l = C.ed > C.st ? C : null;
    }
  }
  u();
  const c = r[r.length - 1], h = e[s - 1], d = t[i - 1];
  return c && c.ed !== Math.max(h.ed, d.ed) && (h.ed > d.ed ? r.push(h) : r.push(d)), Fs(r);
}
function s0(e, t, n, r, s) {
  const { paragraphs: i } = e, { paragraphs: o } = t;
  if (i == null || o == null)
    return;
  const a = Gu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const {
        startIndex: c,
        paragraphStyle: h,
        bullet: d
      } = u;
      let f = [];
      for (const g of a) {
        const {
          startIndex: _,
          paragraphStyle: R,
          bullet: b
        } = g;
        let H, P;
        if (s === pe.COVER ? (H = { ...R, ...h }, P = {
          listId: "",
          listType: zt.BULLET_LIST,
          nestingLevel: 0,
          textStyle: {},
          ...b,
          ...d
        }) : (H = { ...h, ...R }, P = {
          listId: "",
          listType: zt.BULLET_LIST,
          nestingLevel: 0,
          textStyle: {},
          ...d,
          ...b
        }), c === _) {
          f.push({
            startIndex: c,
            paragraphStyle: H,
            bullet: P
          });
          break;
        }
      }
      l.push(...f), f = [];
    }
    t.paragraphs = l;
  }
  return Hu(e, t, n, r), a;
}
function i0(e, t, n, r, s) {
  const { sectionBreaks: i } = e, { sectionBreaks: o } = t;
  if (i == null || o == null)
    return;
  const a = Ku(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c } = u;
      let h = [];
      for (const d of a) {
        const { startIndex: f } = d;
        if (c === f) {
          s === pe.COVER ? h.push({
            ...d,
            ...u
          }) : h.push({
            ...u,
            ...d
          });
          break;
        }
      }
      l.push(...h), h = [];
    }
    t.sectionBreaks = l;
  }
  return Bu(e, t, n, r), a;
}
function o0(e, t, n, r, s) {
  const { customBlocks: i = [] } = e, { customBlocks: o } = t;
  if (i == null || o == null)
    return;
  const a = Xu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c } = u;
      let h = [];
      for (const d of a) {
        const { startIndex: f } = d;
        if (c === f) {
          s === pe.COVER ? h.push({
            ...d,
            ...u
          }) : h.push({
            ...u,
            ...d
          });
          break;
        }
      }
      l.push(...h), h = [];
    }
    t.customBlocks = l;
  }
  return ju(e, t, n, r), i.length && !e.customBlocks && (e.customBlocks = i), a;
}
function a0(e, t, n, r, s) {
  const { tables: i } = e, { tables: o } = t;
  if (i == null || o == null)
    return;
  const a = qu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c, endIndex: h } = u;
      let d = [];
      for (const f of a) {
        const { startIndex: g, endIndex: _ } = f;
        if (g >= c && _ <= h) {
          s === pe.COVER ? d.push({
            ...f,
            ...u
          }) : d.push({
            ...u,
            ...f
          });
          break;
        }
      }
      l.push(...d), d = [];
    }
    t.tables = l;
  }
  return Wu(e, t, n, r), a;
}
function l0(e, t, n, r, s) {
  e.customRanges || (e.customRanges = []), Ui(e.customRanges, r), Ui(e.customRanges, r + n);
  const i = r, o = r + n - 1, { customRanges: a } = t, l = [], u = /* @__PURE__ */ new Map();
  e.customRanges.forEach((h) => {
    const { startIndex: d, endIndex: f } = h;
    d >= i && f <= o ? u.set(h.rangeId, h) : l.push(h);
  });
  const c = [];
  return a ? (a.forEach((h) => {
    const { startIndex: d, endIndex: f } = h;
    l.push({
      ...h,
      startIndex: d + r,
      endIndex: f + r
    });
  }), e.customRanges = Xo(l), c) : [];
}
function u0(e, t, n, r, s) {
  e.customDecorations || (e.customDecorations = []), ki(e.customDecorations, r), ki(e.customDecorations, r + n);
  const i = [], { customDecorations: o } = e, { customDecorations: a = [] } = t;
  if (s === pe.REPLACE) {
    for (let l = 0; l < o.length; l++) {
      const u = o[l], { startIndex: c, endIndex: h } = u;
      c >= r && h <= r + n - 1 && i.push(u);
    }
    a.forEach((l) => {
      const { startIndex: u, endIndex: c } = l;
      o.push({
        ...l,
        startIndex: u + r,
        endIndex: c + r
      });
    });
  } else
    for (const l of a) {
      const { id: u } = l;
      if (l.type === Dn.DELETED) {
        const c = o.filter((h) => h.id === u);
        c.length && i.push(...c);
      } else
        o.push({
          ...l,
          startIndex: l.startIndex + r,
          endIndex: l.endIndex + r
        });
    }
  for (const l of i) {
    const { id: u } = l, c = o.findIndex((h) => h.id === u);
    c !== -1 && o.splice(c, 1);
  }
  return e.customDecorations = zu(o), i;
}
var Ju = /* @__PURE__ */ ((e) => (e[e.copy = 0] = "copy", e[e.cut = 1] = "cut", e))(Ju || {});
function Pi(e, t, n, r = !0) {
  const { textRuns: s } = e;
  if (s) {
    const i = [];
    for (const o of s) {
      const a = J.deepClone(o), { st: l, ed: u } = a;
      J.hasIntersectionBetweenTwoRanges(l, u, t, n) && (t >= l && t <= u ? i.push({
        ...a,
        st: t,
        ed: Math.min(n, u)
      }) : n >= l && n <= u ? i.push({
        ...a,
        st: Math.max(t, l),
        ed: n
      }) : i.push(a));
    }
    return Fs(
      i.map((o) => {
        const { st: a, ed: l } = o;
        return {
          ...o,
          st: a - t,
          ed: l - t
        };
      })
    );
  } else if (r)
    return [{
      st: 0,
      ed: n - t,
      ts: {}
    }];
}
function c0(e, t, n) {
  const { tables: r = [] } = e, s = [];
  for (const i of r) {
    const o = J.deepClone(i), { startIndex: a, endIndex: l } = o;
    a >= t && l <= n && s.push({
      ...o,
      startIndex: a - t,
      endIndex: l - t
    });
  }
  return s;
}
function h0(e, t, n) {
  const { paragraphs: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    if (o >= t && o < n) {
      const a = J.deepClone(i);
      s.push(a);
    }
  }
  if (s.length)
    return s.map((i) => ({
      ...i,
      startIndex: i.startIndex - t
    }));
}
function OR(e, t, n) {
  const { sectionBreaks: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    o >= t && o <= n && s.push(J.deepClone(i));
  }
  if (s.length)
    return s.map((i) => ({
      ...i,
      startIndex: i.startIndex - t
    }));
}
function d0(e, t, n) {
  const { customBlocks: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    o >= t && o < n && s.push(J.deepClone(i));
  }
  if (s.length)
    return s.map((i) => ({
      ...i,
      startIndex: i.startIndex - t
    }));
}
function kt(e, t, n, r = !0, s = 1) {
  const { dataStream: i } = e, o = {
    dataStream: i.slice(t, n)
  };
  o.textRuns = Pi(e, t, n, r);
  const a = c0(e, t, n);
  if (a.length && (o.tables = a), o.paragraphs = h0(e, t, n), s === 1) {
    const u = m0(e, t, n);
    u ? o.customDecorations = u : r && (o.customDecorations = []);
  }
  const { customRanges: l } = f0(e, t, n);
  return l ? o.customRanges = l : r && (o.customRanges = []), o.customBlocks = d0(e, t, n), o;
}
function vR(e) {
  const { dataStream: t, textRuns: n, paragraphs: r, customRanges: s, customDecorations: i, tables: o } = e;
  let a = 0, l = 0;
  s == null || s.forEach((c) => {
    c.startIndex < 0 && (a = Math.max(a, -c.startIndex)), c.endIndex > t.length - 1 && (l = Math.max(l, c.endIndex - t.length + 1));
  });
  const u = `${t}`;
  return n && (n[0] && (n[0].st = n[0].st - a), n[n.length - 1] && (n[n.length - 1].ed = n[n.length - 1].ed + l)), n == null || n.forEach((c) => {
    c.st += a, c.ed += a;
  }), r == null || r.forEach((c) => {
    c.startIndex += a;
  }), s == null || s.forEach((c) => {
    c.startIndex += a, c.endIndex += a;
  }), i == null || i.forEach((c) => {
    c.startIndex += a, c.endIndex += l;
  }), o == null || o.forEach((c) => {
    c.startIndex += a, c.endIndex += l;
  }), {
    ...e,
    dataStream: u,
    textRuns: n,
    paragraphs: r,
    customRanges: s,
    customDecorations: i,
    tables: o
  };
}
function f0(e, t, n) {
  if (e.customRanges == null)
    return {};
  const { customRanges: r } = e;
  return {
    customRanges: r.filter((a) => Math.max(a.startIndex, t) <= Math.min(a.endIndex, n - 1)).map((a) => ({
      ...a,
      startIndex: Math.max(a.startIndex, t),
      endIndex: Math.min(a.endIndex, n - 1)
    })).map((a) => ({
      ...a,
      startIndex: a.startIndex - t,
      endIndex: a.endIndex - t
    })),
    leftOffset: 0,
    rightOffset: 0
  };
}
function m0(e, t, n) {
  if (e.customDecorations == null)
    return;
  const { customDecorations: r = [] } = e, s = [];
  return r.forEach((i) => {
    if (Math.max(i.startIndex, t) <= Math.min(i.endIndex, n - 1)) {
      const o = J.deepClone(i);
      s.push({
        ...o,
        startIndex: Math.max(o.startIndex - t, 0),
        endIndex: Math.min(o.endIndex, n - 1) - t
      });
    }
  }), s;
}
function g0(e, t, n) {
  return e == null || t == null ? e != null ? e : t : Zu(e, t, n);
}
function _0(e, t, n) {
  if (e == null || t == null)
    return e != null ? e : t;
  if (t.length === 0 || e.length === 0)
    return e;
  if (t.length > 1 || e.length > 1)
    throw new Error("Cannot cover multiple customRanges");
  return n === pe.REPLACE ? [{
    ...e[0]
  }] : [{
    ...t[0],
    ...e[0]
  }];
}
function p0(e, t, n) {
  return t.length === 0 || e.length === 0 || n === pe.REPLACE ? e : [
    ...e,
    ...t.filter((r) => !e.some((s) => r.id === s.id))
  ];
}
function fl(e, t, n = pe.COVER) {
  if (t.dataStream !== "")
    throw new Error("Cannot compose other body with non-empty dataStream");
  const r = {
    dataStream: e.dataStream
  }, {
    textRuns: s,
    paragraphs: i = [],
    customRanges: o,
    customDecorations: a = []
  } = e, {
    textRuns: l,
    paragraphs: u = [],
    customRanges: c,
    customDecorations: h = []
  } = t;
  r.textRuns = g0(l, s, n), r.customRanges = _0(c, o, n);
  const d = p0(h, a, n);
  d.length && (r.customDecorations = d);
  const f = [];
  let g = 0, _ = 0;
  for (; g < i.length && _ < u.length; ) {
    const R = i[g], b = u[_], { startIndex: H } = R, { startIndex: P } = b;
    H === P ? (f.push(J.deepMerge(R, b)), g++, _++) : H < P ? (f.push(J.deepClone(R)), g++) : (f.push(J.deepClone(b)), _++);
  }
  return g < i.length && f.push(...i.slice(g)), _ < u.length && f.push(...u.slice(_)), f.length && (r.paragraphs = f), r;
}
function E0(e) {
  const { body: t } = e;
  if (t == null)
    return !0;
  const { textRuns: n, paragraphs: r, customRanges: s, customBlocks: i, customDecorations: o, tables: a } = t;
  return n == null && r == null && s == null && i == null && o == null && a == null;
}
class er {
  constructor(t) {
    p(this, "_index", 0);
    p(this, "_offset", 0);
    this._actions = t;
  }
  hasNext() {
    return this.peekLength() < Number.POSITIVE_INFINITY;
  }
  next(t) {
    t || (t = Number.POSITIVE_INFINITY);
    const n = this._actions[this._index];
    if (n) {
      const r = this._offset, s = n.len;
      return t >= s - r ? (t = s - r, this._index += 1, this._offset = 0) : this._offset += t, n.t === Z.DELETE || n.t === Z.RETAIN && n.body == null ? J.deepClone({
        ...n,
        len: t
      }) : J.deepClone({
        ...n,
        len: t,
        body: kt(n.body, r, r + t, !1)
      });
    } else
      return {
        t: Z.RETAIN,
        len: Number.POSITIVE_INFINITY
      };
  }
  peek() {
    return this._actions[this._index];
  }
  peekLength() {
    return this._actions[this._index] ? this._actions[this._index].len - this._offset : Number.POSITIVE_INFINITY;
  }
  peekType() {
    const t = this._actions[this._index];
    return t ? t.t : Z.RETAIN;
  }
  rest() {
    if (this.hasNext()) {
      if (this._offset === 0)
        return this._actions.slice(this._index);
      {
        const t = this._offset, n = this._index, r = this.next(), s = this._actions.slice(this._index);
        return this._offset = t, this._index = n, [r].concat(s);
      }
    } else return [];
  }
}
function C0(e, t, n) {
  const { dataStream: r } = e, s = n, i = n + t, o = Vu(e, t, n), a = Gu(e, t, n), l = Ku(e, t, n), u = Xu(e, t, n), c = qu(e, t, n), h = Jp(e, t, n), d = Qp(e, t, n);
  let f = "";
  return r && (e.dataStream = L_(r, s, i), f = r.slice(s, i)), {
    dataStream: f,
    textRuns: o,
    paragraphs: a,
    sectionBreaks: l,
    customBlocks: u,
    tables: c,
    customRanges: h,
    customDecorations: d
  };
}
function R0(e, t, n, r) {
  e.dataStream = M_(e.dataStream, r, t.dataStream), $u(e, t, n, r), Hu(e, t, n, r), Bu(e, t, n, r), ju(e, t, n, r), Wu(e, t, n, r), qp(e, t, n, r), Zp(e, t, n, r);
}
function I0(e, t, n, r, s = pe.COVER) {
  return n0(e, t, n, r, s);
}
function w0(e, t, n) {
  return t <= 0 ? { dataStream: "" } : C0(e, t, n);
}
function S0(e, t, n, r) {
  n !== 0 && R0(e, t, n, r);
}
function O0(e, t) {
  const n = new Gn();
  return n.reset(), t.forEach((r) => {
    const s = J.deepClone(r);
    switch (s.t) {
      case Z.RETAIN: {
        const { coverType: i, body: o, len: a } = s;
        o != null && I0(e, o, a, n.cursor, i), n.moveCursor(a);
        break;
      }
      case Z.INSERT: {
        const { body: i, len: o } = s;
        S0(e, i, o, n.cursor), n.moveCursor(o);
        break;
      }
      case Z.DELETE: {
        const { len: i } = s;
        w0(e, i, n.cursor);
        break;
      }
      default:
        throw new Error(`Unknown action type for action: ${s}.`);
    }
  }), e;
}
function v0(e, t, n, r, s) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return [];
  t = J.deepClone(t), e = J.deepClone(e);
  const i = [], o = t.length, a = e.length;
  let l = 0, u = 0, c = null;
  function h() {
    return c ? (i.push(c), c = null, !0) : !1;
  }
  for (; l < o && u < a; ) {
    const { st: _, ed: R, ts: b } = t[l], { st: H, ed: P, ts: W, sId: w } = e[u];
    let C = {};
    if (s === 0)
      C = { ...b }, n === pe.COVER && r === pe.REPLACE && W && (C = Object.assign({}, W, C));
    else if (C = { ...b }, n === pe.REPLACE) {
      if (r === pe.REPLACE)
        C = { ...W };
      else if (b && W) {
        const v = Object.keys(b);
        for (const y of v)
          W[y] && delete C[y];
      }
    } else if (r === pe.REPLACE) {
      if (W) {
        const v = Object.keys(W);
        for (const y of v)
          W[y] !== void 0 && (C[y] = W[y]);
      }
    } else if (W) {
      const v = Object.keys(W);
      for (const y of v)
        C[y] !== void 0 && delete C[y];
    }
    if (R < H)
      h() || i.push(t[l]), l++;
    else if (P < _)
      h() || i.push(e[u]), u++;
    else {
      const v = {
        st: Math.min(_, H),
        ed: Math.max(_, H),
        ts: _ < H ? { ...b } : { ...W }
      };
      v.ed > v.st && i.push(), i.push({
        st: Math.max(_, H),
        ed: Math.min(R, P),
        ts: C,
        sId: w
      }), R < P ? (l++, e[u].st = R, e[u].st === e[u].ed && u++) : (u++, t[l].st = P, t[l].st === t[l].ed && l++);
      const y = {
        st: Math.min(R, P),
        ed: Math.max(R, P),
        ts: R < P ? { ...W } : { ...b },
        sId: R < P ? w : void 0
      };
      c = y.ed > y.st ? y : null;
    }
  }
  h();
  const d = i[i.length - 1], f = t[o - 1], g = e[a - 1];
  return d.ed !== Math.max(f.ed, g.ed) && (f.ed > g.ed ? i.push(f) : i.push(g)), Fs(i, !0);
}
function b0(e, t, n, r, s) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return [];
  if (e.length > 1 || t.length > 1)
    throw new Error("CustomRanges is only supported transform for length one now.");
  const i = e[0], o = t[0];
  if (n === pe.REPLACE)
    return s === 1 ? [J.deepClone(i)] : [J.deepClone(o)];
  if (r === pe.REPLACE) {
    const a = J.deepClone(o);
    return s === 1 && Object.assign(a, J.deepClone(i)), [a];
  } else {
    const a = J.deepClone(o);
    return s === 1 && Object.assign(a, J.deepClone(i)), [a];
  }
}
function ml(e, t, n, r, s) {
  const i = {
    startIndex: t.startIndex
  };
  if (t.paragraphStyle && (i.paragraphStyle = J.deepClone(t.paragraphStyle), e.paragraphStyle)) {
    if (n === pe.REPLACE)
      if (r === pe.REPLACE)
        s === 1 && (i.paragraphStyle = {
          ...e.paragraphStyle
        });
      else if (s === 1) {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          e.paragraphStyle[a] !== void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      } else {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          i.paragraphStyle[a] === void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      }
    else if (r === pe.REPLACE)
      if (s === 1) {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          e.paragraphStyle[a] !== void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      } else {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          i.paragraphStyle[a] === void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      }
    else if (s === 1) {
      const o = Object.keys(e.paragraphStyle);
      for (const a of o)
        i.paragraphStyle[a] && delete i.paragraphStyle[a];
    }
  }
  return n === pe.REPLACE && r === pe.REPLACE ? i.bullet = s === 1 ? J.deepClone(e.bullet) : J.deepClone(t.bullet) : e.bullet === void 0 ? i.bullet = J.deepClone(t.bullet) : n === pe.REPLACE || r === pe.REPLACE ? i.bullet = s === 0 && t.bullet ? J.deepClone(t.bullet) : J.deepClone(e.bullet) : s === 0 && t.bullet !== void 0 && (i.bullet = J.deepClone(t.bullet)), i;
}
function A0(e, t) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return J.deepClone(t);
  const n = [];
  for (const r of t) {
    const { id: s, type: i } = r;
    let o = !1;
    for (const a of e)
      if (a.id === s) {
        (a.type === Dn.DELETED || i === Dn.DELETED) && (o = !0, n.push({
          ...r,
          type: Dn.DELETED
        }));
        break;
      }
    o || n.push(r);
  }
  return n;
}
function y0(e, t, n = !1) {
  const { body: r, coverType: s = pe.COVER } = e, { body: i, coverType: o = pe.COVER } = t;
  if (r == null || r.dataStream !== "" || i == null || i.dataStream !== "")
    throw new Error("Data stream is not supported in retain transform.");
  const a = {
    dataStream: ""
  }, l = o, {
    textRuns: u,
    paragraphs: c = [],
    customRanges: h,
    customDecorations: d
  } = r, {
    textRuns: f,
    paragraphs: g = [],
    customRanges: _,
    customDecorations: R
  } = i, b = v0(
    u,
    f,
    s,
    o,
    n ? 1 : 0
    /* COVER */
  );
  b && (a.textRuns = b);
  const H = b0(
    h,
    _,
    s,
    o,
    n ? 1 : 0
    /* COVER */
  );
  H && (a.customRanges = H);
  const P = A0(
    d,
    R
  );
  P && (a.customDecorations = P);
  const W = [];
  let w = 0, C = 0;
  for (; w < c.length && C < g.length; ) {
    const v = c[w], y = g[C], { startIndex: F } = v, { startIndex: $ } = y;
    if (F === $) {
      let m = {
        startIndex: F
      };
      n ? m = ml(
        v,
        y,
        s,
        o,
        1
        /* COVER_ONLY_NOT_EXISTED */
      ) : m = ml(
        v,
        y,
        s,
        o,
        0
        /* COVER */
      ), W.push(m), w++, C++;
    } else F < $ ? w++ : (W.push(J.deepClone(y)), C++);
  }
  return C < g.length && W.push(...g.slice(C)), W.length && (a.paragraphs = W), {
    coverType: l,
    body: a
  };
}
function gl(e) {
  return Object.keys(e).length === 1;
}
const Mn = class Mn {
  constructor() {
    p(this, "_actions", []);
  }
  static apply(t, n) {
    return O0(t, n);
  }
  // eslint-disable-next-line complexity
  static compose(t, n) {
    const r = new er(t), s = new er(n), i = new Mn();
    for (; r.hasNext() || s.hasNext(); )
      if (s.peekType() === Z.INSERT)
        i.push(s.next());
      else if (r.peekType() === Z.DELETE)
        i.push(r.next());
      else {
        const o = Math.min(r.peekLength(), s.peekLength()), a = r.next(o), l = s.next(o);
        if (a.t === Z.INSERT && l.t === Z.RETAIN)
          l.body == null ? i.push(a) : i.push({
            ...a,
            body: fl(a.body, l.body, l.coverType)
          });
        else if (a.t === Z.RETAIN && l.t === Z.RETAIN)
          if (a.body == null && l.body == null)
            i.push(a.len !== Number.POSITIVE_INFINITY ? a : l);
          else if (a.body && l.body) {
            const u = a.coverType === pe.REPLACE || l.coverType === pe.REPLACE ? pe.REPLACE : pe.COVER;
            i.push({
              ...a,
              t: Z.RETAIN,
              coverType: u,
              body: fl(a.body, l.body, l.coverType)
            });
          } else
            i.push(a.body ? a : l);
        else a.t === Z.RETAIN && l.t === Z.DELETE ? i.push(l) : a.t === Z.INSERT && (l.t, Z.DELETE);
      }
    return i.trimEndUselessRetainAction(), i.serialize();
  }
  /**
   * |(this \| other) | **insert** | **retain** | **delete** |
   * | ---------------- | ---------- | ---------- | ---------- |
   * |    **insert**    |   Case 1   |   Case 2   |   Case 2   |
   * |    **retain**    |   Case 1   |   Case 5   |   Case 4   |
   * |    **delete**    |   Case 1   |   Case 3   |   Case 3   |
   *
   * Case 1: When the other action type is an insert operation,
   *         the insert operation is retained regardless of the type of action this action
   * Case 2: When this action type is an insert operation and the other action type is a
   *         non-insert operation, you need to retain the length of this action insert
   * Case 3: When this action is a delete operation, there are two scenarios:
   *      1) When other is a delete operation, since it is a delete operation, this has
   *         already been deleted, so the target does not need to be in delete, and it can
   *         be continued directly
   *      2) When other is the retain operation, although this action delete occurs first,
   *         the delete priority is higher, so the delete operation is retained, and the origin
   *         delete has been applied, so it is directly continued
   * Case 4: other is the delete operation, this is the retain operation, and the target delete operation
   *         is kept
   * Case 5: When both other and this are retain operations
   *      1) If the other body attribute does not exist, directly retain length
   *      2) If the other body property exists, then execute the TransformBody logic to override it
   */
  // priority - if true, this actions takes priority over other, that is, this actions are considered to happen "first".
  // thisActions is the target action.
  static transform(t, n, r = "right") {
    return this._transform(n, t, r === "left" ? "right" : "left");
  }
  // otherActions is the actions to be transformed.
  static _transform(t, n, r = "right") {
    const s = new er(t), i = new er(n), o = new Mn();
    for (; s.hasNext() || i.hasNext(); )
      if (s.peekType() === Z.INSERT && (r === "left" || i.peekType() !== Z.INSERT)) {
        const a = s.next();
        o.retain(a.len);
      } else if (i.peekType() === Z.INSERT)
        o.push(i.next());
      else {
        const a = Math.min(s.peekLength(), i.peekLength()), l = s.next(a), u = i.next(a);
        if (l.t === Z.DELETE)
          continue;
        if (u.t === Z.DELETE) {
          o.push(u);
          continue;
        }
        if (l.body == null || u.body == null)
          o.push(u);
        else {
          const { coverType: c, body: h } = y0(l, u, r === "left");
          o.push({
            ...u,
            t: Z.RETAIN,
            coverType: c,
            body: h
          });
        }
      }
    return o.trimEndUselessRetainAction(), o.serialize();
  }
  /**
   * Used to transform selection. Why not named transformSelection?
   * Because Univer Doc supports multiple Selections in one document, user need to encapsulate transformSelections at the application layer.
   */
  static transformPosition(t, n, r = !1) {
    const s = new er(t);
    let i = 0;
    for (; s.hasNext() && i <= n; ) {
      const o = s.peekLength(), a = s.peekType();
      if (s.next(), a === Z.DELETE) {
        n -= Math.min(o, n - i);
        continue;
      } else a === Z.INSERT && (i < n || !r) && (n += o);
      i += o;
    }
    return n;
  }
  static isNoop(t) {
    return t.length === 0;
  }
  static invert(t) {
    const n = [];
    for (const r of t)
      if (r.t === Z.INSERT)
        n.push({
          t: Z.DELETE,
          len: r.len,
          body: r.body
        });
      else if (r.t === Z.DELETE) {
        if (r.body == null)
          throw new Error("Can not invert DELETE action without body property, makeInvertible must be called first.");
        n.push({
          t: Z.INSERT,
          body: r.body,
          len: r.len
        });
      } else if (r.body != null) {
        if (r.oldBody == null)
          throw new Error("Can not invert RETAIN action without oldBody property, makeInvertible must be called first.");
        n.push({
          t: Z.RETAIN,
          body: r.oldBody,
          oldBody: r.body,
          len: r.len,
          coverType: pe.REPLACE
        });
      } else
        n.push(r);
    return n;
  }
  static makeInvertible(t, n) {
    const r = [];
    let s = 0;
    for (const i of t) {
      if (i.t === Z.DELETE && (i.body == null || i.body && i.body.dataStream.length !== i.len)) {
        const o = kt(n, s, s + i.len, !1);
        i.len = o.dataStream.length, i.body = o;
      }
      if (i.t === Z.RETAIN && i.body != null) {
        const o = kt(n, s, s + i.len, !0);
        i.oldBody = {
          ...o,
          dataStream: ""
        }, i.len = o.dataStream.length;
      }
      r.push(i), i.t !== Z.INSERT && (s += i.len);
    }
    return r;
  }
  insert(t, n) {
    const r = {
      t: Z.INSERT,
      body: n,
      len: t
    };
    return this.push(r), this;
  }
  retain(t, n, r) {
    const s = {
      t: Z.RETAIN,
      len: t
    };
    return n != null && (s.body = n), r != null && (s.coverType = r), this.push(s), this;
  }
  delete(t) {
    const n = {
      t: Z.DELETE,
      len: t
    };
    return this.push(n), this;
  }
  empty() {
    return this._actions = [], this;
  }
  serialize() {
    return this._actions;
  }
  // eslint-disable-next-line complexity
  push(...t) {
    if (t.length > 1) {
      for (const i of t)
        this.push(i);
      return this;
    }
    let n = this._actions.length, r = this._actions[n - 1];
    const s = J.deepClone(t[0]);
    if (s.t === Z.RETAIN && s.len === 0 && s.body == null)
      return this;
    if (typeof r == "object") {
      if (r.t === Z.DELETE && s.t === Z.DELETE)
        return r.len += s.len, this;
      if (r.t === Z.DELETE && s.t === Z.INSERT && (n -= 1, r = this._actions[n - 1], r == null))
        return this._actions.unshift(s), this;
      if (r.t === Z.RETAIN && s.t === Z.RETAIN && r.body == null && s.body == null)
        return r.len += s.len, this;
      if (r.t === Z.INSERT && gl(r.body) && s.t === Z.INSERT && gl(s.body))
        return r.len += s.len, r.body.dataStream += s.body.dataStream, this;
    }
    return n === this._actions.length ? this._actions.push(s) : this._actions.splice(n, 0, s), this;
  }
  trimEndUselessRetainAction() {
    let t = this._actions[this._actions.length - 1];
    for (; t && t.t === Z.RETAIN && E0(t); )
      this._actions.pop(), t = this._actions[this._actions.length - 1];
    return this;
  }
};
// static name = 'text-x';
p(Mn, "id", "text-x"), p(Mn, "uri", "https://github.com/dream-num/univer#text-x");
let Ne = Mn;
Object.defineProperty(Ne, "name", {
  value: "text-x"
});
const Ln = class Ln {
  static registerSubtype(t) {
    var n;
    t == null || this._subTypes.has(t.name) && ((n = this._subTypes.get(t.name)) == null ? void 0 : n.id) !== Ne.id || (this._subTypes.set(t.name, t), it.type.registerSubtype(t));
  }
  static apply(t, n) {
    if (!it.type.isNoop(n))
      return it.type.apply(t, n);
  }
  static compose(t, n) {
    return it.type.compose(t, n);
  }
  static transform(t, n, r) {
    return it.type.transform(t, n, r);
  }
  // Use to transform cursor position, just call TextXPro.transformPosition.
  static transformPosition(t, n, r = "right") {
    return t && t.length === 2 && t[0] === "body" && t[1].et === Ne.name ? Ne.transformPosition(t[1].e, n, r === "left") : n;
  }
  static invertWithDoc(t, n) {
    return it.type.invertWithDoc(t, n);
  }
  static isNoop(t) {
    return it.type.isNoop(t);
  }
  static getInstance() {
    return this._instance == null && (this._instance = new Ln()), this._instance;
  }
  // eslint-disable-next-line ts/no-explicit-any
  removeOp(t, n) {
    return it.removeOp(t, n);
  }
  moveOp(t, n) {
    return it.moveOp(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  insertOp(t, n) {
    return it.insertOp(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  replaceOp(t, n, r) {
    return it.replaceOp(t, n, r);
  }
  editOp(t, n = ["body"]) {
    return it.editOp(n, Ne.name, t);
  }
};
// static name = 'json-x';
p(Ln, "uri", "https://github.com/dream-num/univer#json-x"), p(Ln, "_subTypes", /* @__PURE__ */ new Map()), p(Ln, "_instance", null);
let Qt = Ln;
Qt.registerSubtype(Ne);
var N0 = /* @__PURE__ */ ((e) => (e.PARAGRAPH = "PARAGRAPH", e.SECTION_BREAK = "SECTION_BREAK", e.TABLE = "TABLE", e.TABLE_ROW = "TABLE_ROW", e.TABLE_CELL = "TABLE_CELL", e.CUSTOM_BLOCK = "CUSTOM_BLOCK", e))(N0 || {}), ct = /* @__PURE__ */ ((e) => (e.PARAGRAPH = "\r", e.SECTION_BREAK = `
`, e.TABLE_START = "", e.TABLE_ROW_START = "\x1B", e.TABLE_CELL_START = "", e.TABLE_CELL_END = "", e.TABLE_ROW_END = "", e.TABLE_END = "", e.CUSTOM_RANGE_START = "", e.CUSTOM_RANGE_END = "", e.COLUMN_BREAK = "\v", e.PAGE_BREAK = "\f", e.DOCS_END = "\0", e.TAB = "	", e.CUSTOM_BLOCK = "\b", e.LETTER = "", e.SPACE = " ", e))(ct || {});
function bR(e) {
  return `${e}`;
}
const T0 = [
  // DataStreamTreeTokenType.PARAGRAPH, // 
  // DataStreamTreeTokenType.SECTION_BREAK, // 
  ct.TABLE_START,
  // 
  ct.TABLE_ROW_START,
  // 
  ct.TABLE_CELL_START,
  // 
  ct.TABLE_CELL_END,
  // 
  ct.TABLE_ROW_END,
  // 
  ct.TABLE_END
  // 
  // DataStreamTreeTokenType.COLUMN_BREAK, // 
  // DataStreamTreeTokenType.PAGE_BREAK, // 
  // DataStreamTreeTokenType.DOCS_END, // 
  // DataStreamTreeTokenType.TAB, // 
  // DataStreamTreeTokenType.CUSTOM_BLOCK, //  mention 
], qo = (e) => {
  const t = e.endsWith(`\r
`) ? e.slice(0, -2) : e;
  return T0.reduce((n, r) => n.replaceAll(r, ""), t);
}, M0 = (e) => e ? qo(e).replaceAll("\r", "") === "" : !0, L0 = (e) => {
  const t = e.replace(/\n/g, "\r"), n = [], r = [];
  let s = 0, i = "";
  const o = (l, u = !0) => {
    const c = t.slice(s, l);
    if (J.isLegalUrl(c)) {
      const h = et(), d = `${c}`, f = {
        startIndex: s,
        endIndex: s + d.length - 1,
        rangeId: h,
        rangeType: pn.HYPERLINK,
        properties: {
          url: e
        }
      };
      r.push(f), i += d, s = l + 1, u && (i += "\r", n.push({ startIndex: l }));
    } else
      i += t.slice(s, l + 1), s = l + 1, u && n.push({ startIndex: l });
  };
  let a = 0;
  for (let l = 0; l < t.length; l++)
    t[l] === "\r" && (o(l), a = l);
  return (a !== t.length - 1 || t.length === 1) && o(t.length, !1), {
    dataStream: i,
    paragraphs: n,
    customRanges: r
  };
}, Qu = {
  id: "default_doc",
  documentStyle: {}
};
class x0 extends lo {
  constructor(n) {
    var r;
    super();
    p(this, "type", we.UNIVER_DOC);
    p(this, "_name$", new tt(""));
    p(this, "name$", this._name$.asObservable());
    p(this, "snapshot");
    this.snapshot = { ...Qu, ...n }, this._name$.next((r = this.snapshot.title) != null ? r : "No Title");
  }
  getUnitId() {
    throw new Error("Method not implemented.");
  }
  getRev() {
    var n;
    return (n = this.snapshot.rev) != null ? n : 1;
  }
  incrementRev() {
    this.snapshot.rev = this.getRev() + 1;
  }
  setRev(n) {
    this.snapshot.rev = n;
  }
  setName(n) {
    this.snapshot.title = n, this._name$.next(n);
  }
  get drawings() {
    return this.snapshot.drawings;
  }
  get documentStyle() {
    return this.snapshot.documentStyle;
  }
  get lists() {
    return this.snapshot.lists;
  }
  get zoomRatio() {
    var n;
    return ((n = this.snapshot.settings) == null ? void 0 : n.zoomRatio) || 1;
  }
  resetDrawing(n, r) {
    this.snapshot.drawings = n, this.snapshot.drawingsOrder = r;
  }
  getBody() {
    return this.snapshot.body;
  }
  getSnapshot() {
    return this.snapshot;
  }
  getBulletPresetList() {
    var s;
    const n = (s = this.snapshot.lists) != null ? s : {};
    return {
      ...$s,
      ...n
    };
  }
  updateDocumentId(n) {
    this.snapshot.id = n;
  }
  updateDocumentRenderConfig(n) {
    const { documentStyle: r } = this.snapshot;
    r.renderConfig == null ? r.renderConfig = n : r.renderConfig = {
      ...r.renderConfig,
      ...n
    };
  }
  getDocumentStyle() {
    return this.snapshot.documentStyle;
  }
  updateDocumentStyle(n) {
    this.snapshot.documentStyle == null ? this.snapshot.documentStyle = n : this.snapshot.documentStyle = {
      ...this.snapshot.documentStyle,
      ...n
    };
  }
  updateDocumentDataMargin(n) {
    const { t: r, l: s, b: i, r: o } = n, { documentStyle: a } = this.snapshot;
    r != null && (a.marginTop = r), s != null && (a.marginLeft = s), i != null && (a.marginBottom = i), o != null && (a.marginRight = o);
  }
  updateDocumentDataPageSize(n, r) {
    const { documentStyle: s } = this.snapshot;
    if (!s.pageSize) {
      s.pageSize = {
        width: n != null ? n : Number.POSITIVE_INFINITY,
        height: r != null ? r : Number.POSITIVE_INFINITY
      };
      return;
    }
    n !== void 0 && (s.pageSize.width = n), r !== void 0 && (s.pageSize.height = r);
  }
  updateDrawing(n, r) {
    const { drawings: s } = this, { width: i, height: o, left: a, top: l } = r, u = s == null ? void 0 : s[n];
    if (!u)
      return;
    const c = u.docTransform;
    c.size.width = i, c.size.height = o, c.positionH.posOffset = a, c.positionV.posOffset = l;
  }
  setZoomRatio(n = 1) {
    this.snapshot.settings ? this.snapshot.settings.zoomRatio = n : this.snapshot.settings = {
      zoomRatio: n
    };
  }
  setDisabled(n) {
    this.snapshot.disabled = n;
  }
  getDisabled() {
    return this.snapshot.disabled;
  }
  getTitle() {
    return this.snapshot.title;
  }
}
class Pt extends x0 {
  constructor(n) {
    var s, i;
    super(J.isEmptyObject(n) ? ig() : n);
    p(this, "_unitId");
    p(this, "headerModelMap", /* @__PURE__ */ new Map());
    p(this, "footerModelMap", /* @__PURE__ */ new Map());
    p(this, "change$", new tt(0));
    const r = 6;
    this._unitId = (s = this.snapshot.id) != null ? s : et(r), this._initializeHeaderFooterModel(), this._name$.next((i = this.snapshot.title) != null ? i : "");
  }
  dispose() {
    super.dispose(), this.headerModelMap.forEach((n) => {
      n.dispose();
    }), this.footerModelMap.forEach((n) => {
      n.dispose();
    }), this._name$.complete();
  }
  getDrawings() {
    return this.snapshot.drawings;
  }
  getDrawingsOrder() {
    return this.snapshot.drawingsOrder;
  }
  getCustomRanges() {
    var n;
    return (n = this.snapshot.body) == null ? void 0 : n.customRanges;
  }
  getCustomDecorations() {
    var n;
    return (n = this.snapshot.body) == null ? void 0 : n.customDecorations;
  }
  getSettings() {
    return this.snapshot.settings;
  }
  // TODO: @JOCS do not use reset, please use apply to modify the snapshot.
  reset(n) {
    if (n.id && n.id !== this._unitId)
      throw new Error("Cannot reset a document model with a different unit id!");
    this.snapshot = { ...Qu, ...n }, this._initializeHeaderFooterModel(), this.change$.next(this.change$.value + 1);
  }
  getSelfOrHeaderFooterModel(n) {
    if (n != null) {
      if (this.headerModelMap.has(n))
        return this.headerModelMap.get(n);
      if (this.footerModelMap.has(n))
        return this.footerModelMap.get(n);
    }
    return this;
  }
  getUnitId() {
    return this._unitId;
  }
  apply(n) {
    if (!Qt.isNoop(n))
      return this.snapshot = Qt.apply(this.snapshot, n), n != null && n.some((r) => Array.isArray(r) && ((r == null ? void 0 : r[0]) === "headers" || (r == null ? void 0 : r[0]) === "footers")) && (this.headerModelMap.clear(), this.footerModelMap.clear(), this._initializeHeaderFooterModel()), this.change$.next(this.change$.value + 1), this.snapshot;
  }
  sliceBody(n, r, s = Ju.copy) {
    const i = this.getBody();
    if (i != null)
      return kt(i, n, r, !1, s);
  }
  _initializeHeaderFooterModel() {
    const { headers: n, footers: r } = this.getSnapshot();
    if (n)
      for (const s in n) {
        const i = n[s];
        this.headerModelMap.set(s, new Pt(i)), this.headerModelMap.get(s).updateDocumentId(this.getUnitId());
      }
    if (r)
      for (const s in r) {
        const i = r[s];
        this.footerModelMap.set(s, new Pt(i)), this.footerModelMap.get(s).updateDocumentId(this.getUnitId());
      }
  }
  updateDocumentId(n) {
    super.updateDocumentId(n), this._unitId = n;
  }
  getPlainText() {
    var n, r;
    return qo((r = (n = this.getBody()) == null ? void 0 : n.dataStream) != null ? r : "");
  }
}
function D0(e) {
  const { ranges: t, id: n, type: r } = e, s = new Ne();
  let i = 0;
  for (let o = 0; o < t.length; o++) {
    const a = t[o], { startOffset: l, endOffset: u } = a;
    l > 0 && s.push({
      t: Z.RETAIN,
      len: l - i
    }), s.push({
      t: Z.RETAIN,
      body: {
        dataStream: "",
        customDecorations: [{
          id: n,
          type: r,
          startIndex: 0,
          endIndex: u - l - 1
        }]
      },
      len: u - l
    }), i = u;
  }
  return s;
}
function U0(e) {
  var c, h, d;
  const { id: t, segmentId: n, documentDataModel: r } = e, s = r == null ? void 0 : r.getBody();
  if (!r || !s)
    return !1;
  const i = (d = (h = (c = r.getSelfOrHeaderFooterModel(n)) == null ? void 0 : c.getBody()) == null ? void 0 : h.customDecorations) == null ? void 0 : d.find((f) => f.id === t);
  if (!i)
    return !1;
  const o = new Ne(), { startIndex: a, endIndex: l } = i, u = l - a + 1;
  return o.push({
    t: Z.RETAIN,
    len: a
  }), o.push({
    t: Z.RETAIN,
    len: u,
    body: {
      dataStream: "",
      customDecorations: [
        {
          startIndex: 0,
          endIndex: u - 1,
          id: t,
          type: Dn.DELETED
        }
      ]
    }
  }), o;
}
function ec(e, t, n, r) {
  return e <= n && t >= n || e >= n && e <= r;
}
function k0(e, t) {
  const n = [];
  for (let r = 0, s = t.length; r < s; r++) {
    const i = t[r];
    e.collapsed ? i.startIndex < e.startOffset && e.startOffset <= i.endIndex && n.push(i) : ec(e.startOffset, e.endOffset - 1, i.startIndex, i.endIndex) && n.push(i);
  }
  return n;
}
function P0(e) {
  return {
    ...J.deepClone(e),
    rangeId: et()
  };
}
function F0(e, t) {
  const n = [];
  let r = e[0];
  for (const s of t)
    s < e[0] || s > e[1] || (r < s && n.push([r, s - 1]), r = s + 1);
  return r <= e[1] && n.push([r, e[1]]), n;
}
function tc(e, t, n, r) {
  const s = [];
  for (let i = 0, o = n.length; i < o; i++) {
    const a = n[i];
    if ((r === void 0 || a.rangeType === r) && Math.max(a.startIndex, e) <= Math.min(a.endIndex, t) && s.push({ ...a }), a.startIndex > t)
      break;
  }
  return s;
}
function $0(e, t) {
  var i, o, a, l, u;
  const n = tc(e.startOffset, e.collapsed ? e.startOffset : e.endOffset - 1, (i = t.customRanges) != null ? i : []), r = Math.min(e.startOffset, (a = (o = n[0]) == null ? void 0 : o.startIndex) != null ? a : 1 / 0), s = Math.max(e.endOffset, ((u = (l = n[n.length - 1]) == null ? void 0 : l.endIndex) != null ? u : -1 / 0) + 1);
  return {
    startOffset: r,
    endOffset: s,
    collapsed: r === s
  };
}
var hi, _l;
function H0() {
  if (_l) return hi;
  _l = 1;
  var e = -1, t = 1, n = 0;
  function r(m, D, S, T, A) {
    if (m === D)
      return m ? [[n, m]] : [];
    if (S != null) {
      var O = F(m, D, S);
      if (O)
        return O;
    }
    var N = a(m, D), M = m.substring(0, N);
    m = m.substring(N), D = D.substring(N), N = u(m, D);
    var L = m.substring(m.length - N);
    m = m.substring(0, m.length - N), D = D.substring(0, D.length - N);
    var k = s(m, D);
    return M && k.unshift([n, M]), L && k.push([n, L]), H(k, A), T && h(k), k;
  }
  function s(m, D) {
    var S;
    if (!m)
      return [[t, D]];
    if (!D)
      return [[e, m]];
    var T = m.length > D.length ? m : D, A = m.length > D.length ? D : m, O = T.indexOf(A);
    if (O !== -1)
      return S = [
        [t, T.substring(0, O)],
        [n, A],
        [t, T.substring(O + A.length)]
      ], m.length > D.length && (S[0][0] = S[2][0] = e), S;
    if (A.length === 1)
      return [
        [e, m],
        [t, D]
      ];
    var N = c(m, D);
    if (N) {
      var M = N[0], L = N[1], k = N[2], q = N[3], V = N[4], oe = r(M, k), le = r(L, q);
      return oe.concat([[n, V]], le);
    }
    return i(m, D);
  }
  function i(m, D) {
    for (var S = m.length, T = D.length, A = Math.ceil((S + T) / 2), O = A, N = 2 * A, M = new Array(N), L = new Array(N), k = 0; k < N; k++)
      M[k] = -1, L[k] = -1;
    M[O + 1] = 0, L[O + 1] = 0;
    for (var q = S - T, V = q % 2 !== 0, oe = 0, le = 0, I = 0, x = 0, Y = 0; Y < A; Y++) {
      for (var z = -Y + oe; z <= Y - le; z += 2) {
        var B = O + z, j;
        z === -Y || z !== Y && M[B - 1] < M[B + 1] ? j = M[B + 1] : j = M[B - 1] + 1;
        for (var Q = j - z; j < S && Q < T && m.charAt(j) === D.charAt(Q); )
          j++, Q++;
        if (M[B] = j, j > S)
          le += 2;
        else if (Q > T)
          oe += 2;
        else if (V) {
          var ee = O + q - z;
          if (ee >= 0 && ee < N && L[ee] !== -1) {
            var U = S - L[ee];
            if (j >= U)
              return o(m, D, j, Q);
          }
        }
      }
      for (var G = -Y + I; G <= Y - x; G += 2) {
        var ee = O + G, U;
        G === -Y || G !== Y && L[ee - 1] < L[ee + 1] ? U = L[ee + 1] : U = L[ee - 1] + 1;
        for (var X = U - G; U < S && X < T && m.charAt(S - U - 1) === D.charAt(T - X - 1); )
          U++, X++;
        if (L[ee] = U, U > S)
          x += 2;
        else if (X > T)
          I += 2;
        else if (!V) {
          var B = O + q - G;
          if (B >= 0 && B < N && M[B] !== -1) {
            var j = M[B], Q = O + j - B;
            if (U = S - U, j >= U)
              return o(m, D, j, Q);
          }
        }
      }
    }
    return [
      [e, m],
      [t, D]
    ];
  }
  function o(m, D, S, T) {
    var A = m.substring(0, S), O = D.substring(0, T), N = m.substring(S), M = D.substring(T), L = r(A, O), k = r(N, M);
    return L.concat(k);
  }
  function a(m, D) {
    if (!m || !D || m.charAt(0) !== D.charAt(0))
      return 0;
    for (var S = 0, T = Math.min(m.length, D.length), A = T, O = 0; S < A; )
      m.substring(O, A) == D.substring(O, A) ? (S = A, O = S) : T = A, A = Math.floor((T - S) / 2 + S);
    return P(m.charCodeAt(A - 1)) && A--, A;
  }
  function l(m, D) {
    var S = m.length, T = D.length;
    if (S == 0 || T == 0)
      return 0;
    S > T ? m = m.substring(S - T) : S < T && (D = D.substring(0, S));
    var A = Math.min(S, T);
    if (m == D)
      return A;
    for (var O = 0, N = 1; ; ) {
      var M = m.substring(A - N), L = D.indexOf(M);
      if (L == -1)
        return O;
      N += L, (L == 0 || m.substring(A - N) == D.substring(0, N)) && (O = N, N++);
    }
  }
  function u(m, D) {
    if (!m || !D || m.slice(-1) !== D.slice(-1))
      return 0;
    for (var S = 0, T = Math.min(m.length, D.length), A = T, O = 0; S < A; )
      m.substring(m.length - A, m.length - O) == D.substring(D.length - A, D.length - O) ? (S = A, O = S) : T = A, A = Math.floor((T - S) / 2 + S);
    return W(m.charCodeAt(m.length - A)) && A--, A;
  }
  function c(m, D) {
    var S = m.length > D.length ? m : D, T = m.length > D.length ? D : m;
    if (S.length < 4 || T.length * 2 < S.length)
      return null;
    function A(le, I, x) {
      for (var Y = le.substring(x, x + Math.floor(le.length / 4)), z = -1, B = "", j, Q, ee, U; (z = I.indexOf(Y, z + 1)) !== -1; ) {
        var G = a(
          le.substring(x),
          I.substring(z)
        ), X = u(
          le.substring(0, x),
          I.substring(0, z)
        );
        B.length < X + G && (B = I.substring(z - X, z) + I.substring(z, z + G), j = le.substring(0, x - X), Q = le.substring(x + G), ee = I.substring(0, z - X), U = I.substring(z + G));
      }
      return B.length * 2 >= le.length ? [
        j,
        Q,
        ee,
        U,
        B
      ] : null;
    }
    var O = A(
      S,
      T,
      Math.ceil(S.length / 4)
    ), N = A(
      S,
      T,
      Math.ceil(S.length / 2)
    ), M;
    if (!O && !N)
      return null;
    N ? O ? M = O[4].length > N[4].length ? O : N : M = N : M = O;
    var L, k, q, V;
    m.length > D.length ? (L = M[0], k = M[1], q = M[2], V = M[3]) : (q = M[0], V = M[1], L = M[2], k = M[3]);
    var oe = M[4];
    return [L, k, q, V, oe];
  }
  function h(m) {
    for (var D = !1, S = [], T = 0, A = null, O = 0, N = 0, M = 0, L = 0, k = 0; O < m.length; )
      m[O][0] == n ? (S[T++] = O, N = L, M = k, L = 0, k = 0, A = m[O][1]) : (m[O][0] == t ? L += m[O][1].length : k += m[O][1].length, A && A.length <= Math.max(N, M) && A.length <= Math.max(L, k) && (m.splice(S[T - 1], 0, [
        e,
        A
      ]), m[S[T - 1] + 1][0] = t, T--, T--, O = T > 0 ? S[T - 1] : -1, N = 0, M = 0, L = 0, k = 0, A = null, D = !0)), O++;
    for (D && H(m), b(m), O = 1; O < m.length; ) {
      if (m[O - 1][0] == e && m[O][0] == t) {
        var q = m[O - 1][1], V = m[O][1], oe = l(q, V), le = l(V, q);
        oe >= le ? (oe >= q.length / 2 || oe >= V.length / 2) && (m.splice(O, 0, [
          n,
          V.substring(0, oe)
        ]), m[O - 1][1] = q.substring(
          0,
          q.length - oe
        ), m[O + 1][1] = V.substring(oe), O++) : (le >= q.length / 2 || le >= V.length / 2) && (m.splice(O, 0, [
          n,
          q.substring(0, le)
        ]), m[O - 1][0] = t, m[O - 1][1] = V.substring(
          0,
          V.length - le
        ), m[O + 1][0] = e, m[O + 1][1] = q.substring(le), O++), O++;
      }
      O++;
    }
  }
  var d = /[^a-zA-Z0-9]/, f = /\s/, g = /[\r\n]/, _ = /\n\r?\n$/, R = /^\r?\n\r?\n/;
  function b(m) {
    function D(le, I) {
      if (!le || !I)
        return 6;
      var x = le.charAt(le.length - 1), Y = I.charAt(0), z = x.match(d), B = Y.match(d), j = z && x.match(f), Q = B && Y.match(f), ee = j && x.match(g), U = Q && Y.match(g), G = ee && le.match(_), X = U && I.match(R);
      return G || X ? 5 : ee || U ? 4 : z && !j && Q ? 3 : j || Q ? 2 : z || B ? 1 : 0;
    }
    for (var S = 1; S < m.length - 1; ) {
      if (m[S - 1][0] == n && m[S + 1][0] == n) {
        var T = m[S - 1][1], A = m[S][1], O = m[S + 1][1], N = u(T, A);
        if (N) {
          var M = A.substring(A.length - N);
          T = T.substring(0, T.length - N), A = M + A.substring(0, A.length - N), O = M + O;
        }
        for (var L = T, k = A, q = O, V = D(T, A) + D(A, O); A.charAt(0) === O.charAt(0); ) {
          T += A.charAt(0), A = A.substring(1) + O.charAt(0), O = O.substring(1);
          var oe = D(T, A) + D(A, O);
          oe >= V && (V = oe, L = T, k = A, q = O);
        }
        m[S - 1][1] != L && (L ? m[S - 1][1] = L : (m.splice(S - 1, 1), S--), m[S][1] = k, q ? m[S + 1][1] = q : (m.splice(S + 1, 1), S--));
      }
      S++;
    }
  }
  function H(m, D) {
    m.push([n, ""]);
    for (var S = 0, T = 0, A = 0, O = "", N = "", M; S < m.length; ) {
      if (S < m.length - 1 && !m[S][1]) {
        m.splice(S, 1);
        continue;
      }
      switch (m[S][0]) {
        case t:
          A++, N += m[S][1], S++;
          break;
        case e:
          T++, O += m[S][1], S++;
          break;
        case n:
          var L = S - A - T - 1;
          if (D) {
            if (L >= 0 && C(m[L][1])) {
              var k = m[L][1].slice(-1);
              if (m[L][1] = m[L][1].slice(
                0,
                -1
              ), O = k + O, N = k + N, !m[L][1]) {
                m.splice(L, 1), S--;
                var q = L - 1;
                m[q] && m[q][0] === t && (A++, N = m[q][1] + N, q--), m[q] && m[q][0] === e && (T++, O = m[q][1] + O, q--), L = q;
              }
            }
            if (w(m[S][1])) {
              var k = m[S][1].charAt(0);
              m[S][1] = m[S][1].slice(1), O += k, N += k;
            }
          }
          if (S < m.length - 1 && !m[S][1]) {
            m.splice(S, 1);
            break;
          }
          if (O.length > 0 || N.length > 0) {
            O.length > 0 && N.length > 0 && (M = a(N, O), M !== 0 && (L >= 0 ? m[L][1] += N.substring(
              0,
              M
            ) : (m.splice(0, 0, [
              n,
              N.substring(0, M)
            ]), S++), N = N.substring(M), O = O.substring(M)), M = u(N, O), M !== 0 && (m[S][1] = N.substring(N.length - M) + m[S][1], N = N.substring(
              0,
              N.length - M
            ), O = O.substring(
              0,
              O.length - M
            )));
            var V = A + T;
            O.length === 0 && N.length === 0 ? (m.splice(S - V, V), S = S - V) : O.length === 0 ? (m.splice(S - V, V, [t, N]), S = S - V + 1) : N.length === 0 ? (m.splice(S - V, V, [e, O]), S = S - V + 1) : (m.splice(
              S - V,
              V,
              [e, O],
              [t, N]
            ), S = S - V + 2);
          }
          S !== 0 && m[S - 1][0] === n ? (m[S - 1][1] += m[S][1], m.splice(S, 1)) : S++, A = 0, T = 0, O = "", N = "";
          break;
      }
    }
    m[m.length - 1][1] === "" && m.pop();
    var oe = !1;
    for (S = 1; S < m.length - 1; )
      m[S - 1][0] === n && m[S + 1][0] === n && (m[S][1].substring(
        m[S][1].length - m[S - 1][1].length
      ) === m[S - 1][1] ? (m[S][1] = m[S - 1][1] + m[S][1].substring(
        0,
        m[S][1].length - m[S - 1][1].length
      ), m[S + 1][1] = m[S - 1][1] + m[S + 1][1], m.splice(S - 1, 1), oe = !0) : m[S][1].substring(0, m[S + 1][1].length) == m[S + 1][1] && (m[S - 1][1] += m[S + 1][1], m[S][1] = m[S][1].substring(m[S + 1][1].length) + m[S + 1][1], m.splice(S + 1, 1), oe = !0)), S++;
    oe && H(m, D);
  }
  function P(m) {
    return m >= 55296 && m <= 56319;
  }
  function W(m) {
    return m >= 56320 && m <= 57343;
  }
  function w(m) {
    return W(m.charCodeAt(0));
  }
  function C(m) {
    return P(m.charCodeAt(m.length - 1));
  }
  function v(m) {
    for (var D = [], S = 0; S < m.length; S++)
      m[S][1].length > 0 && D.push(m[S]);
    return D;
  }
  function y(m, D, S, T) {
    return C(m) || w(T) ? null : v([
      [n, m],
      [e, D],
      [t, S],
      [n, T]
    ]);
  }
  function F(m, D, S) {
    var T = typeof S == "number" ? { index: S, length: 0 } : S.oldRange, A = typeof S == "number" ? null : S.newRange, O = m.length, N = D.length;
    if (T.length === 0 && (A === null || A.length === 0)) {
      var M = T.index, L = m.slice(0, M), k = m.slice(M), q = A ? A.index : null;
      e: {
        var V = M + N - O;
        if (q !== null && q !== V || V < 0 || V > N)
          break e;
        var oe = D.slice(0, V), le = D.slice(V);
        if (le !== k)
          break e;
        var I = Math.min(M, V), x = L.slice(0, I), Y = oe.slice(0, I);
        if (x !== Y)
          break e;
        var z = L.slice(I), B = oe.slice(I);
        return y(x, z, B, k);
      }
      e: {
        if (q !== null && q !== M)
          break e;
        var j = M, oe = D.slice(0, j), le = D.slice(j);
        if (oe !== L)
          break e;
        var Q = Math.min(O - j, N - j), ee = k.slice(k.length - Q), U = le.slice(le.length - Q);
        if (ee !== U)
          break e;
        var z = k.slice(0, k.length - Q), B = le.slice(0, le.length - Q);
        return y(L, z, B, ee);
      }
    }
    if (T.length > 0 && A && A.length === 0)
      e: {
        var x = m.slice(0, T.index), ee = m.slice(T.index + T.length), I = x.length, Q = ee.length;
        if (N < I + Q)
          break e;
        var Y = D.slice(0, I), U = D.slice(N - Q);
        if (x !== Y || ee !== U)
          break e;
        var z = m.slice(I, O - Q), B = D.slice(I, N - Q);
        return y(x, z, B, ee);
      }
    return null;
  }
  function $(m, D, S, T) {
    return r(m, D, S, T, !0);
  }
  return $.INSERT = t, $.DELETE = e, $.EQUAL = n, hi = $, hi;
}
var B0 = H0();
const nc = /* @__PURE__ */ Rt(B0);
function j0(e) {
  var h, d, f;
  const { rangeId: t, segmentId: n, documentDataModel: r, insert: s } = e, i = (d = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.customRanges) == null ? void 0 : d.find((g) => g.rangeId === t);
  if (!i)
    return !1;
  const { startIndex: o, endIndex: a } = i, l = new Ne(), u = a - o + 1;
  l.push({
    t: Z.RETAIN,
    len: o
  }), l.push({
    t: Z.RETAIN,
    len: u,
    body: {
      dataStream: "",
      customRanges: []
    }
  }), s && l.push({
    t: Z.INSERT,
    body: s,
    len: s.dataStream.length
  });
  const c = a + 1 + ((f = s == null ? void 0 : s.dataStream.length) != null ? f : 0);
  return l.selections = [{
    startOffset: c,
    endOffset: c,
    collapsed: !0
  }], l;
}
function W0(e) {
  const { ranges: t, rangeId: n, rangeType: r, wholeEntity: s, properties: i, body: o } = e;
  let a = 0;
  const l = new Ne();
  let u = !1;
  return t.forEach((c) => {
    var P, W, w;
    const h = $0(c, o);
    if (!h || !o)
      return !1;
    const { startOffset: d, endOffset: f } = h, g = (P = o.customRanges) != null ? P : [], _ = (C, v, y) => {
      var S, T, A, O;
      const F = tc(C, v, g, r), $ = Math.min((T = (S = F[0]) == null ? void 0 : S.startIndex) != null ? T : 1 / 0, C), m = Math.max((O = (A = F[F.length - 1]) == null ? void 0 : A.endIndex) != null ? O : -1 / 0, v), D = {
        rangeId: y ? `${n}$${y}` : n,
        rangeType: r,
        startIndex: 0,
        endIndex: m - $,
        wholeEntity: s,
        properties: {
          ...i
        }
      };
      l.push({
        t: Z.RETAIN,
        len: $ - a
      }), l.push({
        t: Z.RETAIN,
        len: m - $ + 1,
        body: {
          dataStream: "",
          customRanges: [D]
        },
        coverType: pe.COVER
      }), a = m + 1;
    }, R = ((W = o.paragraphs) != null ? W : []).filter((C) => C.startIndex < f && C.startIndex > d), b = ((w = o.customBlocks) != null ? w : []).filter((C) => C.startIndex < f && C.startIndex > d);
    F0([d, f - 1], [...R.map((C) => C.startIndex), ...b.map((C) => C.startIndex)]).forEach(([C, v], y) => _(C, v, y)), u = !0, l.selections = [{
      startOffset: h.endOffset,
      endOffset: h.endOffset,
      collapsed: !0
    }];
  }), u ? l : !1;
}
function rc(e, t, n = 0, r = null, s = !0) {
  e.sort((u, c) => u.startOffset - c.startOffset);
  const i = [], { paragraphs: o = [] } = t, a = o == null ? void 0 : o.find(
    (u) => u.startIndex >= e[0].startOffset && u.startIndex < e[0].endOffset
  );
  let l = n;
  if (e.forEach((u) => {
    const { startOffset: c, endOffset: h } = u;
    c > l && (i.push({
      t: Z.RETAIN,
      len: c - l
    }), l = c), l < h && (i.push({
      t: Z.DELETE,
      len: h - l
    }), l = h);
  }), r && i.push({
    t: Z.INSERT,
    body: r,
    len: r.dataStream.length
  }), a && s) {
    const u = o.find((c) => c.startIndex - n >= e[e.length - 1].endOffset - 1);
    u && (u.startIndex > l && (i.push({
      t: Z.RETAIN,
      len: u.startIndex - l
    }), l = u.startIndex), i.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...u,
            startIndex: 0,
            bullet: a == null ? void 0 : a.bullet
          }
        ]
      },
      coverType: pe.REPLACE
    }));
  }
  return i;
}
function Y0(e, t, n = 0) {
  const r = [];
  let s = n;
  return e.forEach((i) => {
    const { startOffset: o, endOffset: a } = i;
    o > s && (r.push({
      t: Z.RETAIN,
      len: o - s
    }), s = o), a > s && (r.push({
      t: Z.RETAIN,
      len: a - s,
      body: {
        ...J.deepClone(t),
        dataStream: ""
      }
    }), s = a);
  }), r;
}
const z0 = (e) => {
  var h;
  const { selection: t, body: n, doc: r } = e, s = t.segmentId, i = (h = r.getSelfOrHeaderFooterModel(s)) == null ? void 0 : h.getBody();
  if (!i) return !1;
  const o = t.collapsed ? null : kt(i, t.startOffset, t.endOffset), a = nc(o ? o.dataStream : "", n.dataStream);
  let l = 0;
  const u = a.map(([d, f]) => {
    switch (d) {
      // retain
      case 0: {
        const g = {
          t: Z.RETAIN,
          body: {
            ...kt(n, l, l + f.length, !1),
            dataStream: ""
          },
          len: f.length
        };
        return l += f.length, g;
      }
      // insert
      case 1: {
        const g = {
          t: Z.INSERT,
          body: kt(n, l, l + f.length),
          len: f.length
        };
        return l += f.length, g;
      }
      // delete
      default:
        return {
          t: Z.DELETE,
          len: f.length
        };
    }
  }), c = new Ne();
  return c.push({
    t: Z.RETAIN,
    len: t.startOffset
  }), c.push(...u), c;
};
function V0(e, t) {
  return !!((e == null ? void 0 : e.length) === (t == null ? void 0 : t.length) && (e != null && e.every((n, r) => JSON.stringify(n) === JSON.stringify(t == null ? void 0 : t[r]))));
}
const G0 = (e) => {
  var d;
  const { selection: t, body: n, doc: r, themeService: s } = e, i = t.segmentId, o = (d = r.getSelfOrHeaderFooterModel(i)) == null ? void 0 : d.getBody();
  if (!o) return !1;
  const a = t.collapsed ? null : kt(o, t.startOffset, t.endOffset), l = nc(a ? a.dataStream : "", n.dataStream);
  let u = 0;
  const c = l.map(([f, g]) => {
    switch (f) {
      // retain
      case 0: {
        const _ = Pi(n, u, u + g.length, !1), R = Pi(a, u, u + g.length, !1), b = {
          t: Z.RETAIN,
          body: V0(_, R) ? void 0 : {
            textRuns: _ == null ? void 0 : _.map((H) => {
              var P, W, w, C, v, y, F;
              return {
                ...H,
                ts: {
                  ...H.ts,
                  cl: (w = (W = (P = H.ts) == null ? void 0 : P.cl) == null ? void 0 : W.rgb) != null && w.includes(".") ? { rgb: s.getColorFromTheme((y = (v = (C = H.ts) == null ? void 0 : C.cl) == null ? void 0 : v.rgb) != null ? y : "") } : (F = H.ts) == null ? void 0 : F.cl
                }
              };
            }),
            dataStream: ""
          },
          len: g.length
        };
        return u += g.length, b;
      }
      // insert
      case 1: {
        const _ = {
          t: Z.INSERT,
          body: kt(n, u, u + g.length),
          len: g.length
        };
        return u += g.length, _;
      }
      // delete
      default:
        return {
          t: Z.DELETE,
          len: g.length
        };
    }
  });
  if (c.every((f) => f.t === Z.RETAIN && !f.body))
    return !1;
  const h = new Ne();
  return h.push({
    t: Z.RETAIN,
    len: t.startOffset
  }), h.push(...c), h;
};
function K0(e, t) {
  const n = [], { customBlocks: r = [] } = e;
  for (const s of t) {
    const { startOffset: i, endOffset: o } = s;
    if (!(i == null || o == null))
      for (const a of r) {
        const { startIndex: l } = a;
        l >= i && l < o && n.push(a.blockId);
      }
  }
  return n;
}
function X0(e, t = "") {
  if (!t)
    return ["body"];
  const { headers: n, footers: r } = e.getSnapshot();
  if (n == null && r == null)
    throw new Error("Document data model must have headers or footers when update by segment id");
  if ((n == null ? void 0 : n[t]) != null)
    return ["headers", t, "body"];
  if ((r == null ? void 0 : r[t]) != null)
    return ["footers", t, "body"];
  throw new Error("Segment id not found in headers or footers");
}
const q0 = (e) => {
  var _, R, b, H;
  const { selection: t, documentDataModel: n, drawings: r } = e, { collapsed: s, startOffset: i, segmentId: o } = t, a = new Ne(), l = Qt.getInstance(), u = [], c = n.getSelfOrHeaderFooterModel(o).getBody();
  if (!c)
    return !1;
  const h = (R = (_ = n.getSnapshot().drawingsOrder) == null ? void 0 : _.length) != null ? R : 0;
  let d = 0;
  if (s)
    i > 0 && a.push({
      t: Z.RETAIN,
      len: i
    });
  else {
    const P = rc([t], c, 0, null, !1);
    a.push(...P);
    const W = K0(c, [t]), w = (b = n.getDrawings()) != null ? b : {}, C = (H = n.getDrawingsOrder()) != null ? H : [], v = W.sort((y, F) => C.indexOf(y) > C.indexOf(F) ? -1 : C.indexOf(y) < C.indexOf(F) ? 1 : 0);
    if (v.length > 0)
      for (const y of v) {
        const F = w[y], $ = C.indexOf(y);
        if (F == null || $ < 0)
          continue;
        const m = l.removeOp(["drawings", y], F), D = l.removeOp(["drawingsOrder", $], y);
        u.push(m), u.push(D), d++;
      }
  }
  a.push({
    t: Z.INSERT,
    body: {
      dataStream: "\b".repeat(r.length),
      customBlocks: r.map((P, W) => ({
        startIndex: W,
        blockId: P.drawingId
      }))
    },
    len: r.length
  });
  const f = X0(n, o), g = l.editOp(a.serialize(), f);
  u.push(g);
  for (const P of r) {
    const { drawingId: W } = P, w = l.insertOp(["drawings", W], P), C = l.insertOp(["drawingsOrder", h - d], W);
    u.push(w), u.push(C);
  }
  return u.reduce((P, W) => Qt.compose(P, W), null);
};
function Z0(e, t) {
  if (typeof t > "u")
    return { startOffset: e, endOffset: e, collapsed: !0 };
  if (t < e)
    throw new Error(`Cannot make a doc selection when endOffset ${t} is less than startOffset ${e}.`);
  return { startOffset: e, endOffset: t, collapsed: e === t };
}
function J0(e) {
  const { startOffset: t, endOffset: n, collapsed: r } = e, s = Math.min(t, n), i = Math.max(t, n);
  return {
    startOffset: s,
    endOffset: i,
    collapsed: r
  };
}
function Q0(e, t, n, r) {
  return Math.max(e, n) <= Math.min(t, r);
}
function Fi(e, t, n, r) {
  const { startOffset: s, endOffset: i } = e, o = r != null ? r : Zo(t, n), a = [];
  let l = -1;
  for (let u = 0; u < o.length; u++) {
    const c = o[u], { startIndex: h } = c;
    (s > l && s <= h || i > l && i <= h || h >= s && h <= i) && a.push(c), l = h;
  }
  return a;
}
function $i(e, t, n) {
  const r = [], s = Zo(t, n);
  for (const i of e) {
    const o = Fi(i, t, n, s);
    r.push(...o);
  }
  return r;
}
const eE = [
  ct.PARAGRAPH,
  ct.TABLE_START,
  ct.TABLE_END,
  ct.TABLE_ROW_START,
  ct.TABLE_CELL_START,
  ct.TABLE_CELL_END
];
function Zo(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r], { startIndex: i } = s;
    let o = i - 1;
    for (; !eE.includes(t[o]) && o >= 0; )
      o--;
    n.push({
      ...s,
      paragraphStart: o + 1,
      paragraphEnd: s.startIndex
    });
  }
  return n;
}
const tE = (e) => {
  var h, d, f;
  const { paragraphs: t, segmentId: n, document: r } = e;
  let s = e.listType;
  const i = (d = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.paragraphs) != null ? d : [], o = t.every((g) => {
    var _;
    return ((_ = g.bullet) == null ? void 0 : _.listType.indexOf(s)) === 0;
  });
  let l = et(6);
  if (t.length === 1) {
    const g = i.indexOf(t[0]), _ = i[g - 1], R = i[g + 1];
    _ && _.bullet && _.bullet.listType.indexOf(s) === 0 ? (l = _.bullet.listId, s !== zt.CHECK_LIST && (s = _.bullet.listType)) : R && R.bullet && R.bullet.listType.indexOf(s) === 0 && (l = R.bullet.listId, s !== zt.CHECK_LIST && (s = R.bullet.listType));
  }
  const u = new Gn();
  u.reset();
  const c = new Ne();
  for (const g of t) {
    const { startIndex: _, paragraphStyle: R = {}, bullet: b } = g;
    c.push({
      t: Z.RETAIN,
      len: _ - u.cursor
    }), c.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          o ? {
            paragraphStyle: R,
            startIndex: 0
          } : {
            startIndex: 0,
            paragraphStyle: {
              ...R
            },
            bullet: {
              nestingLevel: (f = b == null ? void 0 : b.nestingLevel) != null ? f : 0,
              textStyle: {
                fs: 20
              },
              listType: s,
              listId: l
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), u.moveCursorTo(_ + 1);
  }
  return c;
}, nE = (e) => {
  var h;
  const { paragraphIndex: t, segmentId: n, document: r } = e, s = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.paragraphs;
  if (s == null)
    return !1;
  const i = s.find((d) => d.startIndex === t);
  if (!(i != null && i.bullet) || i.bullet.listType.indexOf(zt.CHECK_LIST) === -1)
    return !1;
  const o = new Gn();
  o.reset();
  const a = new Ne(), { startIndex: l, paragraphStyle: u = {} } = i, c = i.bullet.listType === zt.CHECK_LIST ? zt.CHECK_LIST_CHECKED : zt.CHECK_LIST;
  return a.push({
    t: Z.RETAIN,
    len: l - o.cursor
  }), a.push({
    t: Z.RETAIN,
    len: 1,
    body: {
      dataStream: "",
      paragraphs: [
        {
          ...i,
          paragraphStyle: u,
          startIndex: 0,
          bullet: {
            ...i.bullet,
            listType: c
          }
        }
      ]
    },
    coverType: pe.REPLACE
  }), o.moveCursorTo(l + 1), a;
}, rE = (e) => {
  var c, h;
  const { paragraphs: t, listType: n, segmentId: r, document: s } = e;
  if (((c = s.getSelfOrHeaderFooterModel(r).getBody()) == null ? void 0 : c.paragraphs) == null)
    return !1;
  const a = et(6), l = new Gn();
  l.reset();
  const u = new Ne();
  for (const d of t) {
    const { startIndex: f, paragraphStyle: g = {}, bullet: _ } = d;
    u.push({
      t: Z.RETAIN,
      len: f - l.cursor
    }), u.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: g,
            bullet: {
              nestingLevel: (h = _ == null ? void 0 : _.nestingLevel) != null ? h : 0,
              textStyle: (_ == null ? void 0 : _.listType) === n ? _.textStyle : {
                fs: 20
              },
              listType: n,
              listId: a
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), l.moveCursorTo(f + 1);
  }
  return u;
};
function sE(e, t) {
  return t.some((n) => e.startIndex > n.startIndex && e.startIndex < n.endIndex);
}
const iE = (e) => {
  var u, c, h;
  const { paragraphs: t, document: n, type: r } = e, s = new Gn();
  s.reset();
  const i = new Ne(), o = (u = n.getSnapshot().lists) != null ? u : {}, a = (h = (c = n.getBody()) == null ? void 0 : c.tables) != null ? h : [], l = {
    ...$s,
    ...o
  };
  for (const d of t) {
    const { startIndex: f, paragraphStyle: g = {}, bullet: _ } = d, R = sE(d, a);
    if (i.push({
      t: Z.RETAIN,
      len: f - s.cursor
    }), _) {
      const b = _.listType;
      let H = l[b].nestingLevel.length - 1;
      R && (H = Math.min(H, 2)), i.push({
        t: Z.RETAIN,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              startIndex: 0,
              paragraphStyle: {
                ...g
              },
              bullet: {
                ..._,
                nestingLevel: Math.max(Math.min(_.nestingLevel + r, H), 0)
              }
            }
          ]
        },
        coverType: pe.REPLACE
      });
    } else
      i.push({
        t: Z.RETAIN,
        len: 1
      });
    s.moveCursorTo(f + 1);
  }
  return i;
}, oE = (e) => {
  var R, b, H, P;
  const {
    textRanges: t,
    segmentId: n,
    document: r,
    style: s,
    paragraphTextRun: i,
    cursor: o,
    deleteLen: a,
    textX: l
  } = e, u = r.getSelfOrHeaderFooterModel(n), c = (b = (R = u.getBody()) == null ? void 0 : R.paragraphs) != null ? b : [], h = (P = (H = u.getBody()) == null ? void 0 : H.dataStream) != null ? P : "", d = $i(t, c, h), f = new Gn();
  o && f.moveCursorTo(o);
  const g = l != null ? l : new Ne();
  d.sort((W, w) => W.startIndex - w.startIndex);
  const _ = Math.max(0, d[0].paragraphStart - 1);
  _ > f.cursor && (g.push({
    t: Z.RETAIN,
    len: _ - f.cursor
  }), f.moveCursorTo(_)), a && g.push({
    t: Z.DELETE,
    len: a
  });
  for (const W of d) {
    const { startIndex: w, paragraphStyle: C = {} } = W, v = w - f.cursor;
    g.push({
      t: Z.RETAIN,
      len: v,
      ...i ? {
        body: {
          dataStream: "",
          textRuns: [{
            ts: i,
            st: 0,
            ed: v
          }]
        },
        coverType: pe.REPLACE
      } : null
    }), g.push({
      t: Z.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: {
              ...C,
              ...s
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), f.moveCursorTo(w + 1);
  }
  return g;
};
class Je {
}
p(Je, "customRange", {
  add: W0,
  delete: j0,
  copyCustomRange: P0,
  getCustomRangesInterestsWithSelection: k0,
  isIntersecting: ec
}), p(Je, "customDecoration", {
  add: D0,
  delete: U0
}), p(Je, "selection", {
  replace: z0,
  makeSelection: Z0,
  normalizeSelection: J0,
  delete: rc,
  replaceTextRuns: G0,
  retain: Y0
}), p(Je, "range", {
  isIntersects: Q0,
  getParagraphsInRange: Fi,
  getParagraphsInRanges: $i
}), p(Je, "transform", {
  getPlainText: qo,
  fromPlainText: L0,
  isEmptyDocument: M0
}), p(Je, "paragraph", {
  bullet: {
    set: rE,
    switch: tE,
    toggleChecklist: nE,
    changeNestLevel: iE
  },
  style: {
    set: oE
  },
  util: {
    transform: Zo,
    getParagraphsInRange: Fi,
    getParagraphsInRanges: $i
  }
}), p(Je, "drawing", {
  add: q0
});
function AR(e, t, n, r) {
  var u;
  if (t === "")
    return e;
  const s = {
    id: "mock-id",
    body: e,
    documentStyle: {}
  }, i = new Pt(s), o = t.length;
  let a;
  for (; (a = (r ? i.getBody().dataStream : i.getBody().dataStream.toLowerCase()).indexOf(t)) >= 0; ) {
    const c = new Ne(), h = Qt.getInstance();
    if (a > 0 && c.retain(a), n.length > 0) {
      const d = i.sliceBody(a, a + o), f = {
        dataStream: n
      };
      if (Array.isArray(d == null ? void 0 : d.textRuns) && d.textRuns.length && (f.textRuns = [{
        ...d.textRuns[0],
        st: 0,
        ed: n.length
      }]), (u = d == null ? void 0 : d.customRanges) != null && u.length) {
        const g = d.customRanges[0];
        f.customRanges = [{
          ...g,
          startIndex: 0,
          endIndex: n.length - 1
        }];
      }
      c.insert(n.length, f);
    }
    c.delete(o), i.apply(h.editOp(c.serialize()));
  }
  const l = i.getBody();
  return i.dispose(), l;
}
function aE(e) {
  if (e.customRanges || (e.customRanges = []), !e.paragraphs) {
    e.paragraphs = [];
    for (let t = 0; t < e.dataStream.length; t++)
      e.dataStream[t] === "\r" && e.paragraphs.push({ startIndex: t });
  }
  return e.customBlocks || (e.customBlocks = []), e.textRuns || (e.textRuns = []), e.customDecorations || (e.customDecorations = []), e.sectionBreaks || (e.sectionBreaks = []), e.tables || (e.tables = []), e;
}
function sc(e) {
  var t;
  return e.body = aE((t = e.body) != null ? t : { dataStream: "" }), e.drawingsOrder || (e.drawingsOrder = []), e.drawings || (e.drawings = {}), e.documentStyle || (e.documentStyle = {}), e;
}
class Hs {
  /**
   * Creates a new TextStyleValue instance
   * @param {ITextStyle} style The initial style object
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  constructor(t = {}) {
    p(this, "_style");
    this._style = t;
  }
  /**
   * Creates an instance of TextStyleValue.
   * @param {ITextStyle} style style object
   * @returns {TextStyleValue} font style instance
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  static create(t = {}) {
    return new Hs(t);
  }
  /**
   * Gets the font family
   * @returns {Nullable<string>} The font family name or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.fontFamily);
   * ```
   */
  get fontFamily() {
    return this._style.ff;
  }
  /**
   * Gets the font size in points
   * @returns {number | undefined} The font size or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.fontSize);
   * ```
   */
  get fontSize() {
    return this._style.fs;
  }
  /**
   * Gets whether the text is italic
   * @returns {boolean} True if italic, false otherwise
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.italic);
   * ```
   */
  get italic() {
    return this._style.it === ie.TRUE;
  }
  /**
   * Gets whether the text is bold
   * @returns {boolean} True if bold, false otherwise
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.bold);
   * ```
   */
  get bold() {
    return this._style.bl === ie.TRUE;
  }
  /**
   * Gets the underline decoration
   * @returns {TextDecorationBuilder | undefined} The underline decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.underline);
   * ```
   */
  get underline() {
    return this._style.ul && hn.create(this._style.ul);
  }
  /**
   * Gets the bottom border line decoration
   * @returns {TextDecorationBuilder | undefined} The bottom border line decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.bottomBorderLine);
   * ```
   */
  get bottomBorderLine() {
    return this._style.bbl && hn.create(this._style.bbl);
  }
  /**
   * Gets the strikethrough decoration
   * @returns {TextDecorationBuilder | undefined} The strikethrough decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.strikethrough);
   * ```
   */
  get strikethrough() {
    return this._style.st && hn.create(this._style.st);
  }
  /**
   * Gets the overline decoration
   * @returns {TextDecorationBuilder | undefined} The overline decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.overline);
   * ```
   */
  get overline() {
    return this._style.ol && hn.create(this._style.ol);
  }
  /**
   * Gets the background color
   * @returns {Nullable<IColorStyle>} The background color or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.background);
   * ```
   */
  get background() {
    return this._style.bg;
  }
  /**
   * Gets the border settings
   * @returns {Nullable<IBorderData>} The border settings or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.border);
   * ```
   */
  get border() {
    return this._style.bd;
  }
  /**
   * Gets the text color
   * @returns {Nullable<IColorStyle>} The text color or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.color);
   * ```
   */
  get color() {
    return this._style.cl;
  }
  /**
   * Gets the vertical alignment (subscript/superscript)
   * @returns {Nullable<BaselineOffset>} The vertical alignment or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.verticalAlign);
   * ```
   */
  get verticalAlign() {
    return this._style.va;
  }
  /**
   * Gets the number format pattern
   * @returns {Nullable<{ pattern: string }>} The number format pattern or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.numberFormat);
   * ```
   */
  get numberFormat() {
    return this._style.n;
  }
  /**
   * Creates a copy of this font style as a builder
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance with the same style
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * const copy = style.copy();
   * console.log(copy);
   * ```
   */
  copy() {
    return gn.create(J.deepClone(this._style));
  }
  /**
   * Gets the raw style object
   * @returns {ITextStyle} The underlying style object
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.getValue());
   * ```
   */
  getValue() {
    return { ...this._style };
  }
}
class gn extends Hs {
  /**
   * Creates a new TextStyleBuilder instance
   * @param {ITextStyle} style Initial style object
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  static create(t = {}) {
    return new gn(t);
  }
  /**
   * Creates a new TextStyleBuilder instance
   * @param {ITextStyle} style The initial style object
   * @example
   * ```ts
   * const style = new TextStyleBuilder({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  constructor(t = {}) {
    super(t);
  }
  /**
   * Sets the font family
   * @param {string} family The font family name
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setFontFamily('Times New Roman');
   * console.log(style.fontFamily);
   * ```
   */
  setFontFamily(t) {
    return this._style.ff = t, this;
  }
  /**
   * Sets the font size in points
   * @param {number} size The font size
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setFontSize(14);
   * console.log(style.fontSize);
   * ```
   */
  setFontSize(t) {
    return this._style.fs = t, this;
  }
  /**
   * Sets the italic style
   * @param {boolean} value True to make italic, false otherwise
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setItalic(true);
   * console.log(style.italic);
   * ```
   */
  setItalic(t) {
    return this._style.it = t ? 1 : 0, this;
  }
  /**
   * Sets the bold style
   * @param {boolean} value True to make bold, false otherwise
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setBold(true);
   * console.log(style.bold);
   * ```
   */
  setBold(t) {
    return this._style.bl = t ? 1 : 0, this;
  }
  /**
   * Sets the underline decoration
   * @param {TextDecorationBuilder} decoration The underline decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setUnderline({ type: 'single', color: '#FF0000' });
   * console.log(style.underline);
   * ```
   */
  setUnderline(t) {
    return this._style.ul = t.build(), this;
  }
  /**
   * Sets the bottom border line decoration
   * @param {TextDecorationBuilder} decoration The bottom border line decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setBottomBorderLine({ type: 'single', color: '#FF0000' });
   * console.log(style.bottomBorderLine);
   * ```
   */
  setBottomBorderLine(t) {
    return this._style.bbl = t.build(), this;
  }
  /**
   * Sets the strikethrough decoration
   * @param {TextDecorationBuilder} decoration The strikethrough decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setStrikethrough(t) {
    return this._style.st = t.build(), this;
  }
  /**
   * Sets the overline decoration
   * @param {TextDecorationBuilder} decoration The overline decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setOverline(t) {
    return this._style.ol = t.build(), this;
  }
  /**
   * Sets the background color
   * @param {IColorStyle | null} color The background color or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setBackground(t) {
    return this._style.bg = t, this;
  }
  /**
   * Sets the border settings
   * @param {IBorderData | null} border The border settings or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setBorder(t) {
    return this._style.bd = t, this;
  }
  /**
   * Sets the text color
   * @param {IColorStyle | null} color The text color or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setColor(t) {
    return this._style.cl = t, this;
  }
  /**
   * Sets the vertical alignment (subscript/superscript)
   * @param {BaselineOffset | null} offset The vertical alignment or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setVerticalAlign(t) {
    return this._style.va = t, this;
  }
  /**
   * Creates a copy of this font style builder
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance with the same style
   */
  copy() {
    return gn.create(J.deepClone(this._style));
  }
  /**
   * Builds and returns the final style object
   * @returns {ITextStyle} The complete style object
   */
  build() {
    return this.getValue();
  }
}
class hn {
  /**
   * Creates a new TextDecorationBuilder instance
   * @param {ITextDecoration} decoration The initial decoration object
   * @example
   * ```ts
   * const decoration = new TextDecorationBuilder({ s: 1, t: TextDecoration.SINGLE });
   * ```
   */
  constructor(t = { s: 1 }) {
    p(this, "_decoration");
    this._decoration = t;
  }
  /**
   * Creates an instance of TextDecorationBuilder.
   * @param {ITextDecoration} decoration Initial decoration object
   * @returns {TextDecorationBuilder} text decoration builder instance
   * @example
   * ```ts
   * const decoration = TextDecorationBuilder.create({ s: 1, t: TextDecoration.SINGLE });
   * console.log(decoration);
   * ```
   */
  static create(t = { s: 1 }) {
    return new hn(t);
  }
  /**
   * Gets whether the decoration is shown
   * @returns {boolean} True if the decoration is shown
   */
  get show() {
    return this._decoration.s === ie.TRUE;
  }
  /**
   * Gets whether the decoration color follows the font color
   * @returns {boolean} True if the decoration color follows the font color
   */
  get followFontColor() {
    return this._decoration.c === ie.TRUE;
  }
  /**
   * Gets the decoration color
   * @returns {Nullable<IColorStyle>} The decoration color
   */
  get color() {
    return this._decoration.cl;
  }
  /**
   * Gets the decoration line type
   * @returns {Nullable<TextDecoration>} The decoration line type
   */
  get type() {
    return this._decoration.t;
  }
  /**
   * Sets whether the decoration is shown
   * @param {boolean} value True to show the decoration
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setShow(true);
   * ```
   */
  setShow(t) {
    return this._decoration.s = t ? 1 : 0, this;
  }
  /**
   * Sets whether the decoration color follows the font color
   * @param {boolean} value True to follow font color
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setFollowFontColor(false);
   * ```
   */
  setFollowFontColor(t) {
    return this._decoration.c = t ? 1 : 0, this;
  }
  /**
   * Sets the decoration color
   * @param {IColorStyle} color The color style
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setColor({ rgb: '#FF0000' });
   * ```
   */
  setColor(t) {
    return this._decoration.cl = t, this;
  }
  /**
   * Sets the decoration line type
   * @param {TextDecoration} type The line type
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setLineType(TextDecoration.SINGLE);
   * ```
   */
  setLineType(t) {
    return this._decoration.t = t, this;
  }
  /**
   * Creates a copy of this text decoration builder
   * @returns {TextDecorationBuilder} A new TextDecorationBuilder instance with the same decoration
   * @example
   * ```ts
   * const copy = decoration.copy();
   * ```
   */
  copy() {
    return hn.create(J.deepClone(this._decoration));
  }
  /**
   * Builds and returns the final decoration object
   * @returns {ITextDecoration} The complete text decoration object
   * @example
   * ```ts
   * const style = decoration.build();
   * ```
   */
  build() {
    return { ...this._decoration };
  }
}
class Bs {
  constructor(t = {}) {
    p(this, "_style");
    this._style = t;
  }
  /**
   * Creates a new ParagraphStyleValue instance
   * @param {IParagraphStyle} style The initial style object
   * @returns A new ParagraphStyleValue instance
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * ```
   */
  static create(t = {}) {
    return new Bs(t);
  }
  /**
   * Gets the first line indent
   * @returns {Nullable<INumberUnit>} The first line indent
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentFirstLine);
   * ```
   */
  get indentFirstLine() {
    return this._style.indentFirstLine;
  }
  /**
   * Gets the hanging indent
   * @returns {Nullable<INumberUnit>} The hanging indent
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.hanging);
   * ```
   */
  get hanging() {
    return this._style.hanging;
  }
  /**
   * Gets the indent start
   * @returns {Nullable<INumberUnit>} The indent start
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentStart);
   * ```
   */
  get indentStart() {
    return this._style.indentStart;
  }
  /**
   * Gets the indent end
   * @returns {Nullable<INumberUnit>} The indent end
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentEnd);
   * ```
   */
  get tabStops() {
    return this._style.tabStops;
  }
  /**
   * Gets the indent end
   * @returns {Nullable<INumberUnit>} The indent end
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentEnd);
   * ```
   */
  get indentEnd() {
    return this._style.indentEnd;
  }
  /**
   * Gets the text style
   * @returns {Nullable<ITextStyle>} The text style
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.textStyle);
   * ```
   */
  get textStyle() {
    return this._style.textStyle;
  }
  /**
   * Gets the heading id
   * @returns {Nullable<string>} The heading id
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.headingId);
   * ```
   */
  get headingId() {
    return this._style.headingId;
  }
  /**
   * Gets the named style type
   * @returns {Nullable<NamedStyleType>} The named style type
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.namedStyleType);
   * ```
   */
  get namedStyleType() {
    return this._style.namedStyleType;
  }
  /**
   * Gets the horizontal align
   * @returns {Nullable<HorizontalAlign>} The horizontal align
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.horizontalAlign);
   * ```
   */
  get horizontalAlign() {
    return this._style.horizontalAlign;
  }
  /**
   * Gets the line spacing
   * @returns {Nullable<number>} The line spacing
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.lineSpacing);
   * ```
   */
  get lineSpacing() {
    return this._style.lineSpacing;
  }
  /**
   * Gets the text direction
   * @returns {Nullable<TextDirection>} The text direction
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.direction);
   * ```
   */
  get direction() {
    return this._style.direction;
  }
  /**
   * Gets the spacing rule
   * @returns {Nullable<SpacingRule>} The spacing rule
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spacingRule);
   * ```
   */
  get spacingRule() {
    return this._style.spacingRule;
  }
  /**
   * Gets the snap to grid
   * @returns {Nullable<BooleanNumber>} The snap to grid
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.snapToGrid);
   * ```
   */
  get snapToGrid() {
    return this._style.snapToGrid;
  }
  /**
   * Gets the space above
   * @returns {Nullable<INumberUnit>} The space above
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spaceAbove);
   * ```
   */
  get spaceAbove() {
    return this._style.spaceAbove;
  }
  /**
   * Gets the space below
   * @returns {Nullable<INumberUnit>} The space below
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spaceBelow);
   * ```
   */
  get spaceBelow() {
    return this._style.spaceBelow;
  }
  /**
   * Gets the border between
   * @returns {Nullable<IParagraphBorder>} The border between
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderBetween);
   * ```
   */
  get borderBetween() {
    return this._style.borderBetween;
  }
  /**
   * Gets the border top
   * @returns {Nullable<IParagraphBorder>} The border top
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderTop);
   * ```
   */
  get borderTop() {
    return this._style.borderTop;
  }
  /**
   * Gets the border bottom
   * @returns {Nullable<IParagraphBorder>} The border bottom
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderBottom);
   * ```
   */
  get borderBottom() {
    return this._style.borderBottom;
  }
  /**
   * Gets the border left
   * @returns {Nullable<IParagraphBorder>} The border left
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderLeft);
   * ```
   */
  get borderLeft() {
    return this._style.borderLeft;
  }
  /**
   * Gets the border right
   * @returns {Nullable<IParagraphBorder>} The border right
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderRight);
   * ```
   */
  get borderRight() {
    return this._style.borderRight;
  }
  /**
   * Gets the keep lines
   * @returns {boolean} The keep lines
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.keepLines);
   * ```
   */
  get keepLines() {
    return this._style.keepLines === ie.TRUE;
  }
  /**
   * Gets the keep next
   * @returns {boolean} The keep next
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.keepNext);
   * ```
   */
  get keepNext() {
    return this._style.keepNext === ie.TRUE;
  }
  /**
   * Gets the word wrap
   * @returns {boolean} The word wrap
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.wordWrap);
   * ```
   */
  get wordWrap() {
    return this._style.wordWrap === ie.TRUE;
  }
  /**
   * Gets the widow control
   * @returns {boolean} The widow control
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.widowControl);
   * ```
   */
  get widowControl() {
    return this._style.widowControl === ie.TRUE;
  }
  /**
   * Gets the shading
   * @returns {Nullable<IShading>} The shading
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.shading);
   * ```
   */
  get shading() {
    return this._style.shading;
  }
  /**
   * Gets the suppress hyphenation
   * @returns {boolean} The suppress hyphenation
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.suppressHyphenation);
   * ```
   */
  get suppressHyphenation() {
    return this._style.suppressHyphenation === ie.TRUE;
  }
  /**
   * Creates a copy of the paragraph style
   * @returns {ParagraphStyleBuilder} The copy
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  copy() {
    return Cs.create(J.deepClone(this._style));
  }
  /**
   * Gets the value
   * @returns {IParagraphStyle} The value
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.getValue());
   * ```
   */
  getValue() {
    return this._style;
  }
}
class Cs extends Bs {
  /**
   * Creates a new paragraph style builder
   * @param style The paragraph style
   * @returns A new paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  static create(t = {}) {
    return new Cs(t);
  }
  constructor(t = {}) {
    super(t);
  }
  /**
   * Sets the indent first line
   * @param value The indent first line
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentFirstLine(10);
   * ```
   */
  setIndentFirstLine(t) {
    return this._style.indentFirstLine = t, this;
  }
  /**
   * Sets the hanging
   * @param value The hanging
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setHanging(10);
   * ```
   */
  setHanging(t) {
    return this._style.hanging = t, this;
  }
  /**
   * Sets the indent start
   * @param value The indent start
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentStart(10);
   * ```
   */
  setIndentStart(t) {
    return this._style.indentStart = t, this;
  }
  /**
   * Sets the tab stops
   * @param value The tab stops
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTabStops([{ value: 10 }]);
   * ```
   */
  setTabStops(t) {
    return this._style.tabStops = t, this;
  }
  /**
   * Sets the indent end
   * @param value The indent end
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentEnd(10);
   * ```
   */
  setIndentEnd(t) {
    return this._style.indentEnd = t, this;
  }
  /**
   * Sets the text style
   * @param value The text style
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTextStyle({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * ```
   */
  setTextStyle(t) {
    return this._style.textStyle = t, this;
  }
  /**
   * Sets the heading id
   * @param value The heading id
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setHeadingId('test');
   * ```
   */
  setHeadingId(t) {
    return this._style.headingId = t, this;
  }
  /**
   * Sets the named style type
   * @param value The named style type
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setNamedStyleType(NamedStyleType.CHAPTER);
   * ```
   */
  setNamedStyleType(t) {
    return this._style.namedStyleType = t, this;
  }
  /**
   * Sets the vertical align
   * @param value The vertical align
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setVerticalAlign(VerticalAlign.CENTER);
   * ```
   */
  setHorizontalAlign(t) {
    return this._style.horizontalAlign = t, this;
  }
  /**
   * Sets the line spacing
   * @param value The line spacing
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setLineSpacing(10);
   * ```
   */
  setLineSpacing(t) {
    return this._style.lineSpacing = t, this;
  }
  /**
   * Sets the text direction
   * @param value The text direction
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTextDirection(TextDirection.RIGHT_TO_LEFT);
   * ```
   */
  setDirection(t) {
    return this._style.direction = t, this;
  }
  /**
   * Sets the spacing rule
   * @param value The spacing rule
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpacingRule(SpacingRule.AUTO);
   * ```
   */
  setSpacingRule(t) {
    return this._style.spacingRule = t, this;
  }
  /**
   * Sets the snap to grid
   * @param value The snap to grid
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSnapToGrid(true);
   * ```
   */
  setSnapToGrid(t) {
    return this._style.snapToGrid = t ? 1 : 0, this;
  }
  /**
   * Sets the space above
   * @param value The space above
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpaceAbove(10);
   * ```
   */
  setSpaceAbove(t) {
    return this._style.spaceAbove = t, this;
  }
  /**
   * Sets the space below
   * @param value The space below
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpaceBelow(10);
   * ```
   */
  setSpaceBelow(t) {
    return this._style.spaceBelow = t, this;
  }
  /**
   * Sets the border between
   * @param {IParagraphBorder} value The border between
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderBetween({ color: 'red', width: 1 });
   * ```
   */
  setBorderBetween(t) {
    return this._style.borderBetween = t, this;
  }
  /**
   * Sets the border top
   * @param {IParagraphBorder} value The border top
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderTop({ color: 'red', width: 1 });
   * ```
   */
  setBorderTop(t) {
    return this._style.borderTop = t, this;
  }
  /**
   * Sets the border bottom
   * @param {IParagraphBorder} value The border bottom
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderBottom({ color: 'red', width: 1 });
   * ```
   */
  setBorderBottom(t) {
    return this._style.borderBottom = t, this;
  }
  /**
   * Sets the border left
   * @param {IParagraphBorder} value The border left
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderLeft({ color: 'red', width: 1 });
   * ```
   */
  setBorderLeft(t) {
    return this._style.borderLeft = t, this;
  }
  /**
   * Sets the border right
   * @param {IParagraphBorder} value The border right
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderRight({ color: 'red', width: 1 });
   * ```
   */
  setBorderRight(t) {
    return this._style.borderRight = t, this;
  }
  /**
   * Sets the keep lines
   * @param value The keep lines
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setKeepLines(true);
   * ```
   */
  setKeepLines(t) {
    return this._style.keepLines = t ? 1 : 0, this;
  }
  /**
   * Sets the keep next
   * @param value The keep next
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setKeepNext(true);
   * ```
   */
  setKeepNext(t) {
    return this._style.keepNext = t ? 1 : 0, this;
  }
  /**
   * Sets the word wrap
   * @param value The word wrap
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setWordWrap(true);
   * ```
   */
  setWordWrap(t) {
    return this._style.wordWrap = t ? 1 : 0, this;
  }
  /**
   * Sets the widow control
   * @param {boolean} value The widow control value
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setWidowControl(true);
   * ```
   */
  setWidowControl(t) {
    return this._style.widowControl = t ? 1 : 0, this;
  }
  /**
   * Sets the shading style
   * @param {IShading} value The shading configuration
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setShading({ backgroundColor: '#f0f0f0' });
   * ```
   */
  setShading(t) {
    return this._style.shading = t, this;
  }
  /**
   * Sets whether to suppress hyphenation
   * @param {boolean} value The suppress hyphenation value
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSuppressHyphenation(true);
   * ```
   */
  setSuppressHyphenation(t) {
    return this._style.suppressHyphenation = t ? 1 : 0, this;
  }
  /**
   * Creates a copy of the current paragraph style builder
   * @returns {ParagraphStyleBuilder} A new instance of ParagraphStyleBuilder with the same settings
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  copy() {
    return Cs.create(J.deepClone(this._style));
  }
  /**
   * Builds and returns the final paragraph style configuration
   * @returns {IParagraphStyle} The constructed paragraph style object
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const finalStyle = style.build();
   * ```
   */
  build() {
    return this.getValue();
  }
}
class dn {
  constructor(t) {
    p(this, "_data");
    if (!t.body)
      throw new Error("Invalid document data, body is required");
    this._data = sc(t);
  }
  /**
   * Creates a new RichTextValue instance
   * @param {IDocumentData} data The initial data for the rich text value
   * @returns {RichTextValue} A new RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * ```
   */
  static create(t) {
    return new dn(t);
  }
  /**
   * Creates a new RichTextValue instance
   * @param {IDocumentBody} data The initial data for the rich text value
   * @returns {RichTextValue} A new RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.createByBody({ dataStream: 'Hello World\r\n' });
   * ```
   */
  static createByBody(t) {
    return new dn({ body: t, id: "d", documentStyle: {} });
  }
  /**
   * Creates a copy of the current RichTextValue instance
   * @returns {RichTextValue} A new instance of RichTextValue with the same data
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const copy = richText.copy();
   * ```
   */
  copy() {
    return Pn.create(J.deepClone(this._data));
  }
  /**
   * Slices the current RichTextValue instance
   * @param {number} start The start index
   * @param {number} end The end index
   * @returns {RichTextBuilder} A new instance of RichTextBuilder with the sliced data
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const sliced = richText.slice(0, 5);
   * ```
   */
  slice(t, n) {
    const { body: r, ...s } = this._data;
    return Pn.create({
      ...J.deepClone(s),
      body: kt(r, t, n)
    });
  }
  /**
   * Converts the current RichTextValue instance to plain text
   * @returns {string} The plain text representation of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const plainText = richText.toPlainText();
   * ```
   */
  toPlainText() {
    var t, n;
    return Je.transform.getPlainText((n = (t = this._data.body) == null ? void 0 : t.dataStream) != null ? n : "").replaceAll("\r", `
`);
  }
  /**
   * Gets the paragraph style of the current RichTextValue instance
   * @returns {ParagraphStyleValue} The paragraph style of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const style = richText.getParagraphStyle();
   * ```
   */
  getParagraphStyle() {
    var t, n;
    return Bs.create((n = (t = this._data.body) == null ? void 0 : t.paragraphs) == null ? void 0 : n[0].paragraphStyle);
  }
  /**
   * Gets the paragraph bullet of the current RichTextValue instance
   * @returns {ParagraphBulletValue} The paragraph bullet of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const bullet = richText.getParagraphBullet();
   * ```
   */
  getParagraphBullet() {
    var t, n;
    return (n = (t = this._data.body) == null ? void 0 : t.paragraphs) == null ? void 0 : n[0].bullet;
  }
  /**
   * Gets the paragraphs of the current RichTextValue instance
   * @returns {RichTextValue[]} The paragraphs of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const paragraphs = richText.getParagraphs();
   * ```
   */
  getParagraphs() {
    var r, s;
    const t = (s = (r = this._data.body) == null ? void 0 : r.paragraphs) != null ? s : [];
    let n = 0;
    return t.map((i) => {
      const o = this.slice(n, i.startIndex);
      return n = i.startIndex, o;
    });
  }
  /**
   * Gets the text runs of the current RichTextValue instance
   * @returns {TextRunValue[]} The text runs of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const textRuns = richText.getTextRuns();
   * ```
   */
  getTextRuns() {
    var t, n;
    return ((n = (t = this._data.body) == null ? void 0 : t.textRuns) != null ? n : []).map((r) => ({
      ...r,
      ts: r.ts ? Hs.create(r.ts) : null
    }));
  }
  /**
   * Gets the links of the current RichTextValue instance
   * @returns {ICustomRange[]} The links of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const links = richText.getLinks();
   * ```
   */
  getLinks() {
    var t, n, r;
    return (r = (n = (t = this._data.body) == null ? void 0 : t.customRanges) == null ? void 0 : n.filter((s) => s.rangeType === pn.HYPERLINK)) != null ? r : [];
  }
  /**
   * Gets the data of the current RichTextValue instance
   * @returns {IDocumentData} The data of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const data = richText.getData();
   * ```
   */
  getData() {
    return this._data;
  }
}
class Pn extends dn {
  constructor(n) {
    super(n);
    p(this, "_doc");
    this._doc = new Pt(n);
  }
  static newEmptyData() {
    return sc({
      id: "d",
      documentStyle: {},
      drawings: {},
      drawingsOrder: [],
      body: {
        dataStream: `\r
`,
        customBlocks: [],
        customRanges: [],
        paragraphs: [{ startIndex: 0 }],
        textRuns: [],
        tables: [],
        sectionBreaks: []
      }
    });
  }
  /**
   * Creates a new RichTextBuilder instance
   * @param {IDocumentData} data The initial data for the rich text builder
   * @returns {RichTextBuilder} A new RichTextBuilder instance
   */
  static create(n) {
    return new Pn(n != null ? n : Pn.newEmptyData());
  }
  insertText(n, r, s) {
    var c, h;
    let i = ((h = (c = this._data.body) == null ? void 0 : c.dataStream.length) != null ? h : 2) - 2, o, a;
    if (typeof n == "string" ? o = n : (i = Math.min(n, i), o = r), typeof r == "object" ? a = r instanceof gn ? r.build() : r : a = s instanceof gn ? s.build() : s, !o) return this;
    const l = {
      dataStream: o,
      textRuns: a ? [
        {
          ts: a,
          st: i,
          ed: i + o.length
        }
      ] : []
    }, u = Je.selection.replace({
      doc: this._doc,
      selection: { startOffset: i, endOffset: i, collapsed: !0 },
      body: l
    });
    if (!u)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), u.serialize()), this;
  }
  insertRichText(n, r) {
    var a, l;
    let s = ((l = (a = this._data.body) == null ? void 0 : a.dataStream.length) != null ? l : 2) - 2, i;
    typeof n == "object" ? i = n instanceof dn ? n.getData() : n : (s = Math.min(n, s), i = r instanceof dn ? r.getData() : r);
    const o = Je.selection.replace({
      doc: this._doc,
      selection: { startOffset: s, endOffset: s, collapsed: !0 },
      body: i.body
    });
    if (!o)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), o.serialize()), this;
  }
  delete(n, r) {
    if (r !== void 0) {
      if (!r) return this;
      const s = Je.selection.delete([{ startOffset: n, endOffset: n + r, collapsed: !0 }], this._data.body);
      Ne.apply(this._doc.getBody(), s);
    }
    return this;
  }
  /**
   * Sets the style of the text at the specified start and end positions
   * @param {number} start The start position of the text to set the style
   * @param {number} end The end position of the text to set the style
   * @param {TextStyleBuilder | ITextStyle} style The style to set
   * @returns {RichTextBuilder} The current RichTextBuilder instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const newRichText = richText.setStyle(5, 10, { ff: 'Arial', fs: 12 });
   * ```
   */
  setStyle(n, r, s) {
    const i = {
      dataStream: "",
      textRuns: [{
        ts: s instanceof gn ? s.build() : s,
        st: 0,
        ed: r - n
      }]
    }, o = Je.selection.retain([{ startOffset: n, endOffset: r, collapsed: !0 }], i);
    return Ne.apply(this._doc.getBody(), o), this;
  }
  /**
   * Sets the link of the text at the specified start and end positions
   * @param {number} start The start position of the text to set the link
   * @param {number} end The end position of the text to set the link
   * @param {string} link The link to set
   * @returns {RichTextBuilder} The current RichTextBuilder instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const newRichText = richText.setLink(5, 10, 'https://www.example.com');
   * ```
   */
  setLink(n, r, s) {
    const i = Je.customRange.add({
      rangeType: pn.HYPERLINK,
      rangeId: et(),
      properties: {
        url: s
      },
      ranges: [{ startOffset: n, endOffset: r, collapsed: !1 }],
      body: this._data.body
    });
    if (!i)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), i.serialize()), this;
  }
  cancelLink(n, r) {
    if (typeof n == "string") {
      const s = Je.customRange.delete({
        rangeId: n,
        documentDataModel: this._doc
      });
      if (!s)
        throw new Error("Insert text failed, please check.");
      Ne.apply(this._doc.getBody(), s.serialize());
    } else
      this.slice(n, r).getLinks().forEach((i) => {
        const o = Je.customRange.delete({
          rangeId: i.rangeId,
          documentDataModel: this._doc
        });
        if (!o)
          throw new Error("Insert text failed, please check.");
        Ne.apply(this._doc.getBody(), o.serialize());
      });
    return this;
  }
  updateLink(n, r) {
    var i, o;
    const s = (o = (i = this._data.body) == null ? void 0 : i.customRanges) == null ? void 0 : o.find((a) => a.rangeId === n);
    if (!s)
      throw new Error("Link not found");
    return s.properties.url = r, this;
  }
  insertParagraph(n, r) {
    var o, a;
    let s, i;
    return typeof n == "object" ? (s = {
      dataStream: "\r",
      paragraphs: [{
        startIndex: 0,
        paragraphStyle: n.build()
      }]
    }, i = ((a = (o = this._data.body) == null ? void 0 : o.dataStream.length) != null ? a : 2) - 2) : (i = n, s = {
      dataStream: "\r",
      paragraphs: [{
        startIndex: 0,
        paragraphStyle: r == null ? void 0 : r.build()
      }]
    }), this.insertRichText(i, dn.create({ body: s, id: "d", documentStyle: {} })), this;
  }
  insertLink(n, r, s) {
    let i = "", o = "";
    typeof n == "string" ? (i = n, o = r) : (i = r, o = s);
    const a = Pn.createByBody({
      dataStream: i,
      customRanges: [{
        rangeType: pn.HYPERLINK,
        rangeId: et(),
        properties: {
          url: o
        },
        startIndex: 0,
        endIndex: i.length - 1
      }]
    });
    return typeof n == "number" ? this.insertRichText(n, a) : this.insertRichText(a);
  }
}
const yR = "__default_document_sub_component_id20231101__";
class lE {
  constructor() {
    /**
     * An WorkBookObserver can set this property to true to prevent subsequent observers of being notified
     */
    p(this, "skipNextObservers", !1);
    /**
     * This will be populated with the return value of the last function that was executed.
     * If it is the first function in the callback chain it will be the event data.
     */
    p(this, "lastReturnValue");
    p(this, "isStopPropagation", !1);
  }
  stopPropagation() {
    this.isStopPropagation = !0;
  }
}
class NR extends ot {
  constructor() {
    super(...arguments);
    p(this, "_sortedObservers", []);
  }
  /** @deprecated Use `subscribeEvent` instead. */
  subscribe() {
    throw new Error("[EventSubject]: please use `subscribeEvent` instead of `subscribe` method for `EventSubject`.");
  }
  /** @deprecated Use `emitEvent` instead. */
  next() {
    throw new Error("[EventSubject]: please use `emitEvent` instead of `next` method for `EventSubject`.");
  }
  unsubscribe() {
    super.unsubscribe(), this._sortedObservers.length = 0;
  }
  complete() {
    super.complete(), this._sortedObservers.length = 0;
  }
  subscribeEvent(n) {
    let r;
    typeof n == "function" ? r = { next: ([i, o]) => n(i, o) } : r = n;
    const s = super.subscribe(r);
    return this._sortedObservers.push(r), this._sortedObservers.sort((i, o) => {
      var a, l;
      return ((a = i.priority) != null ? a : 0) - ((l = o.priority) != null ? l : 0);
    }), s.add(() => this._sortedObservers = this._sortedObservers.filter((i) => i !== r)), s;
  }
  clearObservers() {
    this._sortedObservers.forEach((n) => {
      var r;
      return (r = n.complete) == null ? void 0 : r.call(n);
    }), this._sortedObservers.length = 0;
  }
  emitEvent(n) {
    var r;
    if (!this.closed) {
      const s = new lE();
      s.lastReturnValue = n;
      for (const i of this._sortedObservers) {
        const o = (r = i.next) == null ? void 0 : r.call(i, [n, s]);
        if (s.lastReturnValue = o, s.skipNextObservers)
          return {
            handled: !0,
            lastReturnValue: s.lastReturnValue,
            stopPropagation: s.isStopPropagation
          };
      }
      return {
        handled: this._sortedObservers.length > 0,
        lastReturnValue: s.lastReturnValue,
        stopPropagation: s.isStopPropagation
      };
    }
    throw new Error("[EventSubject]: cannot emit event on a closed subject.");
  }
}
function TR(e) {
  return new br((t) => {
    const n = e.subscribeEvent((r) => {
      t.next(r);
    });
    return () => n.unsubscribe();
  });
}
const Jo = ht("core.resource-manager.service"), Hi = {
  [xt.Editor]: "Editor",
  [xt.Owner]: "Owner",
  [xt.Reader]: "Reader",
  [xt.UNRECOGNIZED]: "UNRECOGNIZED"
}, Bi = (e) => e ? {
  userID: `${Hi[e]}_${et(8)}`,
  name: Hi[e],
  avatar: ""
} : {
  userID: "",
  name: "",
  avatar: "",
  anonymous: !0,
  canBindAnonymous: !1
}, uE = (e, t) => e.startsWith(Hi[t]);
class Rs extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_model", /* @__PURE__ */ new Map());
    p(this, "_userChange$", new ot());
    p(this, "userChange$", this._userChange$.asObservable());
    p(this, "_currentUser$", new tt(Bi()));
    /**
     * When the current user undergoes a switch or change
     * @memberof UserManagerService
     */
    p(this, "currentUser$", this._currentUser$.asObservable());
  }
  dispose() {
    super.dispose(), this._model.clear(), this._userChange$.complete(), this._currentUser$.complete();
  }
  getCurrentUser() {
    return this._currentUser$.getValue();
  }
  setCurrentUser(n) {
    this.addUser(n), this._currentUser$.next(n);
  }
  addUser(n) {
    this._model.set(n.userID, n), this._userChange$.next({ type: "add", user: n });
  }
  getUser(n, r) {
    const s = this._model.get(n);
    if (s)
      return s;
    r && r();
  }
  delete(n) {
    const r = this.getUser(n);
    this._model.delete(n), r && this._userChange$.next({ type: "delete", user: r });
  }
  clear() {
    this._model.clear(), this._userChange$.next({ type: "clear" });
  }
  list() {
    return Array.from(this._model.values());
  }
}
var cE = Object.getOwnPropertyDescriptor, hE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? cE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, pl = (e, t) => (n, r) => t(n, r, e);
let ji = class {
  // private _sheetPermissionPointMap: Map<string, { action: UnitAction; allowed: boolean }[]> = new Map();
  constructor(e, t) {
    p(this, "_permissionMap", /* @__PURE__ */ new Map([]));
    this._resourceManagerService = e, this._userManagerService = t, this._initSnapshot(), this._initDefaultUser();
  }
  _initDefaultUser() {
    const e = this._userManagerService.getCurrentUser();
    e && e.userID || this._userManagerService.setCurrentUser(Bi(xt.Owner));
  }
  _getRole(e) {
    const t = this._userManagerService.getCurrentUser();
    return t ? uE(t.userID, e) : !1;
  }
  _initSnapshot() {
    this._resourceManagerService.registerPluginResource({
      toJson: (e) => {
        const t = [...this._permissionMap.keys()].reduce((n, r) => {
          const s = this._permissionMap.get(r);
          return n[r] = s, n;
        }, {});
        return JSON.stringify(t);
      },
      parseJson: (e) => JSON.parse(e),
      pluginName: "SHEET_AuthzIoMockService_PLUGIN",
      businesses: [we.UNIVER_SHEET, we.UNIVER_DOC, we.UNIVER_SLIDE],
      onLoad: (e, t) => {
        for (const n in t)
          this._permissionMap.set(n, t[n]);
      },
      onUnLoad: () => {
        this._permissionMap.clear();
      }
    });
  }
  async create(e) {
    return et(8);
  }
  async allowed(e) {
    return Promise.resolve([]);
  }
  async batchAllowed(e) {
    return Promise.resolve([]);
  }
  // eslint-disable-next-line max-lines-per-function
  async list(e) {
    const t = [];
    return e.objectIDs.forEach((n) => {
      const r = this._permissionMap.get(n);
      if (r) {
        const s = {
          objectID: n,
          unitID: e.unitID,
          objectType: r.objectType,
          name: r.name,
          shareOn: !1,
          shareRole: xt.Owner,
          shareScope: -1,
          scope: {
            read: Ri.AllCollaborator,
            edit: Ri.AllCollaborator
          },
          creator: Bi(xt.Owner),
          strategies: [
            {
              action: 6,
              role: 1
            },
            {
              action: 16,
              role: 1
            },
            {
              action: 17,
              role: 1
            },
            {
              action: 18,
              role: 1
            },
            {
              action: 19,
              role: 1
            },
            {
              action: 33,
              role: 1
            },
            {
              action: 34,
              role: 1
            },
            {
              action: 35,
              role: 1
            },
            {
              action: 36,
              role: 1
            },
            {
              action: 37,
              role: 1
            },
            {
              action: 38,
              role: 1
            },
            {
              action: 39,
              role: 1
            },
            {
              action: 40,
              role: 1
            }
          ],
          actions: e.actions.map((i) => ({ action: i, allowed: this._getRole(xt.Owner) || this._getRole(xt.Editor) }))
        };
        t.push(s);
      }
    }), t;
  }
  async listCollaborators() {
    return [];
  }
  async listRoles() {
    return {
      roles: [],
      actions: []
    };
  }
  async deleteCollaborator() {
  }
  async update(e) {
  }
  async updateCollaborator() {
  }
  async createCollaborator() {
  }
  async putCollaborators(e) {
  }
};
ji = hE([
  pl(0, Jo),
  pl(1, Nt(Rs))
], ji);
const dE = ht("IAuthzIoIoService"), ic = ht("univer.config-service");
class fE {
  constructor() {
    p(this, "_configChanged$", new ot());
    p(this, "configChanged$", this._configChanged$.asObservable());
    p(this, "_config", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._config.clear(), this._configChanged$.complete();
  }
  getConfig(t) {
    return this._config.get(t);
  }
  setConfig(t, n, r) {
    var o;
    const { merge: s = !1 } = r || {};
    let i = (o = this._config.get(t)) != null ? o : {};
    s ? i = oo(i, n) : i = n, this._config.set(t, i), this._configChanged$.next({ [t]: i });
  }
  deleteConfig(t) {
    return this._config.delete(t);
  }
  subscribeConfigValue$(t) {
    return new br((n) => {
      Object.prototype.hasOwnProperty.call(this._config, t) && n.next(this._config.get(t));
      const r = this.configChanged$.pipe(Rr((s) => Object.prototype.hasOwnProperty.call(s, t))).subscribe((s) => n.next(s[t]));
      return () => r.unsubscribe();
    });
  }
}
const Xr = "FOCUSING_UNIT", gr = "FOCUSING_SHEET", qr = "FOCUSING_DOC", Zr = "FOCUSING_SLIDE", MR = "FOCUSING_EDITOR_BUT_HIDDEN", mE = "EDITOR_ACTIVATED", LR = "FOCUSING_EDITOR_INPUT_FORMULA", gE = "FOCUSING_FX_BAR_EDITOR", xR = "FOCUSING_UNIVER_EDITOR", DR = "FOCUSING_EDITOR_INPUT_FORMULA", UR = "FOCUSING_PANEL_EDITOR", kR = "FOCUSING_UNIVER_EDITOR_STANDALONE_SINGLE_MODE", PR = "FOCUSING_COMMON_DRAWINGS", FR = "FORMULA_EDITOR_ACTIVATED";
class _E extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_error$", new ot());
    p(this, "error$", this._error$.asObservable());
  }
  dispose() {
    this._error$.complete();
  }
  emit(n) {
    this._error$.next({ errorKey: n });
  }
}
var oc = /* @__PURE__ */ ((e) => (e.URL = "URL", e.UUID = "UUID", e.BASE64 = "BASE64", e))(oc || {}), pE = /* @__PURE__ */ ((e) => (e.SUCCUSS = "0", e.ERROR_EXCEED_SIZE = "1", e.ERROR_IMAGE_TYPE = "2", e.ERROR_UPLOAD_COUNT_LIMIT = "3", e.ERROR_IMAGE = "4", e))(pE || {});
const El = ht("core.image-io.service"), EE = "0.11.0", CE = {
  version: EE
};
function RE(e = "", t = Ns.ZH_CN, n = "") {
  return {
    id: e,
    sheetOrder: [],
    name: n,
    appVersion: CE.version,
    locale: t,
    styles: {},
    sheets: {},
    resources: []
  };
}
class IE {
  constructor(t = {}) {
    p(this, "_styles");
    p(this, "_cacheMap", new gs(1e5));
    this._styles = t, this._generateCacheMap();
  }
  each(t) {
    return Object.entries(this._styles).forEach(t), this;
  }
  search(t, n) {
    if (this._cacheMap.has(n))
      return this._cacheMap.get(n);
    const r = this._getExistingStyleId(t);
    return r || "-1";
  }
  get(t) {
    return typeof t != "string" ? t : (t = String(t), this._styles[t]);
  }
  add(t, n) {
    const r = et(6);
    return this._styles[r] = t, this._cacheMap.set(n, r), r;
  }
  setValue(t) {
    if (t == null) return;
    const n = JSON.stringify(t), r = this.search(t, n);
    return r !== "-1" ? r : this.add(t, n);
  }
  addCustomStyle(t, n) {
    n != null && (this._styles[t] = n, this._cacheMap.set(JSON.stringify(n), t));
  }
  remove(t) {
    this._styles[t] && (delete this._styles[t], this._cacheMap.delete(JSON.stringify(this._styles[t])));
  }
  toJSON() {
    return this._styles;
  }
  // TODO: this should be `deReuseStyle` to be more accurate.
  getStyleByCell(t) {
    let n;
    t && J.isObject(t.s) ? n = t.s : n = (t == null ? void 0 : t.s) && this.get(t.s);
    const r = t == null ? void 0 : t.interceptorStyle;
    return r ? {
      ...n,
      ...r
    } : n;
  }
  _generateCacheMap() {
    const { _styles: t, _cacheMap: n } = this;
    for (const r in t) {
      const s = JSON.stringify(t[r]);
      n.set(s, r);
    }
  }
  _getExistingStyleId(t) {
    const { _styles: n } = this;
    for (const r in n)
      if (J.diffValue(n[r], t))
        return r;
    return null;
  }
}
const $R = (e, t) => t.length === e.length && !e.some((n) => t.some((r) => !En.equals(r, n))), HR = (e, t) => t.length === e.length && e.every((n, r) => {
  const s = t[r];
  return s.unitId === n.unitId && s.sheetId === n.sheetId && En.equals(n.range, s.range);
}), Wi = {
  t: 0,
  b: 2,
  // must over 1, see https://github.com/dream-num/univer/issues/2727
  l: 2,
  r: 2
}, wE = (e) => ({
  sbr: 0.6,
  sbo: e,
  spr: 0.6,
  spo: e
}), Cl = 90;
function Jr(e, t, n = {}) {
  const r = e.length, {
    textRotation: s,
    paddingData: i,
    horizontalAlign: o = Ut.UNSPECIFIED,
    verticalAlign: a = xn.UNSPECIFIED,
    wrapStrategy: l = Bn.UNSPECIFIED,
    cellValueType: u
  } = n, { t: c, r: h, b: d, l: f } = i || Wi, { vertexAngle: g, centerAngle: _ } = ac(s), R = {
    id: "d",
    body: {
      dataStream: `${e}${Bc}`,
      textRuns: [
        {
          ts: t,
          st: 0,
          ed: r
        }
      ],
      paragraphs: [
        {
          startIndex: r,
          paragraphStyle: {
            horizontalAlign: o
          }
        }
      ],
      sectionBreaks: [{
        startIndex: r + 1
      }]
    },
    documentStyle: {
      pageSize: {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      },
      marginTop: c,
      marginBottom: d,
      marginRight: h,
      marginLeft: f,
      renderConfig: {
        horizontalAlign: o,
        verticalAlign: a,
        centerAngle: _,
        vertexAngle: g,
        wrapStrategy: l,
        cellValueType: u
        /**
         * TODO@weird94
         * This config was previously used to fix the issue of cell image editing, now remove it first.
         * If you need to use it, please note the following issues:
         * 1. After delete cell content using backspace, the cell does not enter edit mode.
         * because the code `if (!info || info.actualWidth <= 0) return;`, code in `packages/sheets-ui/src/services/editor/cell-editor-resize.service.ts`
         * 2. copy empty cell content from excel and paste it to univer, the empty cell does not enter edit mode. The reason is the same as above.
         */
        // zeroWidthParagraphBreak: 1,
      }
    },
    drawings: {},
    drawingsOrder: []
  };
  return new Pt(R);
}
function SE(e) {
  if (!e) return {};
  const {
    tr: t,
    td: n,
    ht: r,
    vt: s,
    tb: i,
    pd: o
  } = e;
  return {
    textRotation: t,
    textDirection: n,
    horizontalAlign: r,
    verticalAlign: s,
    wrapStrategy: i,
    paddingData: o
  };
}
function Rl(e) {
  if (!e)
    return {};
  const { ff: t, fs: n, it: r, bl: s, ul: i, st: o, ol: a, cl: l, bg: u } = e, c = {};
  return t && (c.ff = t), n && (c.fs = n), r && (c.it = r), s && (c.bl = s), i && (c.ul = i), o && (c.st = o), a && (c.ol = a), l && (c.cl = l), u && (c.bg = u), c;
}
function OE(e, t, n) {
  var i;
  const r = e.getBody();
  if ((i = r.customRanges) != null && i.some((o) => o.rangeType === pn.HYPERLINK))
    return;
  const s = Je.customRange.add({
    ranges: [
      {
        startOffset: 0,
        endOffset: r.dataStream.length - 1,
        collapsed: !1
      }
    ],
    rangeId: n,
    rangeType: pn.HYPERLINK,
    body: r,
    properties: {
      url: t,
      refId: n
    }
  });
  s && Ne.apply(r, s.serialize());
}
function vE(e) {
  return e != null;
}
const bE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
function Il(e) {
  const t = rt.ff, n = rt.fs;
  if (!e) {
    const h = `${n}pt  ${t}`;
    return {
      fontCache: h,
      fontString: h,
      fontSize: n,
      originFontSize: n,
      fontFamily: t
    };
  }
  let r = ir.ITALIC;
  (e.it === 0 || e.it === void 0) && (r = ir.NORMAL);
  let s = ir.BOLD;
  (e.bl === 0 || e.bl === void 0) && (s = ir.NORMAL);
  let i = n;
  e.fs && (i = Math.ceil(e.fs));
  let o = t;
  if (e.ff) {
    let h = e.ff;
    h = h.replace(/"/g, "").replace(/'/g, ""), h.indexOf(" ") > -1 && (h = `"${h}"`), h == null && (h = t), o = h;
  }
  const { va: a } = e;
  let l = i;
  if (a === Zt.SUBSCRIPT || a === Zt.SUPERSCRIPT) {
    const h = AE(o, l), { sbr: d, spr: f } = h;
    l *= a === Zt.SUBSCRIPT ? d : f;
  }
  const u = `${r} ${s} ${l}pt ${o}`, c = `${u}, ${bE} `;
  return {
    fontCache: u,
    fontString: c,
    fontSize: l,
    originFontSize: i,
    fontFamily: o
  };
}
function AE(e, t) {
  return wE(t);
}
function ac(e) {
  const { a: t = 0, v: n = ie.FALSE } = e || { a: 0, v: ie.FALSE };
  let r = 0, s = t;
  return n === ie.TRUE && (r = Cl, s = Cl), { centerAngle: r, vertexAngle: s };
}
class yE {
  constructor(t, n) {
    p(this, "_columnData", {});
    this._config = t, this._columnData = n;
  }
  /**
   * Get width and hidden status of columns in the sheet
   * @returns {IObjectArrayPrimitiveType<Partial<IColumnData>>} Column data, including width, hidden status, etc.
   */
  getColumnData() {
    return this._columnData;
  }
  getColVisible(t) {
    const { _columnData: n } = this, r = n[t];
    return r ? r.hd !== ie.TRUE : !0;
  }
  /**
   * Get the column style
   * @param {number} col Column index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getColumnStyle(t) {
    var n;
    return (n = this._columnData[t]) == null ? void 0 : n.s;
  }
  /**
   * Set the set column  default style
   * @param {number} col Column index
   * @param {string | Nullable<IStyleData>} style Style data
   */
  setColumnStyle(t, n) {
    const r = this.getColumnOrCreate(t);
    r.s = n;
  }
  /**
   * Get all hidden columns
   * @param start Start index
   * @param end End index
   * @returns Hidden columns range list
   */
  getHiddenCols(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = !1, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getColVisible(o);
      s && a ? (s = !1, r.push({
        rangeType: ge.COLUMN,
        startColumn: i,
        endColumn: o - 1,
        startRow: 0,
        endRow: 0
      })) : !s && !a && (s = !0, i = o);
    }
    return s && r.push({
      startRow: 0,
      endRow: 0,
      startColumn: i,
      endColumn: n,
      rangeType: ge.COLUMN
    }), r;
  }
  /**
   * Get all visible columns
   * @param start Start index
   * @param end End index
   * @returns Visible columns range list
   */
  getVisibleCols(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = !1, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getColVisible(o);
      s && !a ? (s = !1, r.push({
        rangeType: ge.COLUMN,
        startColumn: i,
        endColumn: o - 1,
        startRow: 0,
        endRow: 0
      })) : !s && a && (s = !0, i = o);
    }
    return s && r.push({
      startRow: 0,
      endRow: 0,
      startColumn: i,
      endColumn: n,
      rangeType: ge.COLUMN
    }), r;
  }
  getColumnDatas(t, n) {
    const r = {};
    let s = 0;
    for (let i = t; i < t + n; i++) {
      const o = this.getColumn(i);
      r[s] = o != null ? o : {
        w: this._config.defaultColumnWidth,
        hd: ie.FALSE
      }, s++;
    }
    return r;
  }
  /**
   * Get count of column in the sheet
   * @returns {number} count of column
   */
  getSize() {
    return mn(this._columnData);
  }
  /**
   * Get the width of column
   * @param columnPos column index
   * @returns {number} width of column
   */
  getColumnWidth(t) {
    var n, r;
    return (r = (n = this._columnData[t]) == null ? void 0 : n.w) != null ? r : this._config.defaultColumnWidth;
  }
  /**
   * Set the width of column
   * @param columnPos column index
   * @param width width of column
   */
  setColumnWidth(t, n) {
    const r = this._columnData[t];
    n === this._config.defaultColumnWidth ? r && (delete r.w, Object.keys(r).length === 0 && delete this._columnData[t]) : this._columnData[t] = r ? { ...r, w: n } : { w: n };
  }
  /**
   * Get given column data
   * @param columnPos column index
   */
  getColumn(t) {
    return this._columnData[t];
  }
  /**
   * Remove column data of given column
   * @param columnPos
   */
  removeColumn(t) {
    delete this._columnData[t];
  }
  /**
   * Get given column data or create a column data when it's null
   * This method is used to ensure that the column data should not be null when setting column properties.
   * To prevent data redundancy, if is not setting column properties, you can use `getColumn` method to get column data. don't use this method.
   * @param columnPos column index
   * @returns {Partial<IColumnData>} columnData
   */
  getColumnOrCreate(t) {
    const { _columnData: n } = this, r = n[t];
    if (r)
      return r;
    const s = {};
    return this._columnData[t] = s, s;
  }
  setCustomMetadata(t, n) {
    const r = this.getColumn(t);
    r && (r.custom = n);
  }
  getCustomMetadata(t) {
    var n;
    return (n = this.getColumn(t)) == null ? void 0 : n.custom;
  }
}
const NE = 2e3;
class TE {
  constructor(t, n, r) {
    p(this, "_rowData");
    this._config = t, this._viewModel = n, this._rowData = r;
  }
  /**
   * Get height and hidden status of columns in the sheet
   * @returns {IObjectArrayPrimitiveType<Partial<IRowData>>} Row data, including height, hidden status, etc.
   */
  getRowData() {
    return this._rowData;
  }
  /**
   * Get the row style
   * @param {number} row Row index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getRowStyle(t) {
    var n;
    return (n = this._rowData[t]) == null ? void 0 : n.s;
  }
  /**
   * Set row default style
   * @param {number} row The row index
   * @param {string | Nullable<IStyleData>} style The style data
   */
  setRowStyle(t, n) {
    const r = this.getRowOrCreate(t);
    r.s = n;
  }
  getRowDatas(t, n) {
    const r = {};
    let s = 0;
    for (let i = t; i < t + n; i++) {
      const o = this.getRow(i);
      r[s] = o != null ? o : {
        h: this._config.defaultRowHeight,
        hd: ie.FALSE
      }, s++;
    }
    return r;
  }
  getRowHeight(t, n = 1) {
    const { _rowData: r } = this, s = this._config;
    let i = 0;
    for (let o = 0; o < n; o++) {
      const a = r[o + t] || {
        hd: ie.FALSE,
        h: s.defaultRowHeight
      }, { ia: l, ah: u, h: c = s.defaultRowHeight } = a;
      i += (l == null || l === ie.TRUE) && typeof u == "number" ? u : c;
    }
    return i;
  }
  /**
   * Set row height of given row
   * @param rowPos row index
   * @param height row height
   */
  setRowHeight(t, n) {
    const r = this._rowData[t];
    if (n === this._config.defaultRowHeight)
      r && (delete r.h, Object.keys(r).length === 0 && delete this._rowData[t]);
    else {
      const s = Math.min(n, NE);
      this._rowData[t] = r ? { ...r, h: s } : { h: s };
    }
  }
  /**
   * Get row data of given row
   * @param rowPos row index
   * @returns {Nullable<Partial<IRowData>>} rowData
   */
  getRow(t) {
    return this._rowData[t];
  }
  /**
   * Remove row data of given row
   * @param rowPos
   */
  removeRow(t) {
    delete this._rowData[t];
  }
  /**
   * Get given row data or create a row data when it's null
   * This method is used to ensure that the row data should not be null when setting row properties.
   * To prevent data redundancy, if is not setting row properties, you can use `getRow` method to get row data. don't use this method.
   * @param rowPos row index
   * @returns {Partial<IRowData>} rowData
   */
  getRowOrCreate(t) {
    const { _rowData: n } = this, r = n[t];
    if (r)
      return r;
    const s = {};
    return n[t] = s, s;
  }
  /**
   * Get all hidden rows
   * @param start Start index
   * @param end End index
   * @returns Hidden rows range list
   */
  getHiddenRows(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = !1, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getRowRawVisible(o);
      s && a ? (s = !1, r.push({
        startRow: i,
        endRow: o - 1,
        startColumn: 0,
        endColumn: 0,
        rangeType: ge.ROW
      })) : !s && !a && (s = !0, i = o);
    }
    return s && r.push({ startRow: i, endRow: n, startColumn: 0, endColumn: 0, rangeType: ge.ROW }), r;
  }
  /**
   * Get all visible rows
   * @param start Start index
   * @param end End index
   * @returns Visible rows range list
   */
  getVisibleRows(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = !1, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getRowRawVisible(o);
      s && !a ? (s = !1, r.push({
        startRow: i,
        endRow: o - 1,
        startColumn: 0,
        endColumn: 0,
        rangeType: ge.ROW
      })) : !s && a && (s = !0, i = o);
    }
    return s && r.push({ startRow: i, endRow: n, startColumn: 0, endColumn: 0, rangeType: ge.ROW }), r;
  }
  getRowRawVisible(t) {
    const n = this.getRow(t);
    return n ? n.hd !== ie.TRUE : !0;
  }
  /**
   * Get count of row in the sheet
   * @returns {number} row count
   */
  getSize() {
    return mn(this._rowData);
  }
  setCustomMetadata(t, n) {
    const r = this.getRow(t);
    r && (r.custom = n);
  }
  getCustomMetadata(t) {
    var n;
    return (n = this.getRow(t)) == null ? void 0 : n.custom;
  }
}
const BR = "DEFAULT_WORKSHEET_ROW_COUNT", ME = 1e3, jR = "DEFAULT_WORKSHEET_COLUMN_COUNT", LE = 20, WR = "DEFAULT_WORKSHEET_ROW_HEIGHT", xE = 24, YR = "DEFAULT_WORKSHEET_COLUMN_WIDTH", DE = 88, zR = "DEFAULT_WORKSHEET_ROW_TITLE_WIDTH", UE = 46, VR = "DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT", kE = 20;
function PE(e) {
  const t = {
    name: "Sheet1",
    // TODO: name should have i18n
    id: "sheet-01",
    tabColor: "",
    hidden: ie.FALSE,
    rowCount: ME,
    columnCount: LE,
    zoomRatio: 1,
    freeze: {
      xSplit: 0,
      ySplit: 0,
      startRow: -1,
      startColumn: -1
    },
    scrollTop: 0,
    scrollLeft: 0,
    defaultColumnWidth: DE,
    defaultRowHeight: xE,
    mergeData: [],
    cellData: {},
    rowData: {},
    columnData: {},
    showGridlines: ie.TRUE,
    rowHeader: {
      width: UE,
      hidden: ie.FALSE
    },
    columnHeader: {
      height: kE,
      hidden: ie.FALSE
    },
    rightToLeft: ie.FALSE
  };
  return Object.keys(t).forEach((n) => {
    const r = n;
    typeof e[r] > "u" && (e[r] = t[r]);
  }), e;
}
class FE extends Ve {
  constructor(n) {
    super();
    /**
     * @property Cache for RANGE_TYPE.NORMAL
     */
    p(this, "_cellCache", /* @__PURE__ */ new Map());
    /**
     * @property Cache for RANGE_TYPE.ROW
     */
    p(this, "_rowCache", /* @__PURE__ */ new Map());
    /**
     * @property Cache for RANGE_TYPE.COLUMN
     */
    p(this, "_columnCache", /* @__PURE__ */ new Map());
    /**
     * @property Whether has RANGE_TYPE.ROW
     */
    p(this, "_hasRow", !1);
    /**
     * @property Whether has RANGE_TYPE.COLUMN
     */
    p(this, "_hasColumn", !1);
    /**
     * @property Whether has RANGE_TYPE.ALL
     */
    p(this, "_hasAll", !1);
    /**
     * @property Index for RANGE_TYPE.ALL
     */
    p(this, "_allIndex", -1);
    /**
     * @property the original merge data
     */
    p(this, "_mergeData");
    p(this, "_rangeMap", new gs(5e4));
    p(this, "_skeletonCache", new gs(5e4));
    this._init(n.concat());
  }
  _init(n) {
    this._mergeData = n, this._createCache(n);
  }
  _clearCache() {
    this._cellCache.clear(), this._rowCache.clear(), this._columnCache.clear(), this._hasAll = !1, this._allIndex = -1, this._rangeMap.clear(), this._skeletonCache.clear(), this._hasColumn = !1, this._hasRow = !1;
  }
  _createCache(n) {
    let r = 0;
    for (const s of n) {
      const { rangeType: i } = s;
      i === ge.ROW ? this._createRowCache(s, r) : i === ge.COLUMN ? this._createColumnCache(s, r) : i === ge.ALL ? this._createCellAllCache(r) : this._createCellCache(s, r), r++;
    }
  }
  /**
   * Rebuild the merge data cache when the merge data is changed.
   * @param {IRange[]} mergeData
   */
  rebuild(n) {
    this._clearCache(), this._init(n.concat());
  }
  _createRowCache(n, r) {
    const { startRow: s, endRow: i } = n;
    for (let o = s; o <= i; o++)
      this._rowCache.set(o, r), this._hasRow = !0;
  }
  _createColumnCache(n, r) {
    const { startColumn: s, endColumn: i } = n;
    for (let o = s; o <= i; o++)
      this._columnCache.set(o, r), this._hasColumn = !0;
  }
  _createCellAllCache(n) {
    this._hasAll = !0, this._allIndex = n;
  }
  _createCellCache(n, r) {
    for (let s = n.startRow; s <= n.endRow; s++) {
      let i = this._cellCache.get(s);
      i == null && (i = /* @__PURE__ */ new Map(), this._cellCache.set(s, i));
      for (let o = n.startColumn; o <= n.endColumn; o++)
        i.set(o, r);
    }
  }
  add(n) {
    this._mergeData.push(n), this._clearCache(), this._createCache(this._mergeData);
  }
  remove(n, r) {
    const s = this._getMergeDataIndex(n, r);
    s !== -1 && (this._mergeData.splice(s, 1), this._clearCache(), this._createCache(this._mergeData));
  }
  getMergedCell(n, r) {
    const s = this._getMergeDataIndex(n, r);
    return s !== -1 ? this._mergeData[s] : null;
  }
  /**
   * Return index of merge data if (row,col) is in merge range. -1 means not in merge range.
   * @param row
   * @param column
   * @returns {number} index of merge range.
   */
  getMergeDataIndex(n, r) {
    return this._getMergeDataIndex(n, r);
  }
  isRowContainsMergedCell(n) {
    return this._hasAll || !J.isEmptyObject(this._columnCache) ? !0 : this._mergeData.some((r) => r.startRow <= n && n <= r.endRow);
  }
  isColumnContainsMergedCell(n) {
    return this._hasAll || !J.isEmptyObject(this._rowCache) ? !0 : this._mergeData.some((r) => r.startColumn <= n && n <= r.endColumn);
  }
  getMergedCellRange(n, r, s, i) {
    const o = [], a = `${n}-${r}-${s}-${i}`;
    if (this._rangeMap.has(a))
      return this._getRangeFromCache(a);
    let l = 0;
    const u = [];
    for (const c of this._mergeData || [])
      En.intersects(c, {
        startRow: n,
        endRow: s,
        startColumn: r,
        endColumn: i
      }) && (o.push({
        ...c
      }), u.push(l)), l++;
    return this._rangeMap.set(a, u), o;
  }
  /**
   * @deprecated sigificant performance impact, use _getCellMergeInfo instead.
   * @param startRow
   * @param startColumn
   * @param endRow
   * @param endColumn
   */
  getMergedCellRangeForSkeleton(n, r, s, i) {
    const o = [], a = this._mergeData, l = `${n}-${r}-${s}-${i}`;
    if (this._skeletonCache.has(l))
      return this._getSkeletonRangeFromCache(l);
    const u = [];
    for (let c = 0; c < a.length; c++) {
      const {
        startRow: h,
        endRow: d,
        startColumn: f,
        endColumn: g
      } = a[c];
      for (let _ = n; _ <= s; _++) {
        let R = !1;
        for (let b = r; b <= i; b++)
          if (_ >= h && _ <= d && b >= f && b <= g) {
            o.push({
              startRow: h,
              endRow: d,
              startColumn: f,
              endColumn: g
            }), u.push(c), R = !0;
            break;
          }
        if (R)
          break;
      }
    }
    return this._skeletonCache.set(l, u), o;
  }
  _getRangeFromCache(n) {
    const r = this._rangeMap.get(n) || [], s = [];
    for (const i of r)
      s.push({
        ...this._mergeData[i]
      });
    return s;
  }
  _getSkeletonRangeFromCache(n) {
    const r = this._skeletonCache.get(n) || [], s = [];
    for (const i of r)
      s.push({
        ...this._mergeData[i]
      });
    return s;
  }
  _getMergeDataIndex(n, r) {
    var i;
    if (this._hasAll)
      return this._allIndex;
    if (this._hasRow) {
      const o = this._rowCache.get(n);
      if (o !== void 0)
        return o;
    }
    if (this._hasColumn) {
      const o = this._columnCache.get(r);
      if (o !== void 0)
        return o;
    }
    const s = (i = this._cellCache.get(n)) == null ? void 0 : i.get(r);
    return s !== void 0 ? s : -1;
  }
  getMergeDataSnapshot() {
    return this._mergeData;
  }
  dispose() {
    this._clearCache(), this._mergeData = [];
  }
}
class $E extends Ve {
  constructor(n) {
    super();
    p(this, "_cellContentInterceptor", null);
    p(this, "_rowFilteredInterceptor", null);
    this.getRawCell = n;
  }
  dispose() {
    super.dispose(), this._cellContentInterceptor = null, this._rowFilteredInterceptor = null;
  }
  getCell(n, r, s, i) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, sr.Value | sr.Style, s, i) : this.getRawCell(n, r);
  }
  getCellValueOnly(n, r) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, sr.Value) : this.getRawCell(n, r);
  }
  getCellStyleOnly(n, r) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, sr.Style) : this.getRawCell(n, r);
  }
  getRowFiltered(n) {
    var r, s;
    return (s = (r = this._rowFilteredInterceptor) == null ? void 0 : r.getRowFiltered(n)) != null ? s : !1;
  }
  registerCellContentInterceptor(n) {
    if (this._cellContentInterceptor)
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    return this._cellContentInterceptor = n, We(() => this._cellContentInterceptor = null);
  }
  registerRowFilteredInterceptor(n) {
    if (this._rowFilteredInterceptor)
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    return this._rowFilteredInterceptor = n, We(() => this._rowFilteredInterceptor = null);
  }
}
const wl = {
  isDeepClone: !1,
  displayRawFormula: !1,
  ignoreTextRotation: !1
};
class Is {
  constructor(t, n, r) {
    p(this, "_sheetId");
    p(this, "_snapshot");
    p(this, "_cellData");
    p(this, "_rowManager");
    p(this, "_columnManager");
    p(this, "_viewModel");
    p(this, "_spanModel");
    /**
     * Whether the row style precedes the column style.
     */
    p(this, "_isRowStylePrecedeColumnStyle", !0);
    p(this, "_getCellHeight");
    var a;
    this.unitId = t, this._styles = r, this._snapshot = PE(n);
    const { columnData: s, rowData: i, cellData: o } = this._snapshot;
    this._sheetId = (a = this._snapshot.id) != null ? a : et(6), this._cellData = new pt(o), this._viewModel = new $E((l, u) => this.getCellRaw(l, u)), this._rowManager = new TE(this._snapshot, this._viewModel, i), this._columnManager = new yE(this._snapshot, s), this._spanModel = new FE(this._snapshot.mergeData);
  }
  /**
   * @internal
   * @param callback
   */
  __interceptViewModel(t) {
    t(this._viewModel);
  }
  /**
   * @internal
   * this is an internal method, please do not use it
   */
  __registerGetCellHeight(t) {
    return this._getCellHeight = t, We(() => {
      this._getCellHeight = null;
    });
  }
  getSnapshot() {
    return this._snapshot;
  }
  getCellHeight(t, n) {
    return this._getCellHeight ? this._getCellHeight(t, n) : this._snapshot.defaultRowHeight;
  }
  /**
   * Set the merge data of the sheet, all the merged cells will be rebuilt.
   * @param mergeData
   */
  setMergeData(t) {
    this._snapshot.mergeData = t, this.getSpanModel().rebuild(t);
  }
  getSpanModel() {
    return this._spanModel;
  }
  setIsRowStylePrecedeColumnStyle(t) {
    this._isRowStylePrecedeColumnStyle = t;
  }
  getStyleDataByHash(t) {
    return { ...this._styles.get(t) };
  }
  setStyleData(t) {
    return this._styles.setValue(t);
  }
  getColumnStyle(t, n = !1) {
    return n ? this._columnManager.getColumnStyle(t) : this._styles.get(this._columnManager.getColumnStyle(t));
  }
  /**
   * Set the style of the column.
   * @param {number} column The column index
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setColumnStyle(t, n) {
    this._columnManager.setColumnStyle(t, n);
  }
  getRowStyle(t, n = !1) {
    return n ? this._rowManager.getRowStyle(t) : this._styles.get(this._rowManager.getRowStyle(t));
  }
  /**
   * Set the style of the row.
   * @param {number} row
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setRowStyle(t, n) {
    this._rowManager.setRowStyle(t, n);
  }
  /**
   * Get the default style of the worksheet.
   * @returns {Nullable<IStyleData>} Default Style
   */
  getDefaultCellStyle() {
    return this._snapshot.defaultStyle;
  }
  getDefaultCellStyleInternal() {
    const t = this._snapshot.defaultStyle;
    return this._styles.get(t);
  }
  /**
   * Set Default Style, if the style has been set, all cells style will be base on this style.
   * @param {Nullable<IStyleData>} style The style to be set as default style
   */
  setDefaultCellStyle(t) {
    this._snapshot.defaultStyle = t;
  }
  getCellStyle(t, n) {
    const r = this.getCell(t, n);
    if (r) {
      const s = r.s;
      return typeof s == "string" ? this._styles.get(s) : s;
    }
    return null;
  }
  /**
   * Get the composed style of the cell. If you want to get the style of the cell without merging row style,
   * col style and default style, please use {@link getCellStyle} instead.
   *
   * @param {number} row The row index of the cell
   * @param {number} col The column index of the cell
   * @param {boolean} [rowPriority] If true, row style will precede column style, otherwise use this._isRowStylePrecedeColumnStyle
   * @returns {IStyleData} The composed style of the cell
   */
  getComposedCellStyle(t, n, r) {
    const s = this.getDefaultCellStyleInternal(), i = this.getRowStyle(t), o = this.getColumnStyle(n), a = this.getCell(t, n), l = this._styles.getStyleByCell(a);
    return (r != null ? r : this._isRowStylePrecedeColumnStyle) ? xr(s, o, i, a == null ? void 0 : a.themeStyle, l) : xr(s, i, o, a == null ? void 0 : a.themeStyle, l);
  }
  /**
   * Get the composed style of the cell. If you want to get the style of the cell without merging row style,
   * col style and default style, please use {@link getCellStyle} instead.
   * For performance reason, if you already have the cell data, you can use this method to avoid getting the cell data again.
   *
   * @param {number} row The row index of the cell
   * @param {number} col The column index of the cell
   * @param {Nullable<ICellDataForSheetInterceptor>} cellData The cell data of the cell.
   * @param {boolean} [rowPriority] If true, row style will precede column style, otherwise use this._isRowStylePrecedeColumnStyle
   * @returns {IStyleData} The composed style of the cell
   */
  getComposedCellStyleByCellData(t, n, r, s) {
    const i = this.getDefaultCellStyleInternal(), o = this.getRowStyle(t), a = this.getColumnStyle(n), l = this._styles.getStyleByCell(r);
    return (s != null ? s : this._isRowStylePrecedeColumnStyle) ? xr(i, a, o, r == null ? void 0 : r.themeStyle, l) : xr(i, o, a, r == null ? void 0 : r.themeStyle, l);
  }
  /**
   * Returns WorkSheet Cell Data Matrix
   * @returns WorkSheet Cell Data Matrix
   */
  getCellMatrix() {
    return this._cellData;
  }
  /**
   * Get worksheet printable cell range.
   * @returns
   */
  // eslint-disable-next-line max-lines-per-function
  getCellMatrixPrintRange() {
    const t = this.getCellMatrix(), n = this.getMergeData();
    let r = -1, s = -1, i = -1, o = -1, a = !1, l = !1;
    return t.forEach((u, c) => {
      Object.keys(c).forEach((h) => {
        const d = +h, f = t.getValue(u, d), g = f != null && f.s ? this._styles.get(f.s) : null, _ = (g == null ? void 0 : g.bd) && (g.bd.b || g.bd.l || g.bd.r || g.bd.t || g.bd.bc_tr || g.bd.bl_tr || g.bd.ml_tr || g.bd.tl_bc || g.bd.tl_br || g.bd.tl_mr);
        (f && (f.v !== null && f.v !== void 0 && f.v !== "" || f.p) || g != null && g.bg || _) && (a ? r = Math.min(r, u) : (r = u, a = !0), s = Math.max(s, u), l ? i = Math.min(i, d) : (l = !0, i = d), o = Math.max(o, d));
      });
    }), n.forEach((u) => {
      a ? r = Math.min(r, u.startRow) : (r = u.startRow, a = !0), s = Math.max(s, u.endRow), l ? i = Math.min(i, u.startColumn) : (i = u.startColumn, a = !0), o = Math.max(o, u.endColumn);
    }), !a || !l ? null : {
      startColumn: i,
      startRow: r,
      endColumn: o,
      endRow: s
    };
  }
  /**
   * Returns Row Manager
   * @returns Row Manager
   */
  getRowManager() {
    return this._rowManager;
  }
  /**
   * Returns the ID of its parent unit.
   */
  getUnitId() {
    return this.unitId;
  }
  /**
   * Returns the ID of the sheet represented by this object.
   * @returns ID of the sheet
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Returns Column Manager
   * @returns Column Manager
   */
  getColumnManager() {
    return this._columnManager;
  }
  /**
   * Returns the name of the sheet.
   * @returns name of the sheet
   */
  getName() {
    return this._snapshot.name;
  }
  /**
   * Returns WorkSheet Clone Object
   * @returns WorkSheet Clone Object
   * @deprecated
   */
  clone() {
    const { _snapshot: t } = this, n = J.deepClone(t);
    return new Is(this.unitId, n, this._styles);
  }
  /**
   * Get the merged cell list of the sheet.
   * @returns {IRange[]} merged cell list
   */
  getMergeData() {
    return this._spanModel.getMergeDataSnapshot();
  }
  /**
   * Get the merged cell Range of the sheet cell.
   * If (row, col) is not in a merged cell, return null
   *
   * @param {number} row The row index of test cell
   * @param {number} col The column index of test cell
   * @returns {Nullable<IRange>} The merged cell range of the cell, if the cell is not in a merged cell, return null
   */
  getMergedCell(t, n) {
    return this._spanModel.getMergedCell(t, n);
  }
  /**
   * Get the merged cell info list which has intersection with the given range.
   * @param {number} startRow The start row index of the range
   * @param {number} startColumn The start column index of the range
   * @param {number} endRow The end row index of the range
   * @param {number} endColumn The end column index of the range
   * @returns {IRange} The merged cell info list which has intersection with the given range or empty array if no merged cell in the range
   */
  getMergedCellRange(t, n, r, s) {
    return this._spanModel.getMergedCellRange(t, n, r, s);
  }
  /**
   * Get if the row contains merged cell
   * @param {number} row The row index
   * @returns {boolean} Is merge cell across row
   */
  isRowContainsMergedCell(t) {
    return this._spanModel.isRowContainsMergedCell(t);
  }
  /**
   * Get if the column contains merged cell
   * @param {number} column The column index
   * @returns {boolean} Is merge cell across column
   */
  isColumnContainsMergedCell(t) {
    return this._spanModel.isColumnContainsMergedCell(t);
  }
  /**
   * Get cell info with merge data
   * @param {number} row - The row index of the cell.
   * @param {number} column - The column index of the cell.
   * @type {selectionCell}
   * @property {number} actualRow - The actual row index of the cell
   * @property {number} actualColumn - The actual column index of the cell
   * @property {boolean} isMergedMainCell - Whether the cell is the main cell of the merged cell, only the upper left cell in the merged cell returns true here
   * @property {boolean} isMerged - Whether the cell is in a merged cell, the upper left cell in the merged cell returns false here
   * @property {number} endRow - The end row index of the merged cell
   * @property {number} endColumn - The end column index of the merged cell
   * @property {number} startRow - The start row index of the merged cell
   * @property {number} startColumn - The start column index of the merged cell
   * @returns  {selectionCell} - The cell info with merge data
   */
  getCellInfoInMergeData(t, n) {
    const r = this.getMergedCell(t, n);
    let s = !1, i = !1, o = t, a = n, l = t, u = n;
    if (r) {
      const {
        startRow: c,
        endRow: h,
        startColumn: d,
        endColumn: f
      } = r;
      t === c && n === d ? (o = h, a = f, l = c, u = d, i = !0) : t >= c && t <= h && n >= d && n <= f && (o = h, a = f, l = c, u = d, s = !0);
    }
    return {
      actualRow: t,
      actualColumn: n,
      isMergedMainCell: i,
      isMerged: s,
      endRow: o,
      endColumn: a,
      startRow: l,
      startColumn: u
    };
  }
  /**
   * Get cellData, includes cellData, customRender, markers, dataValidate, etc.
   *
   * WARNING: All sheet CELL_CONTENT interceptors will be called in this method, cause performance issue.
   * example: this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT);
   *
   * @param row
   * @param col
   * @returns ICellDataForSheetInterceptor
   */
  getCell(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCell(t, n);
  }
  /**
   * Get cellData only use effect on value interceptor
   * @param {number} number row The row index of the cell.
   * @param {number} number col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on value interceptor
   */
  getCellValueOnly(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCellValueOnly(t, n);
  }
  /**
   * Get cellData only use effect on style interceptor
   * @param {number} row The row index of the cell.
   * @param {number} col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on style interceptor
   */
  getCellStyleOnly(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCellStyleOnly(t, n);
  }
  getCellRaw(t, n) {
    return this.getCellMatrix().getValue(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  getCellWithFilteredInterceptors(t, n, r, s) {
    return this._viewModel.getCell(t, n, r, s);
  }
  getRowFiltered(t) {
    return this._viewModel.getRowFiltered(t);
  }
  /**
   * Get the filtered out rows in a given range. used for remove rows operation, etc.
   * @param range - The range to get filtered rows from.
   * @returns {number[]} An array of row indices that are filtered out within the specified range.
   */
  getRangeFilterRows(t) {
    const n = [];
    for (let r = t.startRow; r <= t.endRow; r++)
      this.getRowFiltered(r) && n.push(r);
    return n;
  }
  getMatrixWithMergedCells(t, n, r, s, i = or.Raw) {
    const o = this.getCellMatrix(), a = this._spanModel.getMergedCellRange(t, n, r, s), l = new pt();
    return cl(t, r, n, s).forEach((u, c) => {
      var d;
      let h;
      if (i === or.Raw)
        h = this.getCellRaw(u, c);
      else if (i === or.Intercepted)
        h = this.getCell(u, c);
      else if (i === or.Both) {
        const f = this.getCellRaw(u, c);
        if (f) {
          h = { ...f };
          const g = (d = this.getCell(u, c)) == null ? void 0 : d.v;
          vE(g) && h && (h.displayV = String(g));
        }
      }
      h && l.setValue(u, c, h);
    }), a.forEach((u) => {
      const { startColumn: c, startRow: h, endColumn: d, endRow: f } = u;
      cl(h, f, c, d).forEach((g, _) => {
        g === h && _ === c && l.setValue(g, _, {
          ...o.getValue(g, _),
          rowSpan: f - h + 1,
          colSpan: d - c + 1
        }), (g !== h || _ !== c) && l.realDeleteValue(g, _);
      });
    }), l;
  }
  getRange(t, n, r, s) {
    return typeof t == "object" ? new Or(this, t, {
      getStyles: () => this._styles
    }) : new Or(
      this,
      {
        startRow: t,
        startColumn: n,
        endColumn: s || n,
        endRow: r || t
      },
      {
        getStyles: () => this._styles
      }
    );
  }
  getScrollLeftTopFromSnapshot() {
    return {
      scrollLeft: this._snapshot.scrollLeft,
      scrollTop: this._snapshot.scrollTop
    };
  }
  /**
   * Return WorkSheetZoomRatio
   * @return zoomRatio
   */
  getZoomRatio() {
    return this._snapshot.zoomRatio || 1;
  }
  /**
   * Returns WorkSheet Configures
   * @returns WorkSheet Configures
   */
  getConfig() {
    return this._snapshot;
  }
  /**
   * Returns  frozen.
   * @returns  frozen
   */
  getFreeze() {
    return this._snapshot.freeze;
  }
  /**
   * Returns the current number of columns in the sheet, regardless of content.
   * @returns the current number of columns in the sheet, regardless of content
   */
  getMaxColumns() {
    const { _snapshot: t } = this, { columnCount: n } = t;
    return n;
  }
  /**
   * Returns the current number of rows in the sheet, regardless of content.
   * @returns the current number of rows in the sheet, regardless of content
   */
  getMaxRows() {
    const { _snapshot: t } = this, { rowCount: n } = t;
    return n;
  }
  getRowCount() {
    return this._snapshot.rowCount;
  }
  setRowCount(t) {
    this._snapshot.rowCount = t;
  }
  getColumnCount() {
    return this._snapshot.columnCount;
  }
  setColumnCount(t) {
    this._snapshot.columnCount = t;
  }
  /**
   * isSheetHidden
   * @returns hidden status of sheet
   */
  isSheetHidden() {
    return this._snapshot.hidden;
  }
  /**
   * Returns true if the sheet's gridlines are hidden; otherwise returns false. Gridlines are visible by default.
   * @returns {boolean} Gridlines Hidden Status.
   */
  hasHiddenGridlines() {
    const { _snapshot: t } = this, { showGridlines: n } = t;
    return n === 0;
  }
  /**
   * Returns the color of the gridlines, or undefined if the gridlines are not colored.
   * @returns {string | undefined} returns the color of the gridlines, or undefined if the gridlines are default.
   */
  getGridlinesColor() {
    return this.getConfig().gridlinesColor;
  }
  /**
   * Gets the sheet tab color, or null if the sheet tab has no color.
   * @returns the sheet tab color or null
   */
  getTabColor() {
    const { _snapshot: t } = this, { tabColor: n } = t;
    return n;
  }
  /**
   * Gets the width in pixels of the given column.
   * @param columnPosition column index
   * @returns Gets the width in pixels of the given column.
   */
  getColumnWidth(t) {
    return this.getColumnManager().getColumnWidth(t);
  }
  /**
   * Gets the height in pixels of the given row.
   * @param row row index
   * @returns Gets the height in pixels of the given row.
   */
  getRowHeight(t) {
    return this._viewModel.getRowFiltered(t) ? 0 : this.getRowManager().getRowHeight(t);
  }
  /**
   * Row is filtered out, that means this row is invisible.
   * @param row
   * @returns {boolean} is row hidden by filter
   */
  isRowFiltered(t) {
    return this._viewModel.getRowFiltered(t);
  }
  /**
   * Get if the row is visible. It may be affected by features like filter and view.
   * @param row the row index
   * @returns {boolean} if the row in visible to the user
   */
  getRowVisible(t) {
    return !this.isRowFiltered(t) && this.getRowRawVisible(t);
  }
  /**
   * Get if the row does not have `hidden` property. This value won't affected by features like filter and view.
   * @param row the row index
   * @returns if the row does not have `hidden` property
   */
  getRowRawVisible(t) {
    return this.getRowManager().getRowRawVisible(t);
  }
  getHiddenRows(t, n) {
    const r = this.getMaxColumns() - 1, s = this._rowManager.getHiddenRows(t, n);
    return s.forEach((i) => i.endColumn = r), s;
  }
  getColVisible(t) {
    return this._columnManager.getColVisible(t);
  }
  getHiddenCols(t, n) {
    const r = this.getMaxRows() - 1, s = this._columnManager.getHiddenCols(t, n);
    return s.forEach((i) => i.endRow = r), s;
  }
  /**
   * Get all visible rows in the sheet.(not include filter & view, like getRawVisibleRows)
   * @returns Visible rows range list
   */
  getVisibleRows() {
    const t = this.getRowCount();
    return this._rowManager.getVisibleRows(0, t - 1);
  }
  /**
   * Get all visible columns in the sheet.(not include filter & view)
   * @returns Visible columns range list
   */
  getVisibleCols() {
    const t = this.getColumnCount();
    return this._columnManager.getVisibleCols(0, t - 1);
  }
  /**
   * Returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   * @returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   */
  isRightToLeft() {
    const { _snapshot: t } = this, { rightToLeft: n } = t;
    return n;
  }
  /**
   * Returns the position of the last row that has content.
   * @returns the position of the last row that has content.
   */
  getLastRowWithContent() {
    return this._cellData.getLength() - 1;
  }
  /**
   * Returns the position of the last column that has content.
   * @returns the position of the last column that has content.
   */
  getLastColumnWithContent() {
    return this._cellData.getRange().endColumn;
  }
  getDataRangeScope() {
    return this._cellData.getStartEndScope();
  }
  cellHasValue(t) {
    return t && (t.v !== void 0 || t.f !== void 0 || t.p !== void 0);
  }
  // #region iterators
  // NOTE: performance intensive. Should keep an eye on methods in this region.
  /**
   * Iterate a range row by row.
   *
   * Performance intensive.
   *
   * @param range the iterate range
   * @param skipEmpty whether to skip empty cells, default to be `true`
   */
  iterateByRow(t, n = !0) {
    const { startRow: r, startColumn: s, endRow: i, endColumn: o } = t, a = this;
    return {
      [Symbol.iterator]: () => {
        let l = r, u = s;
        return {
          next() {
            for (; ; ) {
              if (u > o && (l += 1, u = s), l > i)
                return { done: !0, value: void 0 };
              const c = a.getCell(l, u), h = !c, d = a.getMergedCell(l, u);
              if (d) {
                if (l !== d.startRow || u !== d.startColumn) {
                  u = d.endColumn + 1;
                  continue;
                }
                if (h && n) {
                  u = d.endColumn + 1;
                  continue;
                }
                const g = { row: l, col: u, value: c };
                return g.colSpan = d.endColumn - d.startColumn + 1, g.rowSpan = d.endRow - d.startRow + 1, u = d.endColumn + 1, { done: !1, value: g };
              }
              if (h && n)
                u += 1;
              else {
                const f = { row: l, col: u, value: c };
                return u += 1, { done: !1, value: f };
              }
            }
          }
        };
      }
    };
  }
  /**
   * Iterate a range column by column. This is pretty similar to `iterateByRow` but with different order.
   *
   * Performance intensive.
   *
   * @param range The iterate range.
   * @param skipEmpty Whether to skip empty cells, default to be `true`.
   * @param skipNonTopLeft Whether to skip non-top-left cells of merged cells, default to be `true`. If the
   * parameter is set to `false`, the iterator will return cells in the top row.
   */
  iterateByColumn(t, n = !0, r = !0) {
    const { startRow: s, startColumn: i, endRow: o, endColumn: a } = t, l = this;
    return {
      [Symbol.iterator]: () => {
        let u = s, c = i;
        return {
          next() {
            for (; ; ) {
              if (u > o && (c += 1, u = s), c > a)
                return { done: !0, value: void 0 };
              const h = l.getMergedCell(u, c);
              if (h) {
                const g = u !== h.startRow, _ = g || c !== h.startColumn;
                if (r && _ || !r && g) {
                  u = h.endRow + 1;
                  continue;
                }
                const R = l.getCell(h.startRow, h.startColumn);
                if (!R && n) {
                  u = h.endRow + 1;
                  continue;
                }
                const H = { row: u, col: h.startColumn, value: R };
                return H.colSpan = h.endColumn - h.startColumn + 1, H.rowSpan = h.endRow - h.startRow + 1, u = h.endRow + 1, { done: !1, value: H };
              }
              const d = l.getCell(u, c);
              if (!d && n)
                u += 1;
              else {
                const g = { row: u, col: c, value: d };
                return u += 1, { done: !1, value: g };
              }
            }
          }
        };
      }
    };
  }
  /**
   * This method generates a document model based on the cell's properties and handles the associated styles and configurations.
   * If the cell does not exist, it will return null.
   * PS: This method has significant impact on performance.
   * @param cell
   * @param options
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  getCellDocumentModel(t, n, r = wl) {
    var _;
    if (!t)
      return;
    const { isDeepClone: s, displayRawFormula: i, ignoreTextRotation: o } = {
      ...wl,
      ...r
    };
    let a, l = "document";
    const u = SE(n), c = o ? rt.tr : u.textRotation || rt.tr;
    let h = u.horizontalAlign || rt.ht;
    const d = u.verticalAlign || rt.vt, f = u.wrapStrategy || rt.tb, g = u.paddingData || Wi;
    if (t.f && i)
      a = Jr(t.f.toString(), {}, { verticalAlign: d }), h = rt.ht;
    else if (t.p) {
      const { centerAngle: R, vertexAngle: b } = ac(c);
      a = this._updateConfigAndGetDocumentModel(
        s ? J.deepClone(t.p) : t.p,
        h,
        g,
        {
          horizontalAlign: h,
          verticalAlign: d,
          centerAngle: R,
          vertexAngle: b,
          wrapStrategy: f,
          zeroWidthParagraphBreak: 1
        }
      );
    } else if (t.v != null) {
      const R = Rl(n);
      l = Il(R).fontCache;
      let b = HE(t);
      t.t === fn.FORCE_STRING && i && (b = `'${b}`), a = Jr(b, R, {
        ...u,
        textRotation: c,
        cellValueType: t.t
      });
    }
    return a && t.linkUrl && t.linkId && OE(a, t.linkUrl, t.linkId), {
      documentModel: a,
      fontString: l,
      textRotation: c,
      wrapStrategy: f,
      verticalAlign: d,
      horizontalAlign: h,
      paddingData: g,
      fill: (_ = n == null ? void 0 : n.bg) == null ? void 0 : _.rgb
    };
  }
  _updateConfigAndGetDocumentModel(t, n, r, s) {
    var o, a, l, u, c;
    if (!s || !((o = t.body) != null && o.dataStream))
      return;
    t.documentStyle || (t.documentStyle = {}), t.documentStyle.marginTop = (a = r.t) != null ? a : 0, t.documentStyle.marginBottom = (l = r.b) != null ? l : 2, t.documentStyle.marginLeft = (u = r.l) != null ? u : 2, t.documentStyle.marginRight = (c = r.r) != null ? c : 2, t.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    }, t.documentStyle.renderConfig = {
      ...t.documentStyle.renderConfig,
      ...s
    };
    const i = t.body.paragraphs || [];
    for (const h of i)
      h.paragraphStyle || (h.paragraphStyle = {}), h.paragraphStyle.horizontalAlign = n;
    return new Pt(t);
  }
  /**
   * Only used for cell edit, and no need to rotate text when edit cell content!
   */
  getBlankCellDocumentModel(t, n, r) {
    const s = this.getComposedCellStyleByCellData(n, r, t), i = Rl(s), o = this.getCellDocumentModel(t, s, { ignoreTextRotation: !0 });
    if (o != null)
      return o.documentModel == null && (o.documentModel = Jr("", i)), o;
    const a = "";
    let l = "document";
    const u = rt.tr, c = rt.ht, h = rt.vt, d = rt.tb, f = Wi;
    return l = Il({}).fontCache, {
      documentModel: Jr(a, i),
      fontString: l,
      textRotation: u,
      wrapStrategy: d,
      verticalAlign: h,
      horizontalAlign: c,
      paddingData: f
    };
  }
  // Only used for cell edit, and no need to rotate text when edit cell content!
  getCellDocumentModelWithFormula(t, n, r) {
    const s = this.getComposedCellStyleByCellData(n, r, t);
    return this.getCellDocumentModel(t, s, {
      isDeepClone: !0,
      displayRawFormula: !0,
      ignoreTextRotation: !0
    });
  }
  /**
   * Get custom metadata of worksheet
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(t) {
    this._snapshot.custom = t;
  }
}
function HE(e) {
  var r, s;
  if (!e)
    return "";
  const t = (s = (r = e.p) == null ? void 0 : r.body) == null ? void 0 : s.dataStream;
  if (t)
    return Je.transform.getPlainText(t);
  const n = e.v;
  return typeof n == "string" ? e.t === fn.BOOLEAN ? n.toUpperCase() : n.replace(/[\r\n]/g, "") : typeof n == "number" ? e.t === fn.BOOLEAN ? n ? "TRUE" : "FALSE" : n.toString() : typeof n == "boolean" ? n ? "TRUE" : "FALSE" : "";
}
function GR(e) {
  if (e === null)
    return "";
  if (e != null && e.p) {
    const t = e == null ? void 0 : e.p.body;
    if (t == null)
      return "";
    const n = t.dataStream;
    return Je.transform.getPlainText(n);
  }
  return e == null ? void 0 : e.v;
}
var BE = Object.getOwnPropertyDescriptor, jE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? BE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, WE = (e, t) => (n, r) => t(n, r, e);
function KR(e, t) {
  return `${e.getUnitId()}|${t.getSheetId()}`;
}
let ws = class extends lo {
  constructor(t = {}, n) {
    super();
    p(this, "type", we.UNIVER_SHEET);
    p(this, "_sheetCreated$", new ot());
    p(this, "sheetCreated$", this._sheetCreated$.asObservable());
    p(this, "_sheetDisposed$", new ot());
    p(this, "sheetDisposed$", this._sheetDisposed$.asObservable());
    p(this, "_activeSheet$", new tt(null));
    p(this, "activeSheet$", this._activeSheet$.asObservable());
    /**
     * sheets list
     * @private
     */
    p(this, "_worksheets");
    /**
     * Common style
     * @private
     */
    p(this, "_styles");
    /**
     * number format
     * @private
     */
    // private _formatManage: FormatManager;
    p(this, "_snapshot");
    p(this, "_unitId");
    p(this, "_count");
    p(this, "_name$");
    p(this, "name$");
    this._logService = n;
    const r = RE();
    J.isEmptyObject(t) ? this._snapshot = r : this._snapshot = J.commonExtend(r, t);
    const { styles: s } = this._snapshot;
    (this._snapshot.id == null || this._snapshot.id.length === 0) && (this._snapshot.id = et(6)), this._unitId = this._snapshot.id, this._styles = new IE(s), this._count = 1, this._worksheets = /* @__PURE__ */ new Map(), this._name$ = new tt(t.name || ""), this.name$ = this._name$.asObservable(), this._parseWorksheetSnapshots();
  }
  get _activeSheet() {
    return this._activeSheet$.getValue();
  }
  get name() {
    return this._name$.getValue();
  }
  static isIRangeType(t) {
    return typeof t == "string" || "startRow" in t || "row" in t;
  }
  dispose() {
    super.dispose(), this._sheetCreated$.complete(), this._sheetDisposed$.complete(), this._activeSheet$.complete(), this._name$.complete();
  }
  /**
   * Create a clone of the current snapshot.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @memberof Workbook
   */
  save() {
    return J.deepClone(this._snapshot);
  }
  /**
   * Get current snapshot reference.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @return {*}  {IWorkbookData}
   * @memberof Workbook
   */
  getSnapshot() {
    return this._snapshot;
  }
  /** @deprecated use use name property instead */
  getName() {
    return this._snapshot.name;
  }
  setName(t) {
    this._name$.next(t), this._snapshot.name = t;
  }
  getUnitId() {
    return this._unitId;
  }
  getRev() {
    var t;
    return (t = this._snapshot.rev) != null ? t : 1;
  }
  incrementRev() {
    this._snapshot.rev = this.getRev() + 1;
  }
  setRev(t) {
    this._snapshot.rev = t;
  }
  /**
   * Add a Worksheet into Workbook.
   */
  addWorksheet(t, n, r) {
    const { sheets: s, sheetOrder: i } = this._snapshot;
    if (s[t])
      return !1;
    s[t] = r, i.splice(n, 0, t);
    const o = new Is(this._unitId, r, this._styles);
    return this._worksheets.set(t, o), this._sheetCreated$.next(o), !0;
  }
  getSheetOrders() {
    return this._snapshot.sheetOrder;
  }
  getWorksheets() {
    return this._worksheets;
  }
  getActiveSpreadsheet() {
    return this;
  }
  getStyles() {
    return this._styles;
  }
  addStyles(t) {
    Object.entries(t).forEach(([n, r]) => {
      this._styles.addCustomStyle(n, r);
    });
  }
  removeStyles(t) {
    t.forEach((n) => {
      this._styles.remove(n);
    });
  }
  getConfig() {
    return this._snapshot;
  }
  getIndexBySheetId(t) {
    const { sheetOrder: n } = this._snapshot;
    return n.findIndex((r) => r === t);
  }
  getActiveSheet(t) {
    if (!this._activeSheet && typeof t > "u")
      throw new Error(`[Workbook]: no active Worksheet on Workbook ${this._unitId}!`);
    return this._activeSheet;
  }
  /**
   * If there is no active sheet, the first sheet would
   * be set active.
   * @returns
   */
  ensureActiveSheet() {
    const t = this._activeSheet;
    if (t)
      return t;
    const n = this._snapshot.sheetOrder;
    for (let s = 0, i = n.length; s < i; s++) {
      const o = this._worksheets.get(n[s]);
      if (o && o.isSheetHidden() !== ie.TRUE)
        return this.setActiveSheet(o), o;
    }
    const r = this._worksheets.get(n[0]);
    return this.setActiveSheet(r), r;
  }
  /**
   * ActiveSheet should not be null!
   * There is at least one sheet in a workbook. You can not delete all sheets in a workbook.
   * @param worksheet
   */
  setActiveSheet(t) {
    this._activeSheet$.next(t);
  }
  removeSheet(t) {
    const n = this._worksheets.get(t);
    return n ? (this._worksheets.delete(t), this._snapshot.sheetOrder.splice(this._snapshot.sheetOrder.indexOf(t), 1), delete this._snapshot.sheets[t], this._sheetDisposed$.next(n), !0) : !1;
  }
  getActiveSheetIndex() {
    const { sheetOrder: t } = this._snapshot;
    return t.findIndex((n) => this._worksheets.get(n) === this._activeSheet);
  }
  getSheetSize() {
    return this._snapshot.sheetOrder.length;
  }
  getSheets() {
    const { sheetOrder: t } = this._snapshot;
    return t.map((n) => this._worksheets.get(n));
  }
  getSheetsName() {
    const { sheetOrder: t } = this._snapshot, n = [];
    return t.forEach((r) => {
      const s = this._worksheets.get(r);
      s && n.push(s.getName());
    }), n;
  }
  getSheetIndex(t) {
    const { sheetOrder: n } = this._snapshot;
    return n.findIndex((r) => t.getSheetId() === r);
  }
  getSheetBySheetName(t) {
    const { sheetOrder: n } = this._snapshot, r = n.find((s) => this._worksheets.get(s).getName() === t);
    return this._worksheets.get(r);
  }
  getSheetBySheetId(t) {
    return this._worksheets.get(t);
  }
  getSheetByIndex(t) {
    const { sheetOrder: n } = this._snapshot;
    return this._worksheets.get(n[t]);
  }
  getHiddenWorksheets() {
    return this.getSheets().filter((t) => t.getConfig().hidden === ie.TRUE).map((t) => t.getConfig().id);
  }
  getUnhiddenWorksheets() {
    return this.getSheets().filter((t) => t.getConfig().hidden !== ie.TRUE).map((t) => t.getConfig().id);
  }
  load(t) {
    this._snapshot = t;
  }
  /**
   * Check if sheet name is unique
   * @param name sheet name
   * @returns True if sheet name is unique
   */
  checkSheetName(t) {
    return this.getSheetsName().includes(t);
  }
  /**
   *  Check whether the sheet name is unique and generate a new unique sheet name
   * @param name sheet name
   * @returns Unique sheet name
   */
  uniqueSheetName(t = "Sheet1") {
    let n = t;
    for (; this.checkSheetName(n); )
      n = t + this._count, this._count++;
    return n;
  }
  /**
   * Automatically generate new sheet name
   * @param name sheet name
   * @returns New sheet name
   */
  generateNewSheetName(t) {
    let n = t + this._count;
    for (; this.checkSheetName(n); )
      n = t + this._count, this._count++;
    return n;
  }
  // FIXME: now we always create worksheet from DEFAULT_WORKSHEET?
  /**
   * Get Default Sheet
   */
  _parseWorksheetSnapshots() {
    const { _snapshot: t, _worksheets: n } = this, { sheets: r, sheetOrder: s } = t;
    if (J.isEmptyObject(r)) {
      const i = et();
      r[i] = { id: i };
    }
    for (const i in r) {
      const o = r[i], { name: a } = o;
      o.name = this.uniqueSheetName(a), o.name !== a && this._logService.debug("[Workbook]", `The worksheet name ${a} is duplicated, we changed it to ${o.name}. Please fix the problem in your snapshot.`);
      const l = new Is(this._unitId, o, this._styles);
      n.set(i, l), s.includes(i) || s.push(i);
    }
    this.ensureActiveSheet();
  }
  /**
   * Get custom metadata of workbook
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(t) {
    this._snapshot.custom = t;
  }
};
ws = jE([
  WE(1, yt)
], ws);
class lc extends lo {
  constructor(n) {
    var r;
    super();
    p(this, "type", we.UNIVER_SLIDE);
    p(this, "_activePage$", new tt(null));
    p(this, "activePage$", this._activePage$.asObservable());
    p(this, "_name$");
    p(this, "name$");
    p(this, "_snapshot");
    p(this, "_unitId");
    this._snapshot = { ...Mp, ...n }, this._unitId = (r = this._snapshot.id) != null ? r : et(6), this._name$ = new tt(this._snapshot.title), this.name$ = this._name$.asObservable();
  }
  get _activePage() {
    var r, s;
    const n = this._activePage$.getValue();
    if (!n) {
      const i = (r = this.getPageOrder()) == null ? void 0 : r[0];
      return i ? (s = this.getPages()) == null ? void 0 : s[i] : null;
    }
    return n;
  }
  setName(n) {
    var r;
    this._snapshot.title = n, this._name$.next(n), this._unitId = (r = this._snapshot.id) != null ? r : et(6);
  }
  getRev() {
    return 0;
  }
  incrementRev() {
  }
  setRev(n) {
  }
  getSnapshot() {
    return this._snapshot;
  }
  getUnitId() {
    return this._unitId;
  }
  getPages() {
    var n;
    return (n = this._snapshot.body) == null ? void 0 : n.pages;
  }
  getPageOrder() {
    var n;
    return (n = this._snapshot.body) == null ? void 0 : n.pageOrder;
  }
  getPage(n) {
    const r = this.getPages();
    return r == null ? void 0 : r[n];
  }
  getElementsByPage(n) {
    var r;
    return (r = this.getPage(n)) == null ? void 0 : r.pageElements;
  }
  getElement(n, r) {
    var s;
    return (s = this.getElementsByPage(n)) == null ? void 0 : s[r];
  }
  getPageSize() {
    return this._snapshot.pageSize;
  }
  getBlankPage() {
    const n = et(6);
    return {
      id: n,
      pageType: cu.SLIDE,
      zIndex: 10,
      title: n,
      description: "",
      pageBackgroundFill: {
        rgb: "rgb(255,255,255)"
      },
      pageElements: {}
    };
  }
  setActivePage(n) {
    this._activePage$.next(n);
  }
  getActivePage() {
    return this._activePage;
  }
  updatePage(n, r) {
    this._snapshot.body && (this._snapshot.body.pages[n] = r);
  }
  appendPage(n) {
    var i;
    if (!this._snapshot.body) return;
    this._snapshot.body.pages[n.id] = n;
    const r = this._activePage, s = this._snapshot.body.pageOrder.indexOf((i = r == null ? void 0 : r.id) != null ? i : "");
    this._snapshot.body.pageOrder.splice(s + 1, 0, n.id);
  }
}
var YE = Object.getOwnPropertyDescriptor, zE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? YE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, Sl = (e, t) => (n, r) => t(n, r, e);
const vr = ht("univer.current");
let Yi = class extends Ve {
  constructor(t, n) {
    super();
    p(this, "_unitsByType", /* @__PURE__ */ new Map());
    p(this, "_createHandler");
    p(this, "_ctorByType", /* @__PURE__ */ new Map());
    p(this, "_currentUnits", /* @__PURE__ */ new Map());
    p(this, "_currentUnits$", new tt(this._currentUnits));
    p(this, "currentUnits$", this._currentUnits$.asObservable());
    p(this, "_unitAdded$", new ot());
    p(this, "unitAdded$", this._unitAdded$.asObservable());
    p(this, "_unitDisposed$", new ot());
    p(this, "unitDisposed$", this._unitDisposed$.asObservable());
    p(this, "_focused$", new tt(null));
    p(this, "focused$", this._focused$.asObservable());
    this._injector = t, this._contextService = n;
  }
  dispose() {
    super.dispose(), this._focused$.complete(), this._currentUnits$.complete(), this._unitAdded$.complete(), this._currentUnits.clear(), this._unitsByType.clear();
  }
  __setCreateHandler(t) {
    this._createHandler = t;
  }
  createUnit(t, n, r) {
    return this._createHandler(t, n, this._ctorByType.get(t), r);
  }
  registerCtorForType(t, n) {
    return this._ctorByType.set(t, n), {
      dispose: () => {
        this._ctorByType.delete(t);
      }
    };
  }
  getCurrentTypeOfUnit$(t) {
    return this.currentUnits$.pipe(Ji((n) => {
      var r;
      return (r = n.get(t)) != null ? r : null;
    }), Sc());
  }
  getCurrentUnitForType(t) {
    return this._currentUnits.get(t);
  }
  getCurrentUnitOfType(t) {
    return this.getCurrentUnitForType(t);
  }
  setCurrentUnitForType(t) {
    const n = this._getUnitById(t);
    if (!n) throw new Error(`[UniverInstanceService]: no document with unitId ${t}!`);
    this._currentUnits.set(n[1], n[0]), this._currentUnits$.next(this._currentUnits);
  }
  getTypeOfUnitAdded$(t) {
    return this._unitAdded$.pipe(Rr((n) => n.type === t));
  }
  /**
   * Add a unit into Univer.
   *
   * @ignore
   *
   * @param unit The unit to be added.
   */
  __addUnit(t, n) {
    var o;
    const r = t.type;
    this._unitsByType.has(r) || this._unitsByType.set(r, []);
    const s = this._unitsByType.get(r), i = t.getUnitId();
    if (s.findIndex((a) => a.getUnitId() === i) !== -1)
      throw new Error(`[UniverInstanceService]: cannot create a unit with the same unit id: ${i}.`);
    s.push(t), this._unitAdded$.next(t), ((o = n == null ? void 0 : n.makeCurrent) == null || o) && this.setCurrentUnitForType(t.getUnitId());
  }
  getTypeOfUnitDisposed$(t) {
    return this.unitDisposed$.pipe(Rr((n) => n.type === t));
  }
  getUnit(t, n) {
    var s;
    const r = (s = this._getUnitById(t)) == null ? void 0 : s[0];
    return n && (r == null ? void 0 : r.type) !== n ? null : r;
  }
  getCurrentUniverDocInstance() {
    return this.getCurrentUnitForType(we.UNIVER_DOC);
  }
  getUniverDocInstance(t) {
    return this.getUnit(t, we.UNIVER_DOC);
  }
  getUniverSheetInstance(t) {
    return this.getUnit(t, we.UNIVER_SHEET);
  }
  getAllUnitsForType(t) {
    var n;
    return (n = this._unitsByType.get(t)) != null ? n : [];
  }
  changeDoc(t, n) {
    const r = this.getAllUnitsForType(we.UNIVER_DOC), s = r.find((i) => i.getUnitId() === t);
    if (s != null) {
      const i = r.indexOf(s);
      r.splice(i, 1);
    }
    this.__addUnit(n);
  }
  get focused() {
    var n;
    const t = this._focused$.getValue();
    return t ? (n = this._getUnitById(t)) == null ? void 0 : n[0] : null;
  }
  focusUnit(t) {
    this._focused$.next(t), this.focused instanceof ws ? (this._contextService.setContextValue(Xr, !0), this._contextService.setContextValue(qr, !1), this._contextService.setContextValue(gr, !0), this._contextService.setContextValue(Zr, !1), this.setCurrentUnitForType(t)) : this.focused instanceof Pt ? (this._contextService.setContextValue(Xr, !0), this._contextService.setContextValue(qr, !0), this._contextService.setContextValue(gr, !1), this._contextService.setContextValue(Zr, !1), this.setCurrentUnitForType(t)) : this.focused instanceof lc ? (this._contextService.setContextValue(Xr, !0), this._contextService.setContextValue(qr, !1), this._contextService.setContextValue(gr, !1), this._contextService.setContextValue(Zr, !0), this.setCurrentUnitForType(t)) : (this._contextService.setContextValue(Xr, !1), this._contextService.setContextValue(qr, !1), this._contextService.setContextValue(gr, !1), this._contextService.setContextValue(Zr, !1));
  }
  getFocusedUnit() {
    return this.focused;
  }
  getUnitType(t) {
    const n = this._getUnitById(t);
    return n ? n[1] : we.UNRECOGNIZED;
  }
  disposeUnit(t) {
    const n = this._getUnitById(t);
    if (!n) return !1;
    const [r, s] = n, i = this._unitsByType.get(s), o = i.indexOf(r);
    return i.splice(o, 1), this._tryResetCurrentOnRemoval(t, s), this._tryResetFocusOnRemoval(t), this._unitDisposed$.next(r), !0;
  }
  _tryResetCurrentOnRemoval(t, n) {
    const r = this.getCurrentUnitForType(n);
    (r == null ? void 0 : r.getUnitId()) === t && (this._currentUnits.set(n, null), this._currentUnits$.next(this._currentUnits));
  }
  _tryResetFocusOnRemoval(t) {
    var n;
    ((n = this.focused) == null ? void 0 : n.getUnitId()) === t && this._focused$.next(null);
  }
  _getUnitById(t) {
    for (const [n, r] of this._unitsByType) {
      const s = r.find((i) => i.getUnitId() === t);
      if (s)
        return [s, n];
    }
  }
};
Yi = zE([
  Sl(0, Nt(Yn)),
  Sl(1, Nr)
], Yi);
var ke = /* @__PURE__ */ ((e) => (e[e.Starting = 0] = "Starting", e[e.Ready = 1] = "Ready", e[e.Rendered = 2] = "Rendered", e[e.Steady = 3] = "Steady", e))(ke || {});
const uc = {
  0: "Starting",
  1: "Ready",
  2: "Rendered",
  3: "Steady"
};
var VE = Object.getOwnPropertyDescriptor, GE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? VE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, KE = (e, t) => (n, r) => t(n, r, e);
class XE extends Error {
  constructor(t) {
    super(`[LifecycleService]: lifecycle stage "${uc[t]}" will never be reached!`), this.name = "LifecycleUnreachableError";
  }
}
let Wn = class extends Ve {
  constructor(t) {
    super();
    p(this, "_lifecycle$", new tt(ke.Starting));
    p(this, "lifecycle$", this._lifecycle$.asObservable());
    p(this, "_lock", !1);
    this._logService = t, this._reportProgress(ke.Starting);
  }
  get stage() {
    return this._lifecycle$.getValue();
  }
  set stage(t) {
    if (this._lock) throw new Error("[LifecycleService]: cannot set new stage when related logic is all handled!");
    if (t < this.stage) throw new Error("[LifecycleService]: lifecycle stage cannot go backward!");
    t !== this.stage && (this._lock = !0, this._reportProgress(t), this._lifecycle$.next(t), this._lock = !1);
  }
  dispose() {
    this._lifecycle$.complete(), super.dispose();
  }
  /**
   * Wait for a specific lifecycle stage to be reached.
   * @param stage The lifecycle stage to wait for.
   * If the current stage is already at or beyond the specified stage, it will
   * resolve immediately.
   * If the specified stage is unreachable, it will reject with a
   * `LifecycleUnreachableError`.
   * @returns A promise that resolves when the specified stage is reached.
   */
  onStage(t) {
    return Oc(this.lifecycle$.pipe(
      Rr((n) => n >= t),
      xa((n) => n === t),
      Ji(() => {
      })
    )).catch((n) => n.name === "EmptyError" ? Promise.reject(new XE(t)) : Promise.reject(n));
  }
  /**
   * Subscribe to lifecycle changes and all previous stages and the current
   * stage will be emitted immediately.
   * @returns An observable that emits the lifecycle stages, including the current
   */
  subscribeWithPrevious() {
    return Ll(cc(this.stage), this._lifecycle$.pipe(xl(1))).pipe(xa((t) => t === ke.Steady));
  }
  _reportProgress(t) {
    this._logService.debug("[LifecycleService]", `lifecycle progressed to "${uc[t]}".`);
  }
};
Wn = GE([
  KE(0, yt)
], Wn);
function cc(e) {
  switch (e) {
    case ke.Starting:
      return Mr(ke.Starting);
    case ke.Ready:
      return Mr(ke.Starting, ke.Ready);
    case ke.Rendered:
      return Mr(ke.Starting, ke.Ready, ke.Rendered);
    default:
      return Mr(
        ke.Starting,
        ke.Ready,
        ke.Rendered,
        ke.Steady
      );
  }
}
const XR = ht("ILocalStorageService");
class Fn extends Ve {
  constructor() {
    super();
    p(this, "_currentLocale$", new tt(Ns.ZH_CN));
    p(this, "currentLocale$", this._currentLocale$.asObservable());
    p(this, "_locales", null);
    p(this, "localeChanged$", new ot());
    /**
     * Translate a key to the current locale
     *
     * @param {string} key the key to translate
     * @param {string[]} args optional arguments to replace in the translated string
     * @returns {string} the translated string
     *
     * @example
     * const locales = {
     *   [LocaleType.EN_US]: {
     *     foo: {
     *       bar: 'Hello'
     *    }
     * }
     * t('foo.bar') => 'Hello'
     *
     * @example
     * const locales = {
     *   [LocaleType.EN_US]: {
     *     foo: {
     *       bar: 'Hello {0}'
     *    }
     * }
     * t('foo.bar', 'World') => 'Hello World'
     */
    p(this, "t", (n, ...r) => {
      if (!this._locales) throw new Error("[LocaleService]: Locale not initialized");
      const s = n.split("."), i = this.resolveKeyPath(this._locales[this._currentLocale], s);
      if (typeof i == "string") {
        let o = i;
        return r.forEach((a, l) => {
          o = o.replace(`{${l}}`, a);
        }), o;
      } else
        return n;
    });
    this.disposeWithMe(We(() => {
      this._locales = null, this._currentLocale$.complete(), this.localeChanged$.complete();
    }));
  }
  get _currentLocale() {
    return this._currentLocale$.value;
  }
  /**
   * Load more locales after init.
   *
   * @param locales - Locale object
   */
  load(n) {
    var r;
    this._locales = oo((r = this._locales) != null ? r : {}, n);
  }
  setLocale(n) {
    this._currentLocale$.next(n), this.localeChanged$.next();
  }
  getLocales() {
    var n;
    return (n = this._locales) == null ? void 0 : n[this._currentLocale];
  }
  getCurrentLocale() {
    return this._currentLocale;
  }
  resolveKeyPath(n, r) {
    const s = r.shift();
    if (s && n && s in n) {
      const i = n[s];
      return r.length > 0 && (typeof i == "object" || Array.isArray(i)) ? this.resolveKeyPath(i, r) : i;
    }
    return null;
  }
}
var qE = Object.getOwnPropertyDescriptor, ZE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? qE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, JE = (e, t) => (n, r) => t(n, r, e);
let zi = class {
  constructor(e) {
    this._userManagerService = e;
  }
  async list(e) {
    return {
      list: [{
        type: Ii.PERSON,
        mentions: [
          {
            objectType: Ii.PERSON,
            objectId: this._userManagerService.getCurrentUser().userID,
            label: this._userManagerService.getCurrentUser().name,
            metadata: {
              icon: this._userManagerService.getCurrentUser().avatar
            }
          }
        ],
        metadata: {},
        title: "PEOPLE"
      }],
      page: e.page,
      size: e.size,
      total: 1
    };
  }
};
zi = ZE([
  JE(0, Nt(Rs))
], zi);
const QE = ht("univer.service.mention-io");
var hc = /* @__PURE__ */ ((e) => (e.INIT = "init", e.FETCHING = "fetching", e.DONE = "done", e))(hc || {});
const eC = ht("univer.permission-service");
class tC extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_permissionPointMap", /* @__PURE__ */ new Map());
    p(this, "_permissionPointUpdate$", new ot());
    p(this, "permissionPointUpdate$", this._permissionPointUpdate$.asObservable());
    p(this, "_showComponents", !0);
  }
  setShowComponents(n) {
    this._showComponents = n;
  }
  getShowComponents() {
    return this._showComponents;
  }
  deletePermissionPoint(n) {
    const r = this._permissionPointMap.get(n);
    r && (r.complete(), this._permissionPointMap.delete(n));
  }
  addPermissionPoint(n) {
    const r = n instanceof tt, s = r ? n.getValue() : n;
    return s.id ? this._permissionPointMap.get(s.id) ? (console.warn(`${s.id} PermissionPoint already exists`), !1) : (this._permissionPointMap.set(s.id, r ? n : new tt(s)), this._permissionPointUpdate$.next(s), !0) : !1;
  }
  updatePermissionPoint(n, r) {
    const s = this._permissionPointMap.get(n);
    if (!s)
      return;
    const i = s.getValue();
    i.value = r, i.status = hc.DONE, s.next(i), this._permissionPointUpdate$.next(i);
  }
  clearPermissionMap() {
    this._permissionPointMap.clear();
  }
  getPermissionPoint(n) {
    const r = this._permissionPointMap.get(n);
    if (r)
      return r.getValue();
  }
  getPermissionPoint$(n) {
    const r = this._permissionPointMap.get(n);
    if (r)
      return r;
  }
  composePermission$(n) {
    const r = n.map((s) => {
      var o;
      const i = (o = this._permissionPointMap) == null ? void 0 : o.get(s);
      if (!i)
        throw new Error(`[PermissionService]: ${s} permissionPoint does not exist!`);
      return i.asObservable();
    });
    return vc(r).pipe(
      // Check that all permissions exist
      Nc((s) => s)
    );
  }
  composePermission(n) {
    return n.map((s) => {
      var o;
      const i = (o = this._permissionPointMap) == null ? void 0 : o.get(s);
      if (!i)
        throw new Error(`[PermissionService]: ${s} permissionPoint does not exist!`);
      return i.getValue();
    });
  }
  getAllPermissionPoint() {
    const n = /* @__PURE__ */ new Map();
    return this._permissionPointMap.forEach((r, s) => {
      n.set(s, r);
    }), n;
  }
}
function nC(e, t) {
  if (!t) return e;
  const n = [];
  for (const r of e) {
    const s = t.find(([i]) => i === r[0]);
    if (s) {
      if (s[1] === null) continue;
      n.push([r[0], s[1]]);
    } else
      n.push(r);
  }
  return n;
}
var rC = Object.getOwnPropertyDescriptor, sC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? rC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, di = (e, t) => (n, r) => t(n, r, e);
const iC = 4, dc = Symbol("DependentOn");
class Ol extends Ve {
  onStarting() {
  }
  onReady() {
  }
  onRendered() {
  }
  onSteady() {
  }
  getUnitType() {
    return this.constructor.type;
  }
  getPluginName() {
    return this.constructor.pluginName;
  }
}
p(Ol, "pluginName"), p(Ol, "type", we.UNIVER_UNKNOWN);
class oC {
  constructor() {
    p(this, "_plugins", []);
  }
  addPlugin(t) {
    this._plugins.push(t);
  }
  removePlugins() {
    const t = this._plugins.slice();
    return this._plugins.length = 0, t;
  }
  forEachPlugin(t) {
    this._plugins.forEach(t);
  }
}
function qR(...e) {
  return function(t) {
    t[dc] = e;
  };
}
let Ss = class {
  constructor(e, t, n) {
    p(this, "_pluginRegistry", /* @__PURE__ */ new Map());
    p(this, "_pluginStore", new oC());
    p(this, "_seenPlugins", /* @__PURE__ */ new Set());
    p(this, "_loadedPlugins", /* @__PURE__ */ new Set());
    p(this, "_loadedPluginTypes", /* @__PURE__ */ new Set([we.UNIVER_UNKNOWN]));
    p(this, "_flushTimerByType", /* @__PURE__ */ new Map());
    this._injector = e, this._lifecycleService = t, this._logService = n;
  }
  dispose() {
    this._pluginStore.removePlugins().forEach((e) => e.dispose()), this._flushTimerByType.forEach((e) => clearTimeout(e));
  }
  /**
   * Register a plugin into univer.
   * @param {PluginCtor} ctor The plugin's constructor.
   * @param {ConstructorParameters} [config] The configuration for the plugin.
   */
  registerPlugin(e, t) {
    this._assertPluginValid(e);
    const n = { plugin: e, options: t };
    this._pluginRegistry.set(e.pluginName, n), this._logService.debug("[PluginService]", `Plugin "${e.pluginName}" registered.`);
    const { type: r } = e;
    this._loadedPluginTypes.has(r) && (r === we.UNIVER_UNKNOWN ? this._loadFromPlugins([n]) : this._flushType(r));
  }
  startPluginsForType(e) {
    this._loadedPluginTypes.has(e) || this._loadPluginsForType(e);
  }
  _loadPluginsForType(e) {
    const t = Array.from(this._pluginRegistry.keys()), n = [];
    t.forEach((r) => {
      const s = this._pluginRegistry.get(r);
      s.plugin.type === e && n.push(s);
    }), this._loadFromPlugins(n), this._loadedPluginTypes.add(e);
  }
  _assertPluginValid(e) {
    const { type: t, pluginName: n } = e;
    if (t === we.UNRECOGNIZED)
      throw new Error(`[PluginService]: invalid plugin type for ${e.name}. Please assign a "type" to your plugin.`);
    if (!n)
      throw new Error(`[PluginService]: no plugin name for ${e.name}. Please assign a "pluginName" to your plugin.`);
    if (this._seenPlugins.has(n))
      throw new Error(`[PluginService]: duplicated plugin name for "${n}". Maybe a plugin that dependents on "${n} has already registered it. In that case please register "${n}" before the that plugin.`);
    this._seenPlugins.add(e.pluginName);
  }
  _flushType(e) {
    this._flushTimerByType.get(e) === void 0 && this._flushTimerByType.set(e, setTimeout(() => {
      this._loadPluginsForType(e), this._flushTimerByType.delete(e);
    }, iC));
  }
  _loadFromPlugins(e) {
    const t = [], n = /* @__PURE__ */ new Set(), r = (i) => {
      const { plugin: o } = i, { pluginName: a } = o;
      if (this._loadedPlugins.has(a) || n.has(a))
        return;
      n.add(a), this._pluginRegistry.delete(a);
      const l = o[dc];
      l && l.forEach((u) => {
        const c = this._pluginRegistry.get(u.pluginName);
        if (c)
          r(c);
        else if (!this._seenPlugins.has(u.pluginName) && !n.has(u.pluginName)) {
          if (o.type === we.UNIVER_UNKNOWN && u.type !== we.UNIVER_UNKNOWN)
            throw new Error(
              `[PluginService]: cannot register a plugin with Univer type that depends on a plugin with other type. The dependent is ${o.pluginName} and the dependency is ${u.pluginName}.`
            );
          o.type !== u.type && u.type !== we.UNIVER_UNKNOWN && this._logService.debug(
            "[PluginService]",
            `Plugin "${a}" depends on "${u.pluginName}" which has different type.`
          ), this._logService.debug(
            "[PluginService]",
            `Plugin "${a}" depends on "${u.pluginName}" which is not registered. Univer will automatically register it with default configuration.`
          ), this._assertPluginValid(u), r({ plugin: u, options: void 0 });
        }
      }), t.push(i);
    };
    e.forEach((i) => r(i));
    const s = t.map((i) => this._initPlugin(i.plugin, i.options));
    this._pluginsRunLifecycle(s);
  }
  _pluginsRunLifecycle(e) {
    const t = this._lifecycleService.stage;
    if (cc(t).subscribe((n) => this._runStage(e, n)), t !== ke.Steady) {
      const n = this._lifecycleService.lifecycle$.pipe(
        xl(1)
      ).subscribe((r) => {
        this._runStage(e, r), r === ke.Steady && n.unsubscribe();
      });
    }
  }
  _runStage(e, t) {
    e.forEach((n) => {
      switch (t) {
        case ke.Starting:
          n.onStarting();
          break;
        case ke.Ready:
          n.onReady();
          break;
        case ke.Rendered:
          n.onRendered();
          break;
        case ke.Steady:
          n.onSteady();
          break;
      }
    });
  }
  _initPlugin(e, t) {
    const n = this._injector.createInstance(e, t);
    return this._pluginStore.addPlugin(n), this._loadedPlugins.add(e.pluginName), this._logService.debug("[PluginService]", `Plugin "${n.getPluginName()}" loaded.`), n;
  }
};
Ss = sC([
  di(0, Nt(Yn)),
  di(1, Nt(Wn)),
  di(2, yt)
], Ss);
const vl = ht("resource-loader-service");
var aC = Object.getOwnPropertyDescriptor, lC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? aC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, uC = (e, t) => (n, r) => t(n, r, e);
let Vi = class extends Ve {
  constructor(t) {
    super();
    p(this, "_resourceMap", /* @__PURE__ */ new Map());
    p(this, "_register$", new ot());
    p(this, "register$", this._register$.asObservable());
    this._logService = t;
  }
  getAllResourceHooks() {
    return [...this._resourceMap.values()];
  }
  getResources(t, n) {
    return n ? this.getResourcesByType(t, n) : this.getAllResourceHooks().map((i) => {
      const o = i.toJson(t);
      return {
        name: i.pluginName,
        data: o
      };
    });
  }
  getResourcesByType(t, n) {
    return this.getAllResourceHooks().filter((i) => i.businesses.includes(n)).map((i) => {
      const o = i.toJson(t);
      return {
        name: i.pluginName,
        data: o
      };
    });
  }
  registerPluginResource(t) {
    const n = t.pluginName;
    if (this._resourceMap.has(n))
      throw new Error(`the pluginName is registered {${n}}`);
    return this._resourceMap.set(n, t), this._register$.next(t), We(() => this._resourceMap.delete(n));
  }
  disposePluginResource(t) {
    this._resourceMap.delete(t);
  }
  loadResources(t, n) {
    this.getAllResourceHooks().forEach((r) => {
      var i;
      const s = (i = n == null ? void 0 : n.find((o) => o.name === r.pluginName)) == null ? void 0 : i.data;
      if (s)
        try {
          const o = r.parseJson(s);
          r.onLoad(t, o);
        } catch (o) {
          this._logService.error("[ResourceManagerService]", "loadResources error", o);
        }
    });
  }
  unloadResources(t, n) {
    this.getAllResourceHooks().filter((r) => r.businesses.includes(n)).forEach((r) => {
      r.onUnLoad(t);
    });
  }
  dispose() {
    this._register$.complete(), this._resourceMap.clear();
  }
};
Vi = lC([
  uC(0, yt)
], Vi);
class Gi extends Ve {
  constructor() {
    super();
    p(this, "_darkMode$", new tt(!1));
    p(this, "darkMode$", this._darkMode$.asObservable());
    // Cache for valid theme colors
    p(this, "_validColorCache", /* @__PURE__ */ new Map());
    p(this, "_currentTheme", Lr);
    p(this, "_currentTheme$", new tt(this._currentTheme));
    p(this, "currentTheme$", this._currentTheme$.asObservable());
    this.disposeWithMe(We(() => {
      this._currentTheme = Lr, this._currentTheme$.complete(), this._darkMode$.complete();
    }));
  }
  get darkMode() {
    return this._darkMode$.getValue();
  }
  /**
   * Whether the given color is a valid theme color.
   * A valid theme color can be a direct key in the theme object or a nested key with a dot notation.
   * For example:
   * @param {string} color - The color string to validate.
   * @returns {boolean} True if the color is valid, false otherwise.
   * @example
   * isValidThemeColor('primary.600'); // true
   * isValidThemeColor('blue'); // false
   */
  isValidThemeColor(n) {
    if (this._validColorCache.has(n))
      return this._validColorCache.get(n);
    let r = !1;
    const s = n.split(".");
    if (s.length === 1)
      r = n in Lr;
    else if (s.length === 2) {
      const [i, o] = s;
      r = i in Lr && o in this._currentTheme[i];
    }
    return this._validColorCache.set(n, r), r;
  }
  /**
   * Get the current theme.
   * @returns The current theme.
   */
  getCurrentTheme() {
    return this._currentTheme;
  }
  /**
   * Set the current theme.
   * @param theme - The new theme to set.
   */
  setTheme(n) {
    this._currentTheme = n, this._currentTheme$.next(n);
  }
  /**
   * Get the current theme as an observable.
   * @param {boolean} darkMode - Whether to set the theme in dark mode.
   */
  setDarkMode(n) {
    this._darkMode$.next(n);
  }
  /**
   * Get a color from the current theme.
   * @param {string} color - The color key to retrieve.
   * @returns {string} The color value from the current theme.
   */
  getColorFromTheme(n) {
    return vf(this._currentTheme, n);
  }
}
var cC = Object.getOwnPropertyDescriptor, hC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? cC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, fi = (e, t) => (n, r) => t(n, r, e);
const Qo = ht("univer.undo-redo.service"), dC = 20;
class fc {
  dispose() {
  }
  async dispatchToHandlers() {
    return !1;
  }
}
const fC = "univer.command.redo", mC = "univer.command.undo", gC = new class extends fc {
  constructor() {
    super(...arguments);
    p(this, "type", Ms.COMMAND);
    p(this, "id", mC);
  }
  handler(t) {
    const n = t.get(Qo), r = n.pitchTopUndoElement();
    if (!r)
      return !1;
    const s = t.get(Ls);
    return fo(r.undoMutations, s) ? (n.popUndoToRedo(), !0) : !1;
  }
}(), _C = new class extends fc {
  constructor() {
    super(...arguments);
    p(this, "type", Ms.COMMAND);
    p(this, "id", fC);
  }
  handler(t) {
    const n = t.get(Qo), r = n.pitchTopRedoElement();
    if (!r)
      return !1;
    const s = t.get(Ls);
    return fo(r.redoMutations, s) ? (n.popRedoToUndo(), !0) : !1;
  }
}();
let Ki = class extends Ve {
  constructor(t, n, r) {
    super();
    p(this, "undoRedoStatus$");
    p(this, "_undoRedoStatus$", new tt({ undos: 0, redos: 0 }));
    // Undo and redo stacks are per unit.
    p(this, "_undoStacks", /* @__PURE__ */ new Map());
    p(this, "_redoStacks", /* @__PURE__ */ new Map());
    p(this, "_batchingStatus", /* @__PURE__ */ new Map());
    this._univerInstanceService = t, this._commandService = n, this._contextService = r, this.undoRedoStatus$ = this._undoRedoStatus$.asObservable(), this.disposeWithMe(this._commandService.registerCommand(gC)), this.disposeWithMe(this._commandService.registerCommand(_C)), this.disposeWithMe(We(() => this._undoRedoStatus$.complete())), this.disposeWithMe(We(this._univerInstanceService.focused$.subscribe(() => this._updateStatus())));
  }
  pushUndoRedo(t) {
    const { unitID: n } = t, r = this._getRedoStack(n, !0), s = this._getUndoStack(n, !0);
    if (r.length = 0, this._batchingStatus.has(t.unitID)) {
      const o = this._batchingStatus.get(t.unitID), a = this._pitchUndoElement(t.unitID);
      o === 0 || !a ? (i(t), this._batchingStatus.set(
        t.unitID,
        1
        /* CREATED */
      )) : this._tryBatchingElements(a, t);
    } else
      i(t);
    function i(o) {
      s.push(o), s.length > dC && s.splice(0, 1);
    }
    this._updateStatus();
  }
  clearUndoRedo(t) {
    const n = this._getRedoStack(t);
    n && (n.length = 0);
    const r = this._getUndoStack(t);
    r && (r.length = 0), this._updateStatus();
  }
  pitchTopUndoElement() {
    const t = this._getFocusedUnitId();
    return this._pitchUndoElement(t);
  }
  pitchTopRedoElement() {
    const t = this._getFocusedUnitId();
    return this._pitchRedoElement(t);
  }
  _pitchUndoElement(t) {
    const n = this._getUndoStack(t);
    return n != null && n.length ? n[n.length - 1] : null;
  }
  _pitchRedoElement(t) {
    const n = this._getRedoStack(t);
    return n != null && n.length ? n[n.length - 1] : null;
  }
  popUndoToRedo() {
    const n = this._getUndoStackForFocused().pop();
    n && (this._getRedoStackForFocused().push(n), this._updateStatus());
  }
  popRedoToUndo() {
    const n = this._getRedoStackForFocused().pop();
    n && (this._getUndoStackForFocused().push(n), this._updateStatus());
  }
  rollback(t, n) {
    const r = n || this._getFocusedUnitId(), s = this._getUndoStack(r), i = s == null ? void 0 : s[(s == null ? void 0 : s.length) - 1];
    i && i.id === t && (s.pop(), fo(i.undoMutations, this._commandService));
  }
  __tempBatchingUndoRedo(t) {
    if (this._batchingStatus.has(t))
      throw new Error("[LocalUndoRedoService]: cannot batching undo redo twice at the same time!");
    return this._batchingStatus.set(
      t,
      0
      /* WAITING */
    ), We(() => this._batchingStatus.delete(t));
  }
  _updateStatus() {
    var s, i;
    const t = this._getFocusedUnitId(), n = t && ((s = this._undoStacks.get(t)) == null ? void 0 : s.length) || 0, r = t && ((i = this._redoStacks.get(t)) == null ? void 0 : i.length) || 0;
    this._undoRedoStatus$.next({
      undos: n,
      redos: r
    });
  }
  _getUndoStack(t, n = !1) {
    let r = this._undoStacks.get(t);
    return !r && n && (r = [], this._undoStacks.set(t, r)), r || null;
  }
  _getRedoStack(t, n = !1) {
    let r = this._redoStacks.get(t);
    return !r && n && (r = [], this._redoStacks.set(t, r)), r || null;
  }
  _getUndoStackForFocused() {
    const t = this._getFocusedUnitId();
    if (!t)
      throw new Error("No focused univer instance!");
    return this._getUndoStack(t, !0);
  }
  _getRedoStackForFocused() {
    const t = this._getFocusedUnitId();
    if (!t)
      throw new Error("No focused univer instance!");
    return this._getRedoStack(t, !0);
  }
  _tryBatchingElements(t, n) {
    t.redoMutations.push(...n.redoMutations), t.undoMutations.push(...n.undoMutations);
  }
  _getFocusedUnitId() {
    var i, o, a, l;
    let t = "";
    const n = this._contextService.getContextValue(gr), r = this._contextService.getContextValue(gE), s = this._contextService.getContextValue(mE);
    return n ? r ? t = Ul : s ? t = Dl : t = (o = (i = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : i.getUnitId()) != null ? o : "" : t = (l = (a = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : a.getUnitId()) != null ? l : "", t;
  }
};
Ki = hC([
  fi(0, vr),
  fi(1, Ls),
  fi(2, Nr)
], Ki);
class pC {
  constructor(t, n = 100) {
    p(this, "_imageCacheMap");
    this._injector = t, this._imageCacheMap = new gs(n);
  }
  _getImageCacheKey(t, n) {
    return `${t}-${n}`;
  }
  getImage(t, n, r, s) {
    const i = this._getImageCacheKey(t, n), o = this._imageCacheMap.get(i);
    return o || ((async () => {
      const a = new Image(), l = this._injector.has(El) ? this._injector.get(El) : null;
      if (t === oc.UUID)
        try {
          a.src = await (l == null ? void 0 : l.getImage(n)) || "";
        } catch (u) {
          console.error(u);
        }
      else
        a.src = n;
      a.onload = () => {
        a.removeAttribute("data-error"), r == null || r();
      }, a.onerror = () => {
        a.setAttribute("data-error", "true"), s == null || s();
      }, this._imageCacheMap.set(i, a);
    })(), null);
  }
}
function ZR(e) {
  return !(e.length === 0 || e.length > 31 || e.startsWith("'") || e.endsWith("'") || /[:\\\/\?\*\[\]]/.test(e));
}
function JR(e, t) {
  return !(!e || e.length === 0 || e.length > 255 || t.has(e) || /[ :\\\/\?\*\[\]]/.test(e) || !/^[\p{L}_]/u.test(e) || /^\$?[A-Za-z]{1,3}\$?[0-9]+$/.test(e) || /^[rR]\d+[cC]\d+$/.test(e) || /^\d+$/.test(e));
}
const bl = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], mi = 1, tr = 8;
class ea {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const s = r >> 4;
    if (s !== mi)
      throw new Error(`Got v${s} data when expected v${mi}.`);
    const i = bl[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [o] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new ea(a, o, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, s) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = bl.indexOf(this.ArrayType), o = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    s && s instanceof ArrayBuffer ? (this.data = s, this.ids = new this.IndexArrayType(this.data, tr, t), this.coords = new this.ArrayType(this.data, tr + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(tr + o + a + l), this.ids = new this.IndexArrayType(this.data, tr, t), this.coords = new this.ArrayType(this.data, tr + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (mi << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Xi(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, s) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: o, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, h = l.pop() || 0, d = l.pop() || 0;
      if (h - d <= a) {
        for (let R = d; R <= h; R++) {
          const b = o[2 * R], H = o[2 * R + 1];
          b >= t && b <= r && H >= n && H <= s && u.push(i[R]);
        }
        continue;
      }
      const f = d + h >> 1, g = o[2 * f], _ = o[2 * f + 1];
      g >= t && g <= r && _ >= n && _ <= s && u.push(i[f]), (c === 0 ? t <= g : n <= _) && (l.push(d), l.push(f - 1), l.push(1 - c)), (c === 0 ? r >= g : s >= _) && (l.push(f + 1), l.push(h), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: s, coords: i, nodeSize: o } = this, a = [0, s.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, h = a.pop() || 0, d = a.pop() || 0;
      if (h - d <= o) {
        for (let R = d; R <= h; R++)
          Al(i[2 * R], i[2 * R + 1], t, n) <= u && l.push(s[R]);
        continue;
      }
      const f = d + h >> 1, g = i[2 * f], _ = i[2 * f + 1];
      Al(g, _, t, n) <= u && l.push(s[f]), (c === 0 ? t - r <= g : n - r <= _) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= _) && (a.push(f + 1), a.push(h), a.push(1 - c));
    }
    return l;
  }
}
function Xi(e, t, n, r, s, i) {
  if (s - r <= n) return;
  const o = r + s >> 1;
  mc(e, t, o, r, s, i), Xi(e, t, n, r, o - 1, 1 - i), Xi(e, t, n, o + 1, s, 1 - i);
}
function mc(e, t, n, r, s, i) {
  for (; s > r; ) {
    if (s - r > 600) {
      const u = s - r + 1, c = n - r + 1, h = Math.log(u), d = 0.5 * Math.exp(2 * h / 3), f = 0.5 * Math.sqrt(h * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), g = Math.max(r, Math.floor(n - c * d / u + f)), _ = Math.min(s, Math.floor(n + (u - c) * d / u + f));
      mc(e, t, n, g, _, i);
    }
    const o = t[2 * n + i];
    let a = r, l = s;
    for (nr(e, t, r, n), t[2 * s + i] > o && nr(e, t, r, s); a < l; ) {
      for (nr(e, t, a, l), a++, l--; t[2 * a + i] < o; ) a++;
      for (; t[2 * l + i] > o; ) l--;
    }
    t[2 * r + i] === o ? nr(e, t, r, l) : (l++, nr(e, t, l, s)), l <= n && (r = l + 1), n <= l && (s = l - 1);
  }
}
function nr(e, t, n, r) {
  gi(e, n, r), gi(t, 2 * n, 2 * r), gi(t, 2 * n + 1, 2 * r + 1);
}
function gi(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Al(e, t, n, r) {
  const s = e - n, i = t - r;
  return s * s + i * i;
}
class QR {
  constructor(t = !1) {
    p(this, "_tree", /* @__PURE__ */ new Map());
    // unitId -> subUnitId -> row -> column -> ids
    p(this, "_oneCellCache", /* @__PURE__ */ new Map());
    p(this, "_kdTree", /* @__PURE__ */ new Map());
    this._enableOneCellCache = t;
  }
  dispose() {
    this.clear();
  }
  getTree(t, n) {
    return this._tree.has(t) || this._tree.set(t, /* @__PURE__ */ new Map()), this._tree.get(t).has(n) || this._tree.get(t).set(n, new Di()), this._tree.get(t).get(n);
  }
  _getOneCellCache(t, n, r, s) {
    return this._oneCellCache.has(t) || this._oneCellCache.set(t, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).has(n) || this._oneCellCache.get(t).set(n, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).get(n).has(r) || this._oneCellCache.get(t).get(n).set(r, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).get(n).get(r).has(s) || this._oneCellCache.get(t).get(n).get(r).set(s, /* @__PURE__ */ new Set()), this._oneCellCache.get(t).get(n).get(r).get(s);
  }
  _removeOneCellCache(t, n, r, s, i) {
    const o = this._oneCellCache.get(t);
    if (!o) return;
    const a = o.get(n);
    if (!a) return;
    const l = a.get(r);
    if (!l) return;
    const u = l.get(s);
    u && u.delete(i);
  }
  _removeCellCacheByRange(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, o = this._oneCellCache.get(n);
    if (!o) return;
    const a = o.get(r);
    if (!a) return;
    const { startRow: l, startColumn: u, endRow: c, endColumn: h } = s;
    for (let d = l; d <= c; d++) {
      const f = a.get(d);
      if (f)
        for (let g = u; g <= h; g++) {
          const _ = f.get(g);
          _ && _.delete(i);
        }
    }
  }
  _insertOneCellCache(t, n, r, s, i) {
    this._getOneCellCache(t, n, r, s).add(i);
  }
  _getRdTreeItems(t) {
    const n = [];
    for (const [r, s] of t)
      for (const [i, o] of s)
        n.push({
          x: i,
          y: r,
          ids: o
        });
    return n;
  }
  _searchByOneCellCache(t) {
    var g;
    const { unitId: n, sheetId: r, range: s } = t, { startRow: i, startColumn: o, endRow: a, endColumn: l } = s, u = (g = this._kdTree.get(n)) == null ? void 0 : g.get(r);
    if (!u)
      return [];
    const { tree: c, items: h } = u, d = c.range(o, i, l, a), f = [];
    for (const _ of d) {
      const R = h[_];
      f.push(...Array.from(R.ids));
    }
    return f;
  }
  /**
   * Open the kd-tree search state.
   * The kd-tree is used to search for data in a single cell.
   */
  openKdTree() {
    var t;
    for (const [n, r] of this._oneCellCache) {
      this._kdTree.has(n) || this._kdTree.set(n, /* @__PURE__ */ new Map());
      for (const [s, i] of r) {
        const o = this._getRdTreeItems(i), a = new ea(o.length);
        (t = this._kdTree.get(n)) == null || t.set(s, {
          tree: a,
          items: o
        });
        for (const l of o)
          a.add(l.x, l.y);
        a.finish();
      }
    }
  }
  closeKdTree() {
    var t;
    for (const [n, r] of this._oneCellCache)
      for (const [s, i] of r)
        (t = this._kdTree.get(n)) == null || t.set(s, void 0);
  }
  insert(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t;
    if (!n || n.length === 0)
      return;
    let { startRow: o, endRow: a, startColumn: l, endColumn: u } = s;
    if (this._enableOneCellCache && o === a && l === u) {
      this._insertOneCellCache(n, r, o, l, i);
      return;
    }
    const c = this.getTree(n, r);
    Number.isNaN(o) && (o = 0), Number.isNaN(l) && (l = 0), Number.isNaN(a) && (a = Number.POSITIVE_INFINITY), Number.isNaN(u) && (u = Number.POSITIVE_INFINITY), c.insert({
      minX: l,
      minY: o,
      maxX: u,
      maxY: a,
      id: i
    });
  }
  bulkInsert(t) {
    for (const n of t)
      this.insert(n);
  }
  *searchGenerator(t) {
    var a;
    const { unitId: n, sheetId: r, range: s } = t;
    if (this._enableOneCellCache) {
      const l = this._searchByOneCellCache(t);
      for (const u of l)
        yield u;
    }
    const i = (a = this._tree.get(n)) == null ? void 0 : a.get(r);
    if (!i)
      return;
    const o = i.search({
      minX: s.startColumn,
      minY: s.startRow,
      maxX: s.endColumn,
      maxY: s.endRow
    });
    for (const l of o)
      yield l.id;
  }
  bulkSearch(t, n) {
    const r = /* @__PURE__ */ new Set();
    for (const s of t)
      for (const i of this.searchGenerator(s))
        (n == null ? void 0 : n.has(i)) !== !0 && r.add(i);
    return r;
  }
  removeById(t, n) {
    var r, s;
    n ? ((r = this._tree.get(t)) == null || r.delete(n), (s = this._oneCellCache.get(t)) == null || s.delete(n)) : (this._tree.delete(t), this._oneCellCache.delete(t));
  }
  _removeRTreeItem(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, o = this.getTree(n, r), a = o.search({
      minX: s.startColumn,
      minY: s.startRow,
      maxX: s.endColumn,
      maxY: s.endRow
    });
    for (let l = 0; l < a.length; l++)
      a[l].id === i && o.remove(a[l]);
  }
  remove(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, { startRow: o, startColumn: a, endRow: l, endColumn: u } = s;
    this._enableOneCellCache ? o === l && a === u ? this._removeOneCellCache(n, r, s.startRow, s.startColumn, i) : (this._removeCellCacheByRange(t), this._removeRTreeItem(t)) : this._removeRTreeItem(t);
  }
  bulkRemove(t) {
    for (const n of t)
      this.remove(n);
  }
  clear() {
    this._tree.clear(), this._oneCellCache.clear();
  }
  toJSON() {
    const t = {};
    return this._tree.forEach((n, r) => {
      t[r] = {}, n.forEach((s, i) => {
        t[r][i] = s.toJSON();
      });
    }), t;
  }
  fromJSON(t) {
    this._tree.clear();
    for (const n in t) {
      this._tree.set(n, /* @__PURE__ */ new Map());
      for (const r in t[n]) {
        const s = new Di();
        s.fromJSON(t[n][r]), this._tree.get(n).set(r, s);
      }
    }
  }
}
function eI(e) {
  return new Promise((t) => setTimeout(t, e));
}
function tI(e = 1) {
  return new Promise((t) => {
    let n = 0;
    const r = () => {
      n++, n >= e ? t() : requestAnimationFrame(r);
    };
    requestAnimationFrame(r);
  });
}
var EC = Object.getOwnPropertyDescriptor, CC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? EC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, RC = (e, t) => (n, r) => t(n, r, e);
let qi = class extends Ve {
  constructor(t) {
    super();
    p(this, "_fontLocale");
    p(this, "_dirty", !0);
    this._localeService = t, this._localeInitial();
  }
  get dirty() {
    return this._dirty;
  }
  getFontLocale() {
    return this._fontLocale;
  }
  makeDirty(t) {
    this._dirty = t;
  }
  dispose() {
    super.dispose(), this._fontLocale = null;
  }
  _localeInitial() {
  }
};
qi = CC([
  RC(0, Nt(Fn))
], qi);
var IC = Object.getOwnPropertyDescriptor, wC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? IC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, Qr = (e, t) => (n, r) => t(n, r, e);
let yl = class extends qi {
  constructor(t, n, r, s, i, o) {
    super(r);
    /**
     * @deprecated avoid use `IWorksheetData` directly, use API provided by `Worksheet`, otherwise
     * `ViewModel` will be not working.
     */
    p(this, "_worksheetData");
    p(this, "_renderRawFormula", !1);
    p(this, "_cellData");
    p(this, "_imageCacheMap");
    /**
     * Whether auto height for merged cells
     */
    p(this, "_skipAutoHeightForMergedCells", !0);
    p(this, "_rowTotalHeight", 0);
    p(this, "_columnTotalWidth", 0);
    p(this, "_rowHeaderWidth", 0);
    p(this, "_columnHeaderHeight", 0);
    p(this, "_rowHeightAccumulation", []);
    p(this, "_columnWidthAccumulation", []);
    p(this, "_marginTop", 0);
    p(this, "_marginLeft", 0);
    /** Scale of Scene */
    p(this, "_scaleX");
    p(this, "_scaleY");
    /** Viewport scrolled value */
    p(this, "_scrollX");
    /** Viewport scrolled value */
    p(this, "_scrollY");
    this.worksheet = t, this._styles = n, this._contextService = s, this._configService = i, this._injector = o, this._worksheetData = this.worksheet.getConfig(), this._cellData = this.worksheet.getCellMatrix(), this._imageCacheMap = new pC(this._injector), this.initConfig();
  }
  initConfig() {
    var t, n;
    this._skipAutoHeightForMergedCells = !((t = this._configService.getConfig(Wc)) != null && t), this.worksheet.setIsRowStylePrecedeColumnStyle((n = this._configService.getConfig(jc)) != null ? n : !1);
  }
  resetCache() {
  }
  /**
   * @deprecated should never expose a property that is provided by another module!
   */
  getWorksheetConfig() {
    return this._worksheetData;
  }
  /**
   * Get which Workbook and Worksheet this skeleton is attached to.
   * @returns [unitId, sheetId]
   */
  getLocation() {
    return [this.worksheet.getUnitId(), this.worksheet.getSheetId()];
  }
  set columnHeaderHeight(t) {
    this._columnHeaderHeight = t, this._worksheetData.columnHeader.height = t;
  }
  set rowHeaderWidth(t) {
    this._rowHeaderWidth = t, this._worksheetData.rowHeader.width = t;
  }
  get rowHeightAccumulation() {
    return this._rowHeightAccumulation;
  }
  get rowTotalHeight() {
    return this._rowTotalHeight;
  }
  get columnWidthAccumulation() {
    return this._columnWidthAccumulation;
  }
  get columnTotalWidth() {
    return this._columnTotalWidth;
  }
  get rowHeaderWidth() {
    return this._rowHeaderWidth;
  }
  get columnHeaderHeight() {
    return this._columnHeaderHeight;
  }
  setMarginLeft(t) {
    this._marginLeft = t;
  }
  setMarginTop(t) {
    this._marginTop = t;
  }
  setScale(t, n) {
    this._updateLayout(), this._scaleX = t, this._scaleY = n || t, this._updateLayout();
  }
  setScroll(t, n) {
    J.isDefine(t) && (this._scrollX = t), J.isDefine(n) && (this._scrollY = n);
  }
  get scrollX() {
    return this._scrollX;
  }
  get scrollY() {
    return this._scrollY;
  }
  get scaleX() {
    return this._scaleX;
  }
  get scaleY() {
    return this._scaleY;
  }
  get rowHeaderWidthAndMarginLeft() {
    return this.rowHeaderWidth + this._marginLeft;
  }
  get columnHeaderHeightAndMarginTop() {
    return this.columnHeaderHeight + this._marginTop;
  }
  get imageCacheMap() {
    return this._imageCacheMap;
  }
  _generateRowMatrixCache(t, n, r) {
    let s = 0;
    const i = [], o = n;
    for (let a = 0; a < t; a++) {
      let l = r;
      if (this.worksheet.getRowFiltered(a))
        l = 0;
      else if (o[a] != null) {
        const u = o[a];
        if (!u)
          continue;
        const { h: c = r, ah: h, ia: d } = u;
        (d == null || d === ie.TRUE) && typeof h == "number" ? l = h : l = c, u.hd === ie.TRUE && (l = 0);
      }
      s += l, i.push(s);
    }
    return {
      rowTotalHeight: s,
      rowHeightAccumulation: i
    };
  }
  /**
   * Calc columnWidthAccumulation by columnData
   * @param colCount
   * @param columnData
   * @param defaultColumnWidth
   */
  _generateColumnMatrixCache(t, n, r) {
    let s = 0;
    const i = [], o = n;
    for (let a = 0; a < t; a++) {
      let l = r;
      if (o[a] != null) {
        const u = o[a];
        if (!u)
          continue;
        u.w != null && (l = u.w), u.hd === ie.TRUE && (l = 0);
      }
      s += l, i.push(s);
    }
    return {
      columnTotalWidth: s,
      columnWidthAccumulation: i
    };
  }
  intersectMergeRange(t, n) {
    return !!this.worksheet.getMergedCell(t, n);
  }
  //eslint-disable-next-line complexity
  _getOverflowBound(t, n, r, s, i = Ut.LEFT) {
    let o = 0;
    if (n > r) {
      const a = this._columnWidthAccumulation.length - 1;
      for (let l = n; l >= r; l--) {
        const u = l, c = this.worksheet.getCell(t, u);
        if (!Fa(c) && u !== n || this.intersectMergeRange(t, u))
          return u === n ? u : u + 1 > a ? a : u + 1;
        const { startX: h, endX: d } = rr(
          t,
          u,
          this.rowHeightAccumulation,
          this.columnWidthAccumulation
        );
        if (i === Ut.CENTER && u === n ? o += (d - h) / 2 : o += d - h, s < o)
          return u;
      }
      return n;
    }
    for (let a = n; a <= r; a++) {
      const l = a, u = this.worksheet.getCell(t, l);
      if (!Fa(u) && l !== n || this.intersectMergeRange(t, l))
        return l === n ? l : l - 1 < 0 ? 0 : l - 1;
      const { startX: c, endX: h } = rr(
        t,
        l,
        this.rowHeightAccumulation,
        this.columnWidthAccumulation
      );
      if (i === Ut.CENTER && l === n ? o += (h - c) / 2 : o += h - c, s < o)
        return l;
    }
    return r;
  }
  /**
   * Calculate data for row col & cell position.
   * This method should be called whenever a sheet is dirty.
   * Update position value to this._rowHeaderWidth & this._rowHeightAccumulation & this._columnHeaderHeight & this._columnWidthAccumulation.
   */
  _updateLayout() {
    if (!this.dirty)
      return;
    const {
      rowData: t,
      columnData: n,
      defaultRowHeight: r,
      defaultColumnWidth: s,
      rowCount: i,
      columnCount: o,
      rowHeader: a,
      columnHeader: l
    } = this._worksheetData, { rowTotalHeight: u, rowHeightAccumulation: c } = this._generateRowMatrixCache(i, t, r), { columnTotalWidth: h, columnWidthAccumulation: d } = this._generateColumnMatrixCache(
      o,
      n,
      s
    );
    this._rowHeaderWidth = a.hidden !== ie.TRUE ? this._dynamicallyUpdateRowHeaderWidth(a) : 0, this._columnHeaderHeight = l.hidden !== ie.TRUE ? l.height : 0, this._rowTotalHeight = u, this._rowHeightAccumulation = c, this._columnTotalWidth = h, this._columnWidthAccumulation = d, this.makeDirty(!1);
  }
  /**
   * Refresh cache after markDirty by SheetSkeletonManagerService.reCalculate()
   * @param bounds
   */
  calculate() {
    return this.resetCache(), this._updateLayout(), this;
  }
  resetRangeCache(t) {
  }
  _dynamicallyUpdateRowHeaderWidth(t) {
    const r = `${this.worksheet.getRowCount()}`.length * 8;
    return Math.max(t.width, r);
  }
  _hasUnMergedCellInRow(t, n, r) {
    if (!this.worksheet.getMergeData())
      return !1;
    for (let i = n; i <= r; i++) {
      const { isMerged: o, isMergedMainCell: a } = this.worksheet.getCellInfoInMergeData(t, i);
      if (!o && !a)
        return !0;
    }
    return !1;
  }
  /**
   * expand curr range if it's intersect with merge range.
   * @param range
   * @returns {IRange} expanded range because merge info.
   */
  expandRangeByMerge(t) {
    let { startRow: n, startColumn: r, endRow: s, endColumn: i } = t;
    const o = this._worksheetData.mergeData;
    if (!o)
      return {
        startRow: n,
        startColumn: r,
        endRow: s,
        endColumn: i
      };
    let a = !0;
    const l = new pt();
    for (; a; ) {
      a = !1;
      for (let u = 0; u < o.length; u++) {
        const {
          startRow: c,
          startColumn: h,
          endRow: d,
          endColumn: f
        } = o[u];
        if (l.getValue(c, h))
          continue;
        Wp({
          startColumn: r,
          startRow: n,
          endColumn: i,
          endRow: s
        }, {
          startColumn: h,
          startRow: c,
          endColumn: f,
          endRow: d
        }) && (n = Math.min(n, c), r = Math.min(r, h), s = Math.max(s, d), i = Math.max(i, f), l.setValue(c, h, !0), a = !0);
      }
    }
    return {
      startRow: n,
      startColumn: r,
      endRow: s,
      endColumn: i
    };
  }
  getColumnCount() {
    return this._columnWidthAccumulation.length;
  }
  getRowCount() {
    return this._rowHeightAccumulation.length;
  }
  /**
   * New version to get merge data.
   * @param row
   * @param column
   * @returns {ISelectionCell} The cell info with merge data
   */
  _getCellMergeInfo(t, n) {
    return this.worksheet.getCellInfoInMergeData(t, n);
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex instead.
   * @param rowIndex
   * @param columnIndex
   * @param header
   * @returns
   */
  getNoMergeCellPositionByIndex(t, n, r = !0) {
    return this.getNoMergeCellWithCoordByIndex(t, n, r);
  }
  /**
   * Original name: getNoMergeCellPositionByIndex
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellWithCoordByIndex(t, n, r = !0) {
    const {
      rowHeightAccumulation: s,
      columnWidthAccumulation: i,
      rowHeaderWidthAndMarginLeft: o,
      columnHeaderHeightAndMarginTop: a
    } = this;
    let { startY: l, endY: u, startX: c, endX: h } = rr(
      t,
      n,
      s,
      i
    );
    return r && (l += a, u += a, c += o, h += o), {
      startY: l,
      endY: u,
      startX: c,
      endX: h
    };
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex(row, col, false)
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellPositionByIndexWithNoHeader(t, n) {
    const { rowHeightAccumulation: r, columnWidthAccumulation: s } = this, { startY: i, endY: o, startX: a, endX: l } = rr(
      t,
      n,
      r,
      s
    );
    return {
      startY: i,
      endY: o,
      startX: a,
      endX: l
    };
  }
  /**
   *
   * @param offsetY scaled offset y
   * @param scaleY scale y
   * @param scrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   */
  getRowIndexByOffsetY(t, n, r, s) {
    var a;
    const { rowHeightAccumulation: i } = this;
    t = OC(
      t,
      n,
      r,
      this.columnHeaderHeightAndMarginTop
    );
    let o = Pr(
      i,
      t,
      s == null ? void 0 : s.firstMatch
    );
    return s != null && s.closeFirst && Math.abs(i[o] - t) < Math.abs(t - ((a = i[o - 1]) != null ? a : 0)) && (o = o + 1), o;
  }
  /**
   * Get column index by offset x.
   * @param offsetX scaled offset x
   * @param scaleX scale x
   * @param scrollXY scrollXY
   * @returns column index
   */
  getColumnIndexByOffsetX(t, n, r, s) {
    var l;
    const i = SC(
      t,
      n,
      r,
      this.rowHeaderWidthAndMarginLeft
    ), { columnWidthAccumulation: o } = this;
    let a = Pr(
      o,
      i,
      s == null ? void 0 : s.firstMatch
    );
    return s != null && s.closeFirst && Math.abs(o[a] - i) < Math.abs(i - ((l = o[a - 1]) != null ? l : 0)) && (a = a + 1), a;
  }
  /**
   * Get cell index by offset(o)
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY  render viewport scroll {x, y}, scene.getScrollXYByRelativeCoords, scene.getScrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   * @returns {row, col}
   */
  getCellIndexByOffset(t, n, r, s, i, o) {
    const a = this.getRowIndexByOffsetY(
      n,
      s,
      i,
      o
    ), l = this.getColumnIndexByOffsetX(
      t,
      r,
      i,
      o
    );
    return {
      row: a,
      column: l
    };
  }
  /**
   * Unlike getCellWithCoordByOffset, returning data doesn't include coord.
   * @param offsetX
   * @param offsetY
   * @param scaleX
   * @param scaleY
   * @param scrollXY
   */
  getCellByOffset(t, n, r, s, i) {
    const o = this == null ? void 0 : this.getCellIndexByOffset(
      t,
      n,
      r,
      s,
      i,
      { firstMatch: !0 }
    );
    return o ? this.worksheet.getCellInfoInMergeData(
      o.row,
      o.column
    ) : null;
  }
  /**
   * Return cell information corresponding to the current coordinates, including the merged cell object.
   *
   * @param row Specified Row Coordinate
   * @param column Specified Column Coordinate
   */
  getCellWithCoordByIndex(t, n, r = !0) {
    const {
      rowHeightAccumulation: s,
      columnWidthAccumulation: i,
      rowHeaderWidthAndMarginLeft: o,
      columnHeaderHeightAndMarginTop: a
    } = this, l = rr(
      t,
      n,
      s,
      i,
      this.worksheet.getCellInfoInMergeData(t, n)
    ), { isMerged: u, isMergedMainCell: c } = l;
    let { startY: h, endY: d, startX: f, endX: g, mergeInfo: _ } = l, R = o, b = a;
    return r === !1 && (R = 0, b = 0), h += b, d += b, f += R, g += R, _.startY += b, _.endY += b, _.startX += R, _.endX += R, {
      actualRow: t,
      actualColumn: n,
      startX: f,
      startY: h,
      endX: g,
      endY: d,
      isMerged: u,
      isMergedMainCell: c,
      mergeInfo: _
    };
  }
  /**
   * Get cell by pos(offsetX, offsetY). Combine getCellIndexByOffset and then getCellWithCoordByIndex.
   *
   * options.matchFirst true means get cell would skip all invisible cells.
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY render viewportScroll {x, y}
   * @param options {IGetRowColByPosOptions}
   * @returns {ICellWithCoord} Selection data with coordinates
   */
  getCellWithCoordByOffset(t, n, r, s, i, o) {
    const { row: a, column: l } = this.getCellIndexByOffset(
      t,
      n,
      r,
      s,
      i,
      o
    );
    return this.getCellWithCoordByIndex(a, l);
  }
  /**
   * Original name: getOffsetByPositionX
   * @param column
   * @returns
   */
  getOffsetByColumn(t) {
    const { columnWidthAccumulation: n, rowHeaderWidthAndMarginLeft: r } = this, s = n.length - 1, i = n[t];
    return i != null ? i + r : t < 0 ? r : n[s] + r;
  }
  /**
   * Original name: getOffsetByPositionY
   * @param row
   */
  getOffsetByRow(t) {
    const { rowHeightAccumulation: n, columnHeaderHeightAndMarginTop: r } = this, s = n.length - 1, i = n[t];
    return i != null ? i + r : t < 0 ? r : n[s] + r;
  }
  /**
   * Original name: getDecomposedOffset
   * @param offsetX
   * @param offsetY
   */
  getOffsetRelativeToRowCol(t, n) {
    const r = Pr(this.columnWidthAccumulation, t);
    let s = 0;
    r === 0 ? s = t : s = t - this._columnWidthAccumulation[r - 1];
    const i = Pr(this.rowHeightAccumulation, n);
    let o = 0;
    return i === 0 ? o = n : o = n - this._rowHeightAccumulation[i - 1], {
      row: i,
      column: r,
      columnOffset: s,
      rowOffset: o
    };
  }
  _updateConfigAndGetDocumentModel(t, n, r, s) {
    var o, a, l, u, c;
    if (!s || !((o = t.body) != null && o.dataStream))
      return;
    t.documentStyle || (t.documentStyle = {}), t.documentStyle.marginTop = (a = r.t) != null ? a : 0, t.documentStyle.marginBottom = (l = r.b) != null ? l : 2, t.documentStyle.marginLeft = (u = r.l) != null ? u : 2, t.documentStyle.marginRight = (c = r.r) != null ? c : 2, t.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    }, t.documentStyle.renderConfig = {
      ...t.documentStyle.renderConfig,
      ...s
    };
    const i = t.body.paragraphs || [];
    for (const h of i)
      h.paragraphStyle || (h.paragraphStyle = {}), h.paragraphStyle.horizontalAlign = n;
    return new Pt(t);
  }
  dispose() {
    super.dispose(), this._rowHeightAccumulation = [], this._columnWidthAccumulation = [], this._rowTotalHeight = 0, this._columnTotalWidth = 0, this._rowHeaderWidth = 0, this._columnHeaderHeight = 0, this._worksheetData = null, this._cellData = null, this._styles = null, this.worksheet = null;
  }
};
yl = wC([
  Qr(2, Nt(Fn)),
  Qr(3, Nr),
  Qr(4, ic),
  Qr(5, Nt(Yn))
], yl);
function gc(e, t, n, r) {
  const s = e - 1, i = t - 1, o = n[s] || 0;
  let a = n[e];
  a == null && (a = n[n.length - 1]);
  const l = r[i] || 0;
  let u = r[t];
  return u == null && (u = r[r.length - 1]), {
    startY: o,
    endY: a,
    startX: l,
    endX: u
  };
}
function nI(e, t, n, r) {
  return gc(e, t, n, r);
}
function rr(e, t, n, r, s) {
  e = J.clamp(e, 0, n.length - 1), t = J.clamp(t, 0, r.length - 1);
  let { startY: i, endY: o, startX: a, endX: l } = gc(
    e,
    t,
    n,
    r
  );
  if (!s)
    return {
      startY: i,
      endY: o,
      startX: a,
      endX: l,
      isMerged: !1,
      isMergedMainCell: !1,
      actualRow: e,
      actualColumn: t,
      mergeInfo: {
        startY: i,
        endY: o,
        startX: a,
        endX: l,
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    };
  const {
    isMerged: u,
    isMergedMainCell: c,
    startRow: h,
    startColumn: d,
    endRow: f,
    endColumn: g
  } = s;
  let _ = {
    startRow: h,
    startColumn: d,
    endRow: f,
    endColumn: g,
    startY: i,
    endY: o,
    startX: a,
    endX: l
  };
  const R = n.length - 1, b = r.length - 1;
  if (u && h !== -1 && d !== -1) {
    const H = n[h - 1] || 0, P = n[f] || n[R], W = r[d - 1] || 0, w = r[g] || r[b];
    _ = {
      ..._,
      startY: H,
      endY: P,
      startX: W,
      endX: w
    };
  } else if (!u && f !== -1 && g !== -1) {
    const H = n[f] || n[R], P = r[g] || r[b];
    _ = {
      ..._,
      startY: i,
      endY: H,
      startX: a,
      endX: P
    };
  }
  return {
    isMerged: u,
    isMergedMainCell: c,
    actualRow: e,
    actualColumn: t,
    startY: i,
    endY: o,
    startX: a,
    endX: l,
    mergeInfo: _
  };
}
function SC(e, t, n, r) {
  const { x: s } = n;
  return e / t + s - r;
}
function OC(e, t, n, r) {
  const { y: s } = n;
  return e = e / t + s - r, e;
}
const rI = ["script", "style", "meta", "comment", "link"];
var vC = /* @__PURE__ */ ((e) => (e[e.INFO = 0] = "INFO", e[e.STOP = 1] = "STOP", e[e.WARNING = 2] = "WARNING", e))(vC || {}), bC = /* @__PURE__ */ ((e) => (e[e.DISABLED = 0] = "DISABLED", e[e.FULL_ALPHA = 1] = "FULL_ALPHA", e[e.FULL_HANGUL = 2] = "FULL_HANGUL", e[e.FULL_KATAKANA = 3] = "FULL_KATAKANA", e[e.HALF_ALPHA = 4] = "HALF_ALPHA", e[e.HALF_HANGUL = 5] = "HALF_HANGUL", e[e.HALF_KATAKANA = 6] = "HALF_KATAKANA", e[e.HIRAGANA = 7] = "HIRAGANA", e[e.NO_CONTROL = 8] = "NO_CONTROL", e[e.OFF = 9] = "OFF", e[e.ON = 10] = "ON", e))(bC || {}), AC = /* @__PURE__ */ ((e) => (e.BETWEEN = "between", e.EQUAL = "equal", e.GREATER_THAN = "greaterThan", e.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", e.LESS_THAN = "lessThan", e.LESS_THAN_OR_EQUAL = "lessThanOrEqual", e.NOT_BETWEEN = "notBetween", e.NOT_EQUAL = "notEqual", e))(AC || {}), yC = /* @__PURE__ */ ((e) => (e[e.TEXT = 0] = "TEXT", e[e.ARROW = 1] = "ARROW", e[e.CUSTOM = 2] = "CUSTOM", e))(yC || {}), NC = /* @__PURE__ */ ((e) => (e.VALID = "valid", e.INVALID = "invalid", e.VALIDATING = "validating", e))(NC || {}), TC = /* @__PURE__ */ ((e) => (e.CUSTOM = "custom", e.LIST = "list", e.LIST_MULTIPLE = "listMultiple", e.NONE = "none", e.TEXT_LENGTH = "textLength", e.DATE = "date", e.TIME = "time", e.WHOLE = "whole", e.DECIMAL = "decimal", e.CHECKBOX = "checkbox", e.ANY = "any", e))(TC || {}), MC = Object.getOwnPropertyDescriptor, LC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? MC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
}, Nl = (e, t) => (n, r) => t(n, r, e);
let Zi = class extends Ve {
  constructor(e, t) {
    super(), this._resourceManagerService = e, this._univerInstanceService = t, this._init();
  }
  _init() {
    const e = (n) => {
      n.businesses.forEach((r) => {
        switch (r) {
          case we.UNRECOGNIZED:
          case we.UNIVER_UNKNOWN:
          case we.UNIVER_SLIDE:
          case we.UNIVER_DOC: {
            this._univerInstanceService.getAllUnitsForType(we.UNIVER_DOC).forEach((s) => {
              const o = (s.getSnapshot().resources || []).find((a) => a.name === n.pluginName);
              if (o)
                try {
                  const a = n.parseJson(o.data);
                  n.onLoad(s.getUnitId(), a);
                } catch {
                  console.error(`Load Document{${s.getUnitId()}} Resources{${n.pluginName}} Data Error.`);
                }
            });
            break;
          }
          case we.UNIVER_SHEET:
            this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET).forEach((s) => {
              const o = (s.getSnapshot().resources || []).find((a) => a.name === n.pluginName);
              if (o)
                try {
                  const a = n.parseJson(o.data);
                  n.onLoad(s.getUnitId(), a);
                } catch {
                  console.error(`Load Workbook{${s.getUnitId()}} Resources{${n.pluginName}} Data Error.`);
                }
            });
        }
      });
    };
    this._resourceManagerService.getAllResourceHooks().forEach((n) => e(n)), this.disposeWithMe(this._resourceManagerService.register$.subscribe((n) => e(n))), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_SHEET).subscribe((n) => {
        this._resourceManagerService.loadResources(n.getUnitId(), n.getSnapshot().resources);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_DOC).subscribe((n) => {
        const r = n.getUnitId();
        Yc(r) || this._resourceManagerService.loadResources(n.getUnitId(), n.getSnapshot().resources);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_SHEET).subscribe((n) => {
        this._resourceManagerService.unloadResources(n.getUnitId(), we.UNIVER_SHEET);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_DOC).subscribe((n) => {
        this._resourceManagerService.unloadResources(n.getUnitId(), we.UNIVER_DOC);
      })
    );
  }
  saveUnit(e) {
    const t = this._univerInstanceService.getUnit(e);
    if (!t)
      return null;
    const n = this._resourceManagerService.getResources(e, t.type), r = J.deepClone(t.getSnapshot());
    return r.resources = n, r;
  }
};
Zi = LC([
  Nl(0, Nt(Jo)),
  Nl(1, Nt(vr))
], Zi);
class sI {
  /**
   * Create a Univer instance.
   * @param config Configuration data for Univer
   * @param parentInjector An optional parent injector of the Univer injector. For more information, see https://redi.wendell.fun/docs/hierarchy.
   */
  constructor(t = {}, n) {
    p(this, "_startedTypes", /* @__PURE__ */ new Set());
    p(this, "_injector");
    p(this, "_disposingCallbacks", new ao());
    const r = this._injector = xC(n, t == null ? void 0 : t.override), { theme: s, darkMode: i, locale: o, locales: a, logLevel: l } = t;
    s && this._injector.get(Gi).setTheme(s), i && this._injector.get(Gi).setDarkMode(i), a && this._injector.get(Fn).load(a), o && this._injector.get(Fn).setLocale(o), l && this._injector.get(yt).setLogLevel(l), this._init(r);
  }
  get _univerInstanceService() {
    return this._injector.get(vr);
  }
  get _pluginService() {
    return this._injector.get(Ss);
  }
  /**
   * @ignore
   */
  __getInjector() {
    return this._injector;
  }
  /**
   * Register a callback function which will be called when this Univer instance is disposing.
   *
   * @ignore
   *
   * @param callback The callback function.
   * @returns To remove this callback function from this Univer instance's on disposing list.
   */
  onDispose(t) {
    const n = this._disposingCallbacks.add(We(t));
    return We(() => n.dispose(!0));
  }
  dispose() {
    this._disposingCallbacks.dispose(), this._injector.dispose();
  }
  setLocale(t) {
    this._injector.get(Fn).setLocale(t);
  }
  createUnit(t, n) {
    return this._univerInstanceService.createUnit(t, n);
  }
  /**
   * Create a univer sheet instance with internal dependency injection.
   *
   * @deprecated use `createUnit` instead
   */
  createUniverSheet(t) {
    return this._injector.get(yt).warn("[Univer]", "Univer.createUniverSheet is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_SHEET, t);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverDoc(t) {
    return this._injector.get(yt).warn("[Univer]", "Univer.createUniverDoc is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_DOC, t);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverSlide(t) {
    return this._injector.get(yt).warn("[Univer]", "Univer.createUniverSlide is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_SLIDE, t);
  }
  _init(t) {
    this._univerInstanceService.registerCtorForType(we.UNIVER_SHEET, ws), this._univerInstanceService.registerCtorForType(we.UNIVER_DOC, Pt), this._univerInstanceService.registerCtorForType(we.UNIVER_SLIDE, lc);
    const n = t.get(vr);
    n.__setCreateHandler(
      (r, s, i, o) => {
        if (!this._startedTypes.has(r)) {
          this._pluginService.startPluginsForType(r), this._startedTypes.add(r);
          const l = t.createInstance(i, s);
          return n.__addUnit(l, o), this._tryProgressToReady(), l;
        }
        const a = t.createInstance(i, s);
        return n.__addUnit(a, o), a;
      }
    );
  }
  _tryProgressToReady() {
    this._injector.get(Wn).stage < ke.Ready && (this._injector.get(Wn).stage = ke.Ready);
  }
  /** Register a plugin into univer. */
  registerPlugin(t, n) {
    this._pluginService.registerPlugin(t, n);
  }
  /**
   * Register multiple plugins into univer.
   * @param plugins An array of tuples, where each tuple contains a plugin constructor and its optional configuration.
   */
  registerPlugins(t) {
    t.forEach((n) => {
      const [r, s] = n;
      this._pluginService.registerPlugin(r, s);
    });
  }
}
function xC(e, t) {
  const n = nC([
    [_E],
    [Fn],
    [Gi],
    [Wn],
    [Ss],
    [Rs],
    // abstract services
    [vr, { useClass: Yi }],
    [eC, { useClass: tC }],
    [yt, { useClass: gg, lazy: !0 }],
    [Ls, { useClass: vi }],
    [Qo, { useClass: Ki, lazy: !0 }],
    [ic, { useClass: fE }],
    [Nr, { useClass: fg }],
    [Jo, { useClass: Vi, lazy: !0 }],
    [vl, { useClass: Zi, lazy: !0 }],
    [dE, { useClass: ji }],
    [QE, { useClass: zi, lazy: !0 }]
  ], t), r = e ? e.createChild(n) : new Yn(n);
  return zc(r, [
    [Rs],
    [vl]
  ]), r;
}
Dc();
export {
  ER as ABCToNumber,
  Wc as AUTO_HEIGHT_FOR_MERGED_CELLS,
  ye as AbsoluteRefType,
  er as ActionIterator,
  Zm as AlignTypeH,
  Jm as AlignTypeV,
  tg as ArrangeTypeEnum,
  Sm as ArrowsAndMarkersShapes,
  QC as AsyncInterceptorManager,
  YC as AsyncLock,
  ji as AuthzIoLocalService,
  dm as AutoFillSeries,
  Zt as BaselineOffset,
  wm as BasicShapes,
  Mm as BlockType,
  ie as BooleanNumber,
  Le as BorderStyleTypes,
  fm as BorderType,
  Je as BuildTextUtils,
  Ts as BulletAlignment,
  Ua as COLORS,
  KC as CanceledError,
  or as CellModeEnum,
  fn as CellValueType,
  jn as Color,
  mo as ColorBuilder,
  bt as ColorKit,
  At as ColorType,
  Dm as ColumnSeparatorType,
  vi as CommandService,
  Ms as CommandType,
  mm as CommonHideTypes,
  fE as ConfigService,
  fg as ContextService,
  gm as CopyPasteType,
  _i as CustomCommandExecutionError,
  Dn as CustomDecorationType,
  pn as CustomRangeType,
  lR as DEFAULT_CELL,
  Qu as DEFAULT_DOC,
  yR as DEFAULT_DOCUMENT_SUB_COMPONENT_ID,
  Bc as DEFAULT_EMPTY_DOCUMENT_VALUE,
  yp as DEFAULT_NUMBER_FORMAT,
  oR as DEFAULT_RANGE,
  iR as DEFAULT_RANGE_ARRAY,
  aR as DEFAULT_SELECTION,
  Mp as DEFAULT_SLIDE,
  rt as DEFAULT_STYLES,
  bp as DEFAULT_TEXT_FORMAT,
  Ap as DEFAULT_TEXT_FORMAT_EXCEL,
  LE as DEFAULT_WORKSHEET_COLUMN_COUNT,
  jR as DEFAULT_WORKSHEET_COLUMN_COUNT_KEY,
  kE as DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT,
  VR as DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT_KEY,
  DE as DEFAULT_WORKSHEET_COLUMN_WIDTH,
  YR as DEFAULT_WORKSHEET_COLUMN_WIDTH_KEY,
  ME as DEFAULT_WORKSHEET_ROW_COUNT,
  BR as DEFAULT_WORKSHEET_ROW_COUNT_KEY,
  xE as DEFAULT_WORKSHEET_ROW_HEIGHT,
  WR as DEFAULT_WORKSHEET_ROW_HEIGHT_KEY,
  UE as DEFAULT_WORKSHEET_ROW_TITLE_WIDTH,
  zR as DEFAULT_WORKSHEET_ROW_TITLE_WIDTH_KEY,
  Ul as DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
  Dl as DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
  Hc as DOCS_ZEN_EDITOR_UNIT_ID_KEY,
  fR as DOC_DRAWING_PRINTING_COMPONENT_KEY,
  jg as DOC_RANGE_TYPE,
  Hm as DashStyleType,
  N0 as DataStreamTreeNodeType,
  ct as DataStreamTreeTokenType,
  vC as DataValidationErrorStyle,
  bC as DataValidationImeMode,
  AC as DataValidationOperator,
  yC as DataValidationRenderMode,
  NC as DataValidationStatus,
  TC as DataValidationType,
  _m as DeleteDirection,
  qR as DependentOn,
  gg as DesktopLogService,
  pm as DeveloperMetadataVisibility,
  Em as Dimension,
  Cm as Direction,
  Ve as Disposable,
  ao as DisposableCollection,
  Nm as DocStyleType,
  Pt as DocumentDataModel,
  uu as DocumentFlavor,
  ng as DrawingTypeEnum,
  mE as EDITOR_ACTIVATED,
  Lp as EXTENSION_NAMES,
  _E as ErrorService,
  lE as EventState,
  NR as EventSubject,
  PR as FOCUSING_COMMON_DRAWINGS,
  qr as FOCUSING_DOC,
  MR as FOCUSING_EDITOR_BUT_HIDDEN,
  LR as FOCUSING_EDITOR_INPUT_FORMULA,
  DR as FOCUSING_EDITOR_STANDALONE,
  gE as FOCUSING_FX_BAR_EDITOR,
  UR as FOCUSING_PANEL_EDITOR,
  gr as FOCUSING_SHEET,
  Zr as FOCUSING_SLIDE,
  Xr as FOCUSING_UNIT,
  xR as FOCUSING_UNIVER_EDITOR,
  kR as FOCUSING_UNIVER_EDITOR_STANDALONE_SINGLE_MODE,
  FR as FORMULA_EDITOR_ACTIVATED,
  Tm as FollowNumberWithType,
  wi as FontItalic,
  ir as FontStyleType,
  Si as FontWeight,
  Lm as GridType,
  Ag as HLSColor,
  Ut as HorizontalAlign,
  dE as IAuthzIoService,
  Ls as ICommandService,
  ic as IConfigService,
  Nr as IContextService,
  El as IImageIoService,
  XR as ILocalStorageService,
  yt as ILogService,
  QE as IMentionIOService,
  eC as IPermissionService,
  vl as IResourceLoaderService,
  Jo as IResourceManagerService,
  jc as IS_ROW_STYLE_PRECEDE_COLUMN_STYLE,
  Qo as IUndoRedoService,
  vr as IUniverInstanceService,
  pC as ImageCacheMap,
  oc as ImageSourceType,
  pE as ImageUploadStatusType,
  sr as InterceptorEffectEnum,
  ZC as InterceptorManager,
  Rm as InterpolationPointType,
  p1 as JSON1,
  Qt as JSONX,
  Br as LRUHelper,
  gs as LRUMap,
  Wn as LifecycleService,
  ke as LifecycleStages,
  XE as LifecycleUnreachableError,
  me as ListGlyphType,
  Ki as LocalUndoRedoService,
  Fn as LocaleService,
  Ns as LocaleType,
  mg as LogLevel,
  Fr as MOVE_BUFFER_VALUE,
  Gn as MemoryCursor,
  zi as MentionIOLocalService,
  Ii as MentionType,
  cR as NAMED_STYLE_MAP,
  hR as NAMED_STYLE_SPACE_MAP,
  qe as NamedStyleType,
  Rg as NilCommand,
  qm as NumberUnitType,
  pt as ObjectMatrix,
  Km as ObjectRelativeFromH,
  Xm as ObjectRelativeFromV,
  Om as OtherShapes,
  mR as PAGE_SIZE,
  _1 as PAPER_TYPES,
  $s as PRESET_LIST_TYPE,
  dR as PRINT_CHART_COMPONENT_KEY,
  rg as PageElementType,
  eg as PageOrientType,
  cu as PageType,
  gt as PaperType,
  km as ParagraphElementType,
  Cs as ParagraphStyleBuilder,
  Bs as ParagraphStyleValue,
  tC as PermissionService,
  hc as PermissionStatus,
  Ol as Plugin,
  Ss as PluginService,
  Fm as PositionedObjectLayoutType,
  zt as PresetListType,
  Im as ProtectionType,
  e0 as QuickListType,
  SR as QuickListTypeMap,
  Bg as RANGE_DIRECTION,
  ge as RANGE_TYPE,
  Di as RBush,
  d1 as RCDisposable,
  y1 as RGBA_PAREN,
  A1 as RGB_PAREN,
  vg as ROTATE_BUFFER_VALUE,
  QR as RTree,
  Or as Range,
  En as Rectangle,
  _C as RedoCommand,
  fC as RedoCommandId,
  pR as RefAlias,
  su as Registry,
  iu as RegistryAsMap,
  bm as RelativeDate,
  sg as RelativeSlideLink,
  Vi as ResourceManagerService,
  bi as RgbColor,
  Pn as RichTextBuilder,
  dn as RichTextValue,
  h1 as RxDisposable,
  uR as SHEET_EDITOR_UNITS,
  xm as SectionType,
  yl as SheetSkeleton,
  Am as SheetTypes,
  $E as SheetViewModel,
  qi as Skeleton,
  Ju as SliceBodyType,
  lc as SlideDataModel,
  $m as SpacingRule,
  vm as SpecialShapes,
  IE as Styles,
  bg as THEME_COLORS,
  Bm as TabStopAlignment,
  Wm as TableAlignmentType,
  Ym as TableLayoutType,
  Vm as TableRowHeightRule,
  jm as TableSizeType,
  zm as TableTextWrapType,
  ym as TextDecoration,
  hn as TextDecorationBuilder,
  ms as TextDirection,
  Um as TextDirectionType,
  gn as TextStyleBuilder,
  Hs as TextStyleValue,
  Ne as TextX,
  Z as TextXActionType,
  Ai as ThemeColor,
  st as ThemeColorType,
  co as ThemeColors,
  Gi as ThemeService,
  J as Tools,
  gC as UndoCommand,
  mC as UndoCommandId,
  lo as UnitModel,
  sI as Univer,
  Yi as UniverInstanceService,
  we as UniverInstanceType,
  pe as UpdateDocsAttributeType,
  Rs as UserManagerService,
  xn as VerticalAlign,
  Gm as VerticalAlignmentType,
  ws as Workbook,
  Is as Worksheet,
  Bn as WrapStrategy,
  Pm as WrapTextType,
  OE as addLinkToDocumentModel,
  w1 as afterInitApply,
  R1 as afterTime,
  eI as awaitTime,
  Og as binSearchFirstGreaterThanTarget,
  S1 as binarySearchArray,
  C1 as bufferDebounceTime,
  V1 as cellToRange,
  Qm as characterSpacingControlType,
  K1 as checkForSubstrings,
  v1 as checkIfMove,
  X1 as checkParagraphHasBullet,
  q1 as checkParagraphHasIndent,
  T_ as checkParagraphHasIndentByStyle,
  O1 as codeToBlob,
  fl as composeBody,
  Gc as composeInterceptors,
  xr as composeStyles,
  P1 as concatMatrixArray,
  b1 as convertBodyToHtml,
  zg as convertCellToRange,
  I1 as convertObservableToBehaviorSubject,
  $a as covertCellValue,
  G1 as covertCellValues,
  Da as covertTextRunToHtml,
  JC as createAsyncInterceptorKey,
  Bi as createDefaultUser,
  Jr as createDocumentModelWithStyle,
  qC as createInterceptorKey,
  VC as createInternalEditorID,
  m1 as createREGEXFromWildChar,
  cl as createRowColIter,
  JR as customNameCharacterCheck,
  tn as dayjs,
  n1 as debounce,
  $C as dedupe,
  HC as dedupeBy,
  mu as deepCompare,
  tI as delayAnimationFrame,
  L_ as deleteContent,
  HE as extractPureTextFromCell,
  wg as fromCallback,
  TR as fromEventSubject,
  c1 as fromObservable,
  et as generateRandomId,
  vf as get,
  mn as getArrayLength,
  kt as getBodySlice,
  Qs as getBodySliceHtml,
  W1 as getBorderStyleType,
  gc as getCellCoordByIndexSimple,
  D1 as getCellInfoInMergeData,
  nI as getCellPositionByIndexSimple,
  M1 as getCellValueType,
  rr as getCellWithCoordByIndexCore,
  Wt as getColorStyle,
  d0 as getCustomBlockSlice,
  m0 as getCustomDecorationSlice,
  f0 as getCustomRangeSlice,
  Y1 as getDocsUpdateBody,
  Wp as getIntersectRange,
  sR as getNumfmtParseValueFilter,
  GR as getOriginCellValue,
  h0 as getParagraphsSlice,
  qo as getPlainText,
  g1 as getReverseDirection,
  OR as getSectionBreakSlice,
  c0 as getTableSlice,
  Pi as getTextRunSlice,
  SC as getTransformOffsetX,
  OC as getTransformOffsetY,
  KR as getWorksheetUID,
  jC as groupBy,
  j1 as handleStyleToString,
  J1 as hashAlgorithm,
  go as horizontalLineSegmentsSubtraction,
  k1 as insertMatrixArray,
  M_ as insertTextToContent,
  e1 as invertColorByHSL,
  t1 as invertColorByMatrix,
  N1 as isBlackColor,
  zC as isBooleanString,
  Fa as isCellCoverable,
  Hg as isCellV,
  nR as isDefaultFormat,
  Vg as isEmptyCell,
  B1 as isFormulaId,
  Gg as isFormulaString,
  $g as isICellData,
  Yc as isInternalEditorID,
  f1 as isNodeEnv,
  vE as isNotNullOrUndefined,
  L1 as isNullCell,
  Jf as isNumeric,
  rR as isPatternEqualWithoutDecimal,
  $R as isRangesEqual,
  Z1 as isRealNum,
  o1 as isSafeNumeric,
  Kg as isSameStyleTextRun,
  tR as isTextFormat,
  HR as isUnitRangesEqual,
  z1 as isValidRange,
  T1 as isWhiteColor,
  WC as makeArray,
  H1 as makeCellRangeToRangeData,
  $1 as makeCellToSelection,
  bR as makeCustomRangeStream,
  U1 as mapObjectMatrix,
  oo as merge,
  Q1 as mergeLocales,
  nC as mergeOverrideWithDependencies,
  u1 as mergeSets,
  r1 as mergeWith,
  PE as mergeWorksheetSnapshotWithDefault,
  i1 as mixinClass,
  Pa as moveMatrixArray,
  gR as moveRangeByOffset,
  ZR as nameCharacterCheck,
  vR as normalizeBody,
  Fs as normalizeTextRuns,
  CR as numberToABC,
  RR as numberToListABC,
  eR as numfmt,
  _R as queryObjectMatrix,
  GC as registerDependencies,
  Os as remove,
  Xp as repeatStringNumTimes,
  AR as replaceInDocumentBody,
  l1 as requestImmediateMacroTask,
  BC as rotate,
  Pr as searchArray,
  Sg as searchInOrderedArray,
  x1 as selectionToArray,
  em as sequence,
  Qf as sequenceAsync,
  fo as sequenceExecute,
  E1 as sequenceExecuteAsync,
  s1 as set,
  Vc as shallowEqual,
  rI as skipParseTagNames,
  F1 as sliceMatrixArray,
  IR as sortRules,
  wR as sortRulesByDesc,
  Ps as sortRulesFactory,
  ka as spliceArray,
  Pu as splitIntoGrid,
  xa as takeAfter,
  nc as textDiff,
  XC as throttle,
  We as toDisposable,
  zc as touchDependencies,
  C0 as updateAttributeByDelete,
  R0 as updateAttributeByInsert,
  a1 as willLoseNumericPrecision
};
